CCS PCM C Compiler, Version 5.015, 5967               04-Nov-21 21:18

               Filename:   E:\DATN_V2\NODE\pic\pic16f887\hellopic.lst

               ROM used:   4510 words (55%)
                           Largest free fragment is 2048
               RAM used:   179 (49%) at main() level
                           265 (72%) worst case
               Stack used: 7 locations (6 in main + 1 for interrupts)
               Stack size: 8

*
0000:  MOVLW  11
0001:  MOVWF  0A
0002:  GOTO   123
0003:  NOP
0004:  MOVWF  7F
0005:  SWAPF  03,W
0006:  CLRF   03
0007:  MOVWF  21
0008:  MOVF   0A,W
0009:  MOVWF  20
000A:  CLRF   0A
000B:  MOVF   04,W
000C:  MOVWF  22
000D:  MOVF   77,W
000E:  MOVWF  23
000F:  MOVF   78,W
0010:  MOVWF  24
0011:  MOVF   79,W
0012:  MOVWF  25
0013:  MOVF   7A,W
0014:  MOVWF  26
0015:  BSF    03.6
0016:  MOVF   0D,W
0017:  BCF    03.6
0018:  MOVWF  27
0019:  BSF    03.6
001A:  MOVF   0F,W
001B:  BCF    03.6
001C:  MOVWF  28
001D:  BSF    03.6
001E:  MOVF   0C,W
001F:  BCF    03.6
0020:  MOVWF  29
0021:  BSF    03.6
0022:  MOVF   0E,W
0023:  BCF    03.6
0024:  MOVWF  2A
0025:  BCF    03.7
0026:  BCF    03.5
0027:  BTFSS  0B.4
0028:  GOTO   02B
0029:  BTFSC  0B.1
002A:  GOTO   052
002B:  MOVLW  8C
002C:  MOVWF  04
002D:  BTFSS  00.5
002E:  GOTO   031
002F:  BTFSC  0C.5
0030:  GOTO   055
0031:  MOVF   22,W
0032:  MOVWF  04
0033:  MOVF   23,W
0034:  MOVWF  77
0035:  MOVF   24,W
0036:  MOVWF  78
0037:  MOVF   25,W
0038:  MOVWF  79
0039:  MOVF   26,W
003A:  MOVWF  7A
003B:  MOVF   27,W
003C:  BSF    03.6
003D:  MOVWF  0D
003E:  BCF    03.6
003F:  MOVF   28,W
0040:  BSF    03.6
0041:  MOVWF  0F
0042:  BCF    03.6
0043:  MOVF   29,W
0044:  BSF    03.6
0045:  MOVWF  0C
0046:  BCF    03.6
0047:  MOVF   2A,W
0048:  BSF    03.6
0049:  MOVWF  0E
004A:  BCF    03.6
004B:  MOVF   20,W
004C:  MOVWF  0A
004D:  SWAPF  21,W
004E:  MOVWF  03
004F:  SWAPF  7F,F
0050:  SWAPF  7F,W
0051:  RETFIE
0052:  BCF    0A.3
0053:  BCF    0A.4
0054:  GOTO   0EF
0055:  BCF    0A.3
0056:  BCF    0A.4
0057:  GOTO   120
....................  
.................... #INCLUDE <thuvien.c> 
.................... #INCLUDE <16F887.H> 
.................... //////////// Standard Header file for the PIC16F887 device //////////////// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2013 Custom Computer Services          //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... #device PIC16F887 
0058:  BCF    0A.0
0059:  BCF    0A.1
005A:  BCF    0A.2
005B:  ADDWF  02,F
005C:  RETLW  30
005D:  RETLW  00
005E:  BCF    0A.0
005F:  BCF    0A.1
0060:  BCF    0A.2
0061:  ADDWF  02,F
0062:  RETLW  5F
0063:  RETLW  00
0064:  BCF    0A.0
0065:  BCF    0A.1
0066:  BCF    0A.2
0067:  ADDWF  02,F
0068:  RETLW  23
0069:  RETLW  00
006A:  BCF    0A.0
006B:  BCF    0A.1
006C:  BCF    0A.2
006D:  ADDWF  02,F
006E:  RETLW  00
006F:  DATA CE,27
0070:  DATA C4,22
0071:  DATA 3A,10
0072:  DATA 00,00
0073:  DATA 30,18
0074:  DATA 30,18
0075:  DATA 20,10
0076:  DATA 20,10
0077:  DATA 20,10
0078:  DATA 20,10
0079:  DATA 20,10
007A:  DATA 00,01
007B:  DATA 20,10
007C:  DATA 20,10
007D:  DATA 20,10
007E:  DATA 5F,10
007F:  DATA 20,10
0080:  DATA 20,10
0081:  DATA 20,10
0082:  DATA 20,10
0083:  DATA 20,10
0084:  DATA 20,10
0085:  DATA 20,00
0086:  DATA 20,10
0087:  DATA 20,10
0088:  DATA 5F,10
0089:  DATA 20,10
008A:  DATA 20,00
008B:  DATA 49,22
008C:  DATA DF,23
008D:  DATA 57,1D
008E:  DATA 00,01
008F:  DATA 30,18
0090:  DATA 30,18
0091:  DATA 30,18
0092:  DATA 20,10
0093:  DATA 20,10
0094:  DATA 20,10
0095:  DATA 20,10
0096:  DATA 00,01
0097:  DATA 20,10
0098:  DATA 20,10
0099:  DATA 20,10
009A:  DATA 5F,10
009B:  DATA 20,10
009C:  DATA 20,10
009D:  DATA 20,10
009E:  DATA 20,10
009F:  DATA 20,10
00A0:  DATA 20,10
00A1:  DATA 20,10
00A2:  DATA 20,00
00A3:  DATA 20,10
00A4:  DATA 20,10
00A5:  DATA 5F,10
00A6:  DATA 20,10
00A7:  DATA 20,10
00A8:  DATA 20,10
00A9:  DATA 20,00
00AA:  DATA C3,27
00AB:  DATA 4E,23
00AC:  DATA C9,23
00AD:  DATA 3A,10
00AE:  DATA 20,10
00AF:  DATA 20,10
00B0:  DATA 20,10
00B1:  DATA 20,00
00B2:  DATA C3,20
00B3:  DATA D3,22
00B4:  DATA 3A,10
00B5:  DATA 20,10
00B6:  DATA 20,10
00B7:  DATA 20,10
00B8:  DATA 20,10
00B9:  DATA 20,00
00BA:  DATA A0,16
00BB:  DATA A0,24
00BC:  DATA C4,16
00BD:  DATA CE,27
00BE:  DATA C4,22
00BF:  DATA 20,10
00C0:  DATA 20,10
00C1:  DATA 20,10
00C2:  DATA 00,01
00C3:  DATA A0,16
00C4:  DATA A0,24
00C5:  DATA C4,16
00C6:  DATA C7,2B
00C7:  DATA 20,10
00C8:  DATA 20,10
00C9:  DATA 20,10
00CA:  DATA 20,00
00CB:  DATA D7,20
00CC:  DATA 49,2A
00CD:  DATA 49,27
00CE:  DATA 47,10
00CF:  DATA 2E,17
00D0:  DATA 2E,17
00D1:  DATA 20,10
00D2:  DATA 20,10
00D3:  DATA 20,10
00D4:  DATA 20,10
00D5:  DATA 00,01
00D6:  DATA D7,20
00D7:  DATA 49,2A
00D8:  DATA 49,27
00D9:  DATA 47,10
00DA:  DATA 2E,17
00DB:  DATA 2E,17
00DC:  DATA 20,10
00DD:  DATA 20,10
00DE:  DATA 20,10
00DF:  DATA 20,10
00E0:  DATA 00,00
00E1:  DATA 20,10
00E2:  DATA 20,10
00E3:  DATA 20,10
00E4:  DATA 20,10
00E5:  DATA 20,10
00E6:  DATA 20,10
00E7:  DATA 00,01
00E8:  DATA 54,21
00E9:  DATA 3A,10
00EA:  DATA 00,01
00EB:  DATA 20,10
00EC:  DATA 20,10
00ED:  DATA 43,21
00EE:  DATA 3A,00
*
013D:  DATA C0,29
013E:  DATA 53,20
013F:  DATA 00,00
*
030E:  MOVF   0B,W
030F:  BSF    03.6
0310:  MOVWF  43
0311:  BCF    03.6
0312:  BCF    0B.7
0313:  BSF    03.5
0314:  BSF    03.6
0315:  BSF    0C.7
0316:  BSF    0C.0
0317:  NOP
0318:  NOP
0319:  BCF    03.5
031A:  BTFSS  43.7
031B:  GOTO   31F
031C:  BCF    03.6
031D:  BSF    0B.7
031E:  BSF    03.6
031F:  MOVF   0C,W
0320:  ANDLW  7F
0321:  BTFSC  03.2
0322:  GOTO   35C
0323:  MOVWF  43
0324:  MOVF   0D,W
0325:  MOVWF  44
0326:  MOVF   0F,W
0327:  MOVWF  45
0328:  MOVF   43,W
0329:  MOVWF  46
032A:  BCF    03.6
032B:  CALL   2D4
032C:  BSF    03.6
032D:  MOVF   44,W
032E:  MOVWF  0D
032F:  MOVF   45,W
0330:  MOVWF  0F
0331:  BCF    03.6
0332:  MOVF   0B,W
0333:  BSF    03.6
0334:  MOVWF  46
0335:  BCF    03.6
0336:  BCF    0B.7
0337:  BSF    03.5
0338:  BSF    03.6
0339:  BSF    0C.7
033A:  BSF    0C.0
033B:  NOP
033C:  NOP
033D:  BCF    03.5
033E:  BTFSS  46.7
033F:  GOTO   343
0340:  BCF    03.6
0341:  BSF    0B.7
0342:  BSF    03.6
0343:  RLF    0C,W
0344:  RLF    0E,W
0345:  ANDLW  7F
0346:  BTFSC  03.2
0347:  GOTO   35C
0348:  MOVWF  43
0349:  MOVF   0D,W
034A:  MOVWF  44
034B:  MOVF   0F,W
034C:  MOVWF  45
034D:  MOVF   43,W
034E:  MOVWF  46
034F:  BCF    03.6
0350:  CALL   2D4
0351:  BSF    03.6
0352:  MOVF   44,W
0353:  MOVWF  0D
0354:  MOVF   45,W
0355:  MOVWF  0F
0356:  INCF   0D,F
0357:  BTFSC  03.2
0358:  INCF   0F,F
0359:  BCF    03.6
035A:  GOTO   30E
035B:  BSF    03.6
035C:  BCF    03.6
035D:  RETURN
035E:  BTFSC  03.1
035F:  GOTO   363
0360:  MOVLW  64
0361:  MOVWF  04
0362:  BSF    03.7
0363:  BSF    03.6
0364:  MOVF   5F,W
0365:  XORWF  63,W
0366:  ANDLW  80
0367:  MOVWF  69
0368:  BTFSS  5F.7
0369:  GOTO   375
036A:  COMF   5C,F
036B:  COMF   5D,F
036C:  COMF   5E,F
036D:  COMF   5F,F
036E:  INCF   5C,F
036F:  BTFSC  03.2
0370:  INCF   5D,F
0371:  BTFSC  03.2
0372:  INCF   5E,F
0373:  BTFSC  03.2
0374:  INCF   5F,F
0375:  BTFSS  63.7
0376:  GOTO   382
0377:  COMF   60,F
0378:  COMF   61,F
0379:  COMF   62,F
037A:  COMF   63,F
037B:  INCF   60,F
037C:  BTFSC  03.2
037D:  INCF   61,F
037E:  BTFSC  03.2
037F:  INCF   62,F
0380:  BTFSC  03.2
0381:  INCF   63,F
0382:  CLRF   77
0383:  CLRF   78
0384:  CLRF   79
0385:  CLRF   7A
0386:  CLRF   64
0387:  CLRF   65
0388:  CLRF   66
0389:  CLRF   67
038A:  MOVF   63,W
038B:  IORWF  62,W
038C:  IORWF  61,W
038D:  IORWF  60,W
038E:  BTFSC  03.2
038F:  GOTO   3C0
0390:  MOVLW  20
0391:  MOVWF  68
0392:  BCF    03.0
0393:  RLF    5C,F
0394:  RLF    5D,F
0395:  RLF    5E,F
0396:  RLF    5F,F
0397:  RLF    64,F
0398:  RLF    65,F
0399:  RLF    66,F
039A:  RLF    67,F
039B:  MOVF   63,W
039C:  SUBWF  67,W
039D:  BTFSS  03.2
039E:  GOTO   3A9
039F:  MOVF   62,W
03A0:  SUBWF  66,W
03A1:  BTFSS  03.2
03A2:  GOTO   3A9
03A3:  MOVF   61,W
03A4:  SUBWF  65,W
03A5:  BTFSS  03.2
03A6:  GOTO   3A9
03A7:  MOVF   60,W
03A8:  SUBWF  64,W
03A9:  BTFSS  03.0
03AA:  GOTO   3BA
03AB:  MOVF   60,W
03AC:  SUBWF  64,F
03AD:  MOVF   61,W
03AE:  BTFSS  03.0
03AF:  INCFSZ 61,W
03B0:  SUBWF  65,F
03B1:  MOVF   62,W
03B2:  BTFSS  03.0
03B3:  INCFSZ 62,W
03B4:  SUBWF  66,F
03B5:  MOVF   63,W
03B6:  BTFSS  03.0
03B7:  INCFSZ 63,W
03B8:  SUBWF  67,F
03B9:  BSF    03.0
03BA:  RLF    77,F
03BB:  RLF    78,F
03BC:  RLF    79,F
03BD:  RLF    7A,F
03BE:  DECFSZ 68,F
03BF:  GOTO   392
03C0:  BTFSS  69.7
03C1:  GOTO   3CD
03C2:  COMF   77,F
03C3:  COMF   78,F
03C4:  COMF   79,F
03C5:  COMF   7A,F
03C6:  INCF   77,F
03C7:  BTFSC  03.2
03C8:  INCF   78,F
03C9:  BTFSC  03.2
03CA:  INCF   79,F
03CB:  BTFSC  03.2
03CC:  INCF   7A,F
03CD:  MOVF   64,W
03CE:  MOVWF  00
03CF:  INCF   04,F
03D0:  MOVF   65,W
03D1:  MOVWF  00
03D2:  INCF   04,F
03D3:  MOVF   66,W
03D4:  MOVWF  00
03D5:  INCF   04,F
03D6:  MOVF   67,W
03D7:  MOVWF  00
03D8:  BCF    03.6
03D9:  RETURN
*
03F3:  MOVLW  20
03F4:  MOVWF  60
03F5:  CLRF   5C
03F6:  CLRF   5D
03F7:  CLRF   5E
03F8:  CLRF   5F
03F9:  MOVF   57,W
03FA:  MOVWF  7A
03FB:  MOVF   56,W
03FC:  MOVWF  79
03FD:  MOVF   55,W
03FE:  MOVWF  78
03FF:  MOVF   54,W
0400:  MOVWF  77
0401:  BCF    03.0
0402:  BTFSS  77.0
0403:  GOTO   412
0404:  MOVF   58,W
0405:  ADDWF  5C,F
0406:  MOVF   59,W
0407:  BTFSC  03.0
0408:  INCFSZ 59,W
0409:  ADDWF  5D,F
040A:  MOVF   5A,W
040B:  BTFSC  03.0
040C:  INCFSZ 5A,W
040D:  ADDWF  5E,F
040E:  MOVF   5B,W
040F:  BTFSC  03.0
0410:  INCFSZ 5B,W
0411:  ADDWF  5F,F
0412:  RRF    5F,F
0413:  RRF    5E,F
0414:  RRF    5D,F
0415:  RRF    5C,F
0416:  RRF    7A,F
0417:  RRF    79,F
0418:  RRF    78,F
0419:  RRF    77,F
041A:  DECFSZ 60,F
041B:  GOTO   401
*
04FA:  MOVF   00,F
04FB:  BTFSC  03.2
04FC:  GOTO   516
04FD:  BSF    03.6
04FE:  CLRF   1E
04FF:  MOVF   04,W
0500:  MOVWF  1D
0501:  BCF    1E.0
0502:  BTFSC  03.7
0503:  BSF    1E.0
0504:  MOVF   00,W
0505:  MOVWF  46
0506:  BCF    03.6
0507:  CALL   2D4
0508:  BSF    03.6
0509:  MOVF   1D,W
050A:  MOVWF  04
050B:  BCF    03.7
050C:  BTFSC  1E.0
050D:  BSF    03.7
050E:  INCF   04,F
050F:  BTFSS  03.2
0510:  GOTO   514
0511:  BCF    03.6
0512:  INCF   05,F
0513:  BSF    03.6
0514:  BCF    03.6
0515:  GOTO   4FA
0516:  RETURN
0517:  BSF    03.6
0518:  MOVF   1A,W
0519:  CLRF   78
051A:  SUBWF  19,W
051B:  BTFSC  03.0
051C:  GOTO   520
051D:  MOVF   19,W
051E:  MOVWF  77
051F:  GOTO   52C
0520:  CLRF   77
0521:  MOVLW  08
0522:  MOVWF  1B
0523:  RLF    19,F
0524:  RLF    77,F
0525:  MOVF   1A,W
0526:  SUBWF  77,W
0527:  BTFSC  03.0
0528:  MOVWF  77
0529:  RLF    78,F
052A:  DECFSZ 1B,F
052B:  GOTO   523
052C:  BCF    03.6
052D:  RETURN
*
0789:  MOVF   00,F
078A:  BTFSC  03.2
078B:  GOTO   7A6
078C:  BSF    03.6
078D:  CLRF   46
078E:  MOVF   04,W
078F:  MOVWF  45
0790:  BCF    46.0
0791:  BTFSC  03.7
0792:  BSF    46.0
0793:  MOVF   00,W
0794:  BCF    03.6
0795:  BTFSS  0C.4
0796:  GOTO   795
0797:  MOVWF  19
0798:  BSF    03.6
0799:  MOVF   45,W
079A:  MOVWF  04
079B:  BCF    03.7
079C:  BTFSC  46.0
079D:  BSF    03.7
079E:  INCF   04,F
079F:  BTFSS  03.2
07A0:  GOTO   7A4
07A1:  BCF    03.6
07A2:  INCF   05,F
07A3:  BSF    03.6
07A4:  BCF    03.6
07A5:  GOTO   789
07A6:  RETURN
*
0ABE:  CLRF   77
0ABF:  CLRF   78
0AC0:  MOVF   24,W
0AC1:  BCF    03.0
0AC2:  BTFSC  25.0
0AC3:  ADDWF  77,F
0AC4:  RRF    77,F
0AC5:  RRF    78,F
0AC6:  BTFSC  25.1
0AC7:  ADDWF  77,F
0AC8:  RRF    77,F
0AC9:  RRF    78,F
0ACA:  BTFSC  25.2
0ACB:  ADDWF  77,F
0ACC:  RRF    77,F
0ACD:  RRF    78,F
0ACE:  BTFSC  25.3
0ACF:  ADDWF  77,F
0AD0:  RRF    77,F
0AD1:  RRF    78,F
0AD2:  BTFSC  25.4
0AD3:  ADDWF  77,F
0AD4:  RRF    77,F
0AD5:  RRF    78,F
0AD6:  BTFSC  25.5
0AD7:  ADDWF  77,F
0AD8:  RRF    77,F
0AD9:  RRF    78,F
0ADA:  BTFSC  25.6
0ADB:  ADDWF  77,F
0ADC:  RRF    77,F
0ADD:  RRF    78,F
0ADE:  BTFSC  25.7
0ADF:  ADDWF  77,F
0AE0:  RRF    77,F
0AE1:  RRF    78,F
*
0DF2:  BSF    0A.0
0DF3:  BCF    0A.1
0DF4:  BSF    0A.2
0DF5:  ADDWF  02,F
0DF6:  GOTO   426
0DF7:  GOTO   427
0DF8:  GOTO   434
0DF9:  GOTO   441
0DFA:  GOTO   44B
0DFB:  GOTO   455
*
0E79:  MOVLW  8E
0E7A:  MOVWF  77
0E7B:  MOVF   22,W
0E7C:  MOVWF  78
0E7D:  MOVF   21,W
0E7E:  MOVWF  79
0E7F:  CLRF   7A
0E80:  MOVF   78,F
0E81:  BTFSS  03.2
0E82:  GOTO   68D
0E83:  MOVF   79,W
0E84:  MOVWF  78
0E85:  CLRF   79
0E86:  MOVLW  08
0E87:  SUBWF  77,F
0E88:  MOVF   78,F
0E89:  BTFSS  03.2
0E8A:  GOTO   68D
0E8B:  CLRF   77
0E8C:  GOTO   695
0E8D:  BCF    03.0
0E8E:  BTFSC  78.7
0E8F:  GOTO   694
0E90:  RLF    79,F
0E91:  RLF    78,F
0E92:  DECF   77,F
0E93:  GOTO   68D
0E94:  BCF    78.7
*
0EA5:  MOVF   21,W
0EA6:  BTFSC  03.2
0EA7:  GOTO   76A
0EA8:  MOVWF  2D
0EA9:  MOVF   25,W
0EAA:  BTFSC  03.2
0EAB:  GOTO   76A
0EAC:  SUBWF  2D,F
0EAD:  BTFSS  03.0
0EAE:  GOTO   6B4
0EAF:  MOVLW  7F
0EB0:  ADDWF  2D,F
0EB1:  BTFSC  03.0
0EB2:  GOTO   76A
0EB3:  GOTO   6BA
0EB4:  MOVLW  81
0EB5:  SUBWF  2D,F
0EB6:  BTFSS  03.0
0EB7:  GOTO   76A
0EB8:  BTFSC  03.2
0EB9:  GOTO   76A
0EBA:  MOVF   2D,W
0EBB:  MOVWF  77
0EBC:  CLRF   78
0EBD:  CLRF   79
0EBE:  CLRF   7A
0EBF:  CLRF   2C
0EC0:  MOVF   22,W
0EC1:  MOVWF  2B
0EC2:  BSF    2B.7
0EC3:  MOVF   23,W
0EC4:  MOVWF  2A
0EC5:  MOVF   24,W
0EC6:  MOVWF  29
0EC7:  MOVLW  19
0EC8:  MOVWF  2D
0EC9:  MOVF   28,W
0ECA:  SUBWF  29,F
0ECB:  BTFSC  03.0
0ECC:  GOTO   6DD
0ECD:  MOVLW  01
0ECE:  SUBWF  2A,F
0ECF:  BTFSC  03.0
0ED0:  GOTO   6DD
0ED1:  SUBWF  2B,F
0ED2:  BTFSC  03.0
0ED3:  GOTO   6DD
0ED4:  SUBWF  2C,F
0ED5:  BTFSC  03.0
0ED6:  GOTO   6DD
0ED7:  INCF   2C,F
0ED8:  INCF   2B,F
0ED9:  INCF   2A,F
0EDA:  MOVF   28,W
0EDB:  ADDWF  29,F
0EDC:  GOTO   70F
0EDD:  MOVF   27,W
0EDE:  SUBWF  2A,F
0EDF:  BTFSC  03.0
0EE0:  GOTO   6F8
0EE1:  MOVLW  01
0EE2:  SUBWF  2B,F
0EE3:  BTFSC  03.0
0EE4:  GOTO   6F8
0EE5:  SUBWF  2C,F
0EE6:  BTFSC  03.0
0EE7:  GOTO   6F8
0EE8:  INCF   2C,F
0EE9:  INCF   2B,F
0EEA:  MOVF   27,W
0EEB:  ADDWF  2A,F
0EEC:  MOVF   28,W
0EED:  ADDWF  29,F
0EEE:  BTFSS  03.0
0EEF:  GOTO   70F
0EF0:  INCF   2A,F
0EF1:  BTFSS  03.2
0EF2:  GOTO   70F
0EF3:  INCF   2B,F
0EF4:  BTFSS  03.2
0EF5:  GOTO   70F
0EF6:  INCF   2C,F
0EF7:  GOTO   70F
0EF8:  MOVF   26,W
0EF9:  IORLW  80
0EFA:  SUBWF  2B,F
0EFB:  BTFSC  03.0
0EFC:  GOTO   70E
0EFD:  MOVLW  01
0EFE:  SUBWF  2C,F
0EFF:  BTFSC  03.0
0F00:  GOTO   70E
0F01:  INCF   2C,F
0F02:  MOVF   26,W
0F03:  IORLW  80
0F04:  ADDWF  2B,F
0F05:  MOVF   27,W
0F06:  ADDWF  2A,F
0F07:  BTFSS  03.0
0F08:  GOTO   6EC
0F09:  INCF   2B,F
0F0A:  BTFSS  03.2
0F0B:  GOTO   6EC
0F0C:  INCF   2C,F
0F0D:  GOTO   6EC
0F0E:  BSF    7A.0
0F0F:  DECFSZ 2D,F
0F10:  GOTO   712
0F11:  GOTO   71D
0F12:  BCF    03.0
0F13:  RLF    29,F
0F14:  RLF    2A,F
0F15:  RLF    2B,F
0F16:  RLF    2C,F
0F17:  BCF    03.0
0F18:  RLF    7A,F
0F19:  RLF    79,F
0F1A:  RLF    78,F
0F1B:  RLF    2E,F
0F1C:  GOTO   6C9
0F1D:  BTFSS  2E.0
0F1E:  GOTO   725
0F1F:  BCF    03.0
0F20:  RRF    78,F
0F21:  RRF    79,F
0F22:  RRF    7A,F
0F23:  RRF    2E,F
0F24:  GOTO   728
0F25:  DECF   77,F
0F26:  BTFSC  03.2
0F27:  GOTO   76A
0F28:  BTFSC  2E.7
0F29:  GOTO   751
0F2A:  BCF    03.0
0F2B:  RLF    29,F
0F2C:  RLF    2A,F
0F2D:  RLF    2B,F
0F2E:  RLF    2C,F
0F2F:  MOVF   28,W
0F30:  SUBWF  29,F
0F31:  BTFSC  03.0
0F32:  GOTO   73D
0F33:  MOVLW  01
0F34:  SUBWF  2A,F
0F35:  BTFSC  03.0
0F36:  GOTO   73D
0F37:  SUBWF  2B,F
0F38:  BTFSC  03.0
0F39:  GOTO   73D
0F3A:  SUBWF  2C,F
0F3B:  BTFSS  03.0
0F3C:  GOTO   760
0F3D:  MOVF   27,W
0F3E:  SUBWF  2A,F
0F3F:  BTFSC  03.0
0F40:  GOTO   748
0F41:  MOVLW  01
0F42:  SUBWF  2B,F
0F43:  BTFSC  03.0
0F44:  GOTO   748
0F45:  SUBWF  2C,F
0F46:  BTFSS  03.0
0F47:  GOTO   760
0F48:  MOVF   26,W
0F49:  IORLW  80
0F4A:  SUBWF  2B,F
0F4B:  BTFSC  03.0
0F4C:  GOTO   751
0F4D:  MOVLW  01
0F4E:  SUBWF  2C,F
0F4F:  BTFSS  03.0
0F50:  GOTO   760
0F51:  INCF   7A,F
0F52:  BTFSS  03.2
0F53:  GOTO   760
0F54:  INCF   79,F
0F55:  BTFSS  03.2
0F56:  GOTO   760
0F57:  INCF   78,F
0F58:  BTFSS  03.2
0F59:  GOTO   760
0F5A:  INCF   77,F
0F5B:  BTFSC  03.2
0F5C:  GOTO   76A
0F5D:  RRF    78,F
0F5E:  RRF    79,F
0F5F:  RRF    7A,F
0F60:  MOVF   22,W
0F61:  MOVWF  2D
0F62:  MOVF   26,W
0F63:  XORWF  2D,F
0F64:  BTFSS  2D.7
0F65:  GOTO   768
0F66:  BSF    78.7
0F67:  GOTO   76E
0F68:  BCF    78.7
0F69:  GOTO   76E
0F6A:  CLRF   77
0F6B:  CLRF   78
0F6C:  CLRF   79
0F6D:  CLRF   7A
*
0F76:  MOVLW  8E
0F77:  MOVWF  77
0F78:  MOVF   21,W
0F79:  SUBWF  77,F
0F7A:  MOVF   22,W
0F7B:  MOVWF  79
0F7C:  MOVF   23,W
0F7D:  MOVWF  78
0F7E:  BSF    79.7
0F7F:  MOVF   77,F
0F80:  BTFSC  03.2
0F81:  GOTO   78D
0F82:  BCF    03.0
0F83:  MOVF   79,F
0F84:  BTFSS  03.2
0F85:  GOTO   789
0F86:  MOVF   78,F
0F87:  BTFSC  03.2
0F88:  GOTO   78D
0F89:  RRF    79,F
0F8A:  RRF    78,F
0F8B:  DECFSZ 77,F
0F8C:  GOTO   782
0F8D:  BTFSS  22.7
0F8E:  GOTO   794
0F8F:  COMF   78,F
0F90:  COMF   79,F
0F91:  INCF   78,F
0F92:  BTFSC  03.2
0F93:  INCF   79,F
*
10A5:  BCF    03.6
10A6:  MOVF   0B,W
10A7:  BSF    03.6
10A8:  MOVWF  40
10A9:  BCF    03.6
10AA:  BCF    0B.7
10AB:  BSF    03.5
10AC:  BSF    03.6
10AD:  BSF    0C.7
10AE:  BSF    0C.0
10AF:  NOP
10B0:  NOP
10B1:  BCF    03.5
10B2:  BTFSS  40.7
10B3:  GOTO   0B7
10B4:  BCF    03.6
10B5:  BSF    0B.7
10B6:  BSF    03.6
10B7:  MOVF   0C,W
10B8:  ANDLW  7F
10B9:  BTFSC  03.2
10BA:  GOTO   0F4
10BB:  MOVWF  40
10BC:  MOVF   0D,W
10BD:  MOVWF  41
10BE:  MOVF   0F,W
10BF:  MOVWF  42
10C0:  MOVF   40,W
10C1:  BCF    03.6
10C2:  BTFSS  0C.4
10C3:  GOTO   0C2
10C4:  MOVWF  19
10C5:  BSF    03.6
10C6:  MOVF   41,W
10C7:  MOVWF  0D
10C8:  MOVF   42,W
10C9:  MOVWF  0F
10CA:  BCF    03.6
10CB:  MOVF   0B,W
10CC:  BSF    03.6
10CD:  MOVWF  43
10CE:  BCF    03.6
10CF:  BCF    0B.7
10D0:  BSF    03.5
10D1:  BSF    03.6
10D2:  BSF    0C.7
10D3:  BSF    0C.0
10D4:  NOP
10D5:  NOP
10D6:  BCF    03.5
10D7:  BTFSS  43.7
10D8:  GOTO   0DC
10D9:  BCF    03.6
10DA:  BSF    0B.7
10DB:  BSF    03.6
10DC:  RLF    0C,W
10DD:  RLF    0E,W
10DE:  ANDLW  7F
10DF:  BTFSC  03.2
10E0:  GOTO   0F4
10E1:  MOVWF  40
10E2:  MOVF   0D,W
10E3:  MOVWF  41
10E4:  MOVF   0F,W
10E5:  MOVWF  42
10E6:  MOVF   40,W
10E7:  BCF    03.6
10E8:  BTFSS  0C.4
10E9:  GOTO   0E8
10EA:  MOVWF  19
10EB:  BSF    03.6
10EC:  MOVF   41,W
10ED:  MOVWF  0D
10EE:  MOVF   42,W
10EF:  MOVWF  0F
10F0:  INCF   0D,F
10F1:  BTFSC  03.2
10F2:  INCF   0F,F
10F3:  GOTO   0A5
....................  
.................... #list 
....................  
.................... #DEVICE ADC=10 
.................... #INCLUDE <STRING.H> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
*
072B:  BSF    03.6
072C:  MOVF   45,W
072D:  MOVWF  49
072E:  MOVF   44,W
072F:  MOVWF  48
0730:  MOVF   49,W
0731:  MOVWF  7A
0732:  MOVF   48,W
0733:  MOVWF  04
0734:  BCF    03.7
0735:  BTFSC  7A.0
0736:  BSF    03.7
0737:  MOVF   00,F
0738:  BTFSC  03.2
0739:  GOTO   73E
073A:  INCF   48,F
073B:  BTFSC  03.2
073C:  INCF   49,F
073D:  GOTO   730
....................    while(*s2 != '\0') 
073E:  MOVF   47,W
073F:  MOVWF  7A
0740:  MOVF   46,W
0741:  MOVWF  04
0742:  BCF    03.7
0743:  BTFSC  7A.0
0744:  BSF    03.7
0745:  MOVF   00,F
0746:  BTFSC  03.2
0747:  GOTO   75D
....................    { 
....................       *s = *s2; 
0748:  MOVF   46,W
0749:  MOVWF  04
074A:  BCF    03.7
074B:  BTFSC  47.0
074C:  BSF    03.7
074D:  MOVF   00,W
074E:  MOVWF  4C
074F:  MOVF   48,W
0750:  MOVWF  04
0751:  BCF    03.7
0752:  BTFSC  49.0
0753:  BSF    03.7
0754:  MOVF   4C,W
0755:  MOVWF  00
....................       ++s; 
0756:  INCF   48,F
0757:  BTFSC  03.2
0758:  INCF   49,F
....................       ++s2; 
0759:  INCF   46,F
075A:  BTFSC  03.2
075B:  INCF   47,F
075C:  GOTO   73E
....................    } 
....................  
....................    *s = '\0'; 
075D:  MOVF   48,W
075E:  MOVWF  04
075F:  BCF    03.7
0760:  BTFSC  49.0
0761:  BSF    03.7
0762:  CLRF   00
....................    return(s1); 
0763:  MOVF   44,W
0764:  MOVWF  78
0765:  MOVF   45,W
0766:  MOVWF  79
0767:  BCF    03.6
0768:  RETURN
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
*
0B51:  BSF    03.6
0B52:  MOVF   1C,W
0B53:  MOVWF  7A
0B54:  MOVF   1B,W
0B55:  MOVWF  04
0B56:  BCF    03.7
0B57:  BTFSC  7A.0
0B58:  BSF    03.7
0B59:  MOVF   00,W
0B5A:  MOVWF  1F
0B5B:  MOVF   1E,W
0B5C:  MOVWF  7A
0B5D:  MOVF   1D,W
0B5E:  MOVWF  04
0B5F:  BCF    03.7
0B60:  BTFSC  7A.0
0B61:  BSF    03.7
0B62:  MOVF   00,W
0B63:  SUBWF  1F,W
0B64:  BTFSS  03.2
0B65:  GOTO   37D
....................       if (*s1 == '\0') 
0B66:  MOVF   1C,W
0B67:  MOVWF  7A
0B68:  MOVF   1B,W
0B69:  MOVWF  04
0B6A:  BCF    03.7
0B6B:  BTFSC  7A.0
0B6C:  BSF    03.7
0B6D:  MOVF   00,F
0B6E:  BTFSS  03.2
0B6F:  GOTO   373
....................          return(0); 
0B70:  MOVLW  00
0B71:  MOVWF  78
0B72:  GOTO   395
0B73:  MOVF   1C,W
0B74:  MOVWF  7A
0B75:  MOVF   1B,W
0B76:  INCF   1B,F
0B77:  BTFSC  03.2
0B78:  INCF   1C,F
0B79:  INCF   1D,F
0B7A:  BTFSC  03.2
0B7B:  INCF   1E,F
0B7C:  GOTO   352
....................    return((*s1 < *s2) ? -1: 1); 
0B7D:  MOVF   1C,W
0B7E:  MOVWF  7A
0B7F:  MOVF   1B,W
0B80:  MOVWF  04
0B81:  BCF    03.7
0B82:  BTFSC  1C.0
0B83:  BSF    03.7
0B84:  MOVF   00,W
0B85:  MOVWF  1F
0B86:  MOVF   1E,W
0B87:  MOVWF  7A
0B88:  MOVF   1D,W
0B89:  MOVWF  04
0B8A:  BCF    03.7
0B8B:  BTFSC  1E.0
0B8C:  BSF    03.7
0B8D:  MOVF   00,W
0B8E:  SUBWF  1F,W
0B8F:  BTFSC  03.0
0B90:  GOTO   393
0B91:  MOVLW  FF
0B92:  GOTO   394
0B93:  MOVLW  01
0B94:  MOVWF  78
0B95:  BCF    03.6
0B96:  RETURN
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
*
0BC3:  MOVF   1C,W
0BC4:  MOVWF  7A
0BC5:  MOVF   1B,W
0BC6:  MOVWF  04
0BC7:  BCF    03.7
0BC8:  BTFSC  7A.0
0BC9:  BSF    03.7
0BCA:  MOVF   1D,W
0BCB:  SUBWF  00,W
0BCC:  BTFSC  03.2
0BCD:  GOTO   3E0
....................       if (*s == '\0') 
0BCE:  MOVF   1C,W
0BCF:  MOVWF  7A
0BD0:  MOVF   1B,W
0BD1:  MOVWF  04
0BD2:  BCF    03.7
0BD3:  BTFSC  7A.0
0BD4:  BSF    03.7
0BD5:  MOVF   00,F
0BD6:  BTFSS  03.2
0BD7:  GOTO   3DC
....................          return(0); 
0BD8:  MOVLW  00
0BD9:  MOVWF  78
0BDA:  MOVWF  79
0BDB:  GOTO   3E4
0BDC:  INCF   1B,F
0BDD:  BTFSC  03.2
0BDE:  INCF   1C,F
0BDF:  GOTO   3C3
....................    return(s); 
0BE0:  MOVF   1B,W
0BE1:  MOVWF  78
0BE2:  MOVF   1C,W
0BE3:  MOVWF  79
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
*
09EA:  MOVF   26,W
09EB:  MOVWF  2A
09EC:  MOVF   25,W
09ED:  MOVWF  29
09EE:  MOVF   2A,W
09EF:  MOVWF  7A
09F0:  MOVF   29,W
09F1:  MOVWF  04
09F2:  BCF    03.7
09F3:  BTFSC  7A.0
09F4:  BSF    03.7
09F5:  MOVF   00,F
09F6:  BTFSC  03.2
09F7:  GOTO   227
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
09F8:  MOVF   28,W
09F9:  MOVWF  2C
09FA:  MOVF   27,W
09FB:  MOVWF  2B
09FC:  MOVF   2C,W
09FD:  MOVWF  7A
09FE:  MOVF   2B,W
09FF:  MOVWF  04
0A00:  BCF    03.7
0A01:  BTFSC  7A.0
0A02:  BSF    03.7
0A03:  MOVF   00,F
0A04:  BTFSC  03.2
0A05:  GOTO   223
....................          if (*sc1 == *sc2) 
0A06:  MOVF   2A,W
0A07:  MOVWF  7A
0A08:  MOVF   29,W
0A09:  MOVWF  04
0A0A:  BCF    03.7
0A0B:  BTFSC  7A.0
0A0C:  BSF    03.7
0A0D:  MOVF   00,W
0A0E:  MOVWF  2D
0A0F:  MOVF   2C,W
0A10:  MOVWF  7A
0A11:  MOVF   2B,W
0A12:  MOVWF  04
0A13:  BCF    03.7
0A14:  BTFSC  7A.0
0A15:  BSF    03.7
0A16:  MOVF   00,W
0A17:  SUBWF  2D,W
0A18:  BTFSS  03.2
0A19:  GOTO   21F
....................             return(sc1); 
0A1A:  MOVF   29,W
0A1B:  MOVWF  78
0A1C:  MOVF   2A,W
0A1D:  MOVWF  79
0A1E:  GOTO   22A
0A1F:  INCF   2B,F
0A20:  BTFSC  03.2
0A21:  INCF   2C,F
0A22:  GOTO   1FC
0A23:  INCF   29,F
0A24:  BTFSC  03.2
0A25:  INCF   2A,F
0A26:  GOTO   1EE
....................    return(0); 
0A27:  MOVLW  00
0A28:  MOVWF  78
0A29:  MOVWF  79
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
*
0977:  MOVF   26,W
0978:  MOVWF  2A
0979:  MOVF   25,W
097A:  MOVWF  29
097B:  MOVF   2A,W
097C:  MOVWF  7A
097D:  MOVF   29,W
097E:  MOVWF  04
097F:  BCF    03.7
0980:  BTFSC  7A.0
0981:  BSF    03.7
0982:  MOVF   00,F
0983:  BTFSC  03.2
0984:  GOTO   1BC
....................       for (sc2 = s2; ; sc2++) 
0985:  MOVF   28,W
0986:  MOVWF  2C
0987:  MOVF   27,W
0988:  MOVWF  2B
....................     if (*sc2 == '\0') 
0989:  MOVF   2C,W
098A:  MOVWF  7A
098B:  MOVF   2B,W
098C:  MOVWF  04
098D:  BCF    03.7
098E:  BTFSC  7A.0
098F:  BSF    03.7
0990:  MOVF   00,F
0991:  BTFSS  03.2
0992:  GOTO   1A0
....................        return(sc1 - s1); 
0993:  MOVF   25,W
0994:  SUBWF  29,W
0995:  MOVWF  77
0996:  MOVF   2A,W
0997:  MOVWF  7A
0998:  MOVF   26,W
0999:  BTFSS  03.0
099A:  INCFSZ 26,W
099B:  SUBWF  7A,F
099C:  MOVF   77,W
099D:  MOVWF  78
099E:  GOTO   1C7
099F:  GOTO   1B4
....................          else if (*sc1 == *sc2) 
09A0:  MOVF   2A,W
09A1:  MOVWF  7A
09A2:  MOVF   29,W
09A3:  MOVWF  04
09A4:  BCF    03.7
09A5:  BTFSC  7A.0
09A6:  BSF    03.7
09A7:  MOVF   00,W
09A8:  MOVWF  2D
09A9:  MOVF   2C,W
09AA:  MOVWF  7A
09AB:  MOVF   2B,W
09AC:  MOVWF  04
09AD:  BCF    03.7
09AE:  BTFSC  7A.0
09AF:  BSF    03.7
09B0:  MOVF   00,W
09B1:  SUBWF  2D,W
09B2:  BTFSC  03.2
....................             break; 
09B3:  GOTO   1B8
09B4:  INCF   2B,F
09B5:  BTFSC  03.2
09B6:  INCF   2C,F
09B7:  GOTO   189
09B8:  INCF   29,F
09B9:  BTFSC  03.2
09BA:  INCF   2A,F
09BB:  GOTO   17B
....................    return(sc1 - s1); 
09BC:  MOVF   25,W
09BD:  SUBWF  29,W
09BE:  MOVWF  77
09BF:  MOVF   2A,W
09C0:  MOVWF  7A
09C1:  MOVF   26,W
09C2:  BTFSS  03.0
09C3:  INCFSZ 26,W
09C4:  SUBWF  7A,F
09C5:  MOVF   77,W
09C6:  MOVWF  78
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
*
1158:  BCF    03.6
1159:  CLRF   2B
115A:  CLRF   2C
....................  
....................    beg = (s1)? s1: save; 
*
095E:  BSF    03.6
095F:  MOVF   1D,W
0960:  IORWF  1E,W
0961:  BTFSC  03.2
0962:  GOTO   167
0963:  MOVF   1E,W
0964:  MOVWF  7A
0965:  MOVF   1D,W
0966:  GOTO   16C
0967:  BCF    03.6
0968:  MOVF   2C,W
0969:  MOVWF  7A
096A:  MOVF   2B,W
096B:  BSF    03.6
096C:  MOVWF  21
096D:  MOVF   7A,W
096E:  MOVWF  22
....................    beg += strspn(beg, s2); 
096F:  MOVF   22,W
0970:  MOVWF  26
0971:  MOVF   21,W
0972:  MOVWF  25
0973:  MOVF   20,W
0974:  MOVWF  28
0975:  MOVF   1F,W
0976:  MOVWF  27
*
09C7:  MOVF   78,W
09C8:  ADDWF  21,F
09C9:  BTFSC  03.0
09CA:  INCF   22,F
....................    if (*beg == '\0') 
09CB:  MOVF   22,W
09CC:  MOVWF  7A
09CD:  MOVF   21,W
09CE:  MOVWF  04
09CF:  BCF    03.7
09D0:  BTFSC  7A.0
09D1:  BSF    03.7
09D2:  MOVF   00,F
09D3:  BTFSS  03.2
09D4:  GOTO   1E2
....................    { 
....................       *save = ' '; 
09D5:  BCF    03.6
09D6:  MOVF   2B,W
09D7:  MOVWF  04
09D8:  BCF    03.7
09D9:  BTFSC  2C.0
09DA:  BSF    03.7
09DB:  MOVLW  20
09DC:  MOVWF  00
....................       return(0); 
09DD:  MOVLW  00
09DE:  MOVWF  78
09DF:  MOVWF  79
09E0:  GOTO   24E
09E1:  BSF    03.6
....................    } 
....................    end = strpbrk(beg, s2); 
09E2:  MOVF   22,W
09E3:  MOVWF  26
09E4:  MOVF   21,W
09E5:  MOVWF  25
09E6:  MOVF   20,W
09E7:  MOVWF  28
09E8:  MOVF   1F,W
09E9:  MOVWF  27
*
0A2A:  MOVF   79,W
0A2B:  MOVWF  24
0A2C:  MOVF   78,W
0A2D:  MOVWF  23
....................    if (*end != '\0') 
0A2E:  MOVF   24,W
0A2F:  MOVWF  7A
0A30:  MOVF   23,W
0A31:  MOVWF  04
0A32:  BCF    03.7
0A33:  BTFSC  7A.0
0A34:  BSF    03.7
0A35:  MOVF   00,F
0A36:  BTFSC  03.2
0A37:  GOTO   241
....................    { 
....................       *end = '\0'; 
0A38:  MOVF   23,W
0A39:  MOVWF  04
0A3A:  BCF    03.7
0A3B:  BTFSC  24.0
0A3C:  BSF    03.7
0A3D:  CLRF   00
....................       end++; 
0A3E:  INCF   23,F
0A3F:  BTFSC  03.2
0A40:  INCF   24,F
....................    } 
....................    save = end; 
0A41:  MOVF   24,W
0A42:  BCF    03.6
0A43:  MOVWF  2C
0A44:  BSF    03.6
0A45:  MOVF   23,W
0A46:  BCF    03.6
0A47:  MOVWF  2B
....................    return(beg); 
0A48:  BSF    03.6
0A49:  MOVF   21,W
0A4A:  MOVWF  78
0A4B:  MOVF   22,W
0A4C:  MOVWF  79
0A4D:  BCF    03.6
0A4E:  RETURN
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
*
0769:  BSF    03.6
076A:  MOVF   46,W
076B:  MOVWF  48
076C:  MOVF   45,W
076D:  MOVWF  47
076E:  MOVF   48,W
076F:  MOVWF  7A
0770:  MOVF   47,W
0771:  MOVWF  04
0772:  BCF    03.7
0773:  BTFSC  7A.0
0774:  BSF    03.7
0775:  MOVF   00,F
0776:  BTFSC  03.2
0777:  GOTO   77C
0778:  INCF   47,F
0779:  BTFSC  03.2
077A:  INCF   48,F
077B:  GOTO   76E
....................    return(sc - s); 
077C:  MOVF   45,W
077D:  SUBWF  47,W
077E:  MOVWF  77
077F:  MOVF   48,W
0780:  MOVWF  7A
0781:  MOVF   46,W
0782:  BTFSS  03.0
0783:  INCFSZ 46,W
0784:  SUBWF  7A,F
0785:  MOVF   77,W
0786:  MOVWF  78
0787:  BCF    03.6
0788:  RETURN
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #INCLUDE <STDLIB.H> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... /* Standart template: float strtof(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... float strtof(char *s,char *endptr); 
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s,char *endptr); 
.................... float64 strtod(char *s,char *endptr); 
.................... #else 
.................... //provided for compatibility 
.................... #define strtof48(s, e) strtof(s, e) 
.................... #define strtod(s, e) strtof(s, e) 
.................... #endif 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof(s)   strtof(s, 0) 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof48(s) strtof48(s, 0) 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof64(s) strtod(s, 0) 
.................... #endif 
....................  
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float atoe(char * s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s); 
.................... #endif 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... unsigned int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................  
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
*
0A4F:  BSF    03.6
0A50:  CLRF   22
....................    sign = 0; 
0A51:  CLRF   20
....................    base = 10; 
0A52:  MOVLW  0A
0A53:  MOVWF  21
....................    result = 0; 
0A54:  CLRF   1F
....................  
....................    if (!s) 
0A55:  MOVF   1D,W
0A56:  IORWF  1E,W
0A57:  BTFSS  03.2
0A58:  GOTO   25C
....................       return 0; 
0A59:  MOVLW  00
0A5A:  MOVWF  78
0A5B:  GOTO   34F
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
0A5C:  MOVF   22,W
0A5D:  INCF   22,F
0A5E:  ADDWF  1D,W
0A5F:  MOVWF  04
0A60:  BCF    03.7
0A61:  BTFSC  1E.0
0A62:  BSF    03.7
0A63:  MOVF   00,W
0A64:  MOVWF  23
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
0A65:  MOVF   23,W
0A66:  SUBLW  2D
0A67:  BTFSS  03.2
0A68:  GOTO   275
....................    { 
....................       sign = 1;         // Set the sign to negative 
0A69:  MOVLW  01
0A6A:  MOVWF  20
....................       c = s[index++]; 
0A6B:  MOVF   22,W
0A6C:  INCF   22,F
0A6D:  ADDWF  1D,W
0A6E:  MOVWF  04
0A6F:  BCF    03.7
0A70:  BTFSC  1E.0
0A71:  BSF    03.7
0A72:  MOVF   00,W
0A73:  MOVWF  23
....................    } 
0A74:  GOTO   282
....................    else if (c == '+') 
0A75:  MOVF   23,W
0A76:  SUBLW  2B
0A77:  BTFSS  03.2
0A78:  GOTO   282
....................    { 
....................       c = s[index++]; 
0A79:  MOVF   22,W
0A7A:  INCF   22,F
0A7B:  ADDWF  1D,W
0A7C:  MOVWF  04
0A7D:  BCF    03.7
0A7E:  BTFSC  1E.0
0A7F:  BSF    03.7
0A80:  MOVF   00,W
0A81:  MOVWF  23
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
0A82:  MOVF   23,W
0A83:  SUBLW  2F
0A84:  BTFSC  03.0
0A85:  GOTO   345
0A86:  MOVF   23,W
0A87:  SUBLW  39
0A88:  BTFSS  03.0
0A89:  GOTO   345
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
0A8A:  MOVF   23,W
0A8B:  SUBLW  30
0A8C:  BTFSS  03.2
0A8D:  GOTO   2AE
0A8E:  MOVF   22,W
0A8F:  ADDWF  1D,W
0A90:  MOVWF  04
0A91:  BCF    03.7
0A92:  BTFSC  1E.0
0A93:  BSF    03.7
0A94:  MOVF   00,W
0A95:  SUBLW  78
0A96:  BTFSC  03.2
0A97:  GOTO   2A2
0A98:  MOVF   22,W
0A99:  ADDWF  1D,W
0A9A:  MOVWF  04
0A9B:  BCF    03.7
0A9C:  BTFSC  1E.0
0A9D:  BSF    03.7
0A9E:  MOVF   00,W
0A9F:  SUBLW  58
0AA0:  BTFSS  03.2
0AA1:  GOTO   2AE
....................       { 
....................          base = 16; 
0AA2:  MOVLW  10
0AA3:  MOVWF  21
....................          index++; 
0AA4:  INCF   22,F
....................          c = s[index++]; 
0AA5:  MOVF   22,W
0AA6:  INCF   22,F
0AA7:  ADDWF  1D,W
0AA8:  MOVWF  04
0AA9:  BCF    03.7
0AAA:  BTFSC  1E.0
0AAB:  BSF    03.7
0AAC:  MOVF   00,W
0AAD:  MOVWF  23
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
0AAE:  MOVF   21,W
0AAF:  SUBLW  0A
0AB0:  BTFSS  03.2
0AB1:  GOTO   2F3
....................       { 
....................          while (c >= '0' && c <= '9') 
0AB2:  MOVF   23,W
0AB3:  SUBLW  2F
0AB4:  BTFSC  03.0
0AB5:  GOTO   2F2
0AB6:  MOVF   23,W
0AB7:  SUBLW  39
0AB8:  BTFSS  03.0
0AB9:  GOTO   2F2
....................          { 
....................             result = 10*result + (c - '0'); 
0ABA:  MOVLW  0A
0ABB:  MOVWF  24
0ABC:  MOVF   1F,W
0ABD:  MOVWF  25
*
0AE2:  MOVF   78,W
0AE3:  MOVWF  24
0AE4:  MOVLW  30
0AE5:  SUBWF  23,W
0AE6:  ADDWF  24,W
0AE7:  MOVWF  1F
....................             c = s[index++]; 
0AE8:  MOVF   22,W
0AE9:  INCF   22,F
0AEA:  ADDWF  1D,W
0AEB:  MOVWF  04
0AEC:  BCF    03.7
0AED:  BTFSC  1E.0
0AEE:  BSF    03.7
0AEF:  MOVF   00,W
0AF0:  MOVWF  23
0AF1:  GOTO   2B2
....................          } 
....................       } 
0AF2:  GOTO   345
....................       else if (base == 16)    // The number is a hexa number 
0AF3:  MOVF   21,W
0AF4:  SUBLW  10
0AF5:  BTFSS  03.2
0AF6:  GOTO   345
....................       { 
....................          c = toupper(c); 
0AF7:  MOVF   23,W
0AF8:  SUBLW  60
0AF9:  BTFSC  03.0
0AFA:  GOTO   302
0AFB:  MOVF   23,W
0AFC:  SUBLW  7A
0AFD:  BTFSS  03.0
0AFE:  GOTO   302
0AFF:  MOVF   23,W
0B00:  ANDLW  DF
0B01:  GOTO   303
0B02:  MOVF   23,W
0B03:  MOVWF  23
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
0B04:  MOVF   23,W
0B05:  SUBLW  2F
0B06:  BTFSC  03.0
0B07:  GOTO   30C
0B08:  MOVF   23,W
0B09:  SUBLW  39
0B0A:  BTFSC  03.0
0B0B:  GOTO   314
0B0C:  MOVF   23,W
0B0D:  SUBLW  40
0B0E:  BTFSC  03.0
0B0F:  GOTO   345
0B10:  MOVF   23,W
0B11:  SUBLW  46
0B12:  BTFSS  03.0
0B13:  GOTO   345
....................          { 
....................             if (c >= '0' && c <= '9') 
0B14:  MOVF   23,W
0B15:  SUBLW  2F
0B16:  BTFSC  03.0
0B17:  GOTO   325
0B18:  MOVF   23,W
0B19:  SUBLW  39
0B1A:  BTFSS  03.0
0B1B:  GOTO   325
....................                result = (result << 4) + (c - '0'); 
0B1C:  SWAPF  1F,W
0B1D:  MOVWF  24
0B1E:  MOVLW  F0
0B1F:  ANDWF  24,F
0B20:  MOVLW  30
0B21:  SUBWF  23,W
0B22:  ADDWF  24,W
0B23:  MOVWF  1F
0B24:  GOTO   32E
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
0B25:  SWAPF  1F,W
0B26:  MOVWF  24
0B27:  MOVLW  F0
0B28:  ANDWF  24,F
0B29:  MOVLW  41
0B2A:  SUBWF  23,W
0B2B:  ADDLW  0A
0B2C:  ADDWF  24,W
0B2D:  MOVWF  1F
....................  
....................             c = s[index++]; 
0B2E:  MOVF   22,W
0B2F:  INCF   22,F
0B30:  ADDWF  1D,W
0B31:  MOVWF  04
0B32:  BCF    03.7
0B33:  BTFSC  1E.0
0B34:  BSF    03.7
0B35:  MOVF   00,W
0B36:  MOVWF  23
....................             c = toupper(c); 
0B37:  MOVF   23,W
0B38:  SUBLW  60
0B39:  BTFSC  03.0
0B3A:  GOTO   342
0B3B:  MOVF   23,W
0B3C:  SUBLW  7A
0B3D:  BTFSS  03.0
0B3E:  GOTO   342
0B3F:  MOVF   23,W
0B40:  ANDLW  DF
0B41:  GOTO   343
0B42:  MOVF   23,W
0B43:  MOVWF  23
0B44:  GOTO   304
....................          } 
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
0B45:  DECFSZ 20,W
0B46:  GOTO   34D
0B47:  MOVF   21,W
0B48:  SUBLW  0A
0B49:  BTFSS  03.2
0B4A:  GOTO   34D
....................        result = -result; 
0B4B:  COMF   1F,F
0B4C:  INCF   1F,F
....................  
....................    return(result); 
0B4D:  MOVF   1F,W
0B4E:  MOVWF  78
0B4F:  BCF    03.6
0B50:  RETURN
.................... } 
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
*
03DA:  BSF    03.6
03DB:  CLRF   4F
03DC:  CLRF   4E
03DD:  CLRF   4D
03DE:  MOVLW  01
03DF:  MOVWF  4C
03E0:  CLRF   51
03E1:  CLRF   52
.................... { 
....................      unsigned int32 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
03E2:  BTFSS  48.7
03E3:  GOTO   424
....................          sign=1;        // Check for negative number 
03E4:  MOVLW  01
03E5:  MOVWF  51
....................          num*=-1; 
03E6:  MOVF   48,W
03E7:  MOVWF  57
03E8:  MOVF   47,W
03E9:  MOVWF  56
03EA:  MOVF   46,W
03EB:  MOVWF  55
03EC:  MOVF   45,W
03ED:  MOVWF  54
03EE:  MOVLW  FF
03EF:  MOVWF  5B
03F0:  MOVWF  5A
03F1:  MOVWF  59
03F2:  MOVWF  58
*
041C:  MOVF   7A,W
041D:  MOVWF  48
041E:  MOVF   79,W
041F:  MOVWF  47
0420:  MOVF   78,W
0421:  MOVWF  46
0422:  MOVF   77,W
0423:  MOVWF  45
....................      } 
....................  
....................      while(temp>0) { 
0424:  MOVF   4C,F
0425:  BTFSS  03.2
0426:  GOTO   430
0427:  MOVF   4D,F
0428:  BTFSS  03.2
0429:  GOTO   430
042A:  MOVF   4E,F
042B:  BTFSS  03.2
042C:  GOTO   430
042D:  MOVF   4F,F
042E:  BTFSC  03.2
042F:  GOTO   4AC
....................          temp=(num/base); 
0430:  BCF    03.1
0431:  MOVF   48,W
0432:  MOVWF  5F
0433:  MOVF   47,W
0434:  MOVWF  5E
0435:  MOVF   46,W
0436:  MOVWF  5D
0437:  MOVF   45,W
0438:  MOVWF  5C
0439:  CLRF   63
043A:  CLRF   62
043B:  CLRF   61
043C:  MOVF   49,W
043D:  MOVWF  60
043E:  BCF    03.6
043F:  CALL   35E
0440:  MOVF   7A,W
0441:  BSF    03.6
0442:  MOVWF  4F
0443:  MOVF   79,W
0444:  MOVWF  4E
0445:  MOVF   78,W
0446:  MOVWF  4D
0447:  MOVF   77,W
0448:  MOVWF  4C
....................          s[cnt]=(num%base)+'0';    // Conversion 
0449:  MOVF   52,W
044A:  ADDWF  4A,W
044B:  MOVWF  78
044C:  MOVF   4B,W
044D:  MOVWF  7A
044E:  BTFSC  03.0
044F:  INCF   7A,F
0450:  MOVF   78,W
0451:  MOVWF  54
0452:  MOVF   7A,W
0453:  MOVWF  55
0454:  CLRF   57
0455:  MOVF   04,W
0456:  MOVWF  56
0457:  BCF    57.0
0458:  BTFSC  03.7
0459:  BSF    57.0
045A:  BSF    03.1
045B:  MOVLW  58
045C:  MOVWF  04
045D:  BSF    03.7
045E:  MOVF   48,W
045F:  MOVWF  5F
0460:  MOVF   47,W
0461:  MOVWF  5E
0462:  MOVF   46,W
0463:  MOVWF  5D
0464:  MOVF   45,W
0465:  MOVWF  5C
0466:  CLRF   63
0467:  CLRF   62
0468:  CLRF   61
0469:  MOVF   49,W
046A:  MOVWF  60
046B:  BCF    03.6
046C:  CALL   35E
046D:  BSF    03.6
046E:  MOVF   56,W
046F:  MOVWF  04
0470:  BCF    03.7
0471:  BTFSC  57.0
0472:  BSF    03.7
0473:  MOVLW  30
0474:  ADDWF  58,W
0475:  MOVWF  77
0476:  MOVF   59,W
0477:  MOVWF  78
0478:  MOVLW  00
0479:  BTFSC  03.0
047A:  MOVLW  01
047B:  ADDWF  78,F
047C:  MOVF   5A,W
047D:  MOVWF  79
047E:  MOVLW  00
047F:  BTFSC  03.0
0480:  MOVLW  01
0481:  ADDWF  79,F
0482:  MOVF   5B,W
0483:  MOVWF  7A
0484:  MOVLW  00
0485:  BTFSC  03.0
0486:  MOVLW  01
0487:  ADDWF  7A,F
0488:  MOVF   54,W
0489:  MOVWF  04
048A:  BCF    03.7
048B:  BTFSC  55.0
048C:  BSF    03.7
048D:  MOVF   77,W
048E:  MOVWF  00
....................  
....................          if(s[cnt]>0x39) 
048F:  MOVF   52,W
0490:  ADDWF  4A,W
0491:  MOVWF  04
0492:  BCF    03.7
0493:  BTFSC  4B.0
0494:  BSF    03.7
0495:  MOVF   00,W
0496:  SUBLW  39
0497:  BTFSC  03.0
0498:  GOTO   4A2
....................             s[cnt]+=0x7; 
0499:  MOVF   52,W
049A:  ADDWF  4A,W
049B:  MOVWF  04
049C:  BCF    03.7
049D:  BTFSC  4B.0
049E:  BSF    03.7
049F:  MOVLW  07
04A0:  ADDWF  00,W
04A1:  MOVWF  00
....................  
....................          cnt++; 
04A2:  INCF   52,F
....................          num=temp; 
04A3:  MOVF   4F,W
04A4:  MOVWF  48
04A5:  MOVF   4E,W
04A6:  MOVWF  47
04A7:  MOVF   4D,W
04A8:  MOVWF  46
04A9:  MOVF   4C,W
04AA:  MOVWF  45
04AB:  GOTO   424
....................      } 
....................  
....................      if(sign==1) { 
04AC:  DECFSZ 51,W
04AD:  GOTO   4B7
....................          s[cnt]=0x2D;      // Negative sign 
04AE:  MOVF   52,W
04AF:  ADDWF  4A,W
04B0:  MOVWF  04
04B1:  BCF    03.7
04B2:  BTFSC  4B.0
04B3:  BSF    03.7
04B4:  MOVLW  2D
04B5:  MOVWF  00
....................          cnt++; 
04B6:  INCF   52,F
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
04B7:  CLRF   50
04B8:  BCF    03.0
04B9:  RRF    52,W
04BA:  SUBWF  50,W
04BB:  BTFSC  03.0
04BC:  GOTO   4ED
....................  
....................          c=s[i]; 
04BD:  MOVF   50,W
04BE:  ADDWF  4A,W
04BF:  MOVWF  04
04C0:  BCF    03.7
04C1:  BTFSC  4B.0
04C2:  BSF    03.7
04C3:  MOVF   00,W
04C4:  MOVWF  53
....................          s[i]=s[cnt-i-1];        // Reverse the number 
04C5:  MOVF   50,W
04C6:  ADDWF  4A,W
04C7:  MOVWF  78
04C8:  MOVF   4B,W
04C9:  MOVWF  7A
04CA:  BTFSC  03.0
04CB:  INCF   7A,F
04CC:  MOVF   78,W
04CD:  MOVWF  54
04CE:  MOVF   7A,W
04CF:  MOVWF  55
04D0:  MOVF   50,W
04D1:  SUBWF  52,W
04D2:  ADDLW  FF
04D3:  ADDWF  4A,W
04D4:  MOVWF  04
04D5:  BCF    03.7
04D6:  BTFSC  4B.0
04D7:  BSF    03.7
04D8:  MOVF   00,W
04D9:  MOVWF  56
04DA:  MOVF   54,W
04DB:  MOVWF  04
04DC:  BCF    03.7
04DD:  BTFSC  55.0
04DE:  BSF    03.7
04DF:  MOVF   56,W
04E0:  MOVWF  00
....................          s[cnt-i-1]=c; 
04E1:  MOVF   50,W
04E2:  SUBWF  52,W
04E3:  ADDLW  FF
04E4:  ADDWF  4A,W
04E5:  MOVWF  04
04E6:  BCF    03.7
04E7:  BTFSC  4B.0
04E8:  BSF    03.7
04E9:  MOVF   53,W
04EA:  MOVWF  00
04EB:  INCF   50,F
04EC:  GOTO   4B8
....................      } 
....................      s[cnt]='\0';     // End the string 
04ED:  MOVF   52,W
04EE:  ADDWF  4A,W
04EF:  MOVWF  04
04F0:  BCF    03.7
04F1:  BTFSC  4B.0
04F2:  BSF    03.7
04F3:  CLRF   00
....................      return s; 
04F4:  MOVF   4A,W
04F5:  MOVWF  78
04F6:  MOVF   4B,W
04F7:  MOVWF  79
04F8:  BCF    03.6
04F9:  RETURN
.................... } 
....................  
.................... #if defined(__PCD__) 
....................  
.................... char * itoa(signed int48 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int48 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... char * itoa(signed int64 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int64 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................       
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1;         
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................              
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #endif 
....................  
.................... float strtof(char *s, char *endptr) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s, char *endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float48)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float48)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s, char *endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float64)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float64)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtoulGO; 
....................  
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................    { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... int8 mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #if !defined(__PCD__) 
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2);  
.................... #else  
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2);  
.................... #endif 
....................  
....................  
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    unsigned int8 t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=1; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = 0; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
.................... #INCLUDE <STDIO.H> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDIO 
.................... #define _STDIO 
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #ifndef getc 
.................... #define getc getch 
.................... #define getchar getch 
.................... #define puts(s) {printf(s); putchar(13); putchar(10);} 
.................... #define putc putchar 
.................... #endif 
.................... /* maps error number to an error message. Writes a sequence of characters to 
.................... stderr stream thus: if s is not null then string pointed to by s follwed by 
.................... a colon (:) and a space and the appropriate error message returned by strerror 
.................... function with argument errno 
....................  
.................... Returns: no value 
.................... */ 
....................  
.................... #ifdef _ERRNO 
.................... void perror(char *s) 
.................... { 
....................   if(s) 
....................   fprintf(STDERR,"%s: ",s); 
....................   fprintf(STDERR,"%s\r\n",strerror(errno)); 
.................... } 
.................... #endif 
.................... #endif 
....................  
.................... #INCLUDE <MATH.H> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2011 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                    //// 
.................... //// History:                                                           //// 
.................... ////  * 9/20/2001 :  Improvments are made to sin/cos code.              //// 
.................... ////                 The code now is small, much faster,                //// 
.................... ////                 and more accurate.                                 //// 
.................... ////  * 2/21/2007 :  Compiler handles & operator differently and does   //// 
.................... ////                 not return generic (int8 *) so type cast is done   //// 
.................... ////  * 6/19/2010 :  Divisions by constants converted to multiplication //// 
.................... ////                 by its inverse to improve computation speed        //// 
.................... ////  * 1/21/2011 :  Constants used for double precision math updated   //// 
.................... ////                 Updated routines include 64 bit versions of cos,   //// 
.................... ////                 asin,atan,exp,log and dependant functions          //// 
.................... ////  * 1/31/2011 :  Optimized current 32-bit float routines for cos    //// 
.................... ////                 and log function                                   //// 
.................... ////  * 6/13/2011 :  Fixed PCD overload CEIL_FLOOR functions for values //// 
.................... ////                 greater then 10000000 and less then -10000000      //// 
.................... ////                                                                    //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef MATH_H 
.................... #define MATH_H 
....................  
.................... #ifdef PI 
.................... #undef  PI 
.................... #endif 
.................... #define PI     3.1415926535897932 
....................  
....................  
.................... #define SQRT2  1.4142135623730950 
....................  
.................... //float const ps[4] = {5.9304945, 21.125224, 8.9403076, 0.29730279}; 
.................... //float const qs[4] = {1.0000000, 15.035723, 17.764134, 2.4934718}; 
....................  
.................... ///////////////////////////// Round Functions ////////////////////////////// 
....................  
.................... float32 CEIL_FLOOR(float32 x, unsigned int8 n) 
.................... { 
....................    float32 y, res; 
....................    unsigned int16 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................       res = (float32)(unsigned int16)y; 
....................  
....................  else if (y < 10000000.0) 
....................    {  
....................       l = (unsigned int16)(y*0.000030517578125); 
....................       y = 32768.0*(y*0.000030517578125 - (float32)l); 
....................       res = 32768.0*(float32)l; 
....................       res += (float32)(unsigned int16)y; 
....................    } 
....................  
....................  else 
....................   res = y; 
....................  
....................  y = y - (float32)(unsigned int16)y; 
....................  
....................  if (s) 
....................   res = -res; 
....................  
....................  if (y != 0) 
....................  { 
....................   if (s == 1 && n == 0) 
....................    res -= 1.0; 
....................  
....................   if (s == 0 && n == 1) 
....................    res += 1.0; 
....................  } 
....................  if (x == 0) 
....................     res = 0; 
....................  
....................  return (res); 
.................... } 
....................  
.................... // Overloaded Functions to take care for new Data types in PCD 
.................... // Overloaded function CEIL_FLOOR() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 CEIL_FLOOR(float48 x, unsigned int8 n) 
.................... { 
....................    float48 y, res; 
....................    unsigned int32 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................       res = (float48)(unsigned int16)y; 
....................  
....................    else if (y < 549755813888.0) 
....................    { 
....................       l = (unsigned int32)(y*0.000030517578125); 
....................       y = 32768.0*(y*0.000030517578125 - (float48)l); 
....................       res = 32768.0*(float48)l; 
....................       res += (float48)(unsigned int16)y; 
....................    } 
....................    else 
....................    {   
....................       res = y; 
....................       y = 0.0; 
....................    } 
....................     
....................    if(y != 0) 
....................       y = y - (float48)(unsigned int16)y; 
....................  
....................    if (s) 
....................       res = -res; 
....................  
....................    if (y != 0) 
....................    { 
....................       if (s == 1 && n == 0) 
....................          res -= 1.0; 
....................  
....................       if (s == 0 && n == 1) 
....................          res += 1.0; 
....................    } 
....................    if (x == 0) 
....................       res = 0; 
....................  
....................    return (res); 
.................... } 
....................  
....................  
.................... // Overloaded function CEIL_FLOOR() for data type - Float64 
.................... float64 CEIL_FLOOR(float64 x, unsigned int8 n) 
.................... { 
....................    float64 y, res; 
....................    int64 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................       res = (float64)(unsigned int16)y; 
....................    else if (y < 4503599627370496.0) 
....................    { 
....................       l = (int64)(y*0.000030517578125); 
....................       y = 32768.0*(y*0.000030517578125 - (float64)l); 
....................       res = 32768.0*(float64)l; 
....................       res += (float64)(unsigned int16)y; 
....................    } 
....................    else 
....................    { 
....................       res = y; 
....................       y = 0.0; 
....................    } 
....................     
....................    if(y != 0) 
....................       y = y - (float64)(unsigned int16)y; 
....................  
....................    if (s) 
....................       res = -res; 
....................  
....................    if (y != 0) 
....................    { 
....................       if (s == 1 && n == 0) 
....................          res -= 1.0; 
....................  
....................       if (s == 0 && n == 1) 
....................          res += 1.0; 
....................    } 
....................     
....................    if (x == 0) 
....................       res = 0; 
....................  
....................    return (res); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float floor(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : rounds down the number x. 
.................... // Date : N/A 
.................... // 
.................... float32 floor(float32 x) 
.................... { 
....................    return CEIL_FLOOR(x,0); 
.................... } 
.................... // Following 2 functions are overloaded functions of floor() for PCD 
.................... // Overloaded function floor() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 floor(float48 x) 
.................... { 
....................    return CEIL_FLOOR(x, 0); 
.................... } 
....................  
.................... // Overloaded function floor() for data type - Float64 
.................... float64 floor(float64 x) 
.................... { 
....................    return CEIL_FLOOR(x, 0); 
.................... } 
.................... #endif 
....................  
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float ceil(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : rounds up the number x. 
.................... // Date : N/A 
.................... // 
.................... float32 ceil(float32 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
.................... // Following 2 functions are overloaded functions of ceil() for PCD 
.................... // Overloaded function ceil() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 ceil(float48 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
....................  
.................... // Overloaded function ceil() for data type - Float64 
.................... float64 ceil(float64 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
.................... #endif 
....................  
....................  //////////////////////////////////////////////////////////////////////////// 
.................... //   float fabs(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the absolute value of floating point number x 
.................... // Returns : returns the absolute value of x 
.................... // Date : N/A 
.................... // 
.................... #define fabs abs 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float fmod(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the floating point remainder of x/y 
.................... // Returns : returns the value of x= i*y, for some integer i such that, if y 
.................... // is non zero, the result has the same isgn of x na dmagnitude less than the 
.................... // magnitude of y. If y is zero then a domain error occurs. 
.................... // Date : N/A 
.................... // 
....................  
.................... float fmod(float32 x,float32 y) 
.................... { 
....................    float32 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... //Overloaded function for fmod() for PCD 
.................... // Overloaded function fmod() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 fmod(float48 x,float48 y) 
.................... { 
....................    float48 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... // Overloaded function fmod() for data type - Float64 
.................... float64 fmod(float64 x,float64 y) 
.................... { 
....................    float64 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... #endif 
.................... //////////////////// Exponential and logarithmic functions //////////////////// 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float exp(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (e^x) 
.................... // Date : N/A 
.................... // 
.................... #define LN2 0.6931471805599453 
.................... #define LN2_INV 1.4426950408889634073 
....................  
.................... float const pe[6] = {0.000207455774, 0.00127100575, 0.00965065093, 
....................                      0.0554965651,  0.240227138,  0.693147172}; 
....................  
....................  
.................... float32 exp(float32 x) 
.................... { 
....................    float32 y, res, r; 
....................    #if defined(__PCD__) 
....................    int8 data1; 
....................    #endif 
....................    signed int8 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 88.722838) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    n = (signed int16)(x*LN2_INV); 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
.................... #if !defined(__PCD__) 
....................    *((unsigned int8 *)(&res)) = n + 0x7F; 
.................... #endif 
....................  
.................... #if defined(__PCD__)  // Takes care of IEEE format for PCD 
....................    data1 = n+0x7F; 
....................    if(bit_test(data1,0)) 
....................    bit_set(*(((unsigned int8 *)(&res)+2)),7); 
....................    rotate_right(&data1,1); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&res)+3)) = data1; 
.................... #endif 
....................  
....................    y = y*LN2_INV - (float32)n; 
....................  
....................    r = pe[0]*y + pe[1]; 
....................    r = r*y + pe[2]; 
....................    r = r*y + pe[3]; 
....................    r = r*y + pe[4]; 
....................    r = r*y + pe[5]; 
....................  
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
....................  
....................  
.................... //Overloaded function for exp() for PCD 
.................... // Overloaded function exp() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 exp(float48 x) 
.................... { 
....................    float48 y, res, r; 
....................    int8 data1; 
....................    signed int8 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 88.722838) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    n = (signed int16)(x*LN2_INV); 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
....................  
....................    data1 = n+0x7F; 
....................    if(bit_test(data1,0)) 
....................    bit_set(*(((unsigned int8 *)(&res)+4)),7); 
....................    rotate_right(&data1,1); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&res)+5)) = data1; 
....................  
....................    y = y*LN2_INV - (float48)n; 
....................  
....................    r = pe[0]*y + pe[1]; 
....................    r = r*y + pe[2]; 
....................    r = r*y + pe[3]; 
....................    r = r*y + pe[4]; 
....................    r = r*y + pe[5]; 
....................  
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function exp() for data type - Float64 
.................... float64 const pe_64[12] ={9.30741400474913e-011,-4.28655416283316e-011, 
....................                           8.71486547014137e-009,9.84458531538385e-008, 
....................                           1.32588296983536e-006,1.52489283823016e-005, 
....................                           0.000154037598423921,0.00133335487036216, 
....................                           0.00961812936407326,0.0555041086222122, 
....................                           0.240226506962827,0.693147180559823}; 
....................  
.................... float64 exp(float64 x) 
.................... { 
....................    float64 y, res, r; 
....................    unsigned int16 data1, data2; 
....................    unsigned int16 *p; 
....................    signed int16 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 709.7827128) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x*LN2_INV; 
....................    n = (signed int16)y; 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
....................  
.................... #if !defined(__PCD__) 
....................    *((unsigned int16 *)(&res)) = n + 0x7F; 
.................... #endif 
....................    p= (((unsigned int16 *)(&res))+3); 
....................    data1 = *p; 
....................    data2 = *p;    
....................    data1 = n + 0x3FF; 
....................    data1 = data1 <<4; 
....................    if(bit_test(data2,15)) 
....................    bit_set(data1,15); 
....................    data2 = data2 & 0x000F; 
....................    data1 ^= data2; 
....................  
....................    *(((unsigned int16 *)(&res)+3)) = data1; 
....................  
....................  
....................    y = y*LN2_INV - (float64)n; 
....................  
....................    r = pe_64[0]*y + pe_64[1]; 
....................    r = r*y + pe_64[2]; 
....................    r = r*y + pe_64[3]; 
....................    r = r*y + pe_64[4]; 
....................    r = r*y + pe_64[5]; 
....................    r = r*y + pe_64[6]; 
....................    r = r*y + pe_64[7]; 
....................    r = r*y + pe_64[8]; 
....................    r = r*y + pe_64[9]; 
....................    r = r*y + pe_64[10]; 
....................    r = r*y + pe_64[11]; 
....................     
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
.................... #ENDIF 
....................  
....................  
.................... /************************************************************/ 
....................  
.................... float32 const pl[4] = {-1.080310025160955, 1.999999947089217}; 
.................... float32 const ql[4] = {0.091284365719509, -0.873491916557671}; 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float log(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the the natural log of x 
.................... // Date : N/A 
.................... // 
.................... float32 log(float32 x) 
.................... { 
....................    float32 y, res, r, y2; 
....................    #if defined(__PCD__) 
....................    unsigned int8  data1,data2; 
....................    #endif 
....................    signed int8 n; 
....................    #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
.................... #if !defined(__PCD__) 
....................     *((unsigned int8 *)(&y)) = 0x7E;  
.................... #endif 
....................  
.................... #if defined(__PCD__) // Takes care of IEEE format 
....................    data2 = *(((unsigned int8 *)(&y))+3); 
....................    *(((unsigned int8 *)(&y))+3) = 0x3F; 
....................    data1 = *(((unsigned int8 *)(&y))+2); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&y))+2) = data1; 
....................    if(bit_test(data2,7)) 
....................      bit_set(*(((unsigned int8 *)(&y))+3),7); 
.................... #endif 
....................  
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl[0]*y2 + pl[1]; 
....................  
....................       r = ql[0]*y2 + ql[1]; 
....................       r = r*y2 + 1.0; 
....................  
....................       res = y*res/r; 
.................... #if !defined(__PCD__) 
....................       n = *((unsigned int8 *)(&x)) - 0x7E; 
.................... #endif 
.................... #if defined(__PCD__)  
....................     data1 = *(((unsigned int8 *)(&x)+3)); 
....................     rotate_left(&data1,1); 
....................     data2 = *(((unsigned int8 *)(&x)+2)); 
....................     if(bit_test (data2,7)) 
....................       bit_set(data1,0); 
....................     n = data1 - 0x7E; 
.................... #endif 
....................  
....................       if (n<0)  
....................          r = -(float32)-n; 
....................       else 
....................          r = (float32)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................       res = 0.0; 
....................  
....................    return(res); 
.................... } 
....................  
.................... //Overloaded function for log() for PCD 
.................... // Overloaded function log() for data type - Float48 
.................... #if defined(__PCD__) 
.................... // Overloaded function log() for data type - float64 
.................... float64 const pl_64[4] = {-0.145694052150681, 1.365485300000370, 
....................                           -3.120535668274329, 2.000000000000000}; 
....................  
.................... float64 const ql_64[4] = {0.006047500465908, -0.208298281937234, 
....................                           1.113943039156721, -1.893601167470470}; 
....................  
.................... float48 log(float48 x) 
.................... { 
....................    float48 y, res, r, y2; 
....................    unsigned int8  data1,data2; 
....................    signed int8 n; 
.................... #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
.................... #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
....................  
.................... #if !defined(__PCD__) 
....................       *((unsigned int8 *)(&y)) = 0x7E;  
.................... #endif 
....................       data2 = *(((unsigned int8 *)(&y))+5); 
....................       *(((unsigned int8 *)(&y))+5) = 0x3F; 
....................       data1 = *(((unsigned int8 *)(&y))+4); 
....................       bit_clear(data1,7); 
....................       *(((unsigned int8 *)(&y))+4) = data1; 
....................  
....................       if(bit_test(data2,7)) 
....................       bit_set(*(((unsigned int8 *)(&y))+4),7); 
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl_64[0]*y2 + pl_64[1]; 
....................       res = res*y2 + pl_64[2]; 
....................       res = res*y2 + pl_64[3]; 
....................  
....................       r = ql_64[0]*y2 + ql_64[1]; 
....................       r = r*y2 + ql_64[2]; 
....................       r = r*y2 + ql_64[3]; 
....................       r = r*y2 + 1.0;  
....................       res = y*res/r; 
....................  
....................       data1 = *(((unsigned int8 *)(&x)+5)); 
....................       rotate_left(&data1,1); 
....................       data2 = *(((unsigned int8 *)(&x)+4)); 
....................       if(bit_test (data2,7)) 
....................       bit_set(data1,0); 
....................        
....................       n = data1 - 0x7E; 
....................  
....................       if (n<0) 
....................       r = -(float48)-n; 
....................       else 
....................       r = (float48)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................    res = 0.0; 
....................  
....................    return(res); 
.................... } 
....................  
.................... float64 log(float64 x) 
.................... { 
....................    float64 y, res, r, y2; 
....................    unsigned int16  data1,data2; 
....................    unsigned int16 *p; 
....................    signed int16 n; 
....................    #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
....................    #if !defined(__PCD__) 
....................        *((unsigned int8 *)(&y)) = 0x7E;  
....................    #endif 
....................       p= (((unsigned int16 *)(&y))+3); 
....................       data1 = *p; 
....................       data2 = *p; 
....................       data1 = 0x3FE; 
....................       data1 = data1 <<4; 
....................       if(bit_test (data2,15)) 
....................          bit_set(data1,15); 
....................       data2 = data2 & 0x000F; 
....................       data1 ^=data2; 
....................  
....................       *p = data1; 
....................  
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl_64[0]*y2 + pl_64[1]; 
....................       res = res*y2 + pl_64[2]; 
....................       res = res*y2 + pl_64[3]; 
....................  
....................       r = ql_64[0]*y2 + ql_64[1]; 
....................       r = r*y2 + ql_64[2]; 
....................       r = r*y2 + ql_64[3]; 
....................       r = r*y2 + 1.0; 
....................  
....................       res = y*res/r; 
....................   
....................       p= (((unsigned int16 *)(&x))+3); 
....................       data1 = *p; 
....................       bit_clear(data1,15); 
....................       data1 = data1 >>4;     
....................       n = data1 - 0x3FE; 
....................  
....................  
....................       if (n<0) 
....................          r = -(float64)-n; 
....................       else 
....................          r = (float64)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................       res = 0.0; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
....................  
.................... #define LN10 2.3025850929940456 
.................... #define LN10_INV 0.4342944819032518276 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float log10(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the the log base 10 of x 
.................... // Date : N/A 
.................... // 
.................... float32 log10(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = log(x); 
....................    r = r*LN10_INV; 
....................    return(r); 
.................... } 
....................  
.................... //Overloaded functions for log10() for PCD 
.................... // Overloaded function log10() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 log10(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = log(x); 
....................    r = r*LN10_INV; 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function log10() for data type - Float64 
.................... float64 log10(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = log(x); 
....................    r = r*LN10_INV; 
....................    return(r); 
.................... } 
.................... #endif 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float modf(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description :breaks the argument value int integral and fractional parts, 
.................... // ach of which have the same sign as the argument.  It stores the integral part 
.................... // as a float in the object pointed to by the iptr 
.................... // Returns : returns the signed fractional part of value. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 modf(float32 value,float32 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... //Overloaded functions for modf() for PCD 
.................... // Overloaded function modf() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 modf(float48 value,float48 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... // Overloaded function modf() for data type - Float64 
.................... float64 modf(float64 value,float64 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float pwr(float x,float y) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (x^y) 
.................... // Date : N/A 
.................... // Note : 0 is returned when the function will generate an imaginary number 
.................... // 
.................... float32 pwr(float32 x,float32 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... //Overloaded functions for pwr() for PCD 
.................... // Overloaded function pwr() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 pwr(float48 x,float48 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... // Overloaded function pwr() for data type - Float64 
.................... float64 pwr(float64 x,float64 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////// Power functions //////////////////// 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float pow(float x,float y) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (x^y) 
.................... // Date : N/A 
.................... // Note : 0 is returned when the function will generate an imaginary number 
.................... // 
.................... float32 pow(float32 x,float32 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... //Overloaded functions for pow() for PCD 
.................... // Overloaded function for pow() data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 pow(float48 x,float48 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
....................  
.................... // Overloaded function pow() for data type - Float64 
.................... float64 pow(float64 x,float64 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sqrt(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the square root of x 
.................... // Date : N/A 
.................... // 
.................... float32 sqrt(float32 x) 
.................... { 
....................    float32 y, res; 
....................    #if defined(__PCD__) 
....................    unsigned int16 data1,data2; 
....................    #endif 
....................    unsigned int8 *p; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................     
....................    #if !defined(__PCD__) 
....................     p=&y; 
....................    (*p)=(unsigned int8)((((unsigned int16)(*p)) + 127) >> 1); 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     p = (((unsigned int8 *)(&y))+3); 
....................     data1 = *(((unsigned int8 *)(&y))+3); 
....................     data2 = *(((unsigned int8 *)(&y))+2); 
....................     rotate_left(&data1,1);     
....................     if(bit_test(data2,7))     
....................        bit_set(data1,0);     
....................     data1 = ((data1+127) >>1); 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+3) = data1; 
....................     *(((unsigned int8 *)(&y))+2) = data2; 
....................      
....................   #endif 
....................  
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................  
....................       #if !defined(__PCD__) 
....................      (*p)--; 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     data1 = *(((unsigned int8 *)(&y))+3); 
....................     data2 = *(((unsigned int8 *)(&y))+2); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................        bit_set(data1,0);     
....................     data1--; 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+3) = data1; 
....................     *(((unsigned int8 *)(&y))+2) = data2; 
....................      
....................   #endif 
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
.................... //Overloaded functions for sqrt() for PCD 
.................... // Overloaded function sqrt() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sqrt(float48 x) 
.................... { 
....................    float48 y, res; 
....................    unsigned int16 data1,data2; 
....................    unsigned int8 *p; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................     
....................    #if !defined(__PCD__) 
....................     p=&y; 
....................    (*p)=(unsigned int8)((((unsigned int16)(*p)) + 127) >> 1); 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     p = (((unsigned int8 *)(&y))+5); 
....................     data1 = *(((unsigned int8 *)(&y))+5); 
....................     data2 = *(((unsigned int8 *)(&y))+4); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................        bit_set(data1,0);     
....................     data1 = ((data1+127) >>1); 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+5) = data1; 
....................     *(((unsigned int8 *)(&y))+4) = data2; 
....................      
....................   #endif 
....................  
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................  
....................       #if !defined(__PCD__) 
....................      (*p)--; 
....................    #endif 
....................     
....................     data1 = *(((unsigned int8 *)(&y))+5); 
....................     data2 = *(((unsigned int8 *)(&y))+4); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................        bit_set(data1,0);     
....................     data1--; 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+5) = data1; 
....................     *(((unsigned int8 *)(&y))+4) = data2; 
....................      
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function sqrt() for data type - Float64 
.................... float64 sqrt(float64 x) 
.................... { 
....................    float64 y, res; 
....................    unsigned int16 *p; 
....................    unsigned int16 temp1,temp2; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................    p= (((unsigned int16 *)(&y))+3); 
....................    temp1 = *p; 
....................    temp2 = *p; 
....................    bit_clear(temp1,15); 
....................    temp1 = (temp1>>4)+1023; 
....................    temp1 = temp1 >> 1; 
....................    temp1 = (temp1<<4) & 0xFFF0; 
....................    if(bit_test(temp2,15)) 
....................       bit_set(temp1,15); 
....................    temp2 = temp2 & 0x000F; 
....................    temp1 ^= temp2; 
....................     
....................    (*p) = temp1; 
....................     
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................      temp1 = *p; 
....................      temp2 = *p; 
....................      bit_clear(temp1,15); 
....................      temp1 = (temp1>>4); 
....................      temp1--; 
....................      temp1 = (temp1<<4) & 0xFFF0; 
....................      if(bit_test(temp2,15)) 
....................         bit_set(temp1,15); 
....................      temp2 = temp2 & 0x000F; 
....................      temp1 ^= temp2; 
....................      (*p) = temp1; 
....................  
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... ////////////////////////////// Trig Functions ////////////////////////////// 
.................... #ifdef PI_DIV_BY_TWO_INV 
.................... #undef PI_DIV_BY_TWO_INV 
.................... #endif 
.................... #define PI_DIV_BY_TWO_INV 0.63661977236758134 
.................... #ifdef PI_DIV_BY_TWO 
.................... #undef PI_DIV_BY_TWO 
.................... #endif 
.................... #define PI_DIV_BY_TWO   1.5707963267948966 
.................... #ifdef TWOBYPI 
.................... #undef TWOBYPI 
.................... #endif 
.................... #define TWOBYPI          0.6366197723675813 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float cos(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the cosine value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 cos(float32 x) 
.................... { 
....................    float32 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float32 frac; 
....................    float32 p[5] = {                    //by the series definition for cosine 
....................       -0.49999999456337096,            // sum ( ( (-1)^n * x^2n )/(2n)! ) 
....................        0.04166663896921267, 
....................       -0.00138883894522527, 
....................        0.00002476138231734, 
....................       -0.00000026070414770 
....................       //-0.00000000001147, 
....................       // 0.00000000000005 
....................    }; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant 
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 1.0; 
....................    t = t * t; 
....................    for (i = 0; i <= 4; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
....................  
.................... //Overloaded functions for cos() for PCD 
.................... // Overloaded function cos() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 cos(float48 x) 
.................... { 
....................    float48 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float48 frac; 
....................    float48 p[6] = {                    //by the series definition for cosine 
....................       -0.5,                            // sum ( ( (-1)^n * x^2n )/(2n)! ) 
....................        0.04166666666667, 
....................       -0.00138888888889, 
....................        0.00002480158730, 
....................       -0.00000027557319, 
....................        0.00000000208767, 
....................       //-0.00000000001147, 
....................       // 0.00000000000005 
....................    }; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant 
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 0.999999999781; 
....................    t = t * t; 
....................    for (i = 0; i <= 5; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
.................... // Overloaded function cos() for data type - Float64 
.................... float64 cos(float64 x) 
.................... { 
....................    float64 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float64 frac; 
....................    float64 p_64[9] = {               //by the series definition for cosine 
....................      -0.49999999999998740,           // sum ( ( (-1)^n * x^2n )/(2n)! )              
....................       0.04166666666656518, 
....................      -0.00138888888851691, 
....................       0.00002480158658490, 
....................      -0.00000027557239796, 
....................       0.00000000208715031, 
....................      -0.00000000001126577, 
....................       0.00000000000000427, 
....................       0.00000000000000372}; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant 
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 1.0; 
....................    t = t * t; 
....................    for (i = 0; i <= 8; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p_64[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sin(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the sine value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 sin(float32 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
....................  
.................... //Overloaded functions for sin() for PCD 
.................... // Overloaded function sin() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sin(float48 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
....................  
.................... // Overloaded function sin() for data type - Float48 
.................... float64 sin(float64 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float tan(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the tangent value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 tan(float32 x) 
.................... { 
....................    float32 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
.................... //Overloaded functions for tan() for PCD 
.................... // Overloaded function tan() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 tan(float48 x) 
.................... { 
....................    float48 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
....................  
.................... // Overloaded function tan() for data type - Float48 
.................... float64 tan(float64 x) 
.................... { 
....................    float64 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
.................... #endif 
....................  
.................... float32 const pas[3] = {0.49559947, -4.6145309, 5.6036290}; 
.................... float32 const qas[3] = {1.0000000,  -5.5484666, 5.6036290}; 
....................  
.................... float32 ASIN_COS(float32 x, unsigned int8 n) 
.................... { 
....................    float32 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)*0.5); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas[0]*y2 + pas[1]; 
....................    res = res*y2 + pas[2]; 
....................  
....................    r = qas[0]*y2 + qas[1]; 
....................    r = r*y2 + qas[2]; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
....................  
....................  
.................... //Overloaded functions for ASIN_COS() for PCD 
.................... // Overloaded function ASIN_COS() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 ASIN_COS(float48 x, unsigned int8 n) 
.................... { 
....................    float48 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)*0.5); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas[0]*y2 + pas[1]; 
....................    res = res*y2 + pas[2]; 
....................  
....................    r = qas[0]*y2 + qas[1]; 
....................    r = r*y2 + qas[2]; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function ASIN_COS() for data type - Float64 
.................... double pas_64[5]={1.000000000000000,-2.069938587724477,1.421444580548907, 
....................                  -0.360690137621842,0.024929451660228}; 
....................  
.................... double qas_64[5]={-2.236605254391134,1.719212122946451,-0.524122954476133, 
....................                    0.052808872045749,-0.000662536036570}; 
....................                     
.................... float64 ASIN_COS(float64 x, unsigned int8 n) 
.................... { 
....................    float64 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)*0.5); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas_64[4]*y2 + pas_64[3]; 
....................    res = res*y2 + pas_64[2]; 
....................    res = res*y2 + pas_64[1]; 
....................    res = res*y2 + pas_64[0]; 
....................  
....................    r = qas_64[4]*y2 + qas_64[3]; 
....................    r = r*y2 + qas_64[2]; 
....................    r = r*y2 + qas_64[1]; 
....................    r = r*y2 + qas_64[0]; 
....................    r = r*y2 + 1.0; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float asin(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arcsine value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 asin(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
.................... //Overloaded functions for asin() for PCD 
.................... // Overloaded function asin() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 asin(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function asin() for data type - Float64 
.................... float64 asin(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float acos(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arccosine value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 acos(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
.................... //Overloaded functions for acos() for PCD 
.................... // Overloaded function acos() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 acos(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function acos() for data type - Float64 
.................... float64 acos(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
.................... #endif 
....................  
.................... float32 const pat[4] = {0.17630401, 5.6710795, 22.376096, 19.818457}; 
.................... float32 const qat[4] = {1.0000000,  11.368190, 28.982246, 19.818457}; 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float atan(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arctangent value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 atan(float32 x) 
.................... { 
....................    float32 y, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................  
....................    res = pat[0]*y*y + pat[1]; 
....................    res = res*y*y + pat[2]; 
....................    res = res*y*y + pat[3]; 
....................  
....................    r = qat[0]*y*y + qat[1]; 
....................    r = r*y*y + qat[2]; 
....................    r = r*y*y + qat[3]; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
.................... //Overloaded functions for atan() for PCD 
.................... // Overloaded function atan() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 atan(float48 x) 
.................... { 
....................    float48 y, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................  
....................    res = pat[0]*y*y + pat[1]; 
....................    res = res*y*y + pat[2]; 
....................    res = res*y*y + pat[3]; 
....................  
....................    r = qat[0]*y*y + qat[1]; 
....................    r = r*y*y + qat[2]; 
....................    r = r*y*y + qat[3]; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
....................  
.................... float64 pat_64[6]={0.999999999999999,2.249923645595566,1.771541617806449, 
....................                    0.579678874003185,0.072162702162882,0.002281100141660}; 
....................  
.................... float64 qat_64[6]={2.583256978928510,2.432627277466967,1.016760379885393, 
....................                    0.182482977188688,0.011155377971690,0.000100013019160}; 
.................... // Overloaded function atan() for data type - Float64 
.................... float64 atan(float64 x) 
.................... { 
....................    float64 y,y2, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................    y2 = y*y; 
....................    res = pat_64[5]*y2 + pat_64[4]; 
....................    res = res*y2 + pat_64[3]; 
....................    res = res*y2 + pat_64[2]; 
....................    res = res*y2 + pat_64[1]; 
....................    res = res*y2 + pat_64[0]; 
....................  
....................    r = qat_64[5]*y2 + qat_64[4]; 
....................    r = r*y2 + qat_64[3]; 
....................    r = r*y2 + qat_64[2]; 
....................    r = r*y2 + qat_64[1]; 
....................    r = r*y2 + qat_64[0]; 
....................    r = r*y2 + 1.0; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... ///////////////////////////////////////////////////////////////////////////// 
.................... //   float atan2(float y, float x) 
.................... ///////////////////////////////////////////////////////////////////////////// 
.................... // Description :computes the principal value of arc tangent of y/x, using the 
.................... // signs of both the arguments to determine the quadrant of the return value 
.................... // Returns : returns the arc tangent of y/x. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 atan2(float32 y,float32 x) 
.................... { 
....................    float32 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
....................  
.................... //Overloaded functions for atan2() for PCD 
.................... // Overloaded function atan2() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 atan2(float48 y,float48 x) 
.................... { 
....................    float48 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
....................  
.................... // Overloaded function atan2() for data type - Float64 
.................... float64 atan2(float64 y,float64 x) 
.................... { 
....................    float64 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////// Hyperbolic functions //////////////////// 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float cosh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic cosine value of x 
.................... // Returns : returns the hyperbolic cosine value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 cosh(float32 x) 
.................... { 
....................    return ((exp(x)+exp(-x))*0.5); 
.................... } 
.................... //Overloaded functions for cosh() for PCD 
.................... // Overloaded function cosh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 cosh(float48 x) 
.................... { 
....................    return ((exp(x)+exp(-x))*0.5); 
.................... } 
....................  
.................... // Overloaded function cosh() for data type - Float64 
.................... float64 cosh(float64 x) 
.................... { 
....................    return ((exp(x)+exp(-x))*0.5); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sinh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic sine value of x 
.................... // Returns : returns the hyperbolic sine value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 sinh(float32 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))*0.5); 
.................... } 
.................... //Overloaded functions for sinh() for PCD 
.................... // Overloaded function sinh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sinh(float48 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))*0.5); 
.................... } 
....................  
.................... // Overloaded function sinh() for data type - Float48 
.................... float64 sinh(float64 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))*0.5); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float tanh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic tangent value of x 
.................... // Returns : returns the hyperbolic tangent value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 tanh(float32 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
.................... //Overloaded functions for tanh() for PCD 
.................... // Overloaded function tanh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 tanh(float48 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
....................  
.................... // Overloaded function tanh() for data type - Float64 
.................... float64 tanh(float64 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float frexp(float x, signed int *exp) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : breaks a floating point number into a normalized fraction and an integral 
.................... // power of 2. It stores the integer in the signed int object pointed to by exp. 
.................... // Returns : returns the value x, such that x is a double with magnitude in the interval 
.................... // [1/2,1) or zero, and value equals x times 2 raised to the power *exp.If value is zero, 
.................... // both parts of the result are zero. 
.................... // Date : N/A 
.................... // 
....................  
.................... #define LOG2 .30102999566398119521 
.................... #define LOG2_INV 3.32192809488736234787 
.................... float32 frexp(float32 x, signed int8 *exp) 
.................... { 
....................    float32 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)*LOG2_INV)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
....................  
.................... //Overloaded functions for frexp() for PCD 
.................... // Overloaded function frexp() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 frexp(float48 x, signed int8 *exp) 
.................... { 
....................    float48 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)*LOG2_INV)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
....................  
.................... // Overloaded function frexp() for data type - Float64 
.................... float64 frexp(float64 x, signed int8 *exp) 
.................... { 
....................    float64 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)*LOG2_INV)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
.................... #endif 
....................  
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... //   float ldexp(float x, signed int *exp) 
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... // Description : multiplies a floating point number by an integral power of 2. 
.................... // Returns : returns the value of x times 2 raised to the power exp. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 ldexp(float32 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... //Overloaded functions for ldexp() for PCD 
.................... // Overloaded function ldexp() for data type - Float48 
....................  
.................... #if defined(__PCD__) 
.................... float48 ldexp(float48 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... // Overloaded function ldexp() for data type - Float64 
.................... float64 ldexp(float64 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... #endif 
....................  
.................... #endif 
....................  
.................... #INCLUDE <xuatbyte74595.c> 
....................  
.................... #DEFINE      DS               PIN_D1 
.................... #DEFINE      SH_CP            PIN_D0   
.................... #DEFINE      STCP             PIN_D2 
.................... VOID XUATTRANGTHAI(UNSIGNED INT8 BYTEXUAT) 
.................... { 
....................    UNSIGNED INT8   SB;    
....................    #BIT BSERI  = BYTEXUAT.7 
....................     
....................    FOR (SB=0;SB<8;SB++) 
*
0DC3:  CLRF   1C
0DC4:  MOVF   1C,W
0DC5:  SUBLW  07
0DC6:  BTFSS  03.0
0DC7:  GOTO   5DE
....................       {                                                  
....................          OUTPUT_BIT(DS,BSERI);     
0DC8:  BTFSC  1B.7
0DC9:  GOTO   5CE
0DCA:  BCF    03.6
0DCB:  BCF    08.1
0DCC:  GOTO   5D0
0DCD:  BSF    03.6
0DCE:  BCF    03.6
0DCF:  BSF    08.1
0DD0:  BSF    03.5
0DD1:  BCF    08.1
....................          OUTPUT_LOW(SH_CP); OUTPUT_HIGH(SH_CP); 
0DD2:  BCF    08.0
0DD3:  BCF    03.5
0DD4:  BCF    08.0
0DD5:  BSF    03.5
0DD6:  BCF    08.0
0DD7:  BCF    03.5
0DD8:  BSF    08.0
....................          BYTEXUAT=BYTEXUAT<<1; //10010010->00100100   
0DD9:  BCF    03.0
0DDA:  BSF    03.6
0DDB:  RLF    1B,F
0DDC:  INCF   1C,F
0DDD:  GOTO   5C4
....................      } 
....................       OUTPUT_LOW(STCP); OUTPUT_HIGH(STCP); 
0DDE:  BSF    03.5
0DDF:  BCF    03.6
0DE0:  BCF    08.2
0DE1:  BCF    03.5
0DE2:  BCF    08.2
0DE3:  BSF    03.5
0DE4:  BCF    08.2
0DE5:  BCF    03.5
0DE6:  BSF    08.2
.................... } 
....................  
....................  
.................... #FUSES NOWDT, PUT, HS 
.................... #USE DELAY(CLOCK=20M) 
*
0140:  MOVLW  47
0141:  MOVWF  04
0142:  BSF    03.7
0143:  MOVF   00,W
0144:  BTFSC  03.2
0145:  GOTO   153
0146:  MOVLW  06
0147:  MOVWF  78
0148:  CLRF   77
0149:  DECFSZ 77,F
014A:  GOTO   149
014B:  DECFSZ 78,F
014C:  GOTO   148
014D:  MOVLW  7B
014E:  MOVWF  77
014F:  DECFSZ 77,F
0150:  GOTO   14F
0151:  DECFSZ 00,F
0152:  GOTO   146
0153:  RETURN
.................... #USE RS232(BAUD=9600,XMIT=PIN_C6,RCV=PIN_C7) 
.................... #DEFINE BT1_PIN PIN_B1 
.................... #DEFINE BT2_PIN PIN_B2 
.................... #DEFINE BT3_PIN PIN_B3 
.................... #DEFINE LCD_ENABLE_PIN  PIN_E0                                    
.................... #DEFINE LCD_RS_PIN      PIN_E1                                 
.................... #DEFINE LCD_RW_PIN      PIN_E2   
.................... #DEFINE LCD_DATA4       PIN_C0                                
.................... #DEFINE LCD_DATA5       PIN_C1                                  
.................... #DEFINE LCD_DATA6       PIN_C2                                    
.................... #DEFINE LCD_DATA7       PIN_C3   
.................... #INCLUDE <LCD.C> 
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... ////                             LCD.C                                     //// 
.................... ////                 Driver for common LCD modules                         //// 
.................... ////                                                                       //// 
.................... ////  lcd_init()   Must be called before any other function.               //// 
.................... ////                                                                       //// 
.................... ////  lcd_putc(c)  Will display c on the next position of the LCD.         //// 
.................... ////                 \a  Set cursor position to upper left                 //// 
.................... ////                 \f  Clear display, set cursor to upper left           //// 
.................... ////                 \n  Go to start of second line                        //// 
.................... ////                 \b  Move back one position                            //// 
.................... ////              If LCD_EXTENDED_NEWLINE is defined, the \n character     //// 
.................... ////              will erase all remanining characters on the current      //// 
.................... ////              line, and move the cursor to the beginning of the next   //// 
.................... ////              line.                                                    //// 
.................... ////              If LCD_EXTENDED_NEWLINE is defined, the \r character     //// 
.................... ////              will move the cursor to the start of the current         //// 
.................... ////              line.                                                    //// 
.................... ////                                                                       //// 
.................... ////  lcd_gotoxy(x,y) Set write position on LCD (upper left is 1,1)        //// 
.................... ////                                                                       //// 
.................... ////  lcd_getc(x,y)   Returns character at position x,y on LCD             //// 
.................... ////                                                                       //// 
.................... ////  lcd_cursor_on(int1 on)   Turn the cursor on (on=TRUE) or off         //// 
.................... ////              (on=FALSE).                                              //// 
.................... ////                                                                       //// 
.................... ////  lcd_set_cgram_char(w, *p)   Write a custom character to the CGRAM.   //// 
.................... ////                                                                       //// 
.................... ////                                                                       //// 
.................... ////  CONFIGURATION                                                        //// 
.................... ////  The LCD can be configured in one of two ways: a.) port access or     //// 
.................... ////  b.) pin access.  Port access requires the entire 7 bit interface     //// 
.................... ////  connected to one GPIO port, and the data bits (D4:D7 of the LCD)     //// 
.................... ////  connected to sequential pins on the GPIO.  Pin access                //// 
.................... ////  has no requirements, all 7 bits of the control interface can         //// 
.................... ////  can be connected to any GPIO using several ports.                    //// 
.................... ////                                                                       //// 
.................... ////  To use port access, #define LCD_DATA_PORT to the SFR location of     //// 
.................... ////  of the GPIO port that holds the interface, -AND- edit LCD_PIN_MAP    //// 
.................... ////  of this file to configure the pin order.  If you are using a         //// 
.................... ////  baseline PIC (PCB), then LCD_OUTPUT_MAP and LCD_INPUT_MAP also must  //// 
.................... ////  be defined.                                                          //// 
.................... ////                                                                       //// 
.................... ////  Example of port access:                                              //// 
.................... ////     #define LCD_DATA_PORT getenv("SFR:PORTD")                         //// 
.................... ////                                                                       //// 
.................... ////  To use pin access, the following pins must be defined:               //// 
.................... ////     LCD_ENABLE_PIN                                                    //// 
.................... ////     LCD_RS_PIN                                                        //// 
.................... ////     LCD_RW_PIN                                                        //// 
.................... ////     LCD_DATA4                                                         //// 
.................... ////     LCD_DATA5                                                         //// 
.................... ////     LCD_DATA6                                                         //// 
.................... ////     LCD_DATA7                                                         //// 
.................... ////                                                                       //// 
.................... ////  Example of pin access:                                               //// 
.................... ////     #define LCD_ENABLE_PIN  PIN_E0                                    //// 
.................... ////     #define LCD_RS_PIN      PIN_E1                                    //// 
.................... ////     #define LCD_RW_PIN      PIN_E2                                    //// 
.................... ////     #define LCD_DATA4       PIN_D4                                    //// 
.................... ////     #define LCD_DATA5       PIN_D5                                    //// 
.................... ////     #define LCD_DATA6       PIN_D6                                    //// 
.................... ////     #define LCD_DATA7       PIN_D7                                    //// 
.................... ////                                                                       //// 
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2010 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef __LCD_C__ 
.................... #define __LCD_C__ 
....................  
.................... // define the pinout. 
.................... // only required if port access is being used. 
.................... typedef struct   
.................... {                            // This structure is overlayed 
....................    int1 enable;           // on to an I/O port to gain 
....................    int1 rs;               // access to the LCD pins. 
....................    int1 rw;               // The bits are allocated from 
....................    int1 unused;           // low order up.  ENABLE will 
....................    unsigned int     data : 4;         // be LSB pin of that port. 
....................   #if defined(__PCD__)       // The port used will be LCD_DATA_PORT. 
....................    unsigned int    reserved: 8; 
....................   #endif 
.................... } LCD_PIN_MAP; 
....................  
.................... // this is to improve compatability with previous LCD drivers that accepted 
.................... // a define labeled 'use_portb_lcd' that configured the LCD onto port B. 
.................... #if ((defined(use_portb_lcd)) && (use_portb_lcd==TRUE)) 
....................  #define LCD_DATA_PORT getenv("SFR:PORTB") 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
....................    // these definitions only need to be modified for baseline PICs. 
....................    // all other PICs use LCD_PIN_MAP or individual LCD_xxx pin definitions. 
.................... /*                                    EN, RS,   RW,   UNUSED,  DATA  */ 
....................  const LCD_PIN_MAP LCD_OUTPUT_MAP =  {0,  0,    0,    0,       0}; 
....................  const LCD_PIN_MAP LCD_INPUT_MAP =   {0,  0,    0,    0,       0xF}; 
.................... #endif 
....................  
.................... ////////////////////// END CONFIGURATION /////////////////////////////////// 
....................  
.................... #ifndef LCD_ENABLE_PIN 
....................    #define lcd_output_enable(x) lcdlat.enable=x 
....................    #define lcd_enable_tris()   lcdtris.enable=0 
.................... #else 
....................    #define lcd_output_enable(x) output_bit(LCD_ENABLE_PIN, x) 
....................    #define lcd_enable_tris()  output_drive(LCD_ENABLE_PIN) 
.................... #endif 
....................  
.................... #ifndef LCD_RS_PIN 
....................    #define lcd_output_rs(x) lcdlat.rs=x 
....................    #define lcd_rs_tris()   lcdtris.rs=0 
.................... #else 
....................    #define lcd_output_rs(x) output_bit(LCD_RS_PIN, x) 
....................    #define lcd_rs_tris()  output_drive(LCD_RS_PIN) 
.................... #endif 
....................  
.................... #ifndef LCD_RW_PIN 
....................    #define lcd_output_rw(x) lcdlat.rw=x 
....................    #define lcd_rw_tris()   lcdtris.rw=0 
.................... #else 
....................    #define lcd_output_rw(x) output_bit(LCD_RW_PIN, x) 
....................    #define lcd_rw_tris()  output_drive(LCD_RW_PIN) 
.................... #endif 
....................  
.................... // original version of this library incorrectly labeled LCD_DATA0 as LCD_DATA4, 
.................... // LCD_DATA1 as LCD_DATA5, and so on.  this block of code makes the driver 
.................... // compatible with any code written for the original library 
.................... #if (defined(LCD_DATA0) && defined(LCD_DATA1) && defined(LCD_DATA2) && defined(LCD_DATA3) && !defined(LCD_DATA4) && !defined(LCD_DATA5) && !defined(LCD_DATA6) && !defined(LCD_DATA7)) 
....................    #define  LCD_DATA4    LCD_DATA0 
....................    #define  LCD_DATA5    LCD_DATA1 
....................    #define  LCD_DATA6    LCD_DATA2 
....................    #define  LCD_DATA7    LCD_DATA3 
.................... #endif 
....................  
.................... #ifndef LCD_DATA4 
.................... #ifndef LCD_DATA_PORT 
....................    #if defined(__PCB__) 
....................       #define LCD_DATA_PORT      0x06     //portb 
....................       #define set_tris_lcd(x)   set_tris_b(x) 
....................    #else 
....................      #if defined(PIN_D0) 
....................       #define LCD_DATA_PORT      getenv("SFR:PORTD")     //portd 
....................      #else 
....................       #define LCD_DATA_PORT      getenv("SFR:PORTB")     //portb 
....................      #endif 
....................    #endif    
.................... #endif 
....................  
.................... #if defined(__PCB__) 
....................    LCD_PIN_MAP lcd, lcdlat; 
....................    #byte lcd = LCD_DATA_PORT 
....................    #byte lcdlat = LCD_DATA_PORT 
.................... #elif defined(__PCM__) 
....................    LCD_PIN_MAP lcd, lcdlat, lcdtris; 
....................    #byte lcd = LCD_DATA_PORT 
....................    #byte lcdlat = LCD_DATA_PORT 
....................    #byte lcdtris = LCD_DATA_PORT+0x80 
.................... #elif defined(__PCH__) 
....................    LCD_PIN_MAP lcd, lcdlat, lcdtris; 
....................    #byte lcd = LCD_DATA_PORT 
....................    #byte lcdlat = LCD_DATA_PORT+9 
....................    #byte lcdtris = LCD_DATA_PORT+0x12 
.................... #elif defined(__PCD__) 
....................    LCD_PIN_MAP lcd, lcdlat, lcdtris; 
....................    #word lcd = LCD_DATA_PORT 
....................    #word lcdlat = LCD_DATA_PORT+2 
....................    #word lcdtris = LCD_DATA_PORT-0x02 
.................... #endif 
.................... #endif   //LCD_DATA4 not defined 
....................  
.................... #ifndef LCD_TYPE 
....................    #define LCD_TYPE 2           // 0=5x7, 1=5x10, 2=2 lines 
.................... #endif 
....................  
.................... #ifndef LCD_LINE_TWO 
....................    #define LCD_LINE_TWO 0x40    // LCD RAM address for the second line 
.................... #endif 
....................  
.................... #ifndef LCD_LINE_LENGTH 
....................    #define LCD_LINE_LENGTH 20 
.................... #endif 
....................  
.................... unsigned int8 lcd_read_nibble(void); 
....................  
.................... unsigned int8 lcd_read_byte(void) 
.................... { 
....................    unsigned int8 low,high; 
....................  
....................  #if defined(__PCB__) 
....................    set_tris_lcd(LCD_INPUT_MAP); 
....................  #else 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    output_float(LCD_DATA4); 
*
01E7:  BSF    07.0
....................    output_float(LCD_DATA5); 
01E8:  BSF    07.1
....................    output_float(LCD_DATA6); 
01E9:  BSF    07.2
....................    output_float(LCD_DATA7); 
01EA:  BSF    07.3
....................   #else 
....................    lcdtris.data = 0xF; 
....................   #endif 
....................  #endif 
....................          
....................    lcd_output_rw(1); 
01EB:  BCF    03.5
01EC:  BSF    09.2
01ED:  BSF    03.5
01EE:  BCF    09.2
....................    delay_cycles(1); 
01EF:  NOP
....................    lcd_output_enable(1); 
01F0:  BCF    03.5
01F1:  BSF    09.0
01F2:  BSF    03.5
01F3:  BCF    09.0
....................    delay_cycles(1); 
01F4:  NOP
....................    high = lcd_read_nibble(); 
01F5:  BCF    03.5
01F6:  CALL   19C
01F7:  MOVF   78,W
01F8:  BSF    03.6
01F9:  MOVWF  4E
....................        
....................    lcd_output_enable(0); 
01FA:  BCF    03.6
01FB:  BCF    09.0
01FC:  BSF    03.5
01FD:  BCF    09.0
....................    delay_cycles(1); 
01FE:  NOP
....................    lcd_output_enable(1); 
01FF:  BCF    03.5
0200:  BSF    09.0
0201:  BSF    03.5
0202:  BCF    09.0
....................    delay_us(1); 
0203:  GOTO   204
0204:  GOTO   205
0205:  NOP
....................    low = lcd_read_nibble(); 
0206:  BCF    03.5
0207:  CALL   19C
0208:  MOVF   78,W
0209:  BSF    03.6
020A:  MOVWF  4D
....................        
....................    lcd_output_enable(0); 
020B:  BCF    03.6
020C:  BCF    09.0
020D:  BSF    03.5
020E:  BCF    09.0
....................  
....................  #if defined(__PCB__) 
....................    set_tris_lcd(LCD_OUTPUT_MAP); 
....................  #else 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    output_drive(LCD_DATA4); 
020F:  BCF    03.5
0210:  BCF    31.0
0211:  MOVF   31,W
0212:  BSF    03.5
0213:  MOVWF  07
....................    output_drive(LCD_DATA5); 
0214:  BCF    03.5
0215:  BCF    31.1
0216:  MOVF   31,W
0217:  BSF    03.5
0218:  MOVWF  07
....................    output_drive(LCD_DATA6); 
0219:  BCF    03.5
021A:  BCF    31.2
021B:  MOVF   31,W
021C:  BSF    03.5
021D:  MOVWF  07
....................    output_drive(LCD_DATA7); 
021E:  BCF    03.5
021F:  BCF    31.3
0220:  MOVF   31,W
0221:  BSF    03.5
0222:  MOVWF  07
....................   #else 
....................    lcdtris.data = 0x0; 
....................   #endif 
....................  #endif 
....................  
....................    return( (high<<4) | low); 
0223:  BCF    03.5
0224:  BSF    03.6
0225:  SWAPF  4E,W
0226:  MOVWF  77
0227:  MOVLW  F0
0228:  ANDWF  77,F
0229:  MOVF   77,W
022A:  IORWF  4D,W
022B:  MOVWF  78
.................... } 
....................  
.................... unsigned int8 lcd_read_nibble(void) 
.................... { 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
*
019C:  BSF    03.6
019D:  CLRF   4F
....................    unsigned int8 n = 0x00; 
....................  
....................    /* Read the data port */ 
....................    n |= input(LCD_DATA4); 
019E:  BCF    03.6
019F:  BSF    31.0
01A0:  MOVF   31,W
01A1:  BSF    03.5
01A2:  MOVWF  07
01A3:  MOVLW  00
01A4:  BCF    03.5
01A5:  BTFSC  07.0
01A6:  MOVLW  01
01A7:  BSF    03.6
01A8:  IORWF  4F,F
....................    n |= input(LCD_DATA5) << 1; 
01A9:  BCF    03.6
01AA:  BSF    31.1
01AB:  MOVF   31,W
01AC:  BSF    03.5
01AD:  MOVWF  07
01AE:  MOVLW  00
01AF:  BCF    03.5
01B0:  BTFSC  07.1
01B1:  MOVLW  01
01B2:  MOVWF  77
01B3:  BCF    03.0
01B4:  RLF    77,F
01B5:  MOVF   77,W
01B6:  BSF    03.6
01B7:  IORWF  4F,F
....................    n |= input(LCD_DATA6) << 2; 
01B8:  BCF    03.6
01B9:  BSF    31.2
01BA:  MOVF   31,W
01BB:  BSF    03.5
01BC:  MOVWF  07
01BD:  MOVLW  00
01BE:  BCF    03.5
01BF:  BTFSC  07.2
01C0:  MOVLW  01
01C1:  MOVWF  77
01C2:  RLF    77,F
01C3:  RLF    77,F
01C4:  MOVLW  FC
01C5:  ANDWF  77,F
01C6:  MOVF   77,W
01C7:  BSF    03.6
01C8:  IORWF  4F,F
....................    n |= input(LCD_DATA7) << 3; 
01C9:  BCF    03.6
01CA:  BSF    31.3
01CB:  MOVF   31,W
01CC:  BSF    03.5
01CD:  MOVWF  07
01CE:  MOVLW  00
01CF:  BCF    03.5
01D0:  BTFSC  07.3
01D1:  MOVLW  01
01D2:  MOVWF  77
01D3:  RLF    77,F
01D4:  RLF    77,F
01D5:  RLF    77,F
01D6:  MOVLW  F8
01D7:  ANDWF  77,F
01D8:  MOVF   77,W
01D9:  BSF    03.6
01DA:  IORWF  4F,F
....................     
....................    return(n); 
01DB:  MOVF   4F,W
01DC:  MOVWF  78
....................   #else 
01DD:  BCF    03.6
01DE:  RETURN
....................    return(lcd.data); 
....................   #endif 
.................... } 
....................  
.................... void lcd_send_nibble(unsigned int8 n) 
.................... { 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    /* Write to the data port */ 
....................    output_bit(LCD_DATA4, bit_test(n, 0)); 
*
0154:  BSF    03.6
0155:  BTFSC  4E.0
0156:  GOTO   15B
0157:  BCF    03.6
0158:  BCF    07.0
0159:  GOTO   15D
015A:  BSF    03.6
015B:  BCF    03.6
015C:  BSF    07.0
015D:  BCF    31.0
015E:  MOVF   31,W
015F:  BSF    03.5
0160:  MOVWF  07
....................    output_bit(LCD_DATA5, bit_test(n, 1)); 
0161:  BCF    03.5
0162:  BSF    03.6
0163:  BTFSC  4E.1
0164:  GOTO   169
0165:  BCF    03.6
0166:  BCF    07.1
0167:  GOTO   16B
0168:  BSF    03.6
0169:  BCF    03.6
016A:  BSF    07.1
016B:  BCF    31.1
016C:  MOVF   31,W
016D:  BSF    03.5
016E:  MOVWF  07
....................    output_bit(LCD_DATA6, bit_test(n, 2)); 
016F:  BCF    03.5
0170:  BSF    03.6
0171:  BTFSC  4E.2
0172:  GOTO   177
0173:  BCF    03.6
0174:  BCF    07.2
0175:  GOTO   179
0176:  BSF    03.6
0177:  BCF    03.6
0178:  BSF    07.2
0179:  BCF    31.2
017A:  MOVF   31,W
017B:  BSF    03.5
017C:  MOVWF  07
....................    output_bit(LCD_DATA7, bit_test(n, 3)); 
017D:  BCF    03.5
017E:  BSF    03.6
017F:  BTFSC  4E.3
0180:  GOTO   185
0181:  BCF    03.6
0182:  BCF    07.3
0183:  GOTO   187
0184:  BSF    03.6
0185:  BCF    03.6
0186:  BSF    07.3
0187:  BCF    31.3
0188:  MOVF   31,W
0189:  BSF    03.5
018A:  MOVWF  07
....................   #else       
....................    lcdlat.data = n; 
....................   #endif 
....................        
....................    delay_cycles(1); 
018B:  NOP
....................    lcd_output_enable(1); 
018C:  BCF    03.5
018D:  BSF    09.0
018E:  BSF    03.5
018F:  BCF    09.0
....................    delay_us(2); 
0190:  MOVLW  02
0191:  MOVWF  77
0192:  DECFSZ 77,F
0193:  GOTO   192
0194:  GOTO   195
0195:  NOP
....................    lcd_output_enable(0); 
0196:  BCF    03.5
0197:  BCF    09.0
0198:  BSF    03.5
0199:  BCF    09.0
019A:  BCF    03.5
019B:  RETURN
.................... } 
....................  
.................... void lcd_send_byte(unsigned int8 address, unsigned int8 n) 
.................... { 
....................   #if defined(__PCB__) 
....................    set_tris_lcd(LCD_OUTPUT_MAP); 
....................   #else 
....................    lcd_enable_tris(); 
*
01DF:  BSF    03.5
01E0:  BCF    09.0
....................    lcd_rs_tris(); 
01E1:  BCF    09.1
....................    lcd_rw_tris(); 
01E2:  BCF    09.2
....................   #endif 
....................  
....................    lcd_output_rs(0); 
01E3:  BCF    03.5
01E4:  BCF    09.1
01E5:  BSF    03.5
01E6:  BCF    09.1
....................    while ( bit_test(lcd_read_byte(),7) ) ; 
*
022C:  MOVF   78,W
022D:  MOVWF  4D
022E:  BTFSS  4D.7
022F:  GOTO   233
0230:  BSF    03.5
0231:  BCF    03.6
0232:  GOTO   1E7
....................    lcd_output_rs(address); 
0233:  MOVF   4B,F
0234:  BTFSS  03.2
0235:  GOTO   23A
0236:  BCF    03.6
0237:  BCF    09.1
0238:  GOTO   23C
0239:  BSF    03.6
023A:  BCF    03.6
023B:  BSF    09.1
023C:  BSF    03.5
023D:  BCF    09.1
....................    delay_cycles(1); 
023E:  NOP
....................    lcd_output_rw(0); 
023F:  BCF    03.5
0240:  BCF    09.2
0241:  BSF    03.5
0242:  BCF    09.2
....................    delay_cycles(1); 
0243:  NOP
....................    lcd_output_enable(0); 
0244:  BCF    03.5
0245:  BCF    09.0
0246:  BSF    03.5
0247:  BCF    09.0
....................    lcd_send_nibble(n >> 4); 
0248:  BCF    03.5
0249:  BSF    03.6
024A:  SWAPF  4C,W
024B:  MOVWF  4D
024C:  MOVLW  0F
024D:  ANDWF  4D,F
024E:  MOVF   4D,W
024F:  MOVWF  4E
0250:  BCF    03.6
0251:  CALL   154
....................    lcd_send_nibble(n & 0xf); 
0252:  BSF    03.6
0253:  MOVF   4C,W
0254:  ANDLW  0F
0255:  MOVWF  4D
0256:  MOVWF  4E
0257:  BCF    03.6
0258:  CALL   154
0259:  RETURN
.................... } 
....................  
.................... #if defined(LCD_EXTENDED_NEWLINE) 
.................... unsigned int8 g_LcdX, g_LcdY; 
.................... #endif 
....................  
.................... void lcd_init(void)  
.................... { 
....................    unsigned int8 i; 
....................    unsigned int8 LCD_INIT_STRING[4] = {0x20 | (LCD_TYPE << 2), 0xc, 1, 6}; 
025A:  MOVLW  28
025B:  BSF    03.6
025C:  MOVWF  16
025D:  MOVLW  0C
025E:  MOVWF  17
025F:  MOVLW  01
0260:  MOVWF  18
0261:  MOVLW  06
0262:  MOVWF  19
....................                              // These bytes need to be sent to the LCD 
....................                              // to start it up. 
....................     
....................  
....................    lcd_output_enable(0); 
0263:  BCF    03.6
0264:  BCF    09.0
0265:  BSF    03.5
0266:  BCF    09.0
....................    lcd_output_rs(0); 
0267:  BCF    03.5
0268:  BCF    09.1
0269:  BSF    03.5
026A:  BCF    09.1
....................    lcd_output_rw(0); 
026B:  BCF    03.5
026C:  BCF    09.2
026D:  BSF    03.5
026E:  BCF    09.2
....................  
....................  #if defined(__PCB__) 
....................    set_tris_lcd(LCD_OUTPUT_MAP); 
....................  #else 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    output_drive(LCD_DATA4); 
026F:  BCF    03.5
0270:  BCF    31.0
0271:  MOVF   31,W
0272:  BSF    03.5
0273:  MOVWF  07
....................    output_drive(LCD_DATA5); 
0274:  BCF    03.5
0275:  BCF    31.1
0276:  MOVF   31,W
0277:  BSF    03.5
0278:  MOVWF  07
....................    output_drive(LCD_DATA6); 
0279:  BCF    03.5
027A:  BCF    31.2
027B:  MOVF   31,W
027C:  BSF    03.5
027D:  MOVWF  07
....................    output_drive(LCD_DATA7); 
027E:  BCF    03.5
027F:  BCF    31.3
0280:  MOVF   31,W
0281:  BSF    03.5
0282:  MOVWF  07
....................   #else 
....................    lcdtris.data = 0x0; 
....................   #endif 
....................    lcd_enable_tris(); 
0283:  BCF    09.0
....................    lcd_rs_tris(); 
0284:  BCF    09.1
....................    lcd_rw_tris(); 
0285:  BCF    09.2
....................  #endif 
....................      
....................    delay_ms(15); 
0286:  MOVLW  0F
0287:  BCF    03.5
0288:  BSF    03.6
0289:  MOVWF  47
028A:  BCF    03.6
028B:  CALL   140
....................    for(i=1;i<=3;++i) 
028C:  MOVLW  01
028D:  BSF    03.6
028E:  MOVWF  15
028F:  MOVF   15,W
0290:  SUBLW  03
0291:  BTFSS  03.0
0292:  GOTO   29F
....................    { 
....................        lcd_send_nibble(3); 
0293:  MOVLW  03
0294:  MOVWF  4E
0295:  BCF    03.6
0296:  CALL   154
....................        delay_ms(5); 
0297:  MOVLW  05
0298:  BSF    03.6
0299:  MOVWF  47
029A:  BCF    03.6
029B:  CALL   140
029C:  BSF    03.6
029D:  INCF   15,F
029E:  GOTO   28F
....................    } 
....................     
....................    lcd_send_nibble(2); 
029F:  MOVLW  02
02A0:  MOVWF  4E
02A1:  BCF    03.6
02A2:  CALL   154
....................    delay_ms(5); 
02A3:  MOVLW  05
02A4:  BSF    03.6
02A5:  MOVWF  47
02A6:  BCF    03.6
02A7:  CALL   140
....................    for(i=0;i<=3;++i) 
02A8:  BSF    03.6
02A9:  CLRF   15
02AA:  MOVF   15,W
02AB:  SUBLW  03
02AC:  BTFSS  03.0
02AD:  GOTO   2BC
....................       lcd_send_byte(0,LCD_INIT_STRING[i]); 
02AE:  MOVLW  16
02AF:  ADDWF  15,W
02B0:  MOVWF  04
02B1:  BSF    03.7
02B2:  MOVF   00,W
02B3:  MOVWF  1A
02B4:  CLRF   4B
02B5:  MOVF   1A,W
02B6:  MOVWF  4C
02B7:  BCF    03.6
02B8:  CALL   1DF
....................  
....................   #if defined(LCD_EXTENDED_NEWLINE) 
02B9:  BSF    03.6
02BA:  INCF   15,F
02BB:  GOTO   2AA
02BC:  BCF    03.6
02BD:  BCF    0A.3
02BE:  BSF    0A.4
02BF:  GOTO   1F1 (RETURN)
....................    g_LcdX = 0; 
....................    g_LcdY = 0; 
....................   #endif 
.................... } 
....................  
.................... void lcd_gotoxy(unsigned int8 x, unsigned int8 y) 
.................... { 
....................    unsigned int8 address; 
....................     
....................    if(y!=1) 
02C0:  BSF    03.6
02C1:  DECFSZ 48,W
02C2:  GOTO   2C4
02C3:  GOTO   2C7
....................       address=LCD_LINE_TWO; 
02C4:  MOVLW  40
02C5:  MOVWF  49
02C6:  GOTO   2C8
....................    else 
....................       address=0; 
02C7:  CLRF   49
....................       
....................    address+=x-1; 
02C8:  MOVLW  01
02C9:  SUBWF  47,W
02CA:  ADDWF  49,F
....................    lcd_send_byte(0,0x80|address); 
02CB:  MOVF   49,W
02CC:  IORLW  80
02CD:  MOVWF  4A
02CE:  CLRF   4B
02CF:  MOVF   4A,W
02D0:  MOVWF  4C
02D1:  BCF    03.6
02D2:  CALL   1DF
....................  
....................   #if defined(LCD_EXTENDED_NEWLINE) 
02D3:  RETURN
....................    g_LcdX = x - 1; 
....................    g_LcdY = y - 1; 
....................   #endif 
.................... } 
....................  
.................... void lcd_putc(char c) 
.................... { 
....................    switch (c) 
02D4:  BSF    03.6
02D5:  MOVF   46,W
02D6:  XORLW  07
02D7:  BCF    03.6
02D8:  BTFSC  03.2
02D9:  GOTO   2E4
02DA:  XORLW  0B
02DB:  BTFSC  03.2
02DC:  GOTO   2EB
02DD:  XORLW  06
02DE:  BTFSC  03.2
02DF:  GOTO   2F7
02E0:  XORLW  02
02E1:  BTFSC  03.2
02E2:  GOTO   2FF
02E3:  GOTO   306
....................    { 
....................       case '\a'   :  lcd_gotoxy(1,1);     break; 
02E4:  MOVLW  01
02E5:  BSF    03.6
02E6:  MOVWF  47
02E7:  MOVWF  48
02E8:  BCF    03.6
02E9:  CALL   2C0
02EA:  GOTO   30D
....................  
....................       case '\f'   :  lcd_send_byte(0,1); 
02EB:  BSF    03.6
02EC:  CLRF   4B
02ED:  MOVLW  01
02EE:  MOVWF  4C
02EF:  BCF    03.6
02F0:  CALL   1DF
....................                      delay_ms(2); 
02F1:  MOVLW  02
02F2:  BSF    03.6
02F3:  MOVWF  47
02F4:  BCF    03.6
02F5:  CALL   140
....................                     #if defined(LCD_EXTENDED_NEWLINE) 
....................                      g_LcdX = 0; 
....................                      g_LcdY = 0; 
....................                     #endif 
....................                      break; 
02F6:  GOTO   30D
....................  
....................      #if defined(LCD_EXTENDED_NEWLINE) 
....................       case '\r'   :  lcd_gotoxy(1, g_LcdY+1);   break; 
....................       case '\n'   : 
....................          while (g_LcdX++ < LCD_LINE_LENGTH) 
....................          { 
....................             lcd_send_byte(1, ' '); 
....................          } 
....................          lcd_gotoxy(1, g_LcdY+2); 
....................          break; 
....................      #else 
....................       case '\n'   : lcd_gotoxy(1,2);        break; 
02F7:  MOVLW  01
02F8:  BSF    03.6
02F9:  MOVWF  47
02FA:  MOVLW  02
02FB:  MOVWF  48
02FC:  BCF    03.6
02FD:  CALL   2C0
02FE:  GOTO   30D
....................      #endif 
....................       
....................       case '\b'   : lcd_send_byte(0,0x10);  break; 
02FF:  BSF    03.6
0300:  CLRF   4B
0301:  MOVLW  10
0302:  MOVWF  4C
0303:  BCF    03.6
0304:  CALL   1DF
0305:  GOTO   30D
....................       
....................      #if defined(LCD_EXTENDED_NEWLINE) 
....................       default     :  
....................          if (g_LcdX < LCD_LINE_LENGTH) 
....................          { 
....................             lcd_send_byte(1, c); 
....................             g_LcdX++; 
....................          } 
....................          break; 
....................      #else 
....................       default     : lcd_send_byte(1,c);     break; 
0306:  MOVLW  01
0307:  BSF    03.6
0308:  MOVWF  4B
0309:  MOVF   46,W
030A:  MOVWF  4C
030B:  BCF    03.6
030C:  CALL   1DF
....................      #endif 
....................    } 
030D:  RETURN
.................... } 
....................   
.................... char lcd_getc(unsigned int8 x, unsigned int8 y) 
.................... { 
....................    char value; 
....................  
....................    lcd_gotoxy(x,y); 
....................    while ( bit_test(lcd_read_byte(),7) ); // wait until busy flag is low 
....................    lcd_output_rs(1); 
....................    value = lcd_read_byte(); 
....................    lcd_output_rs(0); 
....................     
....................    return(value); 
.................... } 
....................  
.................... // write a custom character to the ram 
.................... // which is 0-7 and specifies which character array we are modifying. 
.................... // ptr points to an array of 8 bytes, where each byte is the next row of 
.................... //    pixels.  only bits 0-4 are used.  the last row is the cursor row, and 
.................... //    usually you will want to leave this byte 0x00. 
.................... void lcd_set_cgram_char(unsigned int8 which, unsigned int8 *ptr) 
.................... { 
....................    unsigned int i; 
....................  
....................    which <<= 3; 
....................    which &= 0x38; 
....................  
....................    lcd_send_byte(0, 0x40 | which);  //set cgram address 
....................  
....................    for(i=0; i<8; i++) 
....................    { 
....................       lcd_send_byte(1, *ptr++); 
....................    } 
....................    
....................    #if defined(LCD_EXTENDED_NEWLINE) 
....................     lcd_gotoxy(g_LcdX+1, g_LcdY+1);  //set ddram address 
....................    #endif 
.................... } 
....................  
.................... void lcd_cursor_on(int1 on) 
.................... { 
....................    if (on) 
....................    { 
....................       lcd_send_byte(0,0x0F);           //turn LCD cursor ON 
....................    } 
....................    else 
....................    { 
....................       lcd_send_byte(0,0x0C);           //turn LCD cursor OFF 
....................    } 
.................... } 
....................  
.................... #endif 
....................  
.................... #BIT TMR1IF = 0x0C.0 //bit thu 0 (TMR1IF) cua PIR1 
....................  
.................... #INCLUDE <khaibaobien.c> // VARIABLE. 
.................... UNSIGNED INT16 KQADC,AN0, AN1; 
.................... UNSIGNED INT8 KET_QUA_ANALOG[]={0,0,0,0}; 
*
115B:  CLRF   38
115C:  CLRF   39
115D:  CLRF   3A
115E:  CLRF   3B
.................... UNSIGNED INT8 CONFIG_FUN=0; 
.................... UNSIGNED INT8 VT=0, KYTU=0;// KYTU[30],  
.................... UNSIGNED INT8 ID_DEVICE_NHAN,TT_DEVICE_NHAN, LENH_DIEU_KHIEN = 0; 
.................... UNSIGNED INT8 ID_GATEWAY[6] = {0,2,6,6,3,6}; 
115F:  CLRF   42
1160:  MOVLW  02
1161:  MOVWF  43
1162:  MOVLW  06
1163:  MOVWF  44
1164:  MOVWF  45
1165:  MOVLW  03
1166:  MOVWF  46
1167:  MOVLW  06
1168:  MOVWF  47
.................... UNSIGNED INT8 ID_NODE[4] = {7,5,9,9}; 
1169:  MOVLW  07
116A:  MOVWF  48
116B:  MOVLW  05
116C:  MOVWF  49
116D:  MOVLW  09
116E:  MOVWF  4A
116F:  MOVWF  4B
.................... UNSIGNED INT8 LEN_PACKAGES = 0; 
.................... UNSIGNED INT8 LENHDIEUKHIEN =0, DODAI_DATA_NHAN =0; 
.................... UNSIGNED INT8 SOLUONGTHIETBI_CONFIG=0, SOLUONGCAMBIEN_CONFIG = 3; 
.................... SIGNED INT8 SOSANH_IDNODE=0, SOSANH_IDGW=0; 
....................  
.................... INT1 TTNHAN = 0, TT_CONFIG=0, TT_CONTROL=0,TT_CONFIG_DONE=0, TT_FUN=0, TT_STT=0 , TT_CONFIG_OKE_UART = 0; 
....................  
.................... CHAR *ID_NODE_CHAR[]= "0589"; 
1170:  MOVLW  30
1171:  MOVWF  56
1172:  MOVLW  35
1173:  MOVWF  57
1174:  MOVLW  38
1175:  MOVWF  58
1176:  MOVLW  39
1177:  MOVWF  59
1178:  CLRF   5A
1179:  CLRF   55
117A:  MOVLW  56
117B:  MOVWF  54
.................... CHAR *ID_GATEWAY_CHAR[]= "127102"; 
117C:  MOVLW  31
117D:  MOVWF  5D
117E:  MOVLW  32
117F:  MOVWF  5E
1180:  MOVLW  37
1181:  MOVWF  5F
1182:  MOVLW  31
1183:  MOVWF  60
1184:  MOVLW  30
1185:  MOVWF  61
1186:  MOVLW  32
1187:  MOVWF  62
1188:  CLRF   63
1189:  CLRF   5C
118A:  MOVLW  5D
118B:  MOVWF  5B
.................... CHAR *ID_NODE_NHAN[]= "0000"; 
118C:  MOVLW  30
118D:  MOVWF  66
118E:  MOVWF  67
118F:  MOVWF  68
1190:  MOVWF  69
1191:  CLRF   6A
1192:  CLRF   65
1193:  MOVLW  66
1194:  MOVWF  64
.................... CHAR *ID_GW_NHAN[]= "000000"; 
1195:  MOVLW  30
1196:  MOVWF  6D
1197:  MOVWF  6E
1198:  MOVWF  6F
1199:  MOVWF  70
119A:  MOVWF  71
119B:  MOVWF  72
119C:  CLRF   73
119D:  CLRF   6C
119E:  MOVLW  6D
119F:  MOVWF  6B
.................... CHAR KYTUCHAR[50]="HIHI"; 
11A0:  MOVLW  48
11A1:  BSF    03.5
11A2:  MOVWF  20
11A3:  MOVLW  49
11A4:  MOVWF  21
11A5:  MOVLW  48
11A6:  MOVWF  22
11A7:  MOVLW  49
11A8:  MOVWF  23
11A9:  CLRF   24
.................... CHAR KYTUCHAR2[25]="HIHI"; 
11AA:  MOVLW  48
11AB:  MOVWF  52
11AC:  MOVLW  49
11AD:  MOVWF  53
11AE:  MOVLW  48
11AF:  MOVWF  54
11B0:  MOVLW  49
11B1:  MOVWF  55
11B2:  CLRF   56
.................... //CHAR *DATA_NHANDUOC[]={"IDGW","IDNODE","COMMAN","DATA"}; 
.................... CHAR *TEMP_CHAR[]="0000";   
11B3:  MOVLW  30
11B4:  MOVWF  6B
11B5:  MOVWF  6C
11B6:  MOVWF  6D
11B7:  MOVWF  6E
11B8:  CLRF   6F
11B9:  CLRF   75
11BA:  MOVLW  EB
11BB:  MOVWF  74
.................... CHAR *TEMP_CHAR2[]="2700";  
11BC:  MOVLW  32
11BD:  BCF    03.5
11BE:  BSF    03.6
11BF:  MOVWF  10
11C0:  MOVLW  37
11C1:  MOVWF  11
11C2:  MOVLW  30
11C3:  MOVWF  12
11C4:  MOVWF  13
11C5:  CLRF   14
11C6:  MOVLW  01
11C7:  MOVWF  7C
11C8:  MOVLW  10
11C9:  MOVWF  7B
.................... //CHAR *TEMP_CHAR3[]="000000";  
....................  
....................  
....................  
.................... //#INCLUDE <CONFIG_NODE.C> // CU HINH NODE. 
.................... #INCLUDE <config_1.C> // CU HINH NODE. 
....................  
.................... //--------------------------------------------------------------------// 
.................... VOID CHON_ID() 
.................... { 
....................    // TT_CONFIG_DONE; 
....................    TT_CONFIG_DONE = 0; 
*
05A7:  BCF    53.3
....................    TT_STT = 1; 
05A8:  BSF    53.5
....................    UNSIGNED INT8 NUM = 0; 
05A9:  BSF    03.6
05AA:  CLRF   15
....................    TEMP_CHAR = "0"; 
05AB:  CLRF   16
05AC:  CLRF   17
05AD:  MOVLW  74
05AE:  MOVWF  04
05AF:  BCF    03.7
05B0:  MOVF   16,W
05B1:  ADDWF  04,F
05B2:  MOVF   17,W
05B3:  BCF    03.6
05B4:  CALL   058
05B5:  MOVWF  00
05B6:  IORLW  00
05B7:  BTFSC  03.2
05B8:  GOTO   5BE
05B9:  BSF    03.6
05BA:  INCF   17,F
05BB:  INCF   16,F
05BC:  GOTO   5AD
05BD:  BCF    03.6
....................    LCD_GOTOXY (1, 2) ; 
05BE:  MOVLW  01
05BF:  BSF    03.6
05C0:  MOVWF  47
05C1:  MOVLW  02
05C2:  MOVWF  48
05C3:  BCF    03.6
05C4:  CALL   2C0
....................    DELAY_MS (10); 
05C5:  MOVLW  0A
05C6:  BSF    03.6
05C7:  MOVWF  47
05C8:  BCF    03.6
05C9:  CALL   140
....................    PRINTF (LCD_PUTC, "NODE: "); 
05CA:  MOVLW  6F
05CB:  BSF    03.6
05CC:  MOVWF  0D
05CD:  MOVLW  00
05CE:  MOVWF  0F
05CF:  BCF    03.6
05D0:  CALL   30E
....................    PRINTF (LCD_PUTC, "0000          "); 
05D1:  MOVLW  73
05D2:  BSF    03.6
05D3:  MOVWF  0D
05D4:  MOVLW  00
05D5:  MOVWF  0F
05D6:  BCF    03.6
05D7:  CALL   30E
....................    LCD_GOTOXY (1, 1) ; 
05D8:  MOVLW  01
05D9:  BSF    03.6
05DA:  MOVWF  47
05DB:  MOVWF  48
05DC:  BCF    03.6
05DD:  CALL   2C0
....................    PRINTF (LCD_PUTC, "      _              ");//6 SPACE PHIA TRUOC "_" 
05DE:  MOVLW  7B
05DF:  BSF    03.6
05E0:  MOVWF  0D
05E1:  MOVLW  00
05E2:  MOVWF  0F
05E3:  BCF    03.6
05E4:  CALL   30E
....................    //ID_GW = "1234";     
....................  
....................    WHILE (TT_STT) 
05E5:  BTFSS  53.5
05E6:  GOTO   663
....................    { 
....................       IF (!INPUT (BT2_PIN)) //NEU NUT BAM DUOC BAM 
05E7:  BSF    03.5
05E8:  BSF    06.2
05E9:  BCF    03.5
05EA:  BTFSC  06.2
05EB:  GOTO   60A
....................       { 
....................           
....................          NUM++; 
05EC:  BSF    03.6
05ED:  INCF   15,F
....................          NUM = NUM % 4; 
05EE:  MOVLW  03
05EF:  ANDWF  15,F
....................          LCD_GOTOXY (3 + NUM, 1); 
05F0:  ADDWF  15,W
05F1:  MOVWF  16
05F2:  MOVWF  47
05F3:  MOVLW  01
05F4:  MOVWF  48
05F5:  BCF    03.6
05F6:  CALL   2C0
....................          PRINTF (LCD_PUTC, "    _    ");//4SPACE 
05F7:  MOVLW  86
05F8:  BSF    03.6
05F9:  MOVWF  0D
05FA:  MOVLW  00
05FB:  MOVWF  0F
05FC:  BCF    03.6
05FD:  CALL   30E
....................          DELAY_MS (300);  
05FE:  MOVLW  02
05FF:  BSF    03.6
0600:  MOVWF  16
0601:  MOVLW  96
0602:  MOVWF  47
0603:  BCF    03.6
0604:  CALL   140
0605:  BSF    03.6
0606:  DECFSZ 16,F
0607:  GOTO   601
....................       } 
0608:  GOTO   661
0609:  BCF    03.6
....................  
....................       ELSE IF (!INPUT (BT3_PIN)) 
060A:  BSF    03.5
060B:  BSF    06.3
060C:  BCF    03.5
060D:  BTFSC  06.3
060E:  GOTO   662
....................       { 
....................          ID_NODE[NUM]++; 
060F:  MOVLW  48
0610:  BSF    03.6
0611:  ADDWF  15,W
0612:  MOVWF  04
0613:  BCF    03.7
0614:  INCF   00,F
....................          ID_NODE[NUM] = ID_NODE[NUM] % 10; 
0615:  MOVLW  48
0616:  ADDWF  15,W
0617:  MOVWF  78
0618:  CLRF   7A
0619:  BTFSC  03.0
061A:  INCF   7A,F
061B:  MOVF   78,W
061C:  MOVWF  16
061D:  MOVF   7A,W
061E:  MOVWF  17
061F:  MOVLW  48
0620:  ADDWF  15,W
0621:  MOVWF  04
0622:  BCF    03.7
0623:  MOVF   00,W
0624:  MOVWF  19
0625:  MOVLW  0A
0626:  MOVWF  1A
0627:  BCF    03.6
0628:  CALL   517
0629:  MOVF   77,W
062A:  BSF    03.6
062B:  MOVWF  18
062C:  MOVF   16,W
062D:  MOVWF  04
062E:  BCF    03.7
062F:  BTFSC  17.0
0630:  BSF    03.7
0631:  MOVF   18,W
0632:  MOVWF  00
....................          ITOA (ID_NODE[NUM], 10, TEMP_CHAR); 
0633:  MOVLW  48
0634:  ADDWF  15,W
0635:  MOVWF  04
0636:  BCF    03.7
0637:  MOVF   00,W
0638:  MOVWF  16
0639:  CLRF   48
063A:  CLRF   47
063B:  CLRF   46
063C:  MOVF   16,W
063D:  MOVWF  45
063E:  MOVLW  0A
063F:  MOVWF  49
0640:  CLRF   4B
0641:  MOVLW  74
0642:  MOVWF  4A
0643:  BCF    03.6
0644:  CALL   3DA
....................          LCD_GOTOXY (7 + NUM, 2); 
0645:  MOVLW  07
0646:  BSF    03.6
0647:  ADDWF  15,W
0648:  MOVWF  16
0649:  MOVWF  47
064A:  MOVLW  02
064B:  MOVWF  48
064C:  BCF    03.6
064D:  CALL   2C0
....................          DELAY_MS (10); 
064E:  MOVLW  0A
064F:  BSF    03.6
0650:  MOVWF  47
0651:  BCF    03.6
0652:  CALL   140
....................          PRINTF (LCD_PUTC, TEMP_CHAR); 
0653:  MOVLW  74
0654:  MOVWF  04
0655:  BCF    03.7
0656:  CALL   4FA
....................          DELAY_MS (300); 
0657:  MOVLW  02
0658:  BSF    03.6
0659:  MOVWF  16
065A:  MOVLW  96
065B:  MOVWF  47
065C:  BCF    03.6
065D:  CALL   140
065E:  BSF    03.6
065F:  DECFSZ 16,F
0660:  GOTO   65A
0661:  BCF    03.6
....................       } 
0662:  GOTO   5E5
....................    } 
.................... } 
....................  
.................... VOID NHAPID_GW() 
*
0664:  BSF    03.6
0665:  CLRF   15
.................... { 
....................    UNSIGNED INT8 NUM = 0; 
....................    TEMP_CHAR = "0"; 
0666:  CLRF   16
0667:  CLRF   17
0668:  MOVLW  74
0669:  MOVWF  04
066A:  BCF    03.7
066B:  MOVF   16,W
066C:  ADDWF  04,F
066D:  MOVF   17,W
066E:  BCF    03.6
066F:  CALL   058
0670:  MOVWF  00
0671:  IORLW  00
0672:  BTFSC  03.2
0673:  GOTO   679
0674:  BSF    03.6
0675:  INCF   17,F
0676:  INCF   16,F
0677:  GOTO   668
0678:  BCF    03.6
....................    TT_CONFIG_DONE = 0; 
0679:  BCF    53.3
....................    TT_STT = 1; 
067A:  BSF    53.5
....................    LCD_GOTOXY (1, 2) ; 
067B:  MOVLW  01
067C:  BSF    03.6
067D:  MOVWF  47
067E:  MOVLW  02
067F:  MOVWF  48
0680:  BCF    03.6
0681:  CALL   2C0
....................    DELAY_MS (10); 
0682:  MOVLW  0A
0683:  BSF    03.6
0684:  MOVWF  47
0685:  BCF    03.6
0686:  CALL   140
....................    PRINTF (LCD_PUTC, "ID_GW:"); 
0687:  MOVLW  8B
0688:  BSF    03.6
0689:  MOVWF  0D
068A:  MOVLW  00
068B:  MOVWF  0F
068C:  BCF    03.6
068D:  CALL   30E
....................    PRINTF (LCD_PUTC, "000000        "); 
068E:  MOVLW  8F
068F:  BSF    03.6
0690:  MOVWF  0D
0691:  MOVLW  00
0692:  MOVWF  0F
0693:  BCF    03.6
0694:  CALL   30E
....................    LCD_GOTOXY (1, 1) ; 
0695:  MOVLW  01
0696:  BSF    03.6
0697:  MOVWF  47
0698:  MOVWF  48
0699:  BCF    03.6
069A:  CALL   2C0
....................    PRINTF (LCD_PUTC, "      _                ");//6 SPACE PHIA TRUOC "_" 
069B:  MOVLW  97
069C:  BSF    03.6
069D:  MOVWF  0D
069E:  MOVLW  00
069F:  MOVWF  0F
06A0:  BCF    03.6
06A1:  CALL   30E
....................    //ID_GW = "1234";     
....................  
....................    WHILE (TT_STT) 
06A2:  BTFSS  53.5
06A3:  GOTO   728
....................    { 
....................       IF (!INPUT (BT2_PIN)) //NEU NUT BAM DUOC BAM 
06A4:  BSF    03.5
06A5:  BSF    06.2
06A6:  BCF    03.5
06A7:  BTFSC  06.2
06A8:  GOTO   6CF
....................       { 
....................           
....................          NUM++; 
06A9:  BSF    03.6
06AA:  INCF   15,F
....................          NUM = NUM % 6; 
06AB:  MOVF   15,W
06AC:  MOVWF  19
06AD:  MOVLW  06
06AE:  MOVWF  1A
06AF:  BCF    03.6
06B0:  CALL   517
06B1:  MOVF   77,W
06B2:  BSF    03.6
06B3:  MOVWF  15
....................          LCD_GOTOXY (3 + NUM, 1); 
06B4:  MOVLW  03
06B5:  ADDWF  15,W
06B6:  MOVWF  16
06B7:  MOVWF  47
06B8:  MOVLW  01
06B9:  MOVWF  48
06BA:  BCF    03.6
06BB:  CALL   2C0
....................          PRINTF (LCD_PUTC, "    _        ");//4SPACE 
06BC:  MOVLW  A3
06BD:  BSF    03.6
06BE:  MOVWF  0D
06BF:  MOVLW  00
06C0:  MOVWF  0F
06C1:  BCF    03.6
06C2:  CALL   30E
....................          DELAY_MS (300);  
06C3:  MOVLW  02
06C4:  BSF    03.6
06C5:  MOVWF  16
06C6:  MOVLW  96
06C7:  MOVWF  47
06C8:  BCF    03.6
06C9:  CALL   140
06CA:  BSF    03.6
06CB:  DECFSZ 16,F
06CC:  GOTO   6C6
....................       } 
06CD:  GOTO   726
06CE:  BCF    03.6
....................  
....................       ELSE IF (!INPUT (BT3_PIN)) 
06CF:  BSF    03.5
06D0:  BSF    06.3
06D1:  BCF    03.5
06D2:  BTFSC  06.3
06D3:  GOTO   727
....................       { 
....................          ID_GATEWAY[NUM]++; 
06D4:  MOVLW  42
06D5:  BSF    03.6
06D6:  ADDWF  15,W
06D7:  MOVWF  04
06D8:  BCF    03.7
06D9:  INCF   00,F
....................          ID_GATEWAY[NUM] = ID_GATEWAY[NUM] % 10; 
06DA:  MOVLW  42
06DB:  ADDWF  15,W
06DC:  MOVWF  78
06DD:  CLRF   7A
06DE:  BTFSC  03.0
06DF:  INCF   7A,F
06E0:  MOVF   78,W
06E1:  MOVWF  16
06E2:  MOVF   7A,W
06E3:  MOVWF  17
06E4:  MOVLW  42
06E5:  ADDWF  15,W
06E6:  MOVWF  04
06E7:  BCF    03.7
06E8:  MOVF   00,W
06E9:  MOVWF  19
06EA:  MOVLW  0A
06EB:  MOVWF  1A
06EC:  BCF    03.6
06ED:  CALL   517
06EE:  MOVF   77,W
06EF:  BSF    03.6
06F0:  MOVWF  18
06F1:  MOVF   16,W
06F2:  MOVWF  04
06F3:  BCF    03.7
06F4:  BTFSC  17.0
06F5:  BSF    03.7
06F6:  MOVF   18,W
06F7:  MOVWF  00
....................          ITOA (ID_GATEWAY[NUM], 10, TEMP_CHAR); 
06F8:  MOVLW  42
06F9:  ADDWF  15,W
06FA:  MOVWF  04
06FB:  BCF    03.7
06FC:  MOVF   00,W
06FD:  MOVWF  16
06FE:  CLRF   48
06FF:  CLRF   47
0700:  CLRF   46
0701:  MOVF   16,W
0702:  MOVWF  45
0703:  MOVLW  0A
0704:  MOVWF  49
0705:  CLRF   4B
0706:  MOVLW  74
0707:  MOVWF  4A
0708:  BCF    03.6
0709:  CALL   3DA
....................          LCD_GOTOXY (7 + NUM, 2); 
070A:  MOVLW  07
070B:  BSF    03.6
070C:  ADDWF  15,W
070D:  MOVWF  16
070E:  MOVWF  47
070F:  MOVLW  02
0710:  MOVWF  48
0711:  BCF    03.6
0712:  CALL   2C0
....................          DELAY_MS (10); 
0713:  MOVLW  0A
0714:  BSF    03.6
0715:  MOVWF  47
0716:  BCF    03.6
0717:  CALL   140
....................          PRINTF (LCD_PUTC, TEMP_CHAR); 
0718:  MOVLW  74
0719:  MOVWF  04
071A:  BCF    03.7
071B:  CALL   4FA
....................          DELAY_MS (300); 
071C:  MOVLW  02
071D:  BSF    03.6
071E:  MOVWF  16
071F:  MOVLW  96
0720:  MOVWF  47
0721:  BCF    03.6
0722:  CALL   140
0723:  BSF    03.6
0724:  DECFSZ 16,F
0725:  GOTO   71F
0726:  BCF    03.6
....................       } 
0727:  GOTO   6A2
....................    } 
.................... } 
....................  
.................... VOID BUTT_OKE() 
.................... { 
....................    TT_CONFIG_DONE = 0; 
*
0118:  BCF    03.6
0119:  BCF    53.3
....................    TT_FUN = 0;//BREAK WHILE BUTT_FUN 
011A:  BCF    53.4
....................    TT_STT = 0;// BREAK WHILE CHONID/NHAPID_GW 
011B:  BCF    53.5
.................... } 
....................  
.................... VOID SELLECT_FUN() 
.................... { 
....................    TT_CONFIG_DONE = 0; 
*
059F:  BCF    53.3
....................  
....................    SWITCH (CONFIG_FUN) 
05A0:  MOVF   3C,W
05A1:  BTFSC  03.2
05A2:  GOTO   5A7
05A3:  XORLW  01
05A4:  BTFSC  03.2
05A5:  GOTO   664
05A6:  GOTO   728
....................    { 
....................       CASE 0: 
....................       CHON_ID (); 
....................       BREAK; 
*
0663:  GOTO   728
....................  
....................       CASE 1:     
....................       NHAPID_GW (); 
....................       BREAK; 
....................    } 
.................... } 
....................  
.................... VOID BUTT_FUN() 
.................... { 
....................    TT_FUN = 1; 
*
052E:  BSF    53.4
....................    LCD_GOTOXY (1, 1) ; 
052F:  MOVLW  01
0530:  BSF    03.6
0531:  MOVWF  47
0532:  MOVWF  48
0533:  BCF    03.6
0534:  CALL   2C0
....................    DELAY_MS (10); 
0535:  MOVLW  0A
0536:  BSF    03.6
0537:  MOVWF  47
0538:  BCF    03.6
0539:  CALL   140
....................    PRINTF (LCD_PUTC, "CONFIG:        "); 
053A:  MOVLW  AA
053B:  BSF    03.6
053C:  MOVWF  0D
053D:  MOVLW  00
053E:  MOVWF  0F
053F:  BCF    03.6
0540:  CALL   30E
....................  
....................    // HIEN THI LCD 
....................    LCD_GOTOXY (1, 2) ; 
0541:  MOVLW  01
0542:  BSF    03.6
0543:  MOVWF  47
0544:  MOVLW  02
0545:  MOVWF  48
0546:  BCF    03.6
0547:  CALL   2C0
....................    DELAY_MS (10); 
0548:  MOVLW  0A
0549:  BSF    03.6
054A:  MOVWF  47
054B:  BCF    03.6
054C:  CALL   140
....................    PRINTF (LCD_PUTC, "CASE:          ") ; 
054D:  MOVLW  B2
054E:  BSF    03.6
054F:  MOVWF  0D
0550:  MOVLW  00
0551:  MOVWF  0F
0552:  BCF    03.6
0553:  CALL   30E
....................  
....................    WHILE (TT_FUN) 
0554:  BTFSS  53.4
0555:  GOTO   59D
....................    { 
....................       IF (INPUT (BT2_PIN) == 0) //NEU NUT BAM DUOC BAM 
0556:  BSF    03.5
0557:  BSF    06.2
0558:  BCF    03.5
0559:  BTFSC  06.2
055A:  GOTO   59C
....................       { 
....................          CONFIG_FUN ++; 
055B:  INCF   3C,F
....................          CONFIG_FUN = CONFIG_FUN % 2; 
055C:  MOVLW  01
055D:  ANDWF  3C,F
....................          DELAY_MS (300); 
055E:  MOVLW  02
055F:  BSF    03.6
0560:  MOVWF  15
0561:  MOVLW  96
0562:  MOVWF  47
0563:  BCF    03.6
0564:  CALL   140
0565:  BSF    03.6
0566:  DECFSZ 15,F
0567:  GOTO   561
....................          //HIEN THI 
....................          LCD_GOTOXY (6, 2) ; 
0568:  MOVLW  06
0569:  MOVWF  47
056A:  MOVLW  02
056B:  MOVWF  48
056C:  BCF    03.6
056D:  CALL   2C0
....................          ITOA (CONFIG_FUN, 10, TEMP_CHAR); 
056E:  BSF    03.6
056F:  CLRF   48
0570:  CLRF   47
0571:  CLRF   46
0572:  BCF    03.6
0573:  MOVF   3C,W
0574:  BSF    03.6
0575:  MOVWF  45
0576:  MOVLW  0A
0577:  MOVWF  49
0578:  CLRF   4B
0579:  MOVLW  74
057A:  MOVWF  4A
057B:  BCF    03.6
057C:  CALL   3DA
....................          DELAY_MS (10); 
057D:  MOVLW  0A
057E:  BSF    03.6
057F:  MOVWF  47
0580:  BCF    03.6
0581:  CALL   140
....................          PRINTF (LCD_PUTC, TEMP_CHAR); 
0582:  MOVLW  74
0583:  MOVWF  04
0584:  BCF    03.7
0585:  CALL   4FA
....................  
....................          SWITCH (CONFIG_FUN) 
0586:  MOVF   3C,W
0587:  BTFSC  03.2
0588:  GOTO   58D
0589:  XORLW  01
058A:  BTFSC  03.2
058B:  GOTO   595
058C:  GOTO   59C
....................          { 
....................             CASE 0: 
....................             PRINTF (LCD_PUTC, " - ID-NODE      "); 
058D:  MOVLW  BA
058E:  BSF    03.6
058F:  MOVWF  0D
0590:  MOVLW  00
0591:  MOVWF  0F
0592:  BCF    03.6
0593:  CALL   30E
....................             BREAK; 
0594:  GOTO   59C
....................  
....................             CASE 1: 
....................             PRINTF (LCD_PUTC, " - ID-GW       "); 
0595:  MOVLW  C3
0596:  BSF    03.6
0597:  MOVWF  0D
0598:  MOVLW  00
0599:  MOVWF  0F
059A:  BCF    03.6
059B:  CALL   30E
....................             BREAK;             
....................          } 
....................       } 
059C:  GOTO   554
....................    } 
....................  
....................    ////// 
....................    IF (!TT_CONFIG_DONE) 
059D:  BTFSC  53.3
059E:  GOTO   728
....................    { 
....................       SELLECT_FUN (); 
....................    } 
*
0728:  BCF    0A.3
0729:  BSF    0A.4
072A:  GOTO   1FE (RETURN)
.................... } 
.................... VOID XULY_IDNODE_NHAP(){ 
....................    //*TEMP_CHAR3 = "\0"; 
....................    *ID_NODE_CHAR = "\0"; 
*
0893:  CLRF   7A
0894:  MOVLW  54
0895:  MOVWF  44
0896:  MOVF   7A,W
0897:  MOVWF  45
0898:  MOVF   44,W
0899:  MOVWF  04
089A:  BCF    03.7
089B:  BTFSC  45.0
089C:  BSF    03.7
089D:  CLRF   00
....................    FOR (int j = 0; j < 4; j++) 
089E:  CLRF   43
089F:  MOVF   43,W
08A0:  SUBLW  03
08A1:  BTFSS  03.0
08A2:  GOTO   0CC
....................    { 
....................       ITOA (ID_NODE[j], 10, TEMP_CHAR); 
08A3:  MOVLW  48
08A4:  ADDWF  43,W
08A5:  MOVWF  04
08A6:  BCF    03.7
08A7:  MOVF   00,W
08A8:  MOVWF  44
08A9:  CLRF   48
08AA:  CLRF   47
08AB:  CLRF   46
08AC:  MOVF   44,W
08AD:  MOVWF  45
08AE:  MOVLW  0A
08AF:  MOVWF  49
08B0:  CLRF   4B
08B1:  MOVLW  74
08B2:  MOVWF  4A
08B3:  BCF    0A.3
08B4:  BCF    03.6
08B5:  CALL   3DA
08B6:  BSF    0A.3
....................       DELAY_MS (1); 
08B7:  MOVLW  01
08B8:  BSF    03.6
08B9:  MOVWF  47
08BA:  BCF    0A.3
08BB:  BCF    03.6
08BC:  CALL   140
08BD:  BSF    0A.3
....................       STRCAT (ID_NODE_CHAR, TEMP_CHAR); 
08BE:  BSF    03.6
08BF:  CLRF   45
08C0:  MOVLW  54
08C1:  MOVWF  44
08C2:  CLRF   47
08C3:  MOVLW  74
08C4:  MOVWF  46
08C5:  BCF    0A.3
08C6:  BCF    03.6
08C7:  CALL   72B
08C8:  BSF    0A.3
08C9:  BSF    03.6
08CA:  INCF   43,F
08CB:  GOTO   09F
....................    }   
....................    //ID_NODE_CHAR = TEMP_CHAR3;    
....................    //STRCPY(ID_NODE_CHAR,TEMP_CHAR3); 
....................    //strcpy 
.................... } 
.................... VOID XULY_IDGW_NHAP(){ 
....................  
....................    *ID_GATEWAY_CHAR = "\0"; 
*
0857:  CLRF   7A
0858:  MOVLW  5B
0859:  MOVWF  44
085A:  MOVF   7A,W
085B:  MOVWF  45
085C:  MOVF   44,W
085D:  MOVWF  04
085E:  BCF    03.7
085F:  BTFSC  45.0
0860:  BSF    03.7
0861:  CLRF   00
....................    FOR (int j = 0; j < 6; j++) 
0862:  CLRF   43
0863:  MOVF   43,W
0864:  SUBLW  05
0865:  BTFSS  03.0
0866:  GOTO   090
....................    { 
....................       ITOA (ID_GATEWAY[j], 10, TEMP_CHAR); 
0867:  MOVLW  42
0868:  ADDWF  43,W
0869:  MOVWF  04
086A:  BCF    03.7
086B:  MOVF   00,W
086C:  MOVWF  44
086D:  CLRF   48
086E:  CLRF   47
086F:  CLRF   46
0870:  MOVF   44,W
0871:  MOVWF  45
0872:  MOVLW  0A
0873:  MOVWF  49
0874:  CLRF   4B
0875:  MOVLW  74
0876:  MOVWF  4A
0877:  BCF    0A.3
0878:  BCF    03.6
0879:  CALL   3DA
087A:  BSF    0A.3
....................       DELAY_MS (1); 
087B:  MOVLW  01
087C:  BSF    03.6
087D:  MOVWF  47
087E:  BCF    0A.3
087F:  BCF    03.6
0880:  CALL   140
0881:  BSF    0A.3
....................       STRCAT (ID_GATEWAY_CHAR, TEMP_CHAR); 
0882:  BSF    03.6
0883:  CLRF   45
0884:  MOVLW  5B
0885:  MOVWF  44
0886:  CLRF   47
0887:  MOVLW  74
0888:  MOVWF  46
0889:  BCF    0A.3
088A:  BCF    03.6
088B:  CALL   72B
088C:  BSF    0A.3
088D:  BSF    03.6
088E:  INCF   43,F
088F:  GOTO   063
....................    }   
.................... } 
....................  
....................  
.................... VOID CONFIG_DONE() 
.................... { 
....................    TT_FUN = 0; 
*
0800:  BCF    53.4
....................    TT_STT = 0; 
0801:  BCF    53.5
....................    CHAR *PACKAGE_CONFIG[]={"*", "LENGHT","C_F", "ID_GW1234" ,"ID_NODE","#"}; 
0802:  MOVLW  2A
0803:  BSF    03.6
0804:  MOVWF  21
0805:  CLRF   22
0806:  MOVLW  4C
0807:  MOVWF  23
0808:  MOVLW  45
0809:  MOVWF  24
080A:  MOVLW  4E
080B:  MOVWF  25
080C:  MOVLW  47
080D:  MOVWF  26
080E:  MOVLW  48
080F:  MOVWF  27
0810:  MOVLW  54
0811:  MOVWF  28
0812:  CLRF   29
0813:  MOVLW  43
0814:  MOVWF  2A
0815:  MOVLW  5F
0816:  MOVWF  2B
0817:  MOVLW  46
0818:  MOVWF  2C
0819:  CLRF   2D
081A:  MOVLW  49
081B:  MOVWF  2E
081C:  MOVLW  44
081D:  MOVWF  2F
081E:  MOVLW  5F
081F:  MOVWF  30
0820:  MOVLW  47
0821:  MOVWF  31
0822:  MOVLW  57
0823:  MOVWF  32
0824:  MOVLW  31
0825:  MOVWF  33
0826:  MOVLW  32
0827:  MOVWF  34
0828:  MOVLW  33
0829:  MOVWF  35
082A:  MOVLW  34
082B:  MOVWF  36
082C:  CLRF   37
082D:  MOVLW  49
082E:  MOVWF  38
082F:  MOVLW  44
0830:  MOVWF  39
0831:  MOVLW  5F
0832:  MOVWF  3A
0833:  MOVLW  4E
0834:  MOVWF  3B
0835:  MOVLW  4F
0836:  MOVWF  3C
0837:  MOVLW  44
0838:  MOVWF  3D
0839:  MOVLW  45
083A:  MOVWF  3E
083B:  CLRF   3F
083C:  MOVLW  23
083D:  MOVWF  40
083E:  CLRF   41
083F:  MOVLW  01
0840:  MOVWF  16
0841:  MOVLW  21
0842:  MOVWF  15
0843:  MOVLW  01
0844:  MOVWF  18
0845:  MOVLW  23
0846:  MOVWF  17
0847:  MOVLW  01
0848:  MOVWF  1A
0849:  MOVLW  2A
084A:  MOVWF  19
084B:  MOVLW  01
084C:  MOVWF  1C
084D:  MOVLW  2E
084E:  MOVWF  1B
084F:  MOVLW  01
0850:  MOVWF  1E
0851:  MOVLW  38
0852:  MOVWF  1D
0853:  MOVLW  01
0854:  MOVWF  20
0855:  MOVLW  40
0856:  MOVWF  1F
....................    XULY_IDGW_NHAP(); 
....................    PACKAGE_CONFIG[3] = ID_GATEWAY_CHAR; 
*
0890:  CLRF   1C
0891:  MOVLW  5B
0892:  MOVWF  1B
....................     
....................     
....................    XULY_IDNODE_NHAP(); 
....................    PACKAGE_CONFIG[4] = ID_NODE_CHAR;     
*
08CC:  CLRF   1E
08CD:  MOVLW  54
08CE:  MOVWF  1D
....................         
....................    LEN_PACKAGES = 0; 
08CF:  BCF    03.6
08D0:  CLRF   4C
....................    PACKAGE_CONFIG[1] = "12"; //DO DAI CUA LENGHT CO DO DAI = 2 
08D1:  MOVLW  31
08D2:  BSF    03.6
08D3:  MOVWF  17
08D4:  MOVLW  32
08D5:  MOVWF  18
....................    FOR (int J = 0; J < 6; J++) 
08D6:  CLRF   42
08D7:  MOVF   42,W
08D8:  SUBLW  05
08D9:  BTFSS  03.0
08DA:  GOTO   0F3
....................    { 
....................       LEN_PACKAGES += strlen(PACKAGE_CONFIG[J]); 
08DB:  BCF    03.0
08DC:  RLF    42,W
08DD:  ADDLW  15
08DE:  MOVWF  04
08DF:  BSF    03.7
08E0:  INCF   04,F
08E1:  MOVF   00,W
08E2:  MOVWF  44
08E3:  DECF   04,F
08E4:  MOVF   00,W
08E5:  MOVWF  43
08E6:  MOVF   44,W
08E7:  MOVWF  46
08E8:  MOVF   43,W
08E9:  MOVWF  45
08EA:  BCF    0A.3
08EB:  BCF    03.6
08EC:  CALL   769
08ED:  BSF    0A.3
08EE:  MOVF   78,W
08EF:  ADDWF  4C,F
08F0:  BSF    03.6
08F1:  INCF   42,F
08F2:  GOTO   0D7
....................    }    
....................    LEN_PACKAGES = LEN_PACKAGES+5; //5 @ 
08F3:  MOVLW  05
08F4:  BCF    03.6
08F5:  ADDWF  4C,F
....................    ITOA (LEN_PACKAGES, 10, TEMP_CHAR); 
08F6:  BSF    03.6
08F7:  CLRF   48
08F8:  CLRF   47
08F9:  CLRF   46
08FA:  BCF    03.6
08FB:  MOVF   4C,W
08FC:  BSF    03.6
08FD:  MOVWF  45
08FE:  MOVLW  0A
08FF:  MOVWF  49
0900:  CLRF   4B
0901:  MOVLW  74
0902:  MOVWF  4A
0903:  BCF    0A.3
0904:  BCF    03.6
0905:  CALL   3DA
0906:  BSF    0A.3
....................    PACKAGE_CONFIG[1] = TEMP_CHAR; 
0907:  BSF    03.6
0908:  CLRF   18
0909:  MOVLW  74
090A:  MOVWF  17
....................     
....................    FOR ( J = 0; J < 6; J++) 
090B:  CLRF   42
090C:  MOVF   42,W
090D:  SUBLW  05
090E:  BTFSS  03.0
090F:  GOTO   12A
....................    { 
....................       PRINTF (PACKAGE_CONFIG[J]); 
0910:  BCF    03.0
0911:  RLF    42,W
0912:  ADDLW  15
0913:  MOVWF  04
0914:  BSF    03.7
0915:  INCF   04,F
0916:  MOVF   00,W
0917:  MOVWF  44
0918:  DECF   04,F
0919:  MOVF   00,W
091A:  MOVWF  43
091B:  MOVWF  04
091C:  BCF    03.7
091D:  BTFSC  44.0
091E:  BSF    03.7
091F:  BCF    0A.3
0920:  BCF    03.6
0921:  CALL   789
0922:  BSF    0A.3
....................       PRINTF ("@"); 
0923:  MOVLW  40
0924:  BTFSS  0C.4
0925:  GOTO   124
0926:  MOVWF  19
0927:  BSF    03.6
0928:  INCF   42,F
0929:  GOTO   10C
....................    } 
....................  
....................  
....................    LCD_GOTOXY (1, 1) ; 
092A:  MOVLW  01
092B:  MOVWF  47
092C:  MOVWF  48
092D:  BCF    0A.3
092E:  BCF    03.6
092F:  CALL   2C0
0930:  BSF    0A.3
....................    DELAY_MS (10); 
0931:  MOVLW  0A
0932:  BSF    03.6
0933:  MOVWF  47
0934:  BCF    0A.3
0935:  BCF    03.6
0936:  CALL   140
0937:  BSF    0A.3
....................    PRINTF (LCD_PUTC, "WAITING ....        ") ; 
0938:  MOVLW  CB
0939:  BSF    03.6
093A:  MOVWF  0D
093B:  MOVLW  00
093C:  MOVWF  0F
093D:  BCF    0A.3
093E:  BCF    03.6
093F:  CALL   30E
0940:  BSF    0A.3
....................    LCD_GOTOXY (1, 2) ; 
0941:  MOVLW  01
0942:  BSF    03.6
0943:  MOVWF  47
0944:  MOVLW  02
0945:  MOVWF  48
0946:  BCF    0A.3
0947:  BCF    03.6
0948:  CALL   2C0
0949:  BSF    0A.3
....................    DELAY_MS (10); 
094A:  MOVLW  0A
094B:  BSF    03.6
094C:  MOVWF  47
094D:  BCF    0A.3
094E:  BCF    03.6
094F:  CALL   140
0950:  BSF    0A.3
....................    PRINTF (LCD_PUTC, "WAITING ....        ") ;    
0951:  MOVLW  D6
0952:  BSF    03.6
0953:  MOVWF  0D
0954:  MOVLW  00
0955:  MOVWF  0F
0956:  BCF    0A.3
0957:  BCF    03.6
0958:  CALL   30E
0959:  BSF    0A.3
....................    TT_CONFIG_DONE = 0; 
095A:  BCF    53.3
095B:  BCF    0A.3
095C:  BSF    0A.4
095D:  GOTO   205 (RETURN)
.................... } 
....................  
....................  
....................  VOID XACNHANCONFIG() 
....................  {    
....................    KYTU=0; 
*
0CA0:  CLRF   3E
....................    OUTPUT_D (0XFF);        
0CA1:  BSF    03.5
0CA2:  CLRF   08
0CA3:  MOVLW  FF
0CA4:  BCF    03.5
0CA5:  MOVWF  08
....................    LCD_GOTOXY (1, 1) ; 
0CA6:  MOVLW  01
0CA7:  BSF    03.6
0CA8:  MOVWF  47
0CA9:  MOVWF  48
0CAA:  BCF    0A.3
0CAB:  BCF    03.6
0CAC:  CALL   2C0
0CAD:  BSF    0A.3
....................    DELAY_MS (10); 
0CAE:  MOVLW  0A
0CAF:  BSF    03.6
0CB0:  MOVWF  47
0CB1:  BCF    0A.3
0CB2:  BCF    03.6
0CB3:  CALL   140
0CB4:  BSF    0A.3
....................    TEMP_CHAR = "_"; 
0CB5:  BSF    03.6
0CB6:  CLRF   1D
0CB7:  CLRF   1E
0CB8:  MOVLW  74
0CB9:  MOVWF  04
0CBA:  BCF    03.7
0CBB:  MOVF   1D,W
0CBC:  ADDWF  04,F
0CBD:  MOVF   1E,W
0CBE:  BCF    0A.3
0CBF:  BCF    03.6
0CC0:  CALL   05E
0CC1:  BSF    0A.3
0CC2:  MOVWF  00
0CC3:  IORLW  00
0CC4:  BTFSC  03.2
0CC5:  GOTO   4CB
0CC6:  BSF    03.6
0CC7:  INCF   1E,F
0CC8:  INCF   1D,F
0CC9:  GOTO   4B8
0CCA:  BCF    03.6
....................    CHAR * TOKEN; 
....................    TOKEN = STRTOK (KYTUCHAR2, TEMP_CHAR);    
0CCB:  BSF    03.6
0CCC:  CLRF   1E
0CCD:  MOVLW  D2
0CCE:  MOVWF  1D
0CCF:  CLRF   20
0CD0:  MOVLW  74
0CD1:  MOVWF  1F
0CD2:  BCF    03.6
0CD3:  CALL   15E
0CD4:  MOVF   79,W
0CD5:  BSF    03.6
0CD6:  MOVWF  1C
0CD7:  MOVF   78,W
0CD8:  MOVWF  1B
....................     WHILE (TOKEN != NULL) 
0CD9:  MOVF   1B,F
0CDA:  BTFSS  03.2
0CDB:  GOTO   4DF
0CDC:  MOVF   1C,F
0CDD:  BTFSC  03.2
0CDE:  GOTO   528
....................     {                 
....................        SWITCH(KYTU) 
0CDF:  BCF    03.6
0CE0:  MOVF   3E,W
0CE1:  BTFSC  03.2
0CE2:  GOTO   4EA
0CE3:  XORLW  01
0CE4:  BTFSC  03.2
0CE5:  GOTO   504
0CE6:  XORLW  03
0CE7:  BTFSC  03.2
0CE8:  GOTO   50E
0CE9:  GOTO   517
....................        { 
....................          CASE 0: 
....................          DELAY_MS (1); 
0CEA:  MOVLW  01
0CEB:  BSF    03.6
0CEC:  MOVWF  47
0CED:  BCF    0A.3
0CEE:  BCF    03.6
0CEF:  CALL   140
0CF0:  BSF    0A.3
....................          PRINTF (LCD_PUTC,TOKEN); 
0CF1:  BSF    03.6
0CF2:  MOVF   1B,W
0CF3:  MOVWF  04
0CF4:  BCF    03.7
0CF5:  BTFSC  1C.0
0CF6:  BSF    03.7
0CF7:  BCF    0A.3
0CF8:  BCF    03.6
0CF9:  CALL   4FA
0CFA:  BSF    0A.3
....................          PRINTF (LCD_PUTC,"            "); 
0CFB:  MOVLW  E1
0CFC:  BSF    03.6
0CFD:  MOVWF  0D
0CFE:  MOVLW  00
0CFF:  MOVWF  0F
0D00:  BCF    0A.3
0D01:  BCF    03.6
0D02:  CALL   30E
0D03:  BSF    0A.3
....................          CASE 1:  
....................          SOLUONGTHIETBI_CONFIG = ATOI(TOKEN); 
0D04:  BSF    03.6
0D05:  MOVF   1C,W
0D06:  MOVWF  1E
0D07:  MOVF   1B,W
0D08:  MOVWF  1D
0D09:  BCF    03.6
0D0A:  CALL   24F
0D0B:  MOVF   78,W
0D0C:  MOVWF  4F
....................          BREAK;                      
0D0D:  GOTO   517
....................          CASE 2: 
....................          SOLUONGCAMBIEN_CONFIG = ATOI(TOKEN); 
0D0E:  BSF    03.6
0D0F:  MOVF   1C,W
0D10:  MOVWF  1E
0D11:  MOVF   1B,W
0D12:  MOVWF  1D
0D13:  BCF    03.6
0D14:  CALL   24F
0D15:  MOVF   78,W
0D16:  MOVWF  50
....................          BREAK;               
....................        }  
....................       TOKEN = STRTOK(NULL, TEMP_CHAR); 
0D17:  BSF    03.6
0D18:  CLRF   1E
0D19:  CLRF   1D
0D1A:  CLRF   20
0D1B:  MOVLW  74
0D1C:  MOVWF  1F
0D1D:  BCF    03.6
0D1E:  CALL   15E
0D1F:  MOVF   79,W
0D20:  BSF    03.6
0D21:  MOVWF  1C
0D22:  MOVF   78,W
0D23:  MOVWF  1B
....................       KYTU++;         
0D24:  BCF    03.6
0D25:  INCF   3E,F
0D26:  BSF    03.6
0D27:  GOTO   4D9
....................     }           
....................    DELAY_MS(500); 
0D28:  MOVLW  02
0D29:  MOVWF  1D
0D2A:  MOVLW  FA
0D2B:  MOVWF  47
0D2C:  BCF    0A.3
0D2D:  BCF    03.6
0D2E:  CALL   140
0D2F:  BSF    0A.3
0D30:  BSF    03.6
0D31:  DECFSZ 1D,F
0D32:  GOTO   52A
....................    DELAY_MS (1);  
0D33:  MOVLW  01
0D34:  MOVWF  47
0D35:  BCF    0A.3
0D36:  BCF    03.6
0D37:  CALL   140
0D38:  BSF    0A.3
....................    OUTPUT_D (0XFF);      
0D39:  BSF    03.5
0D3A:  CLRF   08
0D3B:  MOVLW  FF
0D3C:  BCF    03.5
0D3D:  MOVWF  08
....................    LCD_GOTOXY (1, 2) ; 
0D3E:  MOVLW  01
0D3F:  BSF    03.6
0D40:  MOVWF  47
0D41:  MOVLW  02
0D42:  MOVWF  48
0D43:  BCF    0A.3
0D44:  BCF    03.6
0D45:  CALL   2C0
0D46:  BSF    0A.3
....................    DELAY_MS (10); 
0D47:  MOVLW  0A
0D48:  BSF    03.6
0D49:  MOVWF  47
0D4A:  BCF    0A.3
0D4B:  BCF    03.6
0D4C:  CALL   140
0D4D:  BSF    0A.3
....................    PRINTF (LCD_PUTC,"TB: ");    
0D4E:  MOVLW  E8
0D4F:  BSF    03.6
0D50:  MOVWF  0D
0D51:  MOVLW  00
0D52:  MOVWF  0F
0D53:  BCF    0A.3
0D54:  BCF    03.6
0D55:  CALL   30E
0D56:  BSF    0A.3
....................    ITOA (SOLUONGTHIETBI_CONFIG, 10, TEMP_CHAR);    
0D57:  BSF    03.6
0D58:  CLRF   48
0D59:  CLRF   47
0D5A:  CLRF   46
0D5B:  BCF    03.6
0D5C:  MOVF   4F,W
0D5D:  BSF    03.6
0D5E:  MOVWF  45
0D5F:  MOVLW  0A
0D60:  MOVWF  49
0D61:  CLRF   4B
0D62:  MOVLW  74
0D63:  MOVWF  4A
0D64:  BCF    0A.3
0D65:  BCF    03.6
0D66:  CALL   3DA
0D67:  BSF    0A.3
....................    PRINTF (LCD_PUTC,TEMP_CHAR);    
0D68:  MOVLW  74
0D69:  MOVWF  04
0D6A:  BCF    03.7
0D6B:  BCF    0A.3
0D6C:  CALL   4FA
0D6D:  BSF    0A.3
....................    PRINTF (LCD_PUTC,"    CB:");    
0D6E:  MOVLW  EB
0D6F:  BSF    03.6
0D70:  MOVWF  0D
0D71:  MOVLW  00
0D72:  MOVWF  0F
0D73:  BCF    0A.3
0D74:  BCF    03.6
0D75:  CALL   30E
0D76:  BSF    0A.3
....................    ITOA (SOLUONGCAMBIEN_CONFIG, 10, TEMP_CHAR);    
0D77:  BSF    03.6
0D78:  CLRF   48
0D79:  CLRF   47
0D7A:  CLRF   46
0D7B:  BCF    03.6
0D7C:  MOVF   50,W
0D7D:  BSF    03.6
0D7E:  MOVWF  45
0D7F:  MOVLW  0A
0D80:  MOVWF  49
0D81:  CLRF   4B
0D82:  MOVLW  74
0D83:  MOVWF  4A
0D84:  BCF    0A.3
0D85:  BCF    03.6
0D86:  CALL   3DA
0D87:  BSF    0A.3
....................    PRINTF (LCD_PUTC,TEMP_CHAR);       
0D88:  MOVLW  74
0D89:  MOVWF  04
0D8A:  BCF    03.7
0D8B:  BCF    0A.3
0D8C:  CALL   4FA
0D8D:  BSF    0A.3
....................    OUTPUT_D (0X00); 
0D8E:  BSF    03.5
0D8F:  CLRF   08
0D90:  BCF    03.5
0D91:  CLRF   08
....................    DELAY_MS(500); 
0D92:  MOVLW  02
0D93:  BSF    03.6
0D94:  MOVWF  1D
0D95:  MOVLW  FA
0D96:  MOVWF  47
0D97:  BCF    0A.3
0D98:  BCF    03.6
0D99:  CALL   140
0D9A:  BSF    0A.3
0D9B:  BSF    03.6
0D9C:  DECFSZ 1D,F
0D9D:  GOTO   595
....................    OUTPUT_D (0XFF);     
0D9E:  BSF    03.5
0D9F:  BCF    03.6
0DA0:  CLRF   08
0DA1:  MOVLW  FF
0DA2:  BCF    03.5
0DA3:  MOVWF  08
....................    DELAY_MS(500); 
0DA4:  MOVLW  02
0DA5:  BSF    03.6
0DA6:  MOVWF  1D
0DA7:  MOVLW  FA
0DA8:  MOVWF  47
0DA9:  BCF    0A.3
0DAA:  BCF    03.6
0DAB:  CALL   140
0DAC:  BSF    0A.3
0DAD:  BSF    03.6
0DAE:  DECFSZ 1D,F
0DAF:  GOTO   5A7
....................    OUTPUT_D (0X00); 
0DB0:  BSF    03.5
0DB1:  BCF    03.6
0DB2:  CLRF   08
0DB3:  BCF    03.5
0DB4:  CLRF   08
....................    TT_CONFIG_OKE_UART = 1; 
0DB5:  BSF    53.6
....................     
....................  }  
.................... //--------------------------------------------------------------------// 
....................  
....................  
....................  
....................  
....................  
.................... VOID QUET_PHIM() 
*
00EF:  BSF    03.6
00F0:  CLRF   6A
.................... { 
....................    INT BDT = 0; 
....................  
....................    WHILE (!INPUT (BT1_PIN)) //NEU NUT BAM DUOC BAM 
00F1:  BSF    03.5
00F2:  BCF    03.6
00F3:  BSF    06.1
00F4:  BCF    03.5
00F5:  BTFSC  06.1
00F6:  GOTO   10A
....................    { 
....................       IF (TMR1IF) 
00F7:  BTFSS  0C.0
00F8:  GOTO   107
....................       { 
....................          OUTPUT_TOGGLE (PIN_D7); 
00F9:  BSF    03.5
00FA:  BCF    08.7
00FB:  MOVLW  80
00FC:  BCF    03.5
00FD:  XORWF  08,F
....................          TMR1IF = 0; SET_TIMER1 (3036); BDT++; 
00FE:  BCF    0C.0
00FF:  CLRF   0E
0100:  MOVLW  0B
0101:  MOVWF  0F
0102:  MOVLW  DC
0103:  MOVWF  0E
0104:  BSF    03.6
0105:  INCF   6A,F
0106:  BCF    03.6
....................       } 
0107:  BSF    03.6
0108:  GOTO   0F1
0109:  BCF    03.6
....................    } 
....................  
....................    IF (BDT > 20) 
010A:  BSF    03.6
010B:  MOVF   6A,W
010C:  SUBLW  14
010D:  BTFSC  03.0
010E:  GOTO   118
....................    { 
....................       //CONFIG NODE 
....................       TT_CONFIG = ~TT_CONFIG; // VAO TRANG THAI CONFIG 
010F:  MOVLW  02
0110:  BCF    03.6
0111:  XORWF  53,F
....................       TT_CONTROL = ~TT_CONTROL; 
0112:  MOVLW  04
0113:  XORWF  53,F
....................       //CONFIG_DONE (); 
....................       TT_CONFIG_DONE = 1; 
0114:  BSF    53.3
....................       TT_FUN = 0; 
0115:  BCF    53.4
....................    } 
0116:  GOTO   11C
0117:  BSF    03.6
....................  
....................    ELSE 
....................    { 
....................       BUTT_OKE (); //OKE 
....................    } 
.................... } 
....................  
.................... #INT_EXT 
....................  
....................  VOID NGAT_NGOAI () 
....................  { 
....................     QUET_PHIM (); 
....................  } 
....................  
*
011C:  BCF    0B.1
011D:  BCF    0A.3
011E:  BCF    0A.4
011F:  GOTO   031
....................  #INT_RDA 
....................  VOID NGAT () 
....................  { 
....................     KYTUCHAR[VT] = GETCH (); 
0120:  MOVLW  A0
0121:  ADDWF  3D,W
0122:  MOVWF  04
0123:  BCF    03.7
0124:  BTFSS  0C.5
0125:  GOTO   124
0126:  MOVF   1A,W
0127:  MOVWF  00
....................  
....................     IF (KYTUCHAR[VT] == '.') 
0128:  MOVLW  A0
0129:  ADDWF  3D,W
012A:  MOVWF  04
012B:  BCF    03.7
012C:  MOVF   00,W
012D:  SUBLW  2E
012E:  BTFSS  03.2
012F:  GOTO   138
....................     { 
....................        KYTUCHAR[VT] = '\0'; 
0130:  MOVLW  A0
0131:  ADDWF  3D,W
0132:  MOVWF  04
0133:  BCF    03.7
0134:  CLRF   00
....................        VT = 0; 
0135:  CLRF   3D
....................        TTNHAN = 1; 
0136:  BSF    53.0
....................     } 
0137:  GOTO   139
....................     ELSE 
....................     VT++; 
0138:  INCF   3D,F
0139:  BCF    0C.5
013A:  BCF    0A.3
013B:  BCF    0A.4
013C:  GOTO   031
....................  } 
....................   INT ADC_READ (INT KENH) 
....................  { 
....................     UNSIGNED INT8 ANALOG_PORT[] = {1,2,4,8,16,32,64};  
*
0E10:  MOVLW  01
0E11:  MOVWF  19
0E12:  MOVLW  02
0E13:  MOVWF  1A
0E14:  MOVLW  04
0E15:  MOVWF  1B
0E16:  MOVLW  08
0E17:  MOVWF  1C
0E18:  MOVLW  10
0E19:  MOVWF  1D
0E1A:  MOVLW  20
0E1B:  MOVWF  1E
0E1C:  MOVLW  40
0E1D:  MOVWF  1F
....................     SETUP_ADC_PORTS (ANALOG_PORT[KENH]); 
0E1E:  MOVLW  19
0E1F:  ADDWF  18,W
0E20:  MOVWF  04
0E21:  BSF    03.7
0E22:  MOVF   00,W
0E23:  MOVWF  21
0E24:  MOVWF  22
0E25:  CLRF   23
0E26:  CLRF   24
0E27:  CLRF   25
0E28:  MOVLW  89
0E29:  MOVWF  04
0E2A:  BSF    03.7
0E2B:  MOVLW  C0
0E2C:  ANDWF  00,F
0E2D:  MOVF   24,W
0E2E:  IORWF  00,F
0E2F:  MOVLW  9F
0E30:  MOVWF  04
0E31:  BCF    03.7
0E32:  MOVLW  CF
0E33:  ANDWF  00,F
0E34:  MOVF   23,W
0E35:  IORWF  00,F
0E36:  MOVLW  88
0E37:  MOVWF  04
0E38:  BSF    03.7
0E39:  MOVF   22,W
0E3A:  MOVWF  00
....................     DELAY_MS(3); 
0E3B:  MOVLW  03
0E3C:  MOVWF  47
0E3D:  BCF    0A.3
0E3E:  BCF    03.6
0E3F:  CALL   140
0E40:  BSF    0A.3
....................     SET_ADC_CHANNEL (KENH); 
0E41:  BSF    03.6
0E42:  RLF    18,W
0E43:  MOVWF  77
0E44:  RLF    77,F
0E45:  MOVLW  FC
0E46:  ANDWF  77,F
0E47:  BCF    03.6
0E48:  MOVF   1F,W
0E49:  ANDLW  C3
0E4A:  IORWF  77,W
0E4B:  MOVWF  1F
....................     DELAY_MS(3); 
0E4C:  MOVLW  03
0E4D:  BSF    03.6
0E4E:  MOVWF  47
0E4F:  BCF    0A.3
0E50:  BCF    03.6
0E51:  CALL   140
0E52:  BSF    0A.3
....................     KQADC = 0; 
0E53:  CLRF   33
0E54:  CLRF   32
....................     FOR (INT I = 0; I < 100; I++) 
0E55:  BSF    03.6
0E56:  CLRF   20
0E57:  MOVF   20,W
0E58:  SUBLW  63
0E59:  BTFSS  03.0
0E5A:  GOTO   671
....................     { 
....................        KQADC = KQADC + READ_ADC () ; 
0E5B:  BCF    03.6
0E5C:  BSF    1F.1
0E5D:  BTFSC  1F.1
0E5E:  GOTO   65D
0E5F:  BSF    03.5
0E60:  MOVF   1E,W
0E61:  BCF    03.5
0E62:  ADDWF  32,F
0E63:  MOVF   1E,W
0E64:  BTFSC  03.0
0E65:  INCFSZ 1E,W
0E66:  ADDWF  33,F
....................        DELAY_MS (1); 
0E67:  MOVLW  01
0E68:  BSF    03.6
0E69:  MOVWF  47
0E6A:  BCF    0A.3
0E6B:  BCF    03.6
0E6C:  CALL   140
0E6D:  BSF    0A.3
0E6E:  BSF    03.6
0E6F:  INCF   20,F
0E70:  GOTO   657
....................     } 
....................  
....................     KQADC = KQADC / (100 * 2.046); 
0E71:  BCF    03.6
0E72:  MOVF   33,W
0E73:  BSF    03.6
0E74:  MOVWF  22
0E75:  BCF    03.6
0E76:  MOVF   32,W
0E77:  BSF    03.6
0E78:  MOVWF  21
*
0E95:  MOVF   7A,W
0E96:  MOVWF  24
0E97:  MOVF   79,W
0E98:  MOVWF  23
0E99:  MOVF   78,W
0E9A:  MOVWF  22
0E9B:  MOVF   77,W
0E9C:  MOVWF  21
0E9D:  MOVLW  9A
0E9E:  MOVWF  28
0E9F:  MOVLW  99
0EA0:  MOVWF  27
0EA1:  MOVLW  4C
0EA2:  MOVWF  26
0EA3:  MOVLW  86
0EA4:  MOVWF  25
*
0F6E:  MOVF   7A,W
0F6F:  MOVWF  24
0F70:  MOVF   79,W
0F71:  MOVWF  23
0F72:  MOVF   78,W
0F73:  MOVWF  22
0F74:  MOVF   77,W
0F75:  MOVWF  21
*
0F94:  MOVF   79,W
0F95:  BCF    03.6
0F96:  MOVWF  33
0F97:  MOVF   78,W
0F98:  MOVWF  32
....................     RETURN KQADC; 
0F99:  MOVF   32,W
0F9A:  MOVWF  78
....................  } 
....................  
....................  
....................  VOID READ_ANALOG ( ) 
....................  { 
....................    FOR(INT K = 0; K<SOLUONGCAMBIEN_CONFIG; K++){ 
*
0DFC:  BSF    03.6
0DFD:  CLRF   15
0DFE:  BCF    03.6
0DFF:  MOVF   50,W
0E00:  BSF    03.6
0E01:  SUBWF  15,W
0E02:  BTFSC  03.0
0E03:  GOTO   7A5
....................       KET_QUA_ANALOG[K] = ADC_READ (K);   
0E04:  MOVLW  38
0E05:  ADDWF  15,W
0E06:  MOVWF  78
0E07:  CLRF   7A
0E08:  BTFSC  03.0
0E09:  INCF   7A,F
0E0A:  MOVF   78,W
0E0B:  MOVWF  16
0E0C:  MOVF   7A,W
0E0D:  MOVWF  17
0E0E:  MOVF   15,W
0E0F:  MOVWF  18
*
0F9B:  BSF    03.6
0F9C:  MOVF   16,W
0F9D:  MOVWF  04
0F9E:  BCF    03.7
0F9F:  BTFSC  17.0
0FA0:  BSF    03.7
0FA1:  MOVF   78,W
0FA2:  MOVWF  00
0FA3:  INCF   15,F
0FA4:  GOTO   5FE
....................    } 
0FA5:  BCF    03.6
0FA6:  BCF    0A.3
0FA7:  BSF    0A.4
0FA8:  GOTO   21A (RETURN)
....................  } 
....................  
....................  VOID SEND_ANALOG_UART() 
....................  { 
....................    OUTPUT_TOGGLE(PIN_D6); 
*
1000:  BSF    03.5
1001:  BCF    08.6
1002:  MOVLW  40
1003:  BCF    03.5
1004:  XORWF  08,F
....................    //CHAR *PACKAGE_SS[]={"*", "26","SS", "IDGW12" ,"NODE","ZZ","AA","VV","CC","SS"}; 
....................    CHAR *PACKAGE_SS[]={"IDGW12" ,"NODE","ZZ","AA","VV","CC","SS"};    
1005:  MOVLW  49
1006:  BSF    03.6
1007:  MOVWF  23
1008:  MOVLW  44
1009:  MOVWF  24
100A:  MOVLW  47
100B:  MOVWF  25
100C:  MOVLW  57
100D:  MOVWF  26
100E:  MOVLW  31
100F:  MOVWF  27
1010:  MOVLW  32
1011:  MOVWF  28
1012:  CLRF   29
1013:  MOVLW  4E
1014:  MOVWF  2A
1015:  MOVLW  4F
1016:  MOVWF  2B
1017:  MOVLW  44
1018:  MOVWF  2C
1019:  MOVLW  45
101A:  MOVWF  2D
101B:  CLRF   2E
101C:  MOVLW  5A
101D:  MOVWF  2F
101E:  MOVWF  30
101F:  CLRF   31
1020:  MOVLW  41
1021:  MOVWF  32
1022:  MOVWF  33
1023:  CLRF   34
1024:  MOVLW  56
1025:  MOVWF  35
1026:  MOVWF  36
1027:  CLRF   37
1028:  MOVLW  43
1029:  MOVWF  38
102A:  MOVWF  39
102B:  CLRF   3A
102C:  MOVLW  53
102D:  MOVWF  3B
102E:  MOVWF  3C
102F:  CLRF   3D
1030:  MOVLW  01
1031:  MOVWF  16
1032:  MOVLW  23
1033:  MOVWF  15
1034:  MOVLW  01
1035:  MOVWF  18
1036:  MOVLW  2A
1037:  MOVWF  17
1038:  MOVLW  01
1039:  MOVWF  1A
103A:  MOVLW  2F
103B:  MOVWF  19
103C:  MOVLW  01
103D:  MOVWF  1C
103E:  MOVLW  32
103F:  MOVWF  1B
1040:  MOVLW  01
1041:  MOVWF  1E
1042:  MOVLW  35
1043:  MOVWF  1D
1044:  MOVLW  01
1045:  MOVWF  20
1046:  MOVLW  38
1047:  MOVWF  1F
1048:  MOVLW  01
1049:  MOVWF  22
104A:  MOVLW  3B
104B:  MOVWF  21
....................    PACKAGE_SS[0] = ID_GATEWAY_CHAR; 
104C:  CLRF   16
104D:  MOVLW  5B
104E:  MOVWF  15
....................    PACKAGE_SS[1] = ID_NODE_CHAR; 
104F:  CLRF   18
1050:  MOVLW  54
1051:  MOVWF  17
....................    UNSIGNED INT8 DO_DAI =20; 
1052:  MOVLW  14
1053:  MOVWF  3E
....................     
....................    FOR(INT I = 0; I<SOLUONGCAMBIEN_CONFIG; I++) 
1054:  CLRF   3F
1055:  BCF    03.6
1056:  MOVF   50,W
1057:  BSF    03.6
1058:  SUBWF  3F,W
1059:  BTFSC  03.0
105A:  GOTO   084
....................    { 
....................       ITOA(KET_QUA_ANALOG[I],10,PACKAGE_SS[2+I]); 
105B:  MOVLW  38
105C:  ADDWF  3F,W
105D:  MOVWF  04
105E:  BCF    03.7
105F:  MOVF   00,W
1060:  MOVWF  40
1061:  MOVLW  02
1062:  ADDWF  3F,W
1063:  MOVWF  77
1064:  BCF    03.0
1065:  RLF    77,F
1066:  MOVF   77,W
1067:  ADDLW  15
1068:  MOVWF  04
1069:  BSF    03.7
106A:  INCF   04,F
106B:  MOVF   00,W
106C:  MOVWF  42
106D:  DECF   04,F
106E:  MOVF   00,W
106F:  MOVWF  41
1070:  CLRF   48
1071:  CLRF   47
1072:  CLRF   46
1073:  MOVF   40,W
1074:  MOVWF  45
1075:  MOVLW  0A
1076:  MOVWF  49
1077:  MOVF   42,W
1078:  MOVWF  4B
1079:  MOVF   41,W
107A:  MOVWF  4A
107B:  BCF    0A.4
107C:  BCF    03.6
107D:  CALL   3DA
107E:  BSF    0A.4
....................       DO_DAI = DO_DAI + 3; 
107F:  MOVLW  03
1080:  BSF    03.6
1081:  ADDWF  3E,F
1082:  INCF   3F,F
1083:  GOTO   055
....................    }       
....................    ITOA(DO_DAI,10,TEMP_CHAR2); 
1084:  CLRF   48
1085:  CLRF   47
1086:  CLRF   46
1087:  MOVF   3E,W
1088:  MOVWF  45
1089:  MOVLW  0A
108A:  MOVWF  49
108B:  CLRF   4B
108C:  MOVLW  7B
108D:  MOVWF  4A
108E:  BCF    0A.4
108F:  BCF    03.6
1090:  CALL   3DA
1091:  BSF    0A.4
....................    PRINTF ("*@");    
1092:  MOVLW  2A
1093:  BTFSS  0C.4
1094:  GOTO   093
1095:  MOVWF  19
1096:  MOVLW  40
1097:  BTFSS  0C.4
1098:  GOTO   097
1099:  MOVWF  19
....................    PRINTF (TEMP_CHAR2); 
109A:  MOVLW  7B
109B:  MOVWF  04
109C:  BCF    03.7
109D:  BCF    0A.4
109E:  CALL   789
109F:  BSF    0A.4
....................    PRINTF ("@SS@");    
10A0:  MOVLW  3D
10A1:  BSF    03.6
10A2:  MOVWF  0D
10A3:  MOVLW  01
10A4:  MOVWF  0F
....................    FOR ( I = 0; I < 2 + SOLUONGCAMBIEN_CONFIG; I++) 
*
10F4:  CLRF   3F
10F5:  MOVLW  02
10F6:  BCF    03.6
10F7:  ADDWF  50,W
10F8:  BSF    03.6
10F9:  SUBWF  3F,W
10FA:  BTFSC  03.0
10FB:  GOTO   116
....................    { 
....................       PRINTF (PACKAGE_SS[I]); 
10FC:  BCF    03.0
10FD:  RLF    3F,W
10FE:  ADDLW  15
10FF:  MOVWF  04
1100:  BSF    03.7
1101:  INCF   04,F
1102:  MOVF   00,W
1103:  MOVWF  41
1104:  DECF   04,F
1105:  MOVF   00,W
1106:  MOVWF  40
1107:  MOVWF  04
1108:  BCF    03.7
1109:  BTFSC  41.0
110A:  BSF    03.7
110B:  BCF    0A.4
110C:  BCF    03.6
110D:  CALL   789
110E:  BSF    0A.4
....................       PRINTF ("@"); 
110F:  MOVLW  40
1110:  BTFSS  0C.4
1111:  GOTO   110
1112:  MOVWF  19
1113:  BSF    03.6
1114:  INCF   3F,F
1115:  GOTO   0F5
....................    } 
....................    PRINTF ("#"); 
1116:  MOVLW  23
1117:  BCF    03.6
1118:  BTFSS  0C.4
1119:  GOTO   118
111A:  MOVWF  19
....................    OUTPUT_TOGGLE(PIN_D6); 
111B:  BSF    03.5
111C:  BCF    08.6
111D:  MOVLW  40
111E:  BCF    03.5
111F:  XORWF  08,F
1120:  BCF    0A.3
1121:  BSF    0A.4
1122:  GOTO   22E (RETURN)
....................     
....................  } 
....................  VOID DIEUKHIENTHIETBI() 
....................  { 
....................    LENH_DIEU_KHIEN = 0;   
*
0DB7:  CLRF   41
....................    LENH_DIEU_KHIEN = ATOI(KYTUCHAR2); 
0DB8:  BSF    03.6
0DB9:  CLRF   1E
0DBA:  MOVLW  D2
0DBB:  MOVWF  1D
0DBC:  BCF    03.6
0DBD:  CALL   24F
0DBE:  MOVF   78,W
0DBF:  MOVWF  41
....................    XUATTRANGTHAI(LENH_DIEU_KHIEN); 
0DC0:  MOVF   41,W
0DC1:  BSF    03.6
0DC2:  MOVWF  1B
....................  } 
....................  
....................  VOID XU_LY_UART() 
*
0B97:  MOVLW  2A
0B98:  BSF    03.6
0B99:  MOVWF  15
....................  { 
....................      //ID_NODE_NHAN = KYTU[1] - 48; 
....................     //ID_DEVICE_NHAN = KYTU[2] - 48 + 64; 
....................     //TT_DEVICE_NHAN = KYTU[3] - 48; // - 48 ASCII -- > S?. + 64 -- > PORT_D (D0 = 64)                
....................  
....................     /*TINH DO DAI*/ 
....................     CHAR CH = '*'; 
....................     CHAR *RET; 
....................     *ID_NODE_NHAN = '\0'; 
0B9A:  CLRF   7A
0B9B:  MOVLW  64
0B9C:  MOVWF  04
0B9D:  BCF    03.7
0B9E:  BTFSC  7A.0
0B9F:  BSF    03.7
0BA0:  CLRF   00
....................     *ID_GW_NHAN = '\0'; 
0BA1:  CLRF   7A
0BA2:  MOVLW  6B
0BA3:  MOVWF  04
0BA4:  BCF    03.7
0BA5:  BTFSC  7A.0
0BA6:  BSF    03.7
0BA7:  CLRF   00
....................     KYTUCHAR2 = ""; 
0BA8:  CLRF   1B
0BA9:  CLRF   1C
0BAA:  MOVLW  D2
0BAB:  MOVWF  04
0BAC:  BCF    03.7
0BAD:  MOVF   1B,W
0BAE:  ADDWF  04,F
0BAF:  MOVF   1C,W
0BB0:  BCF    0A.3
0BB1:  BCF    03.6
0BB2:  CALL   06A
0BB3:  BSF    0A.3
0BB4:  MOVWF  00
0BB5:  IORLW  00
0BB6:  BTFSC  03.2
0BB7:  GOTO   3BD
0BB8:  BSF    03.6
0BB9:  INCF   1C,F
0BBA:  INCF   1B,F
0BBB:  GOTO   3AA
0BBC:  BCF    03.6
....................     UNSIGNED INT8 LEN_RET;     
....................     RET = STRCHR(KYTUCHAR,CH); 
0BBD:  BSF    03.6
0BBE:  CLRF   1C
0BBF:  MOVLW  A0
0BC0:  MOVWF  1B
0BC1:  MOVF   15,W
0BC2:  MOVWF  1D
*
0BE4:  MOVF   79,W
0BE5:  MOVWF  17
0BE6:  MOVF   78,W
0BE7:  MOVWF  16
....................     LEN_RET = STRLEN(RET);  
0BE8:  MOVF   17,W
0BE9:  MOVWF  46
0BEA:  MOVF   16,W
0BEB:  MOVWF  45
0BEC:  BCF    0A.3
0BED:  BCF    03.6
0BEE:  CALL   769
0BEF:  BSF    0A.3
0BF0:  MOVF   78,W
0BF1:  BSF    03.6
0BF2:  MOVWF  18
....................     /* LAY TOKEN DAU TIEN */     
....................     KYTU = 0; 
0BF3:  BCF    03.6
0BF4:  CLRF   3E
....................     TEMP_CHAR = "#"; 
0BF5:  BSF    03.6
0BF6:  CLRF   1B
0BF7:  CLRF   1C
0BF8:  MOVLW  74
0BF9:  MOVWF  04
0BFA:  BCF    03.7
0BFB:  MOVF   1B,W
0BFC:  ADDWF  04,F
0BFD:  MOVF   1C,W
0BFE:  BCF    0A.3
0BFF:  BCF    03.6
0C00:  CALL   064
0C01:  BSF    0A.3
0C02:  MOVWF  00
0C03:  IORLW  00
0C04:  BTFSC  03.2
0C05:  GOTO   40B
0C06:  BSF    03.6
0C07:  INCF   1C,F
0C08:  INCF   1B,F
0C09:  GOTO   3F8
0C0A:  BCF    03.6
....................     CHAR * TOKEN; 
....................     TOKEN = STRTOK (KYTUCHAR, TEMP_CHAR);                 
0C0B:  BSF    03.6
0C0C:  CLRF   1E
0C0D:  MOVLW  A0
0C0E:  MOVWF  1D
0C0F:  CLRF   20
0C10:  MOVLW  74
0C11:  MOVWF  1F
0C12:  BCF    03.6
0C13:  CALL   15E
0C14:  MOVF   79,W
0C15:  BSF    03.6
0C16:  MOVWF  1A
0C17:  MOVF   78,W
0C18:  MOVWF  19
....................     /* DUYET QUA CAC TOKEN CON LAI */                 
....................     WHILE (TOKEN != NULL) 
0C19:  MOVF   19,F
0C1A:  BTFSS  03.2
0C1B:  GOTO   41F
0C1C:  MOVF   1A,F
0C1D:  BTFSC  03.2
0C1E:  GOTO   472
....................     {                 
....................        SWITCH(KYTU) 
0C1F:  BCF    03.6
0C20:  MOVF   3E,W
0C21:  ADDLW  FA
0C22:  BTFSC  03.0
0C23:  GOTO   461
0C24:  ADDLW  06
0C25:  GOTO   5F2
....................        { 
....................          CASE 0: 
....................          BREAK; 
0C26:  GOTO   461
....................          CASE 1:  
....................          STRCAT (ID_GW_NHAN, TOKEN); 
0C27:  BSF    03.6
0C28:  CLRF   45
0C29:  MOVLW  6B
0C2A:  MOVWF  44
0C2B:  MOVF   1A,W
0C2C:  MOVWF  47
0C2D:  MOVF   19,W
0C2E:  MOVWF  46
0C2F:  BCF    0A.3
0C30:  BCF    03.6
0C31:  CALL   72B
0C32:  BSF    0A.3
....................          BREAK;                      
0C33:  GOTO   461
....................          CASE 2: 
....................          STRCAT (ID_NODE_NHAN, TOKEN); 
0C34:  BSF    03.6
0C35:  CLRF   45
0C36:  MOVLW  64
0C37:  MOVWF  44
0C38:  MOVF   1A,W
0C39:  MOVWF  47
0C3A:  MOVF   19,W
0C3B:  MOVWF  46
0C3C:  BCF    0A.3
0C3D:  BCF    03.6
0C3E:  CALL   72B
0C3F:  BSF    0A.3
....................          BREAK;       
0C40:  GOTO   461
....................          CASE 3: 
....................          LENHDIEUKHIEN =  ATOI(TOKEN);                  
0C41:  BSF    03.6
0C42:  MOVF   1A,W
0C43:  MOVWF  1E
0C44:  MOVF   19,W
0C45:  MOVWF  1D
0C46:  BCF    03.6
0C47:  CALL   24F
0C48:  MOVF   78,W
0C49:  MOVWF  4D
....................          BREAK;     
0C4A:  GOTO   461
....................          CASE 4: 
....................          DODAI_DATA_NHAN =  ATOI(TOKEN);                  
0C4B:  BSF    03.6
0C4C:  MOVF   1A,W
0C4D:  MOVWF  1E
0C4E:  MOVF   19,W
0C4F:  MOVWF  1D
0C50:  BCF    03.6
0C51:  CALL   24F
0C52:  MOVF   78,W
0C53:  MOVWF  4E
....................          BREAK;   
0C54:  GOTO   461
....................          CASE 5:   
....................          STRCAT (KYTUCHAR2, TOKEN); 
0C55:  BSF    03.6
0C56:  CLRF   45
0C57:  MOVLW  D2
0C58:  MOVWF  44
0C59:  MOVF   1A,W
0C5A:  MOVWF  47
0C5B:  MOVF   19,W
0C5C:  MOVWF  46
0C5D:  BCF    0A.3
0C5E:  BCF    03.6
0C5F:  CALL   72B
0C60:  BSF    0A.3
....................          BREAK;          
....................        }          
....................       TOKEN = STRTOK(NULL, TEMP_CHAR); 
0C61:  BSF    03.6
0C62:  CLRF   1E
0C63:  CLRF   1D
0C64:  CLRF   20
0C65:  MOVLW  74
0C66:  MOVWF  1F
0C67:  BCF    03.6
0C68:  CALL   15E
0C69:  MOVF   79,W
0C6A:  BSF    03.6
0C6B:  MOVWF  1A
0C6C:  MOVF   78,W
0C6D:  MOVWF  19
....................       KYTU++;         
0C6E:  BCF    03.6
0C6F:  INCF   3E,F
0C70:  BSF    03.6
0C71:  GOTO   419
....................     }               
....................       /* SO SANH ID returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................       SOSANH_IDGW = STRCMP(ID_GW_NHAN,ID_GATEWAY_CHAR);       
0C72:  CLRF   1C
0C73:  MOVLW  6B
0C74:  MOVWF  1B
0C75:  CLRF   1E
0C76:  MOVLW  5B
0C77:  MOVWF  1D
0C78:  BCF    03.6
0C79:  CALL   351
0C7A:  MOVF   78,W
0C7B:  MOVWF  52
....................       SOSANH_IDNODE = STRCMP(ID_NODE_NHAN,ID_NODE_CHAR);     
0C7C:  BSF    03.6
0C7D:  CLRF   1C
0C7E:  MOVLW  64
0C7F:  MOVWF  1B
0C80:  CLRF   1E
0C81:  MOVLW  54
0C82:  MOVWF  1D
0C83:  BCF    03.6
0C84:  CALL   351
0C85:  MOVF   78,W
0C86:  MOVWF  51
....................        
....................     IF ( SOSANH_IDGW == 0 && SOSANH_IDNODE == 0 && LEN_RET == DODAI_DATA_NHAN) 
0C87:  MOVF   52,F
0C88:  BTFSS  03.2
0C89:  GOTO   5E8
0C8A:  MOVF   51,F
0C8B:  BTFSS  03.2
0C8C:  GOTO   5E8
0C8D:  MOVF   4E,W
0C8E:  BSF    03.6
0C8F:  SUBWF  18,W
0C90:  BTFSC  03.2
0C91:  GOTO   494
0C92:  BCF    03.6
0C93:  GOTO   5E8
....................     {                       
....................       SWITCH(LENHDIEUKHIEN) 
0C94:  BCF    03.6
0C95:  MOVF   4D,W
0C96:  BTFSC  03.2
0C97:  GOTO   49F
0C98:  XORLW  01
0C99:  BTFSC  03.2
0C9A:  GOTO   4A0
0C9B:  XORLW  03
0C9C:  BTFSC  03.2
0C9D:  GOTO   5B7
0C9E:  GOTO   5E7
....................        { 
....................          CASE 0: 
....................          BREAK; 
0C9F:  GOTO   5E7
....................          CASE 1: 
....................          XACNHANCONFIG(); 
....................          BREAK;                      
*
0DB6:  GOTO   5E7
....................          CASE 2: 
....................          DIEUKHIENTHIETBI(); 
....................          BREAK;               
....................        }  
....................     } 
*
0DE7:  GOTO   5EF
....................     ELSE{ 
....................       DELAY_MS (10); 
0DE8:  MOVLW  0A
0DE9:  BSF    03.6
0DEA:  MOVWF  47
0DEB:  BCF    0A.3
0DEC:  BCF    03.6
0DED:  CALL   140
0DEE:  BSF    0A.3
....................       /*DATA RCV SAI ID NODE, ID GW HOAC LA SAI DO DAI*/ 
....................     } 
0DEF:  BCF    0A.3
0DF0:  BSF    0A.4
0DF1:  GOTO   213 (RETURN)
....................      
....................  } 
....................  
....................  
....................  VOID CHUONG_TRINH_CON () 
....................  { 
....................     FOR (INT I = 0; I <= 30; I++) 
*
07A7:  BSF    03.6
07A8:  CLRF   15
07A9:  MOVF   15,W
07AA:  SUBLW  1E
07AB:  BTFSS  03.0
07AC:  GOTO   7BB
....................     { 
....................        OUTPUT_TOGGLE (PIN_D4); 
07AD:  BSF    03.5
07AE:  BCF    03.6
07AF:  BCF    08.4
07B0:  MOVLW  10
07B1:  BCF    03.5
07B2:  XORWF  08,F
....................        DELAY_MS (100); 
07B3:  MOVLW  64
07B4:  BSF    03.6
07B5:  MOVWF  47
07B6:  BCF    03.6
07B7:  CALL   140
07B8:  BSF    03.6
07B9:  INCF   15,F
07BA:  GOTO   7A9
....................     } 
....................     OUTPUT_TOGGLE(PIN_D4); 
07BB:  BSF    03.5
07BC:  BCF    03.6
07BD:  BCF    08.4
07BE:  MOVLW  10
07BF:  BCF    03.5
07C0:  XORWF  08,F
07C1:  BCF    0A.3
07C2:  BSF    0A.4
07C3:  GOTO   20C (RETURN)
....................  } 
....................  
....................  VOID MAIN  () 
*
1123:  MOVF   03,W
1124:  ANDLW  1F
1125:  MOVWF  03
1126:  BSF    03.5
1127:  BSF    03.6
1128:  BSF    07.3
1129:  MOVLW  08
112A:  BCF    03.6
112B:  MOVWF  19
112C:  MOVLW  02
112D:  MOVWF  1A
112E:  MOVLW  A6
112F:  MOVWF  18
1130:  MOVLW  90
1131:  BCF    03.5
1132:  MOVWF  18
1133:  MOVLW  FF
1134:  MOVWF  31
1135:  CLRF   3C
1136:  CLRF   3D
1137:  CLRF   3E
1138:  CLRF   41
1139:  CLRF   4C
113A:  CLRF   4D
113B:  CLRF   4E
113C:  CLRF   4F
113D:  MOVLW  03
113E:  MOVWF  50
113F:  CLRF   51
1140:  CLRF   52
1141:  BCF    53.0
1142:  BCF    53.1
1143:  BCF    53.2
1144:  BCF    53.3
1145:  BCF    53.4
1146:  BCF    53.5
1147:  BCF    53.6
1148:  BSF    03.5
1149:  BSF    03.6
114A:  MOVF   09,W
114B:  ANDLW  C0
114C:  MOVWF  09
114D:  BCF    03.6
114E:  BCF    1F.4
114F:  BCF    1F.5
1150:  MOVLW  00
1151:  BSF    03.6
1152:  MOVWF  08
1153:  BCF    03.5
1154:  CLRF   07
1155:  CLRF   08
1156:  CLRF   09
1157:  BCF    03.7
....................  { 
....................     SET_TRIS_D (0X00); 
*
11CA:  MOVLW  00
11CB:  BSF    03.5
11CC:  BCF    03.6
11CD:  MOVWF  08
....................     SET_TRIS_B (0XFF); 
11CE:  MOVLW  FF
11CF:  MOVWF  06
....................     SET_TRIS_E (0); 
11D0:  BCF    09.0
11D1:  BCF    09.1
11D2:  BCF    09.2
11D3:  BCF    09.3
....................     SET_TRIS_C (0X80); 
11D4:  MOVLW  80
11D5:  MOVWF  07
11D6:  BCF    03.5
11D7:  MOVWF  31
....................     SETUP_ADC (ADC_CLOCK_DIV_8);        
11D8:  BSF    1F.6
11D9:  BCF    1F.7
11DA:  BSF    03.5
11DB:  BSF    1F.7
11DC:  BCF    03.5
11DD:  BSF    1F.0
....................     ENABLE_INTERRUPTS (INT_TIMER0); 
11DE:  BSF    0B.5
....................     ENABLE_INTERRUPTS (INT_EXT); //CHO PHEP NGAT NGOAI 
11DF:  BSF    0B.4
....................     ENABLE_INTERRUPTS (INT_EXT_H2L); //NGAT XAY RA KHI CO XUNG TU CAO XUONG THAP 
11E0:  BSF    0B.4
11E1:  BSF    03.5
11E2:  BCF    01.6
....................     ENABLE_INTERRUPTS (INT_RDA); 
11E3:  BSF    0C.5
....................     ENABLE_INTERRUPTS (GLOBAL); 
11E4:  MOVLW  C0
11E5:  BCF    03.5
11E6:  IORWF  0B,F
....................      
....................     SETUP_TIMER_1 (T1_INTERNAL|T1_DIV_BY_8); 
11E7:  MOVLW  35
11E8:  MOVWF  10
....................     //SET_TIMER1 (0); 
....................     SET_TIMER1 (3036); 
11E9:  CLRF   0E
11EA:  MOVLW  0B
11EB:  MOVWF  0F
11EC:  MOVLW  DC
11ED:  MOVWF  0E
....................     TMR1IF = 0; 
11EE:  BCF    0C.0
....................     LCD_INIT (); // KHOI TAO LCD 
11EF:  BCF    0A.4
11F0:  GOTO   25A
11F1:  BSF    0A.4
....................  
....................     TT_CONFIG = 0; 
11F2:  BCF    53.1
....................     TT_CONFIG_DONE = 0; 
11F3:  BCF    53.3
....................     TT_CONTROL = 1; 
11F4:  BSF    53.2
....................     OUTPUT_D (0X00); 
11F5:  BSF    03.5
11F6:  CLRF   08
11F7:  BCF    03.5
11F8:  CLRF   08
....................     TTNHAN = 0;     
11F9:  BCF    53.0
....................     WHILE (TRUE) 
....................     { 
....................        IF (TT_CONFIG)             {BUTT_FUN (); } // GOI HAM CHON LENH (SWITCH CASE) 
11FA:  BTFSS  53.1
11FB:  GOTO   200
11FC:  BCF    0A.4
11FD:  GOTO   52E
11FE:  BSF    0A.4
11FF:  GOTO   22F
....................        ELSE IF (TT_CONFIG_DONE)   { CONFIG_DONE ();}        
1200:  BTFSS  53.3
1201:  GOTO   208
1202:  BCF    0A.4
1203:  BSF    0A.3
1204:  GOTO   000
1205:  BSF    0A.4
1206:  BCF    0A.3
1207:  GOTO   22F
....................        ELSE 
....................        { 
....................           WHILE (!TT_CONFIG) 
1208:  BTFSC  53.1
1209:  GOTO   22F
....................           { 
....................              CHUONG_TRINH_CON ();                       
120A:  BCF    0A.4
120B:  GOTO   7A7
120C:  BSF    0A.4
....................              IF (TTNHAN == 1) 
120D:  BTFSS  53.0
120E:  GOTO   215
....................              { 
....................                 TTNHAN = 0; 
120F:  BCF    53.0
....................                 XU_LY_UART(); 
1210:  BCF    0A.4
1211:  BSF    0A.3
1212:  GOTO   397
1213:  BSF    0A.4
1214:  BCF    0A.3
....................              }  
....................               
....................              IF (TT_CONFIG_OKE_UART == 1){ 
1215:  BTFSS  53.6
1216:  GOTO   22E
....................                READ_ANALOG(); 
1217:  BCF    0A.4
1218:  BSF    0A.3
1219:  GOTO   5FC
121A:  BSF    0A.4
121B:  BCF    0A.3
....................                IF (KET_QUA_ANALOG[0]>28) 
121C:  MOVF   38,W
121D:  SUBLW  1C
121E:  BTFSC  03.0
121F:  GOTO   22E
....................                { 
....................                DELAY_MS(500); 
1220:  MOVLW  02
1221:  BSF    03.6
1222:  MOVWF  15
1223:  MOVLW  FA
1224:  MOVWF  47
1225:  BCF    0A.4
1226:  BCF    03.6
1227:  CALL   140
1228:  BSF    0A.4
1229:  BSF    03.6
122A:  DECFSZ 15,F
122B:  GOTO   223
....................                SEND_ANALOG_UART(); 
122C:  BCF    03.6
122D:  GOTO   000
....................                } 
....................              } 
122E:  GOTO   208
....................  
....................           } 
....................        } 
122F:  GOTO   1FA
....................     } 
....................  } 
....................  
1230:  SLEEP

Configuration Fuses:
   Word  1: 2FE2   HS NOWDT PUT MCLR NOPROTECT NOCPD BROWNOUT IESO FCMEN NOLVP NODEBUG
   Word  2: 3FFF   BORV40 NOWRT
