CCS PCM C Compiler, Version 5.015, 5967               21-Nov-21 00:47

               Filename:   E:\DATN_V2\NODE\pic\pic16f887\hellopic.lst

               ROM used:   5446 words (66%)
                           Largest free fragment is 2048
               RAM used:   181 (49%) at main() level
                           267 (73%) worst case
               Stack used: 8 locations (7 in main + 1 for interrupts)
               Stack size: 8

*
0000:  MOVLW  14
0001:  MOVWF  0A
0002:  GOTO   48E
0003:  NOP
0004:  MOVWF  7F
0005:  SWAPF  03,W
0006:  CLRF   03
0007:  MOVWF  21
0008:  MOVF   0A,W
0009:  MOVWF  20
000A:  CLRF   0A
000B:  MOVF   04,W
000C:  MOVWF  22
000D:  MOVF   77,W
000E:  MOVWF  23
000F:  MOVF   78,W
0010:  MOVWF  24
0011:  MOVF   79,W
0012:  MOVWF  25
0013:  MOVF   7A,W
0014:  MOVWF  26
0015:  BSF    03.6
0016:  MOVF   0D,W
0017:  BCF    03.6
0018:  MOVWF  27
0019:  BSF    03.6
001A:  MOVF   0F,W
001B:  BCF    03.6
001C:  MOVWF  28
001D:  BSF    03.6
001E:  MOVF   0C,W
001F:  BCF    03.6
0020:  MOVWF  29
0021:  BSF    03.6
0022:  MOVF   0E,W
0023:  BCF    03.6
0024:  MOVWF  2A
0025:  BCF    03.7
0026:  BCF    03.5
0027:  BTFSS  0B.4
0028:  GOTO   02B
0029:  BTFSC  0B.1
002A:  GOTO   052
002B:  MOVLW  8C
002C:  MOVWF  04
002D:  BTFSS  00.5
002E:  GOTO   031
002F:  BTFSC  0C.5
0030:  GOTO   055
0031:  MOVF   22,W
0032:  MOVWF  04
0033:  MOVF   23,W
0034:  MOVWF  77
0035:  MOVF   24,W
0036:  MOVWF  78
0037:  MOVF   25,W
0038:  MOVWF  79
0039:  MOVF   26,W
003A:  MOVWF  7A
003B:  MOVF   27,W
003C:  BSF    03.6
003D:  MOVWF  0D
003E:  BCF    03.6
003F:  MOVF   28,W
0040:  BSF    03.6
0041:  MOVWF  0F
0042:  BCF    03.6
0043:  MOVF   29,W
0044:  BSF    03.6
0045:  MOVWF  0C
0046:  BCF    03.6
0047:  MOVF   2A,W
0048:  BSF    03.6
0049:  MOVWF  0E
004A:  BCF    03.6
004B:  MOVF   20,W
004C:  MOVWF  0A
004D:  SWAPF  21,W
004E:  MOVWF  03
004F:  SWAPF  7F,F
0050:  SWAPF  7F,W
0051:  RETFIE
0052:  BCF    0A.3
0053:  BCF    0A.4
0054:  GOTO   109
0055:  BCF    0A.3
0056:  BCF    0A.4
0057:  GOTO   14F
....................  
.................... #INCLUDE <thuvien.c> 
.................... #INCLUDE <16F887.H> 
.................... //////////// Standard Header file for the PIC16F887 device //////////////// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2013 Custom Computer Services          //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... #device PIC16F887 
0058:  BCF    0A.0
0059:  BCF    0A.1
005A:  BCF    0A.2
005B:  ADDWF  02,F
005C:  RETLW  30
005D:  RETLW  00
005E:  BCF    0A.0
005F:  BCF    0A.1
0060:  BCF    0A.2
0061:  ADDWF  02,F
0062:  RETLW  5F
0063:  RETLW  00
0064:  BCF    0A.0
0065:  BCF    0A.1
0066:  BCF    0A.2
0067:  ADDWF  02,F
0068:  RETLW  32
0069:  RETLW  32
006A:  RETLW  00
006B:  BCF    0A.0
006C:  BCF    0A.1
006D:  BCF    0A.2
006E:  ADDWF  02,F
006F:  RETLW  32
0070:  RETLW  33
0071:  RETLW  00
0072:  BCF    0A.0
0073:  BCF    0A.1
0074:  BCF    0A.2
0075:  ADDWF  02,F
0076:  RETLW  32
0077:  RETLW  34
0078:  RETLW  00
0079:  BCF    0A.0
007A:  BCF    0A.1
007B:  BCF    0A.2
007C:  ADDWF  02,F
007D:  RETLW  23
007E:  RETLW  00
007F:  BCF    0A.0
0080:  BCF    0A.1
0081:  BCF    0A.2
0082:  ADDWF  02,F
0083:  RETLW  00
0084:  DATA CE,27
0085:  DATA C4,22
0086:  DATA 3A,10
0087:  DATA 00,00
0088:  DATA 20,10
0089:  DATA 20,10
008A:  DATA 20,10
008B:  DATA 20,10
008C:  DATA 20,10
008D:  DATA 00,01
008E:  DATA 20,10
008F:  DATA 20,10
0090:  DATA 20,10
0091:  DATA 5F,10
0092:  DATA 20,10
0093:  DATA 20,10
0094:  DATA 20,10
0095:  DATA 20,10
0096:  DATA 20,10
0097:  DATA 20,10
0098:  DATA 20,00
0099:  DATA 20,10
009A:  DATA 20,10
009B:  DATA 5F,10
009C:  DATA 20,10
009D:  DATA 20,00
009E:  DATA 49,22
009F:  DATA DF,23
00A0:  DATA 57,1D
00A1:  DATA 00,01
00A2:  DATA 20,10
00A3:  DATA 20,10
00A4:  DATA 20,10
00A5:  DATA 20,10
00A6:  DATA 20,10
00A7:  DATA 00,01
00A8:  DATA 20,10
00A9:  DATA 20,10
00AA:  DATA 20,10
00AB:  DATA 5F,10
00AC:  DATA 20,10
00AD:  DATA 20,10
00AE:  DATA 20,10
00AF:  DATA 20,10
00B0:  DATA 20,10
00B1:  DATA 20,10
00B2:  DATA 20,10
00B3:  DATA 20,00
00B4:  DATA 20,10
00B5:  DATA 20,10
00B6:  DATA 5F,10
00B7:  DATA 20,10
00B8:  DATA 20,10
00B9:  DATA 20,10
00BA:  DATA 20,00
00BB:  DATA C3,27
00BC:  DATA 4E,23
00BD:  DATA C9,23
00BE:  DATA 3A,10
00BF:  DATA 20,10
00C0:  DATA 20,10
00C1:  DATA 20,10
00C2:  DATA 20,00
00C3:  DATA C3,20
00C4:  DATA D3,22
00C5:  DATA 3A,10
00C6:  DATA 20,10
00C7:  DATA 20,10
00C8:  DATA 20,10
00C9:  DATA 20,10
00CA:  DATA 20,00
00CB:  DATA A0,16
00CC:  DATA A0,24
00CD:  DATA C4,16
00CE:  DATA CE,27
00CF:  DATA C4,22
00D0:  DATA 20,10
00D1:  DATA 20,10
00D2:  DATA 20,10
00D3:  DATA 00,01
00D4:  DATA A0,16
00D5:  DATA A0,24
00D6:  DATA C4,16
00D7:  DATA C7,2B
00D8:  DATA 20,10
00D9:  DATA 20,10
00DA:  DATA 20,10
00DB:  DATA 20,00
00DC:  DATA D7,20
00DD:  DATA 49,2A
00DE:  DATA 49,27
00DF:  DATA 47,10
00E0:  DATA 2E,17
00E1:  DATA 2E,17
00E2:  DATA 20,10
00E3:  DATA 20,10
00E4:  DATA 20,10
00E5:  DATA 20,10
00E6:  DATA 00,01
00E7:  DATA D7,20
00E8:  DATA 49,2A
00E9:  DATA 49,27
00EA:  DATA 47,10
00EB:  DATA 2E,17
00EC:  DATA 2E,17
00ED:  DATA 20,10
00EE:  DATA 20,10
00EF:  DATA 20,10
00F0:  DATA 20,10
00F1:  DATA 00,00
00F2:  DATA 20,10
00F3:  DATA 20,10
00F4:  DATA 20,10
00F5:  DATA 20,10
00F6:  DATA 20,10
00F7:  DATA 20,10
00F8:  DATA 00,01
00F9:  DATA 54,21
00FA:  DATA 3A,10
00FB:  DATA 00,01
00FC:  DATA 20,10
00FD:  DATA 20,10
00FE:  DATA 43,21
00FF:  DATA 3A,00
0100:  DATA 40,22
0101:  DATA 4B,20
0102:  DATA 00,00
0103:  DATA D3,2B
0104:  DATA 3A,10
0105:  DATA 00,01
0106:  DATA C0,29
0107:  DATA 53,20
0108:  DATA 00,01
*
016C:  DATA E8,34
016D:  DATA E8,34
016E:  DATA E8,37
016F:  DATA 61,37
0170:  DATA 67,00
0171:  DATA 43,24
0172:  DATA C1,27
0173:  DATA C8,27
0174:  DATA 41,27
0175:  DATA 47,00
*
033E:  MOVF   0B,W
033F:  BSF    03.6
0340:  MOVWF  43
0341:  BCF    03.6
0342:  BCF    0B.7
0343:  BSF    03.5
0344:  BSF    03.6
0345:  BSF    0C.7
0346:  BSF    0C.0
0347:  NOP
0348:  NOP
0349:  BCF    03.5
034A:  BTFSS  43.7
034B:  GOTO   34F
034C:  BCF    03.6
034D:  BSF    0B.7
034E:  BSF    03.6
034F:  MOVF   0C,W
0350:  ANDLW  7F
0351:  BTFSC  03.2
0352:  GOTO   38C
0353:  MOVWF  43
0354:  MOVF   0D,W
0355:  MOVWF  44
0356:  MOVF   0F,W
0357:  MOVWF  45
0358:  MOVF   43,W
0359:  MOVWF  46
035A:  BCF    03.6
035B:  CALL   304
035C:  BSF    03.6
035D:  MOVF   44,W
035E:  MOVWF  0D
035F:  MOVF   45,W
0360:  MOVWF  0F
0361:  BCF    03.6
0362:  MOVF   0B,W
0363:  BSF    03.6
0364:  MOVWF  46
0365:  BCF    03.6
0366:  BCF    0B.7
0367:  BSF    03.5
0368:  BSF    03.6
0369:  BSF    0C.7
036A:  BSF    0C.0
036B:  NOP
036C:  NOP
036D:  BCF    03.5
036E:  BTFSS  46.7
036F:  GOTO   373
0370:  BCF    03.6
0371:  BSF    0B.7
0372:  BSF    03.6
0373:  RLF    0C,W
0374:  RLF    0E,W
0375:  ANDLW  7F
0376:  BTFSC  03.2
0377:  GOTO   38C
0378:  MOVWF  43
0379:  MOVF   0D,W
037A:  MOVWF  44
037B:  MOVF   0F,W
037C:  MOVWF  45
037D:  MOVF   43,W
037E:  MOVWF  46
037F:  BCF    03.6
0380:  CALL   304
0381:  BSF    03.6
0382:  MOVF   44,W
0383:  MOVWF  0D
0384:  MOVF   45,W
0385:  MOVWF  0F
0386:  INCF   0D,F
0387:  BTFSC  03.2
0388:  INCF   0F,F
0389:  BCF    03.6
038A:  GOTO   33E
038B:  BSF    03.6
038C:  BCF    03.6
038D:  RETURN
*
03BF:  BTFSC  03.1
03C0:  GOTO   3C4
03C1:  MOVLW  64
03C2:  MOVWF  04
03C3:  BSF    03.7
03C4:  BSF    03.6
03C5:  MOVF   5F,W
03C6:  XORWF  63,W
03C7:  ANDLW  80
03C8:  MOVWF  69
03C9:  BTFSS  5F.7
03CA:  GOTO   3D6
03CB:  COMF   5C,F
03CC:  COMF   5D,F
03CD:  COMF   5E,F
03CE:  COMF   5F,F
03CF:  INCF   5C,F
03D0:  BTFSC  03.2
03D1:  INCF   5D,F
03D2:  BTFSC  03.2
03D3:  INCF   5E,F
03D4:  BTFSC  03.2
03D5:  INCF   5F,F
03D6:  BTFSS  63.7
03D7:  GOTO   3E3
03D8:  COMF   60,F
03D9:  COMF   61,F
03DA:  COMF   62,F
03DB:  COMF   63,F
03DC:  INCF   60,F
03DD:  BTFSC  03.2
03DE:  INCF   61,F
03DF:  BTFSC  03.2
03E0:  INCF   62,F
03E1:  BTFSC  03.2
03E2:  INCF   63,F
03E3:  CLRF   77
03E4:  CLRF   78
03E5:  CLRF   79
03E6:  CLRF   7A
03E7:  CLRF   64
03E8:  CLRF   65
03E9:  CLRF   66
03EA:  CLRF   67
03EB:  MOVF   63,W
03EC:  IORWF  62,W
03ED:  IORWF  61,W
03EE:  IORWF  60,W
03EF:  BTFSC  03.2
03F0:  GOTO   421
03F1:  MOVLW  20
03F2:  MOVWF  68
03F3:  BCF    03.0
03F4:  RLF    5C,F
03F5:  RLF    5D,F
03F6:  RLF    5E,F
03F7:  RLF    5F,F
03F8:  RLF    64,F
03F9:  RLF    65,F
03FA:  RLF    66,F
03FB:  RLF    67,F
03FC:  MOVF   63,W
03FD:  SUBWF  67,W
03FE:  BTFSS  03.2
03FF:  GOTO   40A
0400:  MOVF   62,W
0401:  SUBWF  66,W
0402:  BTFSS  03.2
0403:  GOTO   40A
0404:  MOVF   61,W
0405:  SUBWF  65,W
0406:  BTFSS  03.2
0407:  GOTO   40A
0408:  MOVF   60,W
0409:  SUBWF  64,W
040A:  BTFSS  03.0
040B:  GOTO   41B
040C:  MOVF   60,W
040D:  SUBWF  64,F
040E:  MOVF   61,W
040F:  BTFSS  03.0
0410:  INCFSZ 61,W
0411:  SUBWF  65,F
0412:  MOVF   62,W
0413:  BTFSS  03.0
0414:  INCFSZ 62,W
0415:  SUBWF  66,F
0416:  MOVF   63,W
0417:  BTFSS  03.0
0418:  INCFSZ 63,W
0419:  SUBWF  67,F
041A:  BSF    03.0
041B:  RLF    77,F
041C:  RLF    78,F
041D:  RLF    79,F
041E:  RLF    7A,F
041F:  DECFSZ 68,F
0420:  GOTO   3F3
0421:  BTFSS  69.7
0422:  GOTO   42E
0423:  COMF   77,F
0424:  COMF   78,F
0425:  COMF   79,F
0426:  COMF   7A,F
0427:  INCF   77,F
0428:  BTFSC  03.2
0429:  INCF   78,F
042A:  BTFSC  03.2
042B:  INCF   79,F
042C:  BTFSC  03.2
042D:  INCF   7A,F
042E:  MOVF   64,W
042F:  MOVWF  00
0430:  INCF   04,F
0431:  MOVF   65,W
0432:  MOVWF  00
0433:  INCF   04,F
0434:  MOVF   66,W
0435:  MOVWF  00
0436:  INCF   04,F
0437:  MOVF   67,W
0438:  MOVWF  00
0439:  BCF    03.6
043A:  RETURN
*
0454:  MOVLW  20
0455:  MOVWF  60
0456:  CLRF   5C
0457:  CLRF   5D
0458:  CLRF   5E
0459:  CLRF   5F
045A:  MOVF   57,W
045B:  MOVWF  7A
045C:  MOVF   56,W
045D:  MOVWF  79
045E:  MOVF   55,W
045F:  MOVWF  78
0460:  MOVF   54,W
0461:  MOVWF  77
0462:  BCF    03.0
0463:  BTFSS  77.0
0464:  GOTO   473
0465:  MOVF   58,W
0466:  ADDWF  5C,F
0467:  MOVF   59,W
0468:  BTFSC  03.0
0469:  INCFSZ 59,W
046A:  ADDWF  5D,F
046B:  MOVF   5A,W
046C:  BTFSC  03.0
046D:  INCFSZ 5A,W
046E:  ADDWF  5E,F
046F:  MOVF   5B,W
0470:  BTFSC  03.0
0471:  INCFSZ 5B,W
0472:  ADDWF  5F,F
0473:  RRF    5F,F
0474:  RRF    5E,F
0475:  RRF    5D,F
0476:  RRF    5C,F
0477:  RRF    7A,F
0478:  RRF    79,F
0479:  RRF    78,F
047A:  RRF    77,F
047B:  DECFSZ 60,F
047C:  GOTO   462
*
0599:  MOVF   00,F
059A:  BTFSC  03.2
059B:  GOTO   5B6
059C:  BSF    03.6
059D:  CLRF   46
059E:  MOVF   04,W
059F:  MOVWF  45
05A0:  BCF    46.0
05A1:  BTFSC  03.7
05A2:  BSF    46.0
05A3:  MOVF   00,W
05A4:  BCF    03.6
05A5:  BTFSS  0C.4
05A6:  GOTO   5A5
05A7:  MOVWF  19
05A8:  BSF    03.6
05A9:  MOVF   45,W
05AA:  MOVWF  04
05AB:  BCF    03.7
05AC:  BTFSC  46.0
05AD:  BSF    03.7
05AE:  INCF   04,F
05AF:  BTFSS  03.2
05B0:  GOTO   5B4
05B1:  BCF    03.6
05B2:  INCF   05,F
05B3:  BSF    03.6
05B4:  BCF    03.6
05B5:  GOTO   599
05B6:  RETURN
*
0715:  MOVF   00,F
0716:  BTFSC  03.2
0717:  GOTO   731
0718:  BSF    03.6
0719:  CLRF   20
071A:  MOVF   04,W
071B:  MOVWF  1F
071C:  BCF    20.0
071D:  BTFSC  03.7
071E:  BSF    20.0
071F:  MOVF   00,W
0720:  MOVWF  46
0721:  BCF    03.6
0722:  CALL   304
0723:  BSF    03.6
0724:  MOVF   1F,W
0725:  MOVWF  04
0726:  BCF    03.7
0727:  BTFSC  20.0
0728:  BSF    03.7
0729:  INCF   04,F
072A:  BTFSS  03.2
072B:  GOTO   72F
072C:  BCF    03.6
072D:  INCF   05,F
072E:  BSF    03.6
072F:  BCF    03.6
0730:  GOTO   715
0731:  RETURN
0732:  BSF    03.6
0733:  MOVF   1B,W
0734:  CLRF   78
0735:  SUBWF  1A,W
0736:  BTFSC  03.0
0737:  GOTO   73B
0738:  MOVF   1A,W
0739:  MOVWF  77
073A:  GOTO   747
073B:  CLRF   77
073C:  MOVLW  08
073D:  MOVWF  1C
073E:  RLF    1A,F
073F:  RLF    77,F
0740:  MOVF   1B,W
0741:  SUBWF  77,W
0742:  BTFSC  03.0
0743:  MOVWF  77
0744:  RLF    78,F
0745:  DECFSZ 1C,F
0746:  GOTO   73E
0747:  BCF    03.6
0748:  RETURN
*
0769:  CLRF   77
076A:  CLRF   78
076B:  BSF    03.6
076C:  MOVF   25,W
076D:  BCF    03.0
076E:  BTFSC  26.0
076F:  ADDWF  77,F
0770:  RRF    77,F
0771:  RRF    78,F
0772:  BTFSC  26.1
0773:  ADDWF  77,F
0774:  RRF    77,F
0775:  RRF    78,F
0776:  BTFSC  26.2
0777:  ADDWF  77,F
0778:  RRF    77,F
0779:  RRF    78,F
077A:  BTFSC  26.3
077B:  ADDWF  77,F
077C:  RRF    77,F
077D:  RRF    78,F
077E:  BTFSC  26.4
077F:  ADDWF  77,F
0780:  RRF    77,F
0781:  RRF    78,F
0782:  BTFSC  26.5
0783:  ADDWF  77,F
0784:  RRF    77,F
0785:  RRF    78,F
0786:  BTFSC  26.6
0787:  ADDWF  77,F
0788:  RRF    77,F
0789:  RRF    78,F
078A:  BTFSC  26.7
078B:  ADDWF  77,F
078C:  RRF    77,F
078D:  RRF    78,F
078E:  BCF    03.6
078F:  RETURN
*
07D6:  BSF    03.6
07D7:  MOVF   1F,W
07D8:  ANDLW  07
07D9:  MOVWF  77
07DA:  RRF    1F,W
07DB:  MOVWF  78
07DC:  RRF    78,F
07DD:  RRF    78,F
07DE:  MOVLW  1F
07DF:  ANDWF  78,F
07E0:  MOVF   78,W
07E1:  ADDWF  21,W
07E2:  MOVWF  04
07E3:  BCF    03.7
07E4:  BTFSC  22.0
07E5:  BSF    03.7
07E6:  CLRF   78
07E7:  INCF   78,F
07E8:  INCF   77,F
07E9:  GOTO   7EB
07EA:  RLF    78,F
07EB:  DECFSZ 77,F
07EC:  GOTO   7EA
07ED:  MOVF   20,F
07EE:  BTFSC  03.2
07EF:  GOTO   7F3
07F0:  MOVF   78,W
07F1:  IORWF  00,F
07F2:  GOTO   7F6
07F3:  COMF   78,F
07F4:  MOVF   78,W
07F5:  ANDWF  00,F
07F6:  BCF    03.6
07F7:  RETURN
*
0C39:  BSF    03.6
0C3A:  MOVF   22,W
0C3B:  ANDLW  07
0C3C:  MOVWF  77
0C3D:  RRF    22,W
0C3E:  MOVWF  78
0C3F:  RRF    78,F
0C40:  RRF    78,F
0C41:  MOVLW  1F
0C42:  ANDWF  78,F
0C43:  MOVF   78,W
0C44:  ADDWF  23,W
0C45:  MOVWF  04
0C46:  BCF    03.7
0C47:  BTFSC  24.0
0C48:  BSF    03.7
0C49:  MOVF   00,W
0C4A:  MOVWF  78
0C4B:  INCF   77,F
0C4C:  GOTO   44E
0C4D:  RRF    78,F
0C4E:  DECFSZ 77,F
0C4F:  GOTO   44D
0C50:  BCF    03.6
0C51:  RETURN
0C52:  MOVF   0B,W
0C53:  BSF    03.6
0C54:  MOVWF  41
0C55:  BCF    03.6
0C56:  BCF    0B.7
0C57:  BSF    03.5
0C58:  BSF    03.6
0C59:  BSF    0C.7
0C5A:  BSF    0C.0
0C5B:  NOP
0C5C:  NOP
0C5D:  BCF    03.5
0C5E:  BTFSS  41.7
0C5F:  GOTO   463
0C60:  BCF    03.6
0C61:  BSF    0B.7
0C62:  BSF    03.6
0C63:  MOVF   0C,W
0C64:  ANDLW  7F
0C65:  BTFSC  03.2
0C66:  GOTO   4A2
0C67:  MOVWF  41
0C68:  MOVF   0D,W
0C69:  MOVWF  42
0C6A:  MOVF   0F,W
0C6B:  MOVWF  43
0C6C:  MOVF   41,W
0C6D:  BCF    03.6
0C6E:  BTFSS  0C.4
0C6F:  GOTO   46E
0C70:  MOVWF  19
0C71:  BSF    03.6
0C72:  MOVF   42,W
0C73:  MOVWF  0D
0C74:  MOVF   43,W
0C75:  MOVWF  0F
0C76:  BCF    03.6
0C77:  MOVF   0B,W
0C78:  BSF    03.6
0C79:  MOVWF  44
0C7A:  BCF    03.6
0C7B:  BCF    0B.7
0C7C:  BSF    03.5
0C7D:  BSF    03.6
0C7E:  BSF    0C.7
0C7F:  BSF    0C.0
0C80:  NOP
0C81:  NOP
0C82:  BCF    03.5
0C83:  BTFSS  44.7
0C84:  GOTO   488
0C85:  BCF    03.6
0C86:  BSF    0B.7
0C87:  BSF    03.6
0C88:  RLF    0C,W
0C89:  RLF    0E,W
0C8A:  ANDLW  7F
0C8B:  BTFSC  03.2
0C8C:  GOTO   4A2
0C8D:  MOVWF  41
0C8E:  MOVF   0D,W
0C8F:  MOVWF  42
0C90:  MOVF   0F,W
0C91:  MOVWF  43
0C92:  MOVF   41,W
0C93:  BCF    03.6
0C94:  BTFSS  0C.4
0C95:  GOTO   494
0C96:  MOVWF  19
0C97:  BSF    03.6
0C98:  MOVF   42,W
0C99:  MOVWF  0D
0C9A:  MOVF   43,W
0C9B:  MOVWF  0F
0C9C:  INCF   0D,F
0C9D:  BTFSC  03.2
0C9E:  INCF   0F,F
0C9F:  BCF    03.6
0CA0:  GOTO   452
0CA1:  BSF    03.6
0CA2:  BCF    03.6
0CA3:  RETURN
*
1240:  BCF    0A.0
1241:  BSF    0A.1
1242:  BCF    0A.2
1243:  ADDWF  02,F
1244:  GOTO   093
1245:  GOTO   094
1246:  GOTO   0A1
1247:  GOTO   0AE
1248:  GOTO   0BC
1249:  GOTO   0CA
*
12C4:  MOVLW  8E
12C5:  MOVWF  77
12C6:  MOVF   24,W
12C7:  MOVWF  78
12C8:  MOVF   23,W
12C9:  MOVWF  79
12CA:  CLRF   7A
12CB:  MOVF   78,F
12CC:  BTFSS  03.2
12CD:  GOTO   2D8
12CE:  MOVF   79,W
12CF:  MOVWF  78
12D0:  CLRF   79
12D1:  MOVLW  08
12D2:  SUBWF  77,F
12D3:  MOVF   78,F
12D4:  BTFSS  03.2
12D5:  GOTO   2D8
12D6:  CLRF   77
12D7:  GOTO   2E0
12D8:  BCF    03.0
12D9:  BTFSC  78.7
12DA:  GOTO   2DF
12DB:  RLF    79,F
12DC:  RLF    78,F
12DD:  DECF   77,F
12DE:  GOTO   2D8
12DF:  BCF    78.7
*
12F0:  MOVF   23,W
12F1:  BTFSC  03.2
12F2:  GOTO   3B5
12F3:  MOVWF  2F
12F4:  MOVF   27,W
12F5:  BTFSC  03.2
12F6:  GOTO   3B5
12F7:  SUBWF  2F,F
12F8:  BTFSS  03.0
12F9:  GOTO   2FF
12FA:  MOVLW  7F
12FB:  ADDWF  2F,F
12FC:  BTFSC  03.0
12FD:  GOTO   3B5
12FE:  GOTO   305
12FF:  MOVLW  81
1300:  SUBWF  2F,F
1301:  BTFSS  03.0
1302:  GOTO   3B5
1303:  BTFSC  03.2
1304:  GOTO   3B5
1305:  MOVF   2F,W
1306:  MOVWF  77
1307:  CLRF   78
1308:  CLRF   79
1309:  CLRF   7A
130A:  CLRF   2E
130B:  MOVF   24,W
130C:  MOVWF  2D
130D:  BSF    2D.7
130E:  MOVF   25,W
130F:  MOVWF  2C
1310:  MOVF   26,W
1311:  MOVWF  2B
1312:  MOVLW  19
1313:  MOVWF  2F
1314:  MOVF   2A,W
1315:  SUBWF  2B,F
1316:  BTFSC  03.0
1317:  GOTO   328
1318:  MOVLW  01
1319:  SUBWF  2C,F
131A:  BTFSC  03.0
131B:  GOTO   328
131C:  SUBWF  2D,F
131D:  BTFSC  03.0
131E:  GOTO   328
131F:  SUBWF  2E,F
1320:  BTFSC  03.0
1321:  GOTO   328
1322:  INCF   2E,F
1323:  INCF   2D,F
1324:  INCF   2C,F
1325:  MOVF   2A,W
1326:  ADDWF  2B,F
1327:  GOTO   35A
1328:  MOVF   29,W
1329:  SUBWF  2C,F
132A:  BTFSC  03.0
132B:  GOTO   343
132C:  MOVLW  01
132D:  SUBWF  2D,F
132E:  BTFSC  03.0
132F:  GOTO   343
1330:  SUBWF  2E,F
1331:  BTFSC  03.0
1332:  GOTO   343
1333:  INCF   2E,F
1334:  INCF   2D,F
1335:  MOVF   29,W
1336:  ADDWF  2C,F
1337:  MOVF   2A,W
1338:  ADDWF  2B,F
1339:  BTFSS  03.0
133A:  GOTO   35A
133B:  INCF   2C,F
133C:  BTFSS  03.2
133D:  GOTO   35A
133E:  INCF   2D,F
133F:  BTFSS  03.2
1340:  GOTO   35A
1341:  INCF   2E,F
1342:  GOTO   35A
1343:  MOVF   28,W
1344:  IORLW  80
1345:  SUBWF  2D,F
1346:  BTFSC  03.0
1347:  GOTO   359
1348:  MOVLW  01
1349:  SUBWF  2E,F
134A:  BTFSC  03.0
134B:  GOTO   359
134C:  INCF   2E,F
134D:  MOVF   28,W
134E:  IORLW  80
134F:  ADDWF  2D,F
1350:  MOVF   29,W
1351:  ADDWF  2C,F
1352:  BTFSS  03.0
1353:  GOTO   337
1354:  INCF   2D,F
1355:  BTFSS  03.2
1356:  GOTO   337
1357:  INCF   2E,F
1358:  GOTO   337
1359:  BSF    7A.0
135A:  DECFSZ 2F,F
135B:  GOTO   35D
135C:  GOTO   368
135D:  BCF    03.0
135E:  RLF    2B,F
135F:  RLF    2C,F
1360:  RLF    2D,F
1361:  RLF    2E,F
1362:  BCF    03.0
1363:  RLF    7A,F
1364:  RLF    79,F
1365:  RLF    78,F
1366:  RLF    30,F
1367:  GOTO   314
1368:  BTFSS  30.0
1369:  GOTO   370
136A:  BCF    03.0
136B:  RRF    78,F
136C:  RRF    79,F
136D:  RRF    7A,F
136E:  RRF    30,F
136F:  GOTO   373
1370:  DECF   77,F
1371:  BTFSC  03.2
1372:  GOTO   3B5
1373:  BTFSC  30.7
1374:  GOTO   39C
1375:  BCF    03.0
1376:  RLF    2B,F
1377:  RLF    2C,F
1378:  RLF    2D,F
1379:  RLF    2E,F
137A:  MOVF   2A,W
137B:  SUBWF  2B,F
137C:  BTFSC  03.0
137D:  GOTO   388
137E:  MOVLW  01
137F:  SUBWF  2C,F
1380:  BTFSC  03.0
1381:  GOTO   388
1382:  SUBWF  2D,F
1383:  BTFSC  03.0
1384:  GOTO   388
1385:  SUBWF  2E,F
1386:  BTFSS  03.0
1387:  GOTO   3AB
1388:  MOVF   29,W
1389:  SUBWF  2C,F
138A:  BTFSC  03.0
138B:  GOTO   393
138C:  MOVLW  01
138D:  SUBWF  2D,F
138E:  BTFSC  03.0
138F:  GOTO   393
1390:  SUBWF  2E,F
1391:  BTFSS  03.0
1392:  GOTO   3AB
1393:  MOVF   28,W
1394:  IORLW  80
1395:  SUBWF  2D,F
1396:  BTFSC  03.0
1397:  GOTO   39C
1398:  MOVLW  01
1399:  SUBWF  2E,F
139A:  BTFSS  03.0
139B:  GOTO   3AB
139C:  INCF   7A,F
139D:  BTFSS  03.2
139E:  GOTO   3AB
139F:  INCF   79,F
13A0:  BTFSS  03.2
13A1:  GOTO   3AB
13A2:  INCF   78,F
13A3:  BTFSS  03.2
13A4:  GOTO   3AB
13A5:  INCF   77,F
13A6:  BTFSC  03.2
13A7:  GOTO   3B5
13A8:  RRF    78,F
13A9:  RRF    79,F
13AA:  RRF    7A,F
13AB:  MOVF   24,W
13AC:  MOVWF  2F
13AD:  MOVF   28,W
13AE:  XORWF  2F,F
13AF:  BTFSS  2F.7
13B0:  GOTO   3B3
13B1:  BSF    78.7
13B2:  GOTO   3B9
13B3:  BCF    78.7
13B4:  GOTO   3B9
13B5:  CLRF   77
13B6:  CLRF   78
13B7:  CLRF   79
13B8:  CLRF   7A
*
13C1:  MOVLW  8E
13C2:  MOVWF  77
13C3:  MOVF   23,W
13C4:  SUBWF  77,F
13C5:  MOVF   24,W
13C6:  MOVWF  79
13C7:  MOVF   25,W
13C8:  MOVWF  78
13C9:  BSF    79.7
13CA:  MOVF   77,F
13CB:  BTFSC  03.2
13CC:  GOTO   3D8
13CD:  BCF    03.0
13CE:  MOVF   79,F
13CF:  BTFSS  03.2
13D0:  GOTO   3D4
13D1:  MOVF   78,F
13D2:  BTFSC  03.2
13D3:  GOTO   3D8
13D4:  RRF    79,F
13D5:  RRF    78,F
13D6:  DECFSZ 77,F
13D7:  GOTO   3CD
13D8:  BTFSS  24.7
13D9:  GOTO   3DF
13DA:  COMF   78,F
13DB:  COMF   79,F
13DC:  INCF   78,F
13DD:  BTFSC  03.2
13DE:  INCF   79,F
*
1401:  MOVLW  8E
1402:  MOVWF  77
1403:  MOVF   19,W
1404:  MOVWF  78
1405:  MOVF   18,W
1406:  MOVWF  79
1407:  CLRF   7A
1408:  BTFSS  19.7
1409:  GOTO   40F
140A:  COMF   78,F
140B:  COMF   79,F
140C:  INCF   79,F
140D:  BTFSC  03.2
140E:  INCF   78,F
140F:  MOVF   78,F
1410:  BTFSS  03.2
1411:  GOTO   41C
1412:  MOVF   79,W
1413:  MOVWF  78
1414:  CLRF   79
1415:  MOVLW  08
1416:  SUBWF  77,F
1417:  MOVF   78,F
1418:  BTFSS  03.2
1419:  GOTO   41C
141A:  CLRF   77
141B:  GOTO   425
141C:  BCF    03.0
141D:  BTFSC  78.7
141E:  GOTO   423
141F:  RLF    79,F
1420:  RLF    78,F
1421:  DECF   77,F
1422:  GOTO   41C
1423:  BTFSS  19.7
1424:  BCF    78.7
*
1432:  MOVF   19,W
1433:  MOVWF  20
1434:  MOVF   1D,W
1435:  XORWF  20,F
1436:  BTFSS  20.7
1437:  GOTO   43D
1438:  BCF    03.2
1439:  BCF    03.0
143A:  BTFSC  19.7
143B:  BSF    03.0
143C:  GOTO   470
143D:  MOVF   19,W
143E:  MOVWF  20
143F:  MOVF   1C,W
1440:  MOVWF  21
1441:  MOVF   18,W
1442:  SUBWF  21,F
1443:  BTFSC  03.2
1444:  GOTO   44B
1445:  BTFSS  20.7
1446:  GOTO   470
1447:  MOVF   03,W
1448:  XORLW  01
1449:  MOVWF  03
144A:  GOTO   470
144B:  MOVF   1D,W
144C:  MOVWF  21
144D:  MOVF   19,W
144E:  SUBWF  21,F
144F:  BTFSC  03.2
1450:  GOTO   457
1451:  BTFSS  20.7
1452:  GOTO   470
1453:  MOVF   03,W
1454:  XORLW  01
1455:  MOVWF  03
1456:  GOTO   470
1457:  MOVF   1E,W
1458:  MOVWF  21
1459:  MOVF   1A,W
145A:  SUBWF  21,F
145B:  BTFSC  03.2
145C:  GOTO   463
145D:  BTFSS  20.7
145E:  GOTO   470
145F:  MOVF   03,W
1460:  XORLW  01
1461:  MOVWF  03
1462:  GOTO   470
1463:  MOVF   1F,W
1464:  MOVWF  21
1465:  MOVF   1B,W
1466:  SUBWF  21,F
1467:  BTFSC  03.2
1468:  GOTO   46F
1469:  BTFSS  20.7
146A:  GOTO   470
146B:  MOVF   03,W
146C:  XORLW  01
146D:  MOVWF  03
146E:  GOTO   470
146F:  BCF    03.0
....................  
.................... #list 
....................  
.................... #DEVICE ADC=10 
.................... #INCLUDE <STRING.H> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
*
055B:  BSF    03.6
055C:  MOVF   45,W
055D:  MOVWF  49
055E:  MOVF   44,W
055F:  MOVWF  48
0560:  MOVF   49,W
0561:  MOVWF  7A
0562:  MOVF   48,W
0563:  MOVWF  04
0564:  BCF    03.7
0565:  BTFSC  7A.0
0566:  BSF    03.7
0567:  MOVF   00,F
0568:  BTFSC  03.2
0569:  GOTO   56E
056A:  INCF   48,F
056B:  BTFSC  03.2
056C:  INCF   49,F
056D:  GOTO   560
....................    while(*s2 != '\0') 
056E:  MOVF   47,W
056F:  MOVWF  7A
0570:  MOVF   46,W
0571:  MOVWF  04
0572:  BCF    03.7
0573:  BTFSC  7A.0
0574:  BSF    03.7
0575:  MOVF   00,F
0576:  BTFSC  03.2
0577:  GOTO   58D
....................    { 
....................       *s = *s2; 
0578:  MOVF   46,W
0579:  MOVWF  04
057A:  BCF    03.7
057B:  BTFSC  47.0
057C:  BSF    03.7
057D:  MOVF   00,W
057E:  MOVWF  4C
057F:  MOVF   48,W
0580:  MOVWF  04
0581:  BCF    03.7
0582:  BTFSC  49.0
0583:  BSF    03.7
0584:  MOVF   4C,W
0585:  MOVWF  00
....................       ++s; 
0586:  INCF   48,F
0587:  BTFSC  03.2
0588:  INCF   49,F
....................       ++s2; 
0589:  INCF   46,F
058A:  BTFSC  03.2
058B:  INCF   47,F
058C:  GOTO   56E
....................    } 
....................  
....................    *s = '\0'; 
058D:  MOVF   48,W
058E:  MOVWF  04
058F:  BCF    03.7
0590:  BTFSC  49.0
0591:  BSF    03.7
0592:  CLRF   00
....................    return(s1); 
0593:  MOVF   44,W
0594:  MOVWF  78
0595:  MOVF   45,W
0596:  MOVWF  79
0597:  BCF    03.6
0598:  RETURN
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
*
0790:  BSF    03.6
0791:  MOVF   1D,W
0792:  MOVWF  7A
0793:  MOVF   1C,W
0794:  MOVWF  04
0795:  BCF    03.7
0796:  BTFSC  7A.0
0797:  BSF    03.7
0798:  MOVF   00,W
0799:  MOVWF  20
079A:  MOVF   1F,W
079B:  MOVWF  7A
079C:  MOVF   1E,W
079D:  MOVWF  04
079E:  BCF    03.7
079F:  BTFSC  7A.0
07A0:  BSF    03.7
07A1:  MOVF   00,W
07A2:  SUBWF  20,W
07A3:  BTFSS  03.2
07A4:  GOTO   7BC
....................       if (*s1 == '\0') 
07A5:  MOVF   1D,W
07A6:  MOVWF  7A
07A7:  MOVF   1C,W
07A8:  MOVWF  04
07A9:  BCF    03.7
07AA:  BTFSC  7A.0
07AB:  BSF    03.7
07AC:  MOVF   00,F
07AD:  BTFSS  03.2
07AE:  GOTO   7B2
....................          return(0); 
07AF:  MOVLW  00
07B0:  MOVWF  78
07B1:  GOTO   7D4
07B2:  MOVF   1D,W
07B3:  MOVWF  7A
07B4:  MOVF   1C,W
07B5:  INCF   1C,F
07B6:  BTFSC  03.2
07B7:  INCF   1D,F
07B8:  INCF   1E,F
07B9:  BTFSC  03.2
07BA:  INCF   1F,F
07BB:  GOTO   791
....................    return((*s1 < *s2) ? -1: 1); 
07BC:  MOVF   1D,W
07BD:  MOVWF  7A
07BE:  MOVF   1C,W
07BF:  MOVWF  04
07C0:  BCF    03.7
07C1:  BTFSC  1D.0
07C2:  BSF    03.7
07C3:  MOVF   00,W
07C4:  MOVWF  20
07C5:  MOVF   1F,W
07C6:  MOVWF  7A
07C7:  MOVF   1E,W
07C8:  MOVWF  04
07C9:  BCF    03.7
07CA:  BTFSC  1F.0
07CB:  BSF    03.7
07CC:  MOVF   00,W
07CD:  SUBWF  20,W
07CE:  BTFSC  03.0
07CF:  GOTO   7D2
07D0:  MOVLW  FF
07D1:  GOTO   7D3
07D2:  MOVLW  01
07D3:  MOVWF  78
07D4:  BCF    03.6
07D5:  RETURN
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
*
102C:  MOVF   1D,W
102D:  MOVWF  7A
102E:  MOVF   1C,W
102F:  MOVWF  04
1030:  BCF    03.7
1031:  BTFSC  7A.0
1032:  BSF    03.7
1033:  MOVF   1E,W
1034:  SUBWF  00,W
1035:  BTFSC  03.2
1036:  GOTO   049
....................       if (*s == '\0') 
1037:  MOVF   1D,W
1038:  MOVWF  7A
1039:  MOVF   1C,W
103A:  MOVWF  04
103B:  BCF    03.7
103C:  BTFSC  7A.0
103D:  BSF    03.7
103E:  MOVF   00,F
103F:  BTFSS  03.2
1040:  GOTO   045
....................          return(0); 
1041:  MOVLW  00
1042:  MOVWF  78
1043:  MOVWF  79
1044:  GOTO   04D
1045:  INCF   1C,F
1046:  BTFSC  03.2
1047:  INCF   1D,F
1048:  GOTO   02C
....................    return(s); 
1049:  MOVF   1C,W
104A:  MOVWF  78
104B:  MOVF   1D,W
104C:  MOVWF  79
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
*
0AF1:  MOVF   27,W
0AF2:  MOVWF  2B
0AF3:  MOVF   26,W
0AF4:  MOVWF  2A
0AF5:  MOVF   2B,W
0AF6:  MOVWF  7A
0AF7:  MOVF   2A,W
0AF8:  MOVWF  04
0AF9:  BCF    03.7
0AFA:  BTFSC  7A.0
0AFB:  BSF    03.7
0AFC:  MOVF   00,F
0AFD:  BTFSC  03.2
0AFE:  GOTO   32E
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
0AFF:  MOVF   29,W
0B00:  MOVWF  2D
0B01:  MOVF   28,W
0B02:  MOVWF  2C
0B03:  MOVF   2D,W
0B04:  MOVWF  7A
0B05:  MOVF   2C,W
0B06:  MOVWF  04
0B07:  BCF    03.7
0B08:  BTFSC  7A.0
0B09:  BSF    03.7
0B0A:  MOVF   00,F
0B0B:  BTFSC  03.2
0B0C:  GOTO   32A
....................          if (*sc1 == *sc2) 
0B0D:  MOVF   2B,W
0B0E:  MOVWF  7A
0B0F:  MOVF   2A,W
0B10:  MOVWF  04
0B11:  BCF    03.7
0B12:  BTFSC  7A.0
0B13:  BSF    03.7
0B14:  MOVF   00,W
0B15:  MOVWF  2E
0B16:  MOVF   2D,W
0B17:  MOVWF  7A
0B18:  MOVF   2C,W
0B19:  MOVWF  04
0B1A:  BCF    03.7
0B1B:  BTFSC  7A.0
0B1C:  BSF    03.7
0B1D:  MOVF   00,W
0B1E:  SUBWF  2E,W
0B1F:  BTFSS  03.2
0B20:  GOTO   326
....................             return(sc1); 
0B21:  MOVF   2A,W
0B22:  MOVWF  78
0B23:  MOVF   2B,W
0B24:  MOVWF  79
0B25:  GOTO   331
0B26:  INCF   2C,F
0B27:  BTFSC  03.2
0B28:  INCF   2D,F
0B29:  GOTO   303
0B2A:  INCF   2A,F
0B2B:  BTFSC  03.2
0B2C:  INCF   2B,F
0B2D:  GOTO   2F5
....................    return(0); 
0B2E:  MOVLW  00
0B2F:  MOVWF  78
0B30:  MOVWF  79
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
*
0A7E:  MOVF   27,W
0A7F:  MOVWF  2B
0A80:  MOVF   26,W
0A81:  MOVWF  2A
0A82:  MOVF   2B,W
0A83:  MOVWF  7A
0A84:  MOVF   2A,W
0A85:  MOVWF  04
0A86:  BCF    03.7
0A87:  BTFSC  7A.0
0A88:  BSF    03.7
0A89:  MOVF   00,F
0A8A:  BTFSC  03.2
0A8B:  GOTO   2C3
....................       for (sc2 = s2; ; sc2++) 
0A8C:  MOVF   29,W
0A8D:  MOVWF  2D
0A8E:  MOVF   28,W
0A8F:  MOVWF  2C
....................     if (*sc2 == '\0') 
0A90:  MOVF   2D,W
0A91:  MOVWF  7A
0A92:  MOVF   2C,W
0A93:  MOVWF  04
0A94:  BCF    03.7
0A95:  BTFSC  7A.0
0A96:  BSF    03.7
0A97:  MOVF   00,F
0A98:  BTFSS  03.2
0A99:  GOTO   2A7
....................        return(sc1 - s1); 
0A9A:  MOVF   26,W
0A9B:  SUBWF  2A,W
0A9C:  MOVWF  77
0A9D:  MOVF   2B,W
0A9E:  MOVWF  7A
0A9F:  MOVF   27,W
0AA0:  BTFSS  03.0
0AA1:  INCFSZ 27,W
0AA2:  SUBWF  7A,F
0AA3:  MOVF   77,W
0AA4:  MOVWF  78
0AA5:  GOTO   2CE
0AA6:  GOTO   2BB
....................          else if (*sc1 == *sc2) 
0AA7:  MOVF   2B,W
0AA8:  MOVWF  7A
0AA9:  MOVF   2A,W
0AAA:  MOVWF  04
0AAB:  BCF    03.7
0AAC:  BTFSC  7A.0
0AAD:  BSF    03.7
0AAE:  MOVF   00,W
0AAF:  MOVWF  2E
0AB0:  MOVF   2D,W
0AB1:  MOVWF  7A
0AB2:  MOVF   2C,W
0AB3:  MOVWF  04
0AB4:  BCF    03.7
0AB5:  BTFSC  7A.0
0AB6:  BSF    03.7
0AB7:  MOVF   00,W
0AB8:  SUBWF  2E,W
0AB9:  BTFSC  03.2
....................             break; 
0ABA:  GOTO   2BF
0ABB:  INCF   2C,F
0ABC:  BTFSC  03.2
0ABD:  INCF   2D,F
0ABE:  GOTO   290
0ABF:  INCF   2A,F
0AC0:  BTFSC  03.2
0AC1:  INCF   2B,F
0AC2:  GOTO   282
....................    return(sc1 - s1); 
0AC3:  MOVF   26,W
0AC4:  SUBWF  2A,W
0AC5:  MOVWF  77
0AC6:  MOVF   2B,W
0AC7:  MOVWF  7A
0AC8:  MOVF   27,W
0AC9:  BTFSS  03.0
0ACA:  INCFSZ 27,W
0ACB:  SUBWF  7A,F
0ACC:  MOVF   77,W
0ACD:  MOVWF  78
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
*
14C3:  BCF    03.6
14C4:  CLRF   2B
14C5:  CLRF   2C
....................  
....................    beg = (s1)? s1: save; 
*
0A65:  BSF    03.6
0A66:  MOVF   1E,W
0A67:  IORWF  1F,W
0A68:  BTFSC  03.2
0A69:  GOTO   26E
0A6A:  MOVF   1F,W
0A6B:  MOVWF  7A
0A6C:  MOVF   1E,W
0A6D:  GOTO   273
0A6E:  BCF    03.6
0A6F:  MOVF   2C,W
0A70:  MOVWF  7A
0A71:  MOVF   2B,W
0A72:  BSF    03.6
0A73:  MOVWF  22
0A74:  MOVF   7A,W
0A75:  MOVWF  23
....................    beg += strspn(beg, s2); 
0A76:  MOVF   23,W
0A77:  MOVWF  27
0A78:  MOVF   22,W
0A79:  MOVWF  26
0A7A:  MOVF   21,W
0A7B:  MOVWF  29
0A7C:  MOVF   20,W
0A7D:  MOVWF  28
*
0ACE:  MOVF   78,W
0ACF:  ADDWF  22,F
0AD0:  BTFSC  03.0
0AD1:  INCF   23,F
....................    if (*beg == '\0') 
0AD2:  MOVF   23,W
0AD3:  MOVWF  7A
0AD4:  MOVF   22,W
0AD5:  MOVWF  04
0AD6:  BCF    03.7
0AD7:  BTFSC  7A.0
0AD8:  BSF    03.7
0AD9:  MOVF   00,F
0ADA:  BTFSS  03.2
0ADB:  GOTO   2E9
....................    { 
....................       *save = ' '; 
0ADC:  BCF    03.6
0ADD:  MOVF   2B,W
0ADE:  MOVWF  04
0ADF:  BCF    03.7
0AE0:  BTFSC  2C.0
0AE1:  BSF    03.7
0AE2:  MOVLW  20
0AE3:  MOVWF  00
....................       return(0); 
0AE4:  MOVLW  00
0AE5:  MOVWF  78
0AE6:  MOVWF  79
0AE7:  GOTO   355
0AE8:  BSF    03.6
....................    } 
....................    end = strpbrk(beg, s2); 
0AE9:  MOVF   23,W
0AEA:  MOVWF  27
0AEB:  MOVF   22,W
0AEC:  MOVWF  26
0AED:  MOVF   21,W
0AEE:  MOVWF  29
0AEF:  MOVF   20,W
0AF0:  MOVWF  28
*
0B31:  MOVF   79,W
0B32:  MOVWF  25
0B33:  MOVF   78,W
0B34:  MOVWF  24
....................    if (*end != '\0') 
0B35:  MOVF   25,W
0B36:  MOVWF  7A
0B37:  MOVF   24,W
0B38:  MOVWF  04
0B39:  BCF    03.7
0B3A:  BTFSC  7A.0
0B3B:  BSF    03.7
0B3C:  MOVF   00,F
0B3D:  BTFSC  03.2
0B3E:  GOTO   348
....................    { 
....................       *end = '\0'; 
0B3F:  MOVF   24,W
0B40:  MOVWF  04
0B41:  BCF    03.7
0B42:  BTFSC  25.0
0B43:  BSF    03.7
0B44:  CLRF   00
....................       end++; 
0B45:  INCF   24,F
0B46:  BTFSC  03.2
0B47:  INCF   25,F
....................    } 
....................    save = end; 
0B48:  MOVF   25,W
0B49:  BCF    03.6
0B4A:  MOVWF  2C
0B4B:  BSF    03.6
0B4C:  MOVF   24,W
0B4D:  BCF    03.6
0B4E:  MOVWF  2B
....................    return(beg); 
0B4F:  BSF    03.6
0B50:  MOVF   22,W
0B51:  MOVWF  78
0B52:  MOVF   23,W
0B53:  MOVWF  79
0B54:  BCF    03.6
0B55:  RETURN
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
*
0749:  BSF    03.6
074A:  MOVF   44,W
074B:  MOVWF  46
074C:  MOVF   43,W
074D:  MOVWF  45
074E:  MOVF   46,W
074F:  MOVWF  7A
0750:  MOVF   45,W
0751:  MOVWF  04
0752:  BCF    03.7
0753:  BTFSC  7A.0
0754:  BSF    03.7
0755:  MOVF   00,F
0756:  BTFSC  03.2
0757:  GOTO   75C
0758:  INCF   45,F
0759:  BTFSC  03.2
075A:  INCF   46,F
075B:  GOTO   74E
....................    return(sc - s); 
075C:  MOVF   43,W
075D:  SUBWF  45,W
075E:  MOVWF  77
075F:  MOVF   46,W
0760:  MOVWF  7A
0761:  MOVF   44,W
0762:  BTFSS  03.0
0763:  INCFSZ 44,W
0764:  SUBWF  7A,F
0765:  MOVF   77,W
0766:  MOVWF  78
0767:  BCF    03.6
0768:  RETURN
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #INCLUDE <STDLIB.H> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... /* Standart template: float strtof(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... float strtof(char *s,char *endptr); 
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s,char *endptr); 
.................... float64 strtod(char *s,char *endptr); 
.................... #else 
.................... //provided for compatibility 
.................... #define strtof48(s, e) strtof(s, e) 
.................... #define strtod(s, e) strtof(s, e) 
.................... #endif 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof(s)   strtof(s, 0) 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof48(s) strtof48(s, 0) 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof64(s) strtod(s, 0) 
.................... #endif 
....................  
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float atoe(char * s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s); 
.................... #endif 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... unsigned int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................  
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
*
0B56:  BSF    03.6
0B57:  CLRF   23
....................    sign = 0; 
0B58:  CLRF   21
....................    base = 10; 
0B59:  MOVLW  0A
0B5A:  MOVWF  22
....................    result = 0; 
0B5B:  CLRF   20
....................  
....................    if (!s) 
0B5C:  MOVF   1E,W
0B5D:  IORWF  1F,W
0B5E:  BTFSS  03.2
0B5F:  GOTO   363
....................       return 0; 
0B60:  MOVLW  00
0B61:  MOVWF  78
0B62:  GOTO   437
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
0B63:  MOVF   23,W
0B64:  INCF   23,F
0B65:  ADDWF  1E,W
0B66:  MOVWF  04
0B67:  BCF    03.7
0B68:  BTFSC  1F.0
0B69:  BSF    03.7
0B6A:  MOVF   00,W
0B6B:  MOVWF  24
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
0B6C:  MOVF   24,W
0B6D:  SUBLW  2D
0B6E:  BTFSS  03.2
0B6F:  GOTO   37C
....................    { 
....................       sign = 1;         // Set the sign to negative 
0B70:  MOVLW  01
0B71:  MOVWF  21
....................       c = s[index++]; 
0B72:  MOVF   23,W
0B73:  INCF   23,F
0B74:  ADDWF  1E,W
0B75:  MOVWF  04
0B76:  BCF    03.7
0B77:  BTFSC  1F.0
0B78:  BSF    03.7
0B79:  MOVF   00,W
0B7A:  MOVWF  24
....................    } 
0B7B:  GOTO   389
....................    else if (c == '+') 
0B7C:  MOVF   24,W
0B7D:  SUBLW  2B
0B7E:  BTFSS  03.2
0B7F:  GOTO   389
....................    { 
....................       c = s[index++]; 
0B80:  MOVF   23,W
0B81:  INCF   23,F
0B82:  ADDWF  1E,W
0B83:  MOVWF  04
0B84:  BCF    03.7
0B85:  BTFSC  1F.0
0B86:  BSF    03.7
0B87:  MOVF   00,W
0B88:  MOVWF  24
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
0B89:  MOVF   24,W
0B8A:  SUBLW  2F
0B8B:  BTFSC  03.0
0B8C:  GOTO   42D
0B8D:  MOVF   24,W
0B8E:  SUBLW  39
0B8F:  BTFSS  03.0
0B90:  GOTO   42D
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
0B91:  MOVF   24,W
0B92:  SUBLW  30
0B93:  BTFSS  03.2
0B94:  GOTO   3B5
0B95:  MOVF   23,W
0B96:  ADDWF  1E,W
0B97:  MOVWF  04
0B98:  BCF    03.7
0B99:  BTFSC  1F.0
0B9A:  BSF    03.7
0B9B:  MOVF   00,W
0B9C:  SUBLW  78
0B9D:  BTFSC  03.2
0B9E:  GOTO   3A9
0B9F:  MOVF   23,W
0BA0:  ADDWF  1E,W
0BA1:  MOVWF  04
0BA2:  BCF    03.7
0BA3:  BTFSC  1F.0
0BA4:  BSF    03.7
0BA5:  MOVF   00,W
0BA6:  SUBLW  58
0BA7:  BTFSS  03.2
0BA8:  GOTO   3B5
....................       { 
....................          base = 16; 
0BA9:  MOVLW  10
0BAA:  MOVWF  22
....................          index++; 
0BAB:  INCF   23,F
....................          c = s[index++]; 
0BAC:  MOVF   23,W
0BAD:  INCF   23,F
0BAE:  ADDWF  1E,W
0BAF:  MOVWF  04
0BB0:  BCF    03.7
0BB1:  BTFSC  1F.0
0BB2:  BSF    03.7
0BB3:  MOVF   00,W
0BB4:  MOVWF  24
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
0BB5:  MOVF   22,W
0BB6:  SUBLW  0A
0BB7:  BTFSS  03.2
0BB8:  GOTO   3DB
....................       { 
....................          while (c >= '0' && c <= '9') 
0BB9:  MOVF   24,W
0BBA:  SUBLW  2F
0BBB:  BTFSC  03.0
0BBC:  GOTO   3DA
0BBD:  MOVF   24,W
0BBE:  SUBLW  39
0BBF:  BTFSS  03.0
0BC0:  GOTO   3DA
....................          { 
....................             result = 10*result + (c - '0'); 
0BC1:  MOVLW  0A
0BC2:  MOVWF  25
0BC3:  MOVF   20,W
0BC4:  MOVWF  26
0BC5:  BCF    0A.3
0BC6:  BCF    03.6
0BC7:  CALL   769
0BC8:  BSF    0A.3
0BC9:  MOVF   78,W
0BCA:  BSF    03.6
0BCB:  MOVWF  25
0BCC:  MOVLW  30
0BCD:  SUBWF  24,W
0BCE:  ADDWF  25,W
0BCF:  MOVWF  20
....................             c = s[index++]; 
0BD0:  MOVF   23,W
0BD1:  INCF   23,F
0BD2:  ADDWF  1E,W
0BD3:  MOVWF  04
0BD4:  BCF    03.7
0BD5:  BTFSC  1F.0
0BD6:  BSF    03.7
0BD7:  MOVF   00,W
0BD8:  MOVWF  24
0BD9:  GOTO   3B9
....................          } 
....................       } 
0BDA:  GOTO   42D
....................       else if (base == 16)    // The number is a hexa number 
0BDB:  MOVF   22,W
0BDC:  SUBLW  10
0BDD:  BTFSS  03.2
0BDE:  GOTO   42D
....................       { 
....................          c = toupper(c); 
0BDF:  MOVF   24,W
0BE0:  SUBLW  60
0BE1:  BTFSC  03.0
0BE2:  GOTO   3EA
0BE3:  MOVF   24,W
0BE4:  SUBLW  7A
0BE5:  BTFSS  03.0
0BE6:  GOTO   3EA
0BE7:  MOVF   24,W
0BE8:  ANDLW  DF
0BE9:  GOTO   3EB
0BEA:  MOVF   24,W
0BEB:  MOVWF  24
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
0BEC:  MOVF   24,W
0BED:  SUBLW  2F
0BEE:  BTFSC  03.0
0BEF:  GOTO   3F4
0BF0:  MOVF   24,W
0BF1:  SUBLW  39
0BF2:  BTFSC  03.0
0BF3:  GOTO   3FC
0BF4:  MOVF   24,W
0BF5:  SUBLW  40
0BF6:  BTFSC  03.0
0BF7:  GOTO   42D
0BF8:  MOVF   24,W
0BF9:  SUBLW  46
0BFA:  BTFSS  03.0
0BFB:  GOTO   42D
....................          { 
....................             if (c >= '0' && c <= '9') 
0BFC:  MOVF   24,W
0BFD:  SUBLW  2F
0BFE:  BTFSC  03.0
0BFF:  GOTO   40D
0C00:  MOVF   24,W
0C01:  SUBLW  39
0C02:  BTFSS  03.0
0C03:  GOTO   40D
....................                result = (result << 4) + (c - '0'); 
0C04:  SWAPF  20,W
0C05:  MOVWF  25
0C06:  MOVLW  F0
0C07:  ANDWF  25,F
0C08:  MOVLW  30
0C09:  SUBWF  24,W
0C0A:  ADDWF  25,W
0C0B:  MOVWF  20
0C0C:  GOTO   416
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
0C0D:  SWAPF  20,W
0C0E:  MOVWF  25
0C0F:  MOVLW  F0
0C10:  ANDWF  25,F
0C11:  MOVLW  41
0C12:  SUBWF  24,W
0C13:  ADDLW  0A
0C14:  ADDWF  25,W
0C15:  MOVWF  20
....................  
....................             c = s[index++]; 
0C16:  MOVF   23,W
0C17:  INCF   23,F
0C18:  ADDWF  1E,W
0C19:  MOVWF  04
0C1A:  BCF    03.7
0C1B:  BTFSC  1F.0
0C1C:  BSF    03.7
0C1D:  MOVF   00,W
0C1E:  MOVWF  24
....................             c = toupper(c); 
0C1F:  MOVF   24,W
0C20:  SUBLW  60
0C21:  BTFSC  03.0
0C22:  GOTO   42A
0C23:  MOVF   24,W
0C24:  SUBLW  7A
0C25:  BTFSS  03.0
0C26:  GOTO   42A
0C27:  MOVF   24,W
0C28:  ANDLW  DF
0C29:  GOTO   42B
0C2A:  MOVF   24,W
0C2B:  MOVWF  24
0C2C:  GOTO   3EC
....................          } 
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
0C2D:  DECFSZ 21,W
0C2E:  GOTO   435
0C2F:  MOVF   22,W
0C30:  SUBLW  0A
0C31:  BTFSS  03.2
0C32:  GOTO   435
....................        result = -result; 
0C33:  COMF   20,F
0C34:  INCF   20,F
....................  
....................    return(result); 
0C35:  MOVF   20,W
0C36:  MOVWF  78
0C37:  BCF    03.6
0C38:  RETURN
.................... } 
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
*
043B:  BSF    03.6
043C:  CLRF   4F
043D:  CLRF   4E
043E:  CLRF   4D
043F:  MOVLW  01
0440:  MOVWF  4C
0441:  CLRF   51
0442:  CLRF   52
.................... { 
....................      unsigned int32 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
0443:  BTFSS  48.7
0444:  GOTO   485
....................          sign=1;        // Check for negative number 
0445:  MOVLW  01
0446:  MOVWF  51
....................          num*=-1; 
0447:  MOVF   48,W
0448:  MOVWF  57
0449:  MOVF   47,W
044A:  MOVWF  56
044B:  MOVF   46,W
044C:  MOVWF  55
044D:  MOVF   45,W
044E:  MOVWF  54
044F:  MOVLW  FF
0450:  MOVWF  5B
0451:  MOVWF  5A
0452:  MOVWF  59
0453:  MOVWF  58
*
047D:  MOVF   7A,W
047E:  MOVWF  48
047F:  MOVF   79,W
0480:  MOVWF  47
0481:  MOVF   78,W
0482:  MOVWF  46
0483:  MOVF   77,W
0484:  MOVWF  45
....................      } 
....................  
....................      while(temp>0) { 
0485:  MOVF   4C,F
0486:  BTFSS  03.2
0487:  GOTO   491
0488:  MOVF   4D,F
0489:  BTFSS  03.2
048A:  GOTO   491
048B:  MOVF   4E,F
048C:  BTFSS  03.2
048D:  GOTO   491
048E:  MOVF   4F,F
048F:  BTFSC  03.2
0490:  GOTO   50D
....................          temp=(num/base); 
0491:  BCF    03.1
0492:  MOVF   48,W
0493:  MOVWF  5F
0494:  MOVF   47,W
0495:  MOVWF  5E
0496:  MOVF   46,W
0497:  MOVWF  5D
0498:  MOVF   45,W
0499:  MOVWF  5C
049A:  CLRF   63
049B:  CLRF   62
049C:  CLRF   61
049D:  MOVF   49,W
049E:  MOVWF  60
049F:  BCF    03.6
04A0:  CALL   3BF
04A1:  MOVF   7A,W
04A2:  BSF    03.6
04A3:  MOVWF  4F
04A4:  MOVF   79,W
04A5:  MOVWF  4E
04A6:  MOVF   78,W
04A7:  MOVWF  4D
04A8:  MOVF   77,W
04A9:  MOVWF  4C
....................          s[cnt]=(num%base)+'0';    // Conversion 
04AA:  MOVF   52,W
04AB:  ADDWF  4A,W
04AC:  MOVWF  78
04AD:  MOVF   4B,W
04AE:  MOVWF  7A
04AF:  BTFSC  03.0
04B0:  INCF   7A,F
04B1:  MOVF   78,W
04B2:  MOVWF  54
04B3:  MOVF   7A,W
04B4:  MOVWF  55
04B5:  CLRF   57
04B6:  MOVF   04,W
04B7:  MOVWF  56
04B8:  BCF    57.0
04B9:  BTFSC  03.7
04BA:  BSF    57.0
04BB:  BSF    03.1
04BC:  MOVLW  58
04BD:  MOVWF  04
04BE:  BSF    03.7
04BF:  MOVF   48,W
04C0:  MOVWF  5F
04C1:  MOVF   47,W
04C2:  MOVWF  5E
04C3:  MOVF   46,W
04C4:  MOVWF  5D
04C5:  MOVF   45,W
04C6:  MOVWF  5C
04C7:  CLRF   63
04C8:  CLRF   62
04C9:  CLRF   61
04CA:  MOVF   49,W
04CB:  MOVWF  60
04CC:  BCF    03.6
04CD:  CALL   3BF
04CE:  BSF    03.6
04CF:  MOVF   56,W
04D0:  MOVWF  04
04D1:  BCF    03.7
04D2:  BTFSC  57.0
04D3:  BSF    03.7
04D4:  MOVLW  30
04D5:  ADDWF  58,W
04D6:  MOVWF  77
04D7:  MOVF   59,W
04D8:  MOVWF  78
04D9:  MOVLW  00
04DA:  BTFSC  03.0
04DB:  MOVLW  01
04DC:  ADDWF  78,F
04DD:  MOVF   5A,W
04DE:  MOVWF  79
04DF:  MOVLW  00
04E0:  BTFSC  03.0
04E1:  MOVLW  01
04E2:  ADDWF  79,F
04E3:  MOVF   5B,W
04E4:  MOVWF  7A
04E5:  MOVLW  00
04E6:  BTFSC  03.0
04E7:  MOVLW  01
04E8:  ADDWF  7A,F
04E9:  MOVF   54,W
04EA:  MOVWF  04
04EB:  BCF    03.7
04EC:  BTFSC  55.0
04ED:  BSF    03.7
04EE:  MOVF   77,W
04EF:  MOVWF  00
....................  
....................          if(s[cnt]>0x39) 
04F0:  MOVF   52,W
04F1:  ADDWF  4A,W
04F2:  MOVWF  04
04F3:  BCF    03.7
04F4:  BTFSC  4B.0
04F5:  BSF    03.7
04F6:  MOVF   00,W
04F7:  SUBLW  39
04F8:  BTFSC  03.0
04F9:  GOTO   503
....................             s[cnt]+=0x7; 
04FA:  MOVF   52,W
04FB:  ADDWF  4A,W
04FC:  MOVWF  04
04FD:  BCF    03.7
04FE:  BTFSC  4B.0
04FF:  BSF    03.7
0500:  MOVLW  07
0501:  ADDWF  00,W
0502:  MOVWF  00
....................  
....................          cnt++; 
0503:  INCF   52,F
....................          num=temp; 
0504:  MOVF   4F,W
0505:  MOVWF  48
0506:  MOVF   4E,W
0507:  MOVWF  47
0508:  MOVF   4D,W
0509:  MOVWF  46
050A:  MOVF   4C,W
050B:  MOVWF  45
050C:  GOTO   485
....................      } 
....................  
....................      if(sign==1) { 
050D:  DECFSZ 51,W
050E:  GOTO   518
....................          s[cnt]=0x2D;      // Negative sign 
050F:  MOVF   52,W
0510:  ADDWF  4A,W
0511:  MOVWF  04
0512:  BCF    03.7
0513:  BTFSC  4B.0
0514:  BSF    03.7
0515:  MOVLW  2D
0516:  MOVWF  00
....................          cnt++; 
0517:  INCF   52,F
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
0518:  CLRF   50
0519:  BCF    03.0
051A:  RRF    52,W
051B:  SUBWF  50,W
051C:  BTFSC  03.0
051D:  GOTO   54E
....................  
....................          c=s[i]; 
051E:  MOVF   50,W
051F:  ADDWF  4A,W
0520:  MOVWF  04
0521:  BCF    03.7
0522:  BTFSC  4B.0
0523:  BSF    03.7
0524:  MOVF   00,W
0525:  MOVWF  53
....................          s[i]=s[cnt-i-1];        // Reverse the number 
0526:  MOVF   50,W
0527:  ADDWF  4A,W
0528:  MOVWF  78
0529:  MOVF   4B,W
052A:  MOVWF  7A
052B:  BTFSC  03.0
052C:  INCF   7A,F
052D:  MOVF   78,W
052E:  MOVWF  54
052F:  MOVF   7A,W
0530:  MOVWF  55
0531:  MOVF   50,W
0532:  SUBWF  52,W
0533:  ADDLW  FF
0534:  ADDWF  4A,W
0535:  MOVWF  04
0536:  BCF    03.7
0537:  BTFSC  4B.0
0538:  BSF    03.7
0539:  MOVF   00,W
053A:  MOVWF  56
053B:  MOVF   54,W
053C:  MOVWF  04
053D:  BCF    03.7
053E:  BTFSC  55.0
053F:  BSF    03.7
0540:  MOVF   56,W
0541:  MOVWF  00
....................          s[cnt-i-1]=c; 
0542:  MOVF   50,W
0543:  SUBWF  52,W
0544:  ADDLW  FF
0545:  ADDWF  4A,W
0546:  MOVWF  04
0547:  BCF    03.7
0548:  BTFSC  4B.0
0549:  BSF    03.7
054A:  MOVF   53,W
054B:  MOVWF  00
054C:  INCF   50,F
054D:  GOTO   519
....................      } 
....................      s[cnt]='\0';     // End the string 
054E:  MOVF   52,W
054F:  ADDWF  4A,W
0550:  MOVWF  04
0551:  BCF    03.7
0552:  BTFSC  4B.0
0553:  BSF    03.7
0554:  CLRF   00
....................      return s; 
0555:  MOVF   4A,W
0556:  MOVWF  78
0557:  MOVF   4B,W
0558:  MOVWF  79
0559:  BCF    03.6
055A:  RETURN
.................... } 
....................  
.................... #if defined(__PCD__) 
....................  
.................... char * itoa(signed int48 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int48 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... char * itoa(signed int64 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int64 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................       
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1;         
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................              
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #endif 
....................  
.................... float strtof(char *s, char *endptr) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s, char *endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float48)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float48)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s, char *endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float64)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float64)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtoulGO; 
....................  
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................    { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... int8 mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #if !defined(__PCD__) 
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2);  
.................... #else  
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2);  
.................... #endif 
....................  
....................  
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    unsigned int8 t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=1; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = 0; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
.................... #INCLUDE <STDIO.H> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDIO 
.................... #define _STDIO 
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #ifndef getc 
.................... #define getc getch 
.................... #define getchar getch 
.................... #define puts(s) {printf(s); putchar(13); putchar(10);} 
.................... #define putc putchar 
.................... #endif 
.................... /* maps error number to an error message. Writes a sequence of characters to 
.................... stderr stream thus: if s is not null then string pointed to by s follwed by 
.................... a colon (:) and a space and the appropriate error message returned by strerror 
.................... function with argument errno 
....................  
.................... Returns: no value 
.................... */ 
....................  
.................... #ifdef _ERRNO 
.................... void perror(char *s) 
.................... { 
....................   if(s) 
....................   fprintf(STDERR,"%s: ",s); 
....................   fprintf(STDERR,"%s\r\n",strerror(errno)); 
.................... } 
.................... #endif 
.................... #endif 
....................  
.................... #INCLUDE <MATH.H> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2011 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                    //// 
.................... //// History:                                                           //// 
.................... ////  * 9/20/2001 :  Improvments are made to sin/cos code.              //// 
.................... ////                 The code now is small, much faster,                //// 
.................... ////                 and more accurate.                                 //// 
.................... ////  * 2/21/2007 :  Compiler handles & operator differently and does   //// 
.................... ////                 not return generic (int8 *) so type cast is done   //// 
.................... ////  * 6/19/2010 :  Divisions by constants converted to multiplication //// 
.................... ////                 by its inverse to improve computation speed        //// 
.................... ////  * 1/21/2011 :  Constants used for double precision math updated   //// 
.................... ////                 Updated routines include 64 bit versions of cos,   //// 
.................... ////                 asin,atan,exp,log and dependant functions          //// 
.................... ////  * 1/31/2011 :  Optimized current 32-bit float routines for cos    //// 
.................... ////                 and log function                                   //// 
.................... ////  * 6/13/2011 :  Fixed PCD overload CEIL_FLOOR functions for values //// 
.................... ////                 greater then 10000000 and less then -10000000      //// 
.................... ////                                                                    //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef MATH_H 
.................... #define MATH_H 
....................  
.................... #ifdef PI 
.................... #undef  PI 
.................... #endif 
.................... #define PI     3.1415926535897932 
....................  
....................  
.................... #define SQRT2  1.4142135623730950 
....................  
.................... //float const ps[4] = {5.9304945, 21.125224, 8.9403076, 0.29730279}; 
.................... //float const qs[4] = {1.0000000, 15.035723, 17.764134, 2.4934718}; 
....................  
.................... ///////////////////////////// Round Functions ////////////////////////////// 
....................  
.................... float32 CEIL_FLOOR(float32 x, unsigned int8 n) 
.................... { 
....................    float32 y, res; 
....................    unsigned int16 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................       res = (float32)(unsigned int16)y; 
....................  
....................  else if (y < 10000000.0) 
....................    {  
....................       l = (unsigned int16)(y*0.000030517578125); 
....................       y = 32768.0*(y*0.000030517578125 - (float32)l); 
....................       res = 32768.0*(float32)l; 
....................       res += (float32)(unsigned int16)y; 
....................    } 
....................  
....................  else 
....................   res = y; 
....................  
....................  y = y - (float32)(unsigned int16)y; 
....................  
....................  if (s) 
....................   res = -res; 
....................  
....................  if (y != 0) 
....................  { 
....................   if (s == 1 && n == 0) 
....................    res -= 1.0; 
....................  
....................   if (s == 0 && n == 1) 
....................    res += 1.0; 
....................  } 
....................  if (x == 0) 
....................     res = 0; 
....................  
....................  return (res); 
.................... } 
....................  
.................... // Overloaded Functions to take care for new Data types in PCD 
.................... // Overloaded function CEIL_FLOOR() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 CEIL_FLOOR(float48 x, unsigned int8 n) 
.................... { 
....................    float48 y, res; 
....................    unsigned int32 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................       res = (float48)(unsigned int16)y; 
....................  
....................    else if (y < 549755813888.0) 
....................    { 
....................       l = (unsigned int32)(y*0.000030517578125); 
....................       y = 32768.0*(y*0.000030517578125 - (float48)l); 
....................       res = 32768.0*(float48)l; 
....................       res += (float48)(unsigned int16)y; 
....................    } 
....................    else 
....................    {   
....................       res = y; 
....................       y = 0.0; 
....................    } 
....................     
....................    if(y != 0) 
....................       y = y - (float48)(unsigned int16)y; 
....................  
....................    if (s) 
....................       res = -res; 
....................  
....................    if (y != 0) 
....................    { 
....................       if (s == 1 && n == 0) 
....................          res -= 1.0; 
....................  
....................       if (s == 0 && n == 1) 
....................          res += 1.0; 
....................    } 
....................    if (x == 0) 
....................       res = 0; 
....................  
....................    return (res); 
.................... } 
....................  
....................  
.................... // Overloaded function CEIL_FLOOR() for data type - Float64 
.................... float64 CEIL_FLOOR(float64 x, unsigned int8 n) 
.................... { 
....................    float64 y, res; 
....................    int64 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................       res = (float64)(unsigned int16)y; 
....................    else if (y < 4503599627370496.0) 
....................    { 
....................       l = (int64)(y*0.000030517578125); 
....................       y = 32768.0*(y*0.000030517578125 - (float64)l); 
....................       res = 32768.0*(float64)l; 
....................       res += (float64)(unsigned int16)y; 
....................    } 
....................    else 
....................    { 
....................       res = y; 
....................       y = 0.0; 
....................    } 
....................     
....................    if(y != 0) 
....................       y = y - (float64)(unsigned int16)y; 
....................  
....................    if (s) 
....................       res = -res; 
....................  
....................    if (y != 0) 
....................    { 
....................       if (s == 1 && n == 0) 
....................          res -= 1.0; 
....................  
....................       if (s == 0 && n == 1) 
....................          res += 1.0; 
....................    } 
....................     
....................    if (x == 0) 
....................       res = 0; 
....................  
....................    return (res); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float floor(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : rounds down the number x. 
.................... // Date : N/A 
.................... // 
.................... float32 floor(float32 x) 
.................... { 
....................    return CEIL_FLOOR(x,0); 
.................... } 
.................... // Following 2 functions are overloaded functions of floor() for PCD 
.................... // Overloaded function floor() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 floor(float48 x) 
.................... { 
....................    return CEIL_FLOOR(x, 0); 
.................... } 
....................  
.................... // Overloaded function floor() for data type - Float64 
.................... float64 floor(float64 x) 
.................... { 
....................    return CEIL_FLOOR(x, 0); 
.................... } 
.................... #endif 
....................  
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float ceil(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : rounds up the number x. 
.................... // Date : N/A 
.................... // 
.................... float32 ceil(float32 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
.................... // Following 2 functions are overloaded functions of ceil() for PCD 
.................... // Overloaded function ceil() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 ceil(float48 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
....................  
.................... // Overloaded function ceil() for data type - Float64 
.................... float64 ceil(float64 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
.................... #endif 
....................  
....................  //////////////////////////////////////////////////////////////////////////// 
.................... //   float fabs(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the absolute value of floating point number x 
.................... // Returns : returns the absolute value of x 
.................... // Date : N/A 
.................... // 
.................... #define fabs abs 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float fmod(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the floating point remainder of x/y 
.................... // Returns : returns the value of x= i*y, for some integer i such that, if y 
.................... // is non zero, the result has the same isgn of x na dmagnitude less than the 
.................... // magnitude of y. If y is zero then a domain error occurs. 
.................... // Date : N/A 
.................... // 
....................  
.................... float fmod(float32 x,float32 y) 
.................... { 
....................    float32 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... //Overloaded function for fmod() for PCD 
.................... // Overloaded function fmod() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 fmod(float48 x,float48 y) 
.................... { 
....................    float48 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... // Overloaded function fmod() for data type - Float64 
.................... float64 fmod(float64 x,float64 y) 
.................... { 
....................    float64 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... #endif 
.................... //////////////////// Exponential and logarithmic functions //////////////////// 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float exp(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (e^x) 
.................... // Date : N/A 
.................... // 
.................... #define LN2 0.6931471805599453 
.................... #define LN2_INV 1.4426950408889634073 
....................  
.................... float const pe[6] = {0.000207455774, 0.00127100575, 0.00965065093, 
....................                      0.0554965651,  0.240227138,  0.693147172}; 
....................  
....................  
.................... float32 exp(float32 x) 
.................... { 
....................    float32 y, res, r; 
....................    #if defined(__PCD__) 
....................    int8 data1; 
....................    #endif 
....................    signed int8 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 88.722838) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    n = (signed int16)(x*LN2_INV); 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
.................... #if !defined(__PCD__) 
....................    *((unsigned int8 *)(&res)) = n + 0x7F; 
.................... #endif 
....................  
.................... #if defined(__PCD__)  // Takes care of IEEE format for PCD 
....................    data1 = n+0x7F; 
....................    if(bit_test(data1,0)) 
....................    bit_set(*(((unsigned int8 *)(&res)+2)),7); 
....................    rotate_right(&data1,1); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&res)+3)) = data1; 
.................... #endif 
....................  
....................    y = y*LN2_INV - (float32)n; 
....................  
....................    r = pe[0]*y + pe[1]; 
....................    r = r*y + pe[2]; 
....................    r = r*y + pe[3]; 
....................    r = r*y + pe[4]; 
....................    r = r*y + pe[5]; 
....................  
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
....................  
....................  
.................... //Overloaded function for exp() for PCD 
.................... // Overloaded function exp() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 exp(float48 x) 
.................... { 
....................    float48 y, res, r; 
....................    int8 data1; 
....................    signed int8 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 88.722838) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    n = (signed int16)(x*LN2_INV); 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
....................  
....................    data1 = n+0x7F; 
....................    if(bit_test(data1,0)) 
....................    bit_set(*(((unsigned int8 *)(&res)+4)),7); 
....................    rotate_right(&data1,1); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&res)+5)) = data1; 
....................  
....................    y = y*LN2_INV - (float48)n; 
....................  
....................    r = pe[0]*y + pe[1]; 
....................    r = r*y + pe[2]; 
....................    r = r*y + pe[3]; 
....................    r = r*y + pe[4]; 
....................    r = r*y + pe[5]; 
....................  
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function exp() for data type - Float64 
.................... float64 const pe_64[12] ={9.30741400474913e-011,-4.28655416283316e-011, 
....................                           8.71486547014137e-009,9.84458531538385e-008, 
....................                           1.32588296983536e-006,1.52489283823016e-005, 
....................                           0.000154037598423921,0.00133335487036216, 
....................                           0.00961812936407326,0.0555041086222122, 
....................                           0.240226506962827,0.693147180559823}; 
....................  
.................... float64 exp(float64 x) 
.................... { 
....................    float64 y, res, r; 
....................    unsigned int16 data1, data2; 
....................    unsigned int16 *p; 
....................    signed int16 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 709.7827128) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x*LN2_INV; 
....................    n = (signed int16)y; 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
....................  
.................... #if !defined(__PCD__) 
....................    *((unsigned int16 *)(&res)) = n + 0x7F; 
.................... #endif 
....................    p= (((unsigned int16 *)(&res))+3); 
....................    data1 = *p; 
....................    data2 = *p;    
....................    data1 = n + 0x3FF; 
....................    data1 = data1 <<4; 
....................    if(bit_test(data2,15)) 
....................    bit_set(data1,15); 
....................    data2 = data2 & 0x000F; 
....................    data1 ^= data2; 
....................  
....................    *(((unsigned int16 *)(&res)+3)) = data1; 
....................  
....................  
....................    y = y*LN2_INV - (float64)n; 
....................  
....................    r = pe_64[0]*y + pe_64[1]; 
....................    r = r*y + pe_64[2]; 
....................    r = r*y + pe_64[3]; 
....................    r = r*y + pe_64[4]; 
....................    r = r*y + pe_64[5]; 
....................    r = r*y + pe_64[6]; 
....................    r = r*y + pe_64[7]; 
....................    r = r*y + pe_64[8]; 
....................    r = r*y + pe_64[9]; 
....................    r = r*y + pe_64[10]; 
....................    r = r*y + pe_64[11]; 
....................     
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
.................... #ENDIF 
....................  
....................  
.................... /************************************************************/ 
....................  
.................... float32 const pl[4] = {-1.080310025160955, 1.999999947089217}; 
.................... float32 const ql[4] = {0.091284365719509, -0.873491916557671}; 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float log(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the the natural log of x 
.................... // Date : N/A 
.................... // 
.................... float32 log(float32 x) 
.................... { 
....................    float32 y, res, r, y2; 
....................    #if defined(__PCD__) 
....................    unsigned int8  data1,data2; 
....................    #endif 
....................    signed int8 n; 
....................    #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
.................... #if !defined(__PCD__) 
....................     *((unsigned int8 *)(&y)) = 0x7E;  
.................... #endif 
....................  
.................... #if defined(__PCD__) // Takes care of IEEE format 
....................    data2 = *(((unsigned int8 *)(&y))+3); 
....................    *(((unsigned int8 *)(&y))+3) = 0x3F; 
....................    data1 = *(((unsigned int8 *)(&y))+2); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&y))+2) = data1; 
....................    if(bit_test(data2,7)) 
....................      bit_set(*(((unsigned int8 *)(&y))+3),7); 
.................... #endif 
....................  
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl[0]*y2 + pl[1]; 
....................  
....................       r = ql[0]*y2 + ql[1]; 
....................       r = r*y2 + 1.0; 
....................  
....................       res = y*res/r; 
.................... #if !defined(__PCD__) 
....................       n = *((unsigned int8 *)(&x)) - 0x7E; 
.................... #endif 
.................... #if defined(__PCD__)  
....................     data1 = *(((unsigned int8 *)(&x)+3)); 
....................     rotate_left(&data1,1); 
....................     data2 = *(((unsigned int8 *)(&x)+2)); 
....................     if(bit_test (data2,7)) 
....................       bit_set(data1,0); 
....................     n = data1 - 0x7E; 
.................... #endif 
....................  
....................       if (n<0)  
....................          r = -(float32)-n; 
....................       else 
....................          r = (float32)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................       res = 0.0; 
....................  
....................    return(res); 
.................... } 
....................  
.................... //Overloaded function for log() for PCD 
.................... // Overloaded function log() for data type - Float48 
.................... #if defined(__PCD__) 
.................... // Overloaded function log() for data type - float64 
.................... float64 const pl_64[4] = {-0.145694052150681, 1.365485300000370, 
....................                           -3.120535668274329, 2.000000000000000}; 
....................  
.................... float64 const ql_64[4] = {0.006047500465908, -0.208298281937234, 
....................                           1.113943039156721, -1.893601167470470}; 
....................  
.................... float48 log(float48 x) 
.................... { 
....................    float48 y, res, r, y2; 
....................    unsigned int8  data1,data2; 
....................    signed int8 n; 
.................... #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
.................... #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
....................  
.................... #if !defined(__PCD__) 
....................       *((unsigned int8 *)(&y)) = 0x7E;  
.................... #endif 
....................       data2 = *(((unsigned int8 *)(&y))+5); 
....................       *(((unsigned int8 *)(&y))+5) = 0x3F; 
....................       data1 = *(((unsigned int8 *)(&y))+4); 
....................       bit_clear(data1,7); 
....................       *(((unsigned int8 *)(&y))+4) = data1; 
....................  
....................       if(bit_test(data2,7)) 
....................       bit_set(*(((unsigned int8 *)(&y))+4),7); 
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl_64[0]*y2 + pl_64[1]; 
....................       res = res*y2 + pl_64[2]; 
....................       res = res*y2 + pl_64[3]; 
....................  
....................       r = ql_64[0]*y2 + ql_64[1]; 
....................       r = r*y2 + ql_64[2]; 
....................       r = r*y2 + ql_64[3]; 
....................       r = r*y2 + 1.0;  
....................       res = y*res/r; 
....................  
....................       data1 = *(((unsigned int8 *)(&x)+5)); 
....................       rotate_left(&data1,1); 
....................       data2 = *(((unsigned int8 *)(&x)+4)); 
....................       if(bit_test (data2,7)) 
....................       bit_set(data1,0); 
....................        
....................       n = data1 - 0x7E; 
....................  
....................       if (n<0) 
....................       r = -(float48)-n; 
....................       else 
....................       r = (float48)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................    res = 0.0; 
....................  
....................    return(res); 
.................... } 
....................  
.................... float64 log(float64 x) 
.................... { 
....................    float64 y, res, r, y2; 
....................    unsigned int16  data1,data2; 
....................    unsigned int16 *p; 
....................    signed int16 n; 
....................    #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
....................    #if !defined(__PCD__) 
....................        *((unsigned int8 *)(&y)) = 0x7E;  
....................    #endif 
....................       p= (((unsigned int16 *)(&y))+3); 
....................       data1 = *p; 
....................       data2 = *p; 
....................       data1 = 0x3FE; 
....................       data1 = data1 <<4; 
....................       if(bit_test (data2,15)) 
....................          bit_set(data1,15); 
....................       data2 = data2 & 0x000F; 
....................       data1 ^=data2; 
....................  
....................       *p = data1; 
....................  
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl_64[0]*y2 + pl_64[1]; 
....................       res = res*y2 + pl_64[2]; 
....................       res = res*y2 + pl_64[3]; 
....................  
....................       r = ql_64[0]*y2 + ql_64[1]; 
....................       r = r*y2 + ql_64[2]; 
....................       r = r*y2 + ql_64[3]; 
....................       r = r*y2 + 1.0; 
....................  
....................       res = y*res/r; 
....................   
....................       p= (((unsigned int16 *)(&x))+3); 
....................       data1 = *p; 
....................       bit_clear(data1,15); 
....................       data1 = data1 >>4;     
....................       n = data1 - 0x3FE; 
....................  
....................  
....................       if (n<0) 
....................          r = -(float64)-n; 
....................       else 
....................          r = (float64)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................       res = 0.0; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
....................  
.................... #define LN10 2.3025850929940456 
.................... #define LN10_INV 0.4342944819032518276 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float log10(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the the log base 10 of x 
.................... // Date : N/A 
.................... // 
.................... float32 log10(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = log(x); 
....................    r = r*LN10_INV; 
....................    return(r); 
.................... } 
....................  
.................... //Overloaded functions for log10() for PCD 
.................... // Overloaded function log10() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 log10(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = log(x); 
....................    r = r*LN10_INV; 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function log10() for data type - Float64 
.................... float64 log10(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = log(x); 
....................    r = r*LN10_INV; 
....................    return(r); 
.................... } 
.................... #endif 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float modf(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description :breaks the argument value int integral and fractional parts, 
.................... // ach of which have the same sign as the argument.  It stores the integral part 
.................... // as a float in the object pointed to by the iptr 
.................... // Returns : returns the signed fractional part of value. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 modf(float32 value,float32 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... //Overloaded functions for modf() for PCD 
.................... // Overloaded function modf() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 modf(float48 value,float48 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... // Overloaded function modf() for data type - Float64 
.................... float64 modf(float64 value,float64 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float pwr(float x,float y) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (x^y) 
.................... // Date : N/A 
.................... // Note : 0 is returned when the function will generate an imaginary number 
.................... // 
.................... float32 pwr(float32 x,float32 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... //Overloaded functions for pwr() for PCD 
.................... // Overloaded function pwr() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 pwr(float48 x,float48 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... // Overloaded function pwr() for data type - Float64 
.................... float64 pwr(float64 x,float64 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////// Power functions //////////////////// 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float pow(float x,float y) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (x^y) 
.................... // Date : N/A 
.................... // Note : 0 is returned when the function will generate an imaginary number 
.................... // 
.................... float32 pow(float32 x,float32 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... //Overloaded functions for pow() for PCD 
.................... // Overloaded function for pow() data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 pow(float48 x,float48 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
....................  
.................... // Overloaded function pow() for data type - Float64 
.................... float64 pow(float64 x,float64 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sqrt(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the square root of x 
.................... // Date : N/A 
.................... // 
.................... float32 sqrt(float32 x) 
.................... { 
....................    float32 y, res; 
....................    #if defined(__PCD__) 
....................    unsigned int16 data1,data2; 
....................    #endif 
....................    unsigned int8 *p; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................     
....................    #if !defined(__PCD__) 
....................     p=&y; 
....................    (*p)=(unsigned int8)((((unsigned int16)(*p)) + 127) >> 1); 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     p = (((unsigned int8 *)(&y))+3); 
....................     data1 = *(((unsigned int8 *)(&y))+3); 
....................     data2 = *(((unsigned int8 *)(&y))+2); 
....................     rotate_left(&data1,1);     
....................     if(bit_test(data2,7))     
....................        bit_set(data1,0);     
....................     data1 = ((data1+127) >>1); 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+3) = data1; 
....................     *(((unsigned int8 *)(&y))+2) = data2; 
....................      
....................   #endif 
....................  
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................  
....................       #if !defined(__PCD__) 
....................      (*p)--; 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     data1 = *(((unsigned int8 *)(&y))+3); 
....................     data2 = *(((unsigned int8 *)(&y))+2); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................        bit_set(data1,0);     
....................     data1--; 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+3) = data1; 
....................     *(((unsigned int8 *)(&y))+2) = data2; 
....................      
....................   #endif 
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
.................... //Overloaded functions for sqrt() for PCD 
.................... // Overloaded function sqrt() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sqrt(float48 x) 
.................... { 
....................    float48 y, res; 
....................    unsigned int16 data1,data2; 
....................    unsigned int8 *p; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................     
....................    #if !defined(__PCD__) 
....................     p=&y; 
....................    (*p)=(unsigned int8)((((unsigned int16)(*p)) + 127) >> 1); 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     p = (((unsigned int8 *)(&y))+5); 
....................     data1 = *(((unsigned int8 *)(&y))+5); 
....................     data2 = *(((unsigned int8 *)(&y))+4); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................        bit_set(data1,0);     
....................     data1 = ((data1+127) >>1); 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+5) = data1; 
....................     *(((unsigned int8 *)(&y))+4) = data2; 
....................      
....................   #endif 
....................  
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................  
....................       #if !defined(__PCD__) 
....................      (*p)--; 
....................    #endif 
....................     
....................     data1 = *(((unsigned int8 *)(&y))+5); 
....................     data2 = *(((unsigned int8 *)(&y))+4); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................        bit_set(data1,0);     
....................     data1--; 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+5) = data1; 
....................     *(((unsigned int8 *)(&y))+4) = data2; 
....................      
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function sqrt() for data type - Float64 
.................... float64 sqrt(float64 x) 
.................... { 
....................    float64 y, res; 
....................    unsigned int16 *p; 
....................    unsigned int16 temp1,temp2; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................    p= (((unsigned int16 *)(&y))+3); 
....................    temp1 = *p; 
....................    temp2 = *p; 
....................    bit_clear(temp1,15); 
....................    temp1 = (temp1>>4)+1023; 
....................    temp1 = temp1 >> 1; 
....................    temp1 = (temp1<<4) & 0xFFF0; 
....................    if(bit_test(temp2,15)) 
....................       bit_set(temp1,15); 
....................    temp2 = temp2 & 0x000F; 
....................    temp1 ^= temp2; 
....................     
....................    (*p) = temp1; 
....................     
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................      temp1 = *p; 
....................      temp2 = *p; 
....................      bit_clear(temp1,15); 
....................      temp1 = (temp1>>4); 
....................      temp1--; 
....................      temp1 = (temp1<<4) & 0xFFF0; 
....................      if(bit_test(temp2,15)) 
....................         bit_set(temp1,15); 
....................      temp2 = temp2 & 0x000F; 
....................      temp1 ^= temp2; 
....................      (*p) = temp1; 
....................  
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... ////////////////////////////// Trig Functions ////////////////////////////// 
.................... #ifdef PI_DIV_BY_TWO_INV 
.................... #undef PI_DIV_BY_TWO_INV 
.................... #endif 
.................... #define PI_DIV_BY_TWO_INV 0.63661977236758134 
.................... #ifdef PI_DIV_BY_TWO 
.................... #undef PI_DIV_BY_TWO 
.................... #endif 
.................... #define PI_DIV_BY_TWO   1.5707963267948966 
.................... #ifdef TWOBYPI 
.................... #undef TWOBYPI 
.................... #endif 
.................... #define TWOBYPI          0.6366197723675813 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float cos(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the cosine value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 cos(float32 x) 
.................... { 
....................    float32 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float32 frac; 
....................    float32 p[5] = {                    //by the series definition for cosine 
....................       -0.49999999456337096,            // sum ( ( (-1)^n * x^2n )/(2n)! ) 
....................        0.04166663896921267, 
....................       -0.00138883894522527, 
....................        0.00002476138231734, 
....................       -0.00000026070414770 
....................       //-0.00000000001147, 
....................       // 0.00000000000005 
....................    }; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant 
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 1.0; 
....................    t = t * t; 
....................    for (i = 0; i <= 4; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
....................  
.................... //Overloaded functions for cos() for PCD 
.................... // Overloaded function cos() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 cos(float48 x) 
.................... { 
....................    float48 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float48 frac; 
....................    float48 p[6] = {                    //by the series definition for cosine 
....................       -0.5,                            // sum ( ( (-1)^n * x^2n )/(2n)! ) 
....................        0.04166666666667, 
....................       -0.00138888888889, 
....................        0.00002480158730, 
....................       -0.00000027557319, 
....................        0.00000000208767, 
....................       //-0.00000000001147, 
....................       // 0.00000000000005 
....................    }; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant 
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 0.999999999781; 
....................    t = t * t; 
....................    for (i = 0; i <= 5; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
.................... // Overloaded function cos() for data type - Float64 
.................... float64 cos(float64 x) 
.................... { 
....................    float64 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float64 frac; 
....................    float64 p_64[9] = {               //by the series definition for cosine 
....................      -0.49999999999998740,           // sum ( ( (-1)^n * x^2n )/(2n)! )              
....................       0.04166666666656518, 
....................      -0.00138888888851691, 
....................       0.00002480158658490, 
....................      -0.00000027557239796, 
....................       0.00000000208715031, 
....................      -0.00000000001126577, 
....................       0.00000000000000427, 
....................       0.00000000000000372}; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant 
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 1.0; 
....................    t = t * t; 
....................    for (i = 0; i <= 8; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p_64[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sin(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the sine value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 sin(float32 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
....................  
.................... //Overloaded functions for sin() for PCD 
.................... // Overloaded function sin() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sin(float48 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
....................  
.................... // Overloaded function sin() for data type - Float48 
.................... float64 sin(float64 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float tan(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the tangent value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 tan(float32 x) 
.................... { 
....................    float32 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
.................... //Overloaded functions for tan() for PCD 
.................... // Overloaded function tan() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 tan(float48 x) 
.................... { 
....................    float48 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
....................  
.................... // Overloaded function tan() for data type - Float48 
.................... float64 tan(float64 x) 
.................... { 
....................    float64 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
.................... #endif 
....................  
.................... float32 const pas[3] = {0.49559947, -4.6145309, 5.6036290}; 
.................... float32 const qas[3] = {1.0000000,  -5.5484666, 5.6036290}; 
....................  
.................... float32 ASIN_COS(float32 x, unsigned int8 n) 
.................... { 
....................    float32 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)*0.5); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas[0]*y2 + pas[1]; 
....................    res = res*y2 + pas[2]; 
....................  
....................    r = qas[0]*y2 + qas[1]; 
....................    r = r*y2 + qas[2]; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
....................  
....................  
.................... //Overloaded functions for ASIN_COS() for PCD 
.................... // Overloaded function ASIN_COS() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 ASIN_COS(float48 x, unsigned int8 n) 
.................... { 
....................    float48 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)*0.5); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas[0]*y2 + pas[1]; 
....................    res = res*y2 + pas[2]; 
....................  
....................    r = qas[0]*y2 + qas[1]; 
....................    r = r*y2 + qas[2]; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function ASIN_COS() for data type - Float64 
.................... double pas_64[5]={1.000000000000000,-2.069938587724477,1.421444580548907, 
....................                  -0.360690137621842,0.024929451660228}; 
....................  
.................... double qas_64[5]={-2.236605254391134,1.719212122946451,-0.524122954476133, 
....................                    0.052808872045749,-0.000662536036570}; 
....................                     
.................... float64 ASIN_COS(float64 x, unsigned int8 n) 
.................... { 
....................    float64 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)*0.5); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas_64[4]*y2 + pas_64[3]; 
....................    res = res*y2 + pas_64[2]; 
....................    res = res*y2 + pas_64[1]; 
....................    res = res*y2 + pas_64[0]; 
....................  
....................    r = qas_64[4]*y2 + qas_64[3]; 
....................    r = r*y2 + qas_64[2]; 
....................    r = r*y2 + qas_64[1]; 
....................    r = r*y2 + qas_64[0]; 
....................    r = r*y2 + 1.0; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float asin(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arcsine value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 asin(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
.................... //Overloaded functions for asin() for PCD 
.................... // Overloaded function asin() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 asin(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function asin() for data type - Float64 
.................... float64 asin(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float acos(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arccosine value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 acos(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
.................... //Overloaded functions for acos() for PCD 
.................... // Overloaded function acos() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 acos(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function acos() for data type - Float64 
.................... float64 acos(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
.................... #endif 
....................  
.................... float32 const pat[4] = {0.17630401, 5.6710795, 22.376096, 19.818457}; 
.................... float32 const qat[4] = {1.0000000,  11.368190, 28.982246, 19.818457}; 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float atan(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arctangent value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 atan(float32 x) 
.................... { 
....................    float32 y, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................  
....................    res = pat[0]*y*y + pat[1]; 
....................    res = res*y*y + pat[2]; 
....................    res = res*y*y + pat[3]; 
....................  
....................    r = qat[0]*y*y + qat[1]; 
....................    r = r*y*y + qat[2]; 
....................    r = r*y*y + qat[3]; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
.................... //Overloaded functions for atan() for PCD 
.................... // Overloaded function atan() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 atan(float48 x) 
.................... { 
....................    float48 y, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................  
....................    res = pat[0]*y*y + pat[1]; 
....................    res = res*y*y + pat[2]; 
....................    res = res*y*y + pat[3]; 
....................  
....................    r = qat[0]*y*y + qat[1]; 
....................    r = r*y*y + qat[2]; 
....................    r = r*y*y + qat[3]; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
....................  
.................... float64 pat_64[6]={0.999999999999999,2.249923645595566,1.771541617806449, 
....................                    0.579678874003185,0.072162702162882,0.002281100141660}; 
....................  
.................... float64 qat_64[6]={2.583256978928510,2.432627277466967,1.016760379885393, 
....................                    0.182482977188688,0.011155377971690,0.000100013019160}; 
.................... // Overloaded function atan() for data type - Float64 
.................... float64 atan(float64 x) 
.................... { 
....................    float64 y,y2, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................    y2 = y*y; 
....................    res = pat_64[5]*y2 + pat_64[4]; 
....................    res = res*y2 + pat_64[3]; 
....................    res = res*y2 + pat_64[2]; 
....................    res = res*y2 + pat_64[1]; 
....................    res = res*y2 + pat_64[0]; 
....................  
....................    r = qat_64[5]*y2 + qat_64[4]; 
....................    r = r*y2 + qat_64[3]; 
....................    r = r*y2 + qat_64[2]; 
....................    r = r*y2 + qat_64[1]; 
....................    r = r*y2 + qat_64[0]; 
....................    r = r*y2 + 1.0; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... ///////////////////////////////////////////////////////////////////////////// 
.................... //   float atan2(float y, float x) 
.................... ///////////////////////////////////////////////////////////////////////////// 
.................... // Description :computes the principal value of arc tangent of y/x, using the 
.................... // signs of both the arguments to determine the quadrant of the return value 
.................... // Returns : returns the arc tangent of y/x. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 atan2(float32 y,float32 x) 
.................... { 
....................    float32 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
....................  
.................... //Overloaded functions for atan2() for PCD 
.................... // Overloaded function atan2() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 atan2(float48 y,float48 x) 
.................... { 
....................    float48 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
....................  
.................... // Overloaded function atan2() for data type - Float64 
.................... float64 atan2(float64 y,float64 x) 
.................... { 
....................    float64 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////// Hyperbolic functions //////////////////// 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float cosh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic cosine value of x 
.................... // Returns : returns the hyperbolic cosine value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 cosh(float32 x) 
.................... { 
....................    return ((exp(x)+exp(-x))*0.5); 
.................... } 
.................... //Overloaded functions for cosh() for PCD 
.................... // Overloaded function cosh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 cosh(float48 x) 
.................... { 
....................    return ((exp(x)+exp(-x))*0.5); 
.................... } 
....................  
.................... // Overloaded function cosh() for data type - Float64 
.................... float64 cosh(float64 x) 
.................... { 
....................    return ((exp(x)+exp(-x))*0.5); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sinh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic sine value of x 
.................... // Returns : returns the hyperbolic sine value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 sinh(float32 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))*0.5); 
.................... } 
.................... //Overloaded functions for sinh() for PCD 
.................... // Overloaded function sinh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sinh(float48 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))*0.5); 
.................... } 
....................  
.................... // Overloaded function sinh() for data type - Float48 
.................... float64 sinh(float64 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))*0.5); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float tanh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic tangent value of x 
.................... // Returns : returns the hyperbolic tangent value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 tanh(float32 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
.................... //Overloaded functions for tanh() for PCD 
.................... // Overloaded function tanh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 tanh(float48 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
....................  
.................... // Overloaded function tanh() for data type - Float64 
.................... float64 tanh(float64 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float frexp(float x, signed int *exp) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : breaks a floating point number into a normalized fraction and an integral 
.................... // power of 2. It stores the integer in the signed int object pointed to by exp. 
.................... // Returns : returns the value x, such that x is a double with magnitude in the interval 
.................... // [1/2,1) or zero, and value equals x times 2 raised to the power *exp.If value is zero, 
.................... // both parts of the result are zero. 
.................... // Date : N/A 
.................... // 
....................  
.................... #define LOG2 .30102999566398119521 
.................... #define LOG2_INV 3.32192809488736234787 
.................... float32 frexp(float32 x, signed int8 *exp) 
.................... { 
....................    float32 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)*LOG2_INV)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
....................  
.................... //Overloaded functions for frexp() for PCD 
.................... // Overloaded function frexp() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 frexp(float48 x, signed int8 *exp) 
.................... { 
....................    float48 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)*LOG2_INV)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
....................  
.................... // Overloaded function frexp() for data type - Float64 
.................... float64 frexp(float64 x, signed int8 *exp) 
.................... { 
....................    float64 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)*LOG2_INV)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
.................... #endif 
....................  
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... //   float ldexp(float x, signed int *exp) 
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... // Description : multiplies a floating point number by an integral power of 2. 
.................... // Returns : returns the value of x times 2 raised to the power exp. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 ldexp(float32 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... //Overloaded functions for ldexp() for PCD 
.................... // Overloaded function ldexp() for data type - Float48 
....................  
.................... #if defined(__PCD__) 
.................... float48 ldexp(float48 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... // Overloaded function ldexp() for data type - Float64 
.................... float64 ldexp(float64 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... #endif 
....................  
.................... #endif 
....................  
.................... #INCLUDE <xuatbyte74595.c> 
....................  
.................... #DEFINE      DS               PIN_D1 
.................... #DEFINE      SH_CP            PIN_D0   
.................... #DEFINE      STCP             PIN_D2 
.................... VOID XUATTRANGTHAI(UNSIGNED INT8 BYTEXUAT) 
.................... { 
....................    UNSIGNED INT8   SB;    
....................    #BIT BSERI  = BYTEXUAT.7 
....................     
....................    FOR (SB=0;SB<8;SB++) 
*
0CD0:  CLRF   20
0CD1:  MOVF   20,W
0CD2:  SUBLW  07
0CD3:  BTFSS  03.0
0CD4:  GOTO   4EB
....................       {                                                  
....................          OUTPUT_BIT(DS,BSERI);     
0CD5:  BTFSC  1F.7
0CD6:  GOTO   4DB
0CD7:  BCF    03.6
0CD8:  BCF    08.1
0CD9:  GOTO   4DD
0CDA:  BSF    03.6
0CDB:  BCF    03.6
0CDC:  BSF    08.1
0CDD:  BSF    03.5
0CDE:  BCF    08.1
....................          OUTPUT_LOW(SH_CP); OUTPUT_HIGH(SH_CP); 
0CDF:  BCF    08.0
0CE0:  BCF    03.5
0CE1:  BCF    08.0
0CE2:  BSF    03.5
0CE3:  BCF    08.0
0CE4:  BCF    03.5
0CE5:  BSF    08.0
....................          BYTEXUAT=BYTEXUAT<<1; //10010010->00100100   
0CE6:  BCF    03.0
0CE7:  BSF    03.6
0CE8:  RLF    1F,F
0CE9:  INCF   20,F
0CEA:  GOTO   4D1
....................      } 
....................       OUTPUT_LOW(STCP); OUTPUT_HIGH(STCP); 
0CEB:  BSF    03.5
0CEC:  BCF    03.6
0CED:  BCF    08.2
0CEE:  BCF    03.5
0CEF:  BCF    08.2
0CF0:  BSF    03.5
0CF1:  BCF    08.2
0CF2:  BCF    03.5
0CF3:  BSF    08.2
.................... } 
....................  
....................  
.................... #FUSES NOWDT, PUT, HS 
.................... #USE DELAY(CLOCK=4M) 
*
0176:  MOVLW  47
0177:  MOVWF  04
0178:  BSF    03.7
0179:  MOVF   00,W
017A:  BTFSC  03.2
017B:  GOTO   18A
017C:  MOVLW  01
017D:  MOVWF  78
017E:  CLRF   77
017F:  DECFSZ 77,F
0180:  GOTO   17F
0181:  DECFSZ 78,F
0182:  GOTO   17E
0183:  MOVLW  4A
0184:  MOVWF  77
0185:  DECFSZ 77,F
0186:  GOTO   185
0187:  GOTO   188
0188:  DECFSZ 00,F
0189:  GOTO   17C
018A:  RETURN
.................... #USE RS232(BAUD=9600,XMIT=PIN_C6,RCV=PIN_C7) 
.................... #DEFINE BT1_PIN PIN_B1 
.................... #DEFINE BT2_PIN PIN_B2 
.................... #DEFINE BT3_PIN PIN_B3 
.................... #DEFINE LCD_ENABLE_PIN  PIN_E0                                    
.................... #DEFINE LCD_RS_PIN      PIN_E1                                 
.................... #DEFINE LCD_RW_PIN      PIN_E2   
.................... #DEFINE LCD_DATA4       PIN_C0                                
.................... #DEFINE LCD_DATA5       PIN_C1                                  
.................... #DEFINE LCD_DATA6       PIN_C2                                    
.................... #DEFINE LCD_DATA7       PIN_C3   
.................... #INCLUDE <LCD.C> 
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... ////                             LCD.C                                     //// 
.................... ////                 Driver for common LCD modules                         //// 
.................... ////                                                                       //// 
.................... ////  lcd_init()   Must be called before any other function.               //// 
.................... ////                                                                       //// 
.................... ////  lcd_putc(c)  Will display c on the next position of the LCD.         //// 
.................... ////                 \a  Set cursor position to upper left                 //// 
.................... ////                 \f  Clear display, set cursor to upper left           //// 
.................... ////                 \n  Go to start of second line                        //// 
.................... ////                 \b  Move back one position                            //// 
.................... ////              If LCD_EXTENDED_NEWLINE is defined, the \n character     //// 
.................... ////              will erase all remanining characters on the current      //// 
.................... ////              line, and move the cursor to the beginning of the next   //// 
.................... ////              line.                                                    //// 
.................... ////              If LCD_EXTENDED_NEWLINE is defined, the \r character     //// 
.................... ////              will move the cursor to the start of the current         //// 
.................... ////              line.                                                    //// 
.................... ////                                                                       //// 
.................... ////  lcd_gotoxy(x,y) Set write position on LCD (upper left is 1,1)        //// 
.................... ////                                                                       //// 
.................... ////  lcd_getc(x,y)   Returns character at position x,y on LCD             //// 
.................... ////                                                                       //// 
.................... ////  lcd_cursor_on(int1 on)   Turn the cursor on (on=TRUE) or off         //// 
.................... ////              (on=FALSE).                                              //// 
.................... ////                                                                       //// 
.................... ////  lcd_set_cgram_char(w, *p)   Write a custom character to the CGRAM.   //// 
.................... ////                                                                       //// 
.................... ////                                                                       //// 
.................... ////  CONFIGURATION                                                        //// 
.................... ////  The LCD can be configured in one of two ways: a.) port access or     //// 
.................... ////  b.) pin access.  Port access requires the entire 7 bit interface     //// 
.................... ////  connected to one GPIO port, and the data bits (D4:D7 of the LCD)     //// 
.................... ////  connected to sequential pins on the GPIO.  Pin access                //// 
.................... ////  has no requirements, all 7 bits of the control interface can         //// 
.................... ////  can be connected to any GPIO using several ports.                    //// 
.................... ////                                                                       //// 
.................... ////  To use port access, #define LCD_DATA_PORT to the SFR location of     //// 
.................... ////  of the GPIO port that holds the interface, -AND- edit LCD_PIN_MAP    //// 
.................... ////  of this file to configure the pin order.  If you are using a         //// 
.................... ////  baseline PIC (PCB), then LCD_OUTPUT_MAP and LCD_INPUT_MAP also must  //// 
.................... ////  be defined.                                                          //// 
.................... ////                                                                       //// 
.................... ////  Example of port access:                                              //// 
.................... ////     #define LCD_DATA_PORT getenv("SFR:PORTD")                         //// 
.................... ////                                                                       //// 
.................... ////  To use pin access, the following pins must be defined:               //// 
.................... ////     LCD_ENABLE_PIN                                                    //// 
.................... ////     LCD_RS_PIN                                                        //// 
.................... ////     LCD_RW_PIN                                                        //// 
.................... ////     LCD_DATA4                                                         //// 
.................... ////     LCD_DATA5                                                         //// 
.................... ////     LCD_DATA6                                                         //// 
.................... ////     LCD_DATA7                                                         //// 
.................... ////                                                                       //// 
.................... ////  Example of pin access:                                               //// 
.................... ////     #define LCD_ENABLE_PIN  PIN_E0                                    //// 
.................... ////     #define LCD_RS_PIN      PIN_E1                                    //// 
.................... ////     #define LCD_RW_PIN      PIN_E2                                    //// 
.................... ////     #define LCD_DATA4       PIN_D4                                    //// 
.................... ////     #define LCD_DATA5       PIN_D5                                    //// 
.................... ////     #define LCD_DATA6       PIN_D6                                    //// 
.................... ////     #define LCD_DATA7       PIN_D7                                    //// 
.................... ////                                                                       //// 
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2010 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef __LCD_C__ 
.................... #define __LCD_C__ 
....................  
.................... // define the pinout. 
.................... // only required if port access is being used. 
.................... typedef struct   
.................... {                            // This structure is overlayed 
....................    int1 enable;           // on to an I/O port to gain 
....................    int1 rs;               // access to the LCD pins. 
....................    int1 rw;               // The bits are allocated from 
....................    int1 unused;           // low order up.  ENABLE will 
....................    unsigned int     data : 4;         // be LSB pin of that port. 
....................   #if defined(__PCD__)       // The port used will be LCD_DATA_PORT. 
....................    unsigned int    reserved: 8; 
....................   #endif 
.................... } LCD_PIN_MAP; 
....................  
.................... // this is to improve compatability with previous LCD drivers that accepted 
.................... // a define labeled 'use_portb_lcd' that configured the LCD onto port B. 
.................... #if ((defined(use_portb_lcd)) && (use_portb_lcd==TRUE)) 
....................  #define LCD_DATA_PORT getenv("SFR:PORTB") 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
....................    // these definitions only need to be modified for baseline PICs. 
....................    // all other PICs use LCD_PIN_MAP or individual LCD_xxx pin definitions. 
.................... /*                                    EN, RS,   RW,   UNUSED,  DATA  */ 
....................  const LCD_PIN_MAP LCD_OUTPUT_MAP =  {0,  0,    0,    0,       0}; 
....................  const LCD_PIN_MAP LCD_INPUT_MAP =   {0,  0,    0,    0,       0xF}; 
.................... #endif 
....................  
.................... ////////////////////// END CONFIGURATION /////////////////////////////////// 
....................  
.................... #ifndef LCD_ENABLE_PIN 
....................    #define lcd_output_enable(x) lcdlat.enable=x 
....................    #define lcd_enable_tris()   lcdtris.enable=0 
.................... #else 
....................    #define lcd_output_enable(x) output_bit(LCD_ENABLE_PIN, x) 
....................    #define lcd_enable_tris()  output_drive(LCD_ENABLE_PIN) 
.................... #endif 
....................  
.................... #ifndef LCD_RS_PIN 
....................    #define lcd_output_rs(x) lcdlat.rs=x 
....................    #define lcd_rs_tris()   lcdtris.rs=0 
.................... #else 
....................    #define lcd_output_rs(x) output_bit(LCD_RS_PIN, x) 
....................    #define lcd_rs_tris()  output_drive(LCD_RS_PIN) 
.................... #endif 
....................  
.................... #ifndef LCD_RW_PIN 
....................    #define lcd_output_rw(x) lcdlat.rw=x 
....................    #define lcd_rw_tris()   lcdtris.rw=0 
.................... #else 
....................    #define lcd_output_rw(x) output_bit(LCD_RW_PIN, x) 
....................    #define lcd_rw_tris()  output_drive(LCD_RW_PIN) 
.................... #endif 
....................  
.................... // original version of this library incorrectly labeled LCD_DATA0 as LCD_DATA4, 
.................... // LCD_DATA1 as LCD_DATA5, and so on.  this block of code makes the driver 
.................... // compatible with any code written for the original library 
.................... #if (defined(LCD_DATA0) && defined(LCD_DATA1) && defined(LCD_DATA2) && defined(LCD_DATA3) && !defined(LCD_DATA4) && !defined(LCD_DATA5) && !defined(LCD_DATA6) && !defined(LCD_DATA7)) 
....................    #define  LCD_DATA4    LCD_DATA0 
....................    #define  LCD_DATA5    LCD_DATA1 
....................    #define  LCD_DATA6    LCD_DATA2 
....................    #define  LCD_DATA7    LCD_DATA3 
.................... #endif 
....................  
.................... #ifndef LCD_DATA4 
.................... #ifndef LCD_DATA_PORT 
....................    #if defined(__PCB__) 
....................       #define LCD_DATA_PORT      0x06     //portb 
....................       #define set_tris_lcd(x)   set_tris_b(x) 
....................    #else 
....................      #if defined(PIN_D0) 
....................       #define LCD_DATA_PORT      getenv("SFR:PORTD")     //portd 
....................      #else 
....................       #define LCD_DATA_PORT      getenv("SFR:PORTB")     //portb 
....................      #endif 
....................    #endif    
.................... #endif 
....................  
.................... #if defined(__PCB__) 
....................    LCD_PIN_MAP lcd, lcdlat; 
....................    #byte lcd = LCD_DATA_PORT 
....................    #byte lcdlat = LCD_DATA_PORT 
.................... #elif defined(__PCM__) 
....................    LCD_PIN_MAP lcd, lcdlat, lcdtris; 
....................    #byte lcd = LCD_DATA_PORT 
....................    #byte lcdlat = LCD_DATA_PORT 
....................    #byte lcdtris = LCD_DATA_PORT+0x80 
.................... #elif defined(__PCH__) 
....................    LCD_PIN_MAP lcd, lcdlat, lcdtris; 
....................    #byte lcd = LCD_DATA_PORT 
....................    #byte lcdlat = LCD_DATA_PORT+9 
....................    #byte lcdtris = LCD_DATA_PORT+0x12 
.................... #elif defined(__PCD__) 
....................    LCD_PIN_MAP lcd, lcdlat, lcdtris; 
....................    #word lcd = LCD_DATA_PORT 
....................    #word lcdlat = LCD_DATA_PORT+2 
....................    #word lcdtris = LCD_DATA_PORT-0x02 
.................... #endif 
.................... #endif   //LCD_DATA4 not defined 
....................  
.................... #ifndef LCD_TYPE 
....................    #define LCD_TYPE 2           // 0=5x7, 1=5x10, 2=2 lines 
.................... #endif 
....................  
.................... #ifndef LCD_LINE_TWO 
....................    #define LCD_LINE_TWO 0x40    // LCD RAM address for the second line 
.................... #endif 
....................  
.................... #ifndef LCD_LINE_LENGTH 
....................    #define LCD_LINE_LENGTH 20 
.................... #endif 
....................  
.................... unsigned int8 lcd_read_nibble(void); 
....................  
.................... unsigned int8 lcd_read_byte(void) 
.................... { 
....................    unsigned int8 low,high; 
....................  
....................  #if defined(__PCB__) 
....................    set_tris_lcd(LCD_INPUT_MAP); 
....................  #else 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    output_float(LCD_DATA4); 
*
0219:  BSF    07.0
....................    output_float(LCD_DATA5); 
021A:  BSF    07.1
....................    output_float(LCD_DATA6); 
021B:  BSF    07.2
....................    output_float(LCD_DATA7); 
021C:  BSF    07.3
....................   #else 
....................    lcdtris.data = 0xF; 
....................   #endif 
....................  #endif 
....................          
....................    lcd_output_rw(1); 
021D:  BCF    03.5
021E:  BSF    09.2
021F:  BSF    03.5
0220:  BCF    09.2
....................    delay_cycles(1); 
0221:  NOP
....................    lcd_output_enable(1); 
0222:  BCF    03.5
0223:  BSF    09.0
0224:  BSF    03.5
0225:  BCF    09.0
....................    delay_cycles(1); 
0226:  NOP
....................    high = lcd_read_nibble(); 
0227:  BCF    03.5
0228:  CALL   1CE
0229:  MOVF   78,W
022A:  BSF    03.6
022B:  MOVWF  4E
....................        
....................    lcd_output_enable(0); 
022C:  BCF    03.6
022D:  BCF    09.0
022E:  BSF    03.5
022F:  BCF    09.0
....................    delay_cycles(1); 
0230:  NOP
....................    lcd_output_enable(1); 
0231:  BCF    03.5
0232:  BSF    09.0
0233:  BSF    03.5
0234:  BCF    09.0
....................    delay_us(1); 
0235:  NOP
....................    low = lcd_read_nibble(); 
0236:  BCF    03.5
0237:  CALL   1CE
0238:  MOVF   78,W
0239:  BSF    03.6
023A:  MOVWF  4D
....................        
....................    lcd_output_enable(0); 
023B:  BCF    03.6
023C:  BCF    09.0
023D:  BSF    03.5
023E:  BCF    09.0
....................  
....................  #if defined(__PCB__) 
....................    set_tris_lcd(LCD_OUTPUT_MAP); 
....................  #else 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    output_drive(LCD_DATA4); 
023F:  BCF    03.5
0240:  BCF    31.0
0241:  MOVF   31,W
0242:  BSF    03.5
0243:  MOVWF  07
....................    output_drive(LCD_DATA5); 
0244:  BCF    03.5
0245:  BCF    31.1
0246:  MOVF   31,W
0247:  BSF    03.5
0248:  MOVWF  07
....................    output_drive(LCD_DATA6); 
0249:  BCF    03.5
024A:  BCF    31.2
024B:  MOVF   31,W
024C:  BSF    03.5
024D:  MOVWF  07
....................    output_drive(LCD_DATA7); 
024E:  BCF    03.5
024F:  BCF    31.3
0250:  MOVF   31,W
0251:  BSF    03.5
0252:  MOVWF  07
....................   #else 
....................    lcdtris.data = 0x0; 
....................   #endif 
....................  #endif 
....................  
....................    return( (high<<4) | low); 
0253:  BCF    03.5
0254:  BSF    03.6
0255:  SWAPF  4E,W
0256:  MOVWF  77
0257:  MOVLW  F0
0258:  ANDWF  77,F
0259:  MOVF   77,W
025A:  IORWF  4D,W
025B:  MOVWF  78
.................... } 
....................  
.................... unsigned int8 lcd_read_nibble(void) 
.................... { 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
*
01CE:  BSF    03.6
01CF:  CLRF   4F
....................    unsigned int8 n = 0x00; 
....................  
....................    /* Read the data port */ 
....................    n |= input(LCD_DATA4); 
01D0:  BCF    03.6
01D1:  BSF    31.0
01D2:  MOVF   31,W
01D3:  BSF    03.5
01D4:  MOVWF  07
01D5:  MOVLW  00
01D6:  BCF    03.5
01D7:  BTFSC  07.0
01D8:  MOVLW  01
01D9:  BSF    03.6
01DA:  IORWF  4F,F
....................    n |= input(LCD_DATA5) << 1; 
01DB:  BCF    03.6
01DC:  BSF    31.1
01DD:  MOVF   31,W
01DE:  BSF    03.5
01DF:  MOVWF  07
01E0:  MOVLW  00
01E1:  BCF    03.5
01E2:  BTFSC  07.1
01E3:  MOVLW  01
01E4:  MOVWF  77
01E5:  BCF    03.0
01E6:  RLF    77,F
01E7:  MOVF   77,W
01E8:  BSF    03.6
01E9:  IORWF  4F,F
....................    n |= input(LCD_DATA6) << 2; 
01EA:  BCF    03.6
01EB:  BSF    31.2
01EC:  MOVF   31,W
01ED:  BSF    03.5
01EE:  MOVWF  07
01EF:  MOVLW  00
01F0:  BCF    03.5
01F1:  BTFSC  07.2
01F2:  MOVLW  01
01F3:  MOVWF  77
01F4:  RLF    77,F
01F5:  RLF    77,F
01F6:  MOVLW  FC
01F7:  ANDWF  77,F
01F8:  MOVF   77,W
01F9:  BSF    03.6
01FA:  IORWF  4F,F
....................    n |= input(LCD_DATA7) << 3; 
01FB:  BCF    03.6
01FC:  BSF    31.3
01FD:  MOVF   31,W
01FE:  BSF    03.5
01FF:  MOVWF  07
0200:  MOVLW  00
0201:  BCF    03.5
0202:  BTFSC  07.3
0203:  MOVLW  01
0204:  MOVWF  77
0205:  RLF    77,F
0206:  RLF    77,F
0207:  RLF    77,F
0208:  MOVLW  F8
0209:  ANDWF  77,F
020A:  MOVF   77,W
020B:  BSF    03.6
020C:  IORWF  4F,F
....................     
....................    return(n); 
020D:  MOVF   4F,W
020E:  MOVWF  78
....................   #else 
020F:  BCF    03.6
0210:  RETURN
....................    return(lcd.data); 
....................   #endif 
.................... } 
....................  
.................... void lcd_send_nibble(unsigned int8 n) 
.................... { 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    /* Write to the data port */ 
....................    output_bit(LCD_DATA4, bit_test(n, 0)); 
*
018B:  BSF    03.6
018C:  BTFSC  4E.0
018D:  GOTO   192
018E:  BCF    03.6
018F:  BCF    07.0
0190:  GOTO   194
0191:  BSF    03.6
0192:  BCF    03.6
0193:  BSF    07.0
0194:  BCF    31.0
0195:  MOVF   31,W
0196:  BSF    03.5
0197:  MOVWF  07
....................    output_bit(LCD_DATA5, bit_test(n, 1)); 
0198:  BCF    03.5
0199:  BSF    03.6
019A:  BTFSC  4E.1
019B:  GOTO   1A0
019C:  BCF    03.6
019D:  BCF    07.1
019E:  GOTO   1A2
019F:  BSF    03.6
01A0:  BCF    03.6
01A1:  BSF    07.1
01A2:  BCF    31.1
01A3:  MOVF   31,W
01A4:  BSF    03.5
01A5:  MOVWF  07
....................    output_bit(LCD_DATA6, bit_test(n, 2)); 
01A6:  BCF    03.5
01A7:  BSF    03.6
01A8:  BTFSC  4E.2
01A9:  GOTO   1AE
01AA:  BCF    03.6
01AB:  BCF    07.2
01AC:  GOTO   1B0
01AD:  BSF    03.6
01AE:  BCF    03.6
01AF:  BSF    07.2
01B0:  BCF    31.2
01B1:  MOVF   31,W
01B2:  BSF    03.5
01B3:  MOVWF  07
....................    output_bit(LCD_DATA7, bit_test(n, 3)); 
01B4:  BCF    03.5
01B5:  BSF    03.6
01B6:  BTFSC  4E.3
01B7:  GOTO   1BC
01B8:  BCF    03.6
01B9:  BCF    07.3
01BA:  GOTO   1BE
01BB:  BSF    03.6
01BC:  BCF    03.6
01BD:  BSF    07.3
01BE:  BCF    31.3
01BF:  MOVF   31,W
01C0:  BSF    03.5
01C1:  MOVWF  07
....................   #else       
....................    lcdlat.data = n; 
....................   #endif 
....................        
....................    delay_cycles(1); 
01C2:  NOP
....................    lcd_output_enable(1); 
01C3:  BCF    03.5
01C4:  BSF    09.0
01C5:  BSF    03.5
01C6:  BCF    09.0
....................    delay_us(2); 
01C7:  GOTO   1C8
....................    lcd_output_enable(0); 
01C8:  BCF    03.5
01C9:  BCF    09.0
01CA:  BSF    03.5
01CB:  BCF    09.0
01CC:  BCF    03.5
01CD:  RETURN
.................... } 
....................  
.................... void lcd_send_byte(unsigned int8 address, unsigned int8 n) 
.................... { 
....................   #if defined(__PCB__) 
....................    set_tris_lcd(LCD_OUTPUT_MAP); 
....................   #else 
....................    lcd_enable_tris(); 
*
0211:  BSF    03.5
0212:  BCF    09.0
....................    lcd_rs_tris(); 
0213:  BCF    09.1
....................    lcd_rw_tris(); 
0214:  BCF    09.2
....................   #endif 
....................  
....................    lcd_output_rs(0); 
0215:  BCF    03.5
0216:  BCF    09.1
0217:  BSF    03.5
0218:  BCF    09.1
....................    while ( bit_test(lcd_read_byte(),7) ) ; 
*
025C:  MOVF   78,W
025D:  MOVWF  4D
025E:  BTFSS  4D.7
025F:  GOTO   263
0260:  BSF    03.5
0261:  BCF    03.6
0262:  GOTO   219
....................    lcd_output_rs(address); 
0263:  MOVF   4B,F
0264:  BTFSS  03.2
0265:  GOTO   26A
0266:  BCF    03.6
0267:  BCF    09.1
0268:  GOTO   26C
0269:  BSF    03.6
026A:  BCF    03.6
026B:  BSF    09.1
026C:  BSF    03.5
026D:  BCF    09.1
....................    delay_cycles(1); 
026E:  NOP
....................    lcd_output_rw(0); 
026F:  BCF    03.5
0270:  BCF    09.2
0271:  BSF    03.5
0272:  BCF    09.2
....................    delay_cycles(1); 
0273:  NOP
....................    lcd_output_enable(0); 
0274:  BCF    03.5
0275:  BCF    09.0
0276:  BSF    03.5
0277:  BCF    09.0
....................    lcd_send_nibble(n >> 4); 
0278:  BCF    03.5
0279:  BSF    03.6
027A:  SWAPF  4C,W
027B:  MOVWF  4D
027C:  MOVLW  0F
027D:  ANDWF  4D,F
027E:  MOVF   4D,W
027F:  MOVWF  4E
0280:  BCF    03.6
0281:  CALL   18B
....................    lcd_send_nibble(n & 0xf); 
0282:  BSF    03.6
0283:  MOVF   4C,W
0284:  ANDLW  0F
0285:  MOVWF  4D
0286:  MOVWF  4E
0287:  BCF    03.6
0288:  CALL   18B
0289:  RETURN
.................... } 
....................  
.................... #if defined(LCD_EXTENDED_NEWLINE) 
.................... unsigned int8 g_LcdX, g_LcdY; 
.................... #endif 
....................  
.................... void lcd_init(void)  
.................... { 
....................    unsigned int8 i; 
....................    unsigned int8 LCD_INIT_STRING[4] = {0x20 | (LCD_TYPE << 2), 0xc, 1, 6}; 
028A:  MOVLW  28
028B:  BSF    03.6
028C:  MOVWF  17
028D:  MOVLW  0C
028E:  MOVWF  18
028F:  MOVLW  01
0290:  MOVWF  19
0291:  MOVLW  06
0292:  MOVWF  1A
....................                              // These bytes need to be sent to the LCD 
....................                              // to start it up. 
....................     
....................  
....................    lcd_output_enable(0); 
0293:  BCF    03.6
0294:  BCF    09.0
0295:  BSF    03.5
0296:  BCF    09.0
....................    lcd_output_rs(0); 
0297:  BCF    03.5
0298:  BCF    09.1
0299:  BSF    03.5
029A:  BCF    09.1
....................    lcd_output_rw(0); 
029B:  BCF    03.5
029C:  BCF    09.2
029D:  BSF    03.5
029E:  BCF    09.2
....................  
....................  #if defined(__PCB__) 
....................    set_tris_lcd(LCD_OUTPUT_MAP); 
....................  #else 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    output_drive(LCD_DATA4); 
029F:  BCF    03.5
02A0:  BCF    31.0
02A1:  MOVF   31,W
02A2:  BSF    03.5
02A3:  MOVWF  07
....................    output_drive(LCD_DATA5); 
02A4:  BCF    03.5
02A5:  BCF    31.1
02A6:  MOVF   31,W
02A7:  BSF    03.5
02A8:  MOVWF  07
....................    output_drive(LCD_DATA6); 
02A9:  BCF    03.5
02AA:  BCF    31.2
02AB:  MOVF   31,W
02AC:  BSF    03.5
02AD:  MOVWF  07
....................    output_drive(LCD_DATA7); 
02AE:  BCF    03.5
02AF:  BCF    31.3
02B0:  MOVF   31,W
02B1:  BSF    03.5
02B2:  MOVWF  07
....................   #else 
....................    lcdtris.data = 0x0; 
....................   #endif 
....................    lcd_enable_tris(); 
02B3:  BCF    09.0
....................    lcd_rs_tris(); 
02B4:  BCF    09.1
....................    lcd_rw_tris(); 
02B5:  BCF    09.2
....................  #endif 
....................      
....................    delay_ms(15); 
02B6:  MOVLW  0F
02B7:  BCF    03.5
02B8:  BSF    03.6
02B9:  MOVWF  47
02BA:  BCF    03.6
02BB:  CALL   176
....................    for(i=1;i<=3;++i) 
02BC:  MOVLW  01
02BD:  BSF    03.6
02BE:  MOVWF  16
02BF:  MOVF   16,W
02C0:  SUBLW  03
02C1:  BTFSS  03.0
02C2:  GOTO   2CF
....................    { 
....................        lcd_send_nibble(3); 
02C3:  MOVLW  03
02C4:  MOVWF  4E
02C5:  BCF    03.6
02C6:  CALL   18B
....................        delay_ms(5); 
02C7:  MOVLW  05
02C8:  BSF    03.6
02C9:  MOVWF  47
02CA:  BCF    03.6
02CB:  CALL   176
02CC:  BSF    03.6
02CD:  INCF   16,F
02CE:  GOTO   2BF
....................    } 
....................     
....................    lcd_send_nibble(2); 
02CF:  MOVLW  02
02D0:  MOVWF  4E
02D1:  BCF    03.6
02D2:  CALL   18B
....................    delay_ms(5); 
02D3:  MOVLW  05
02D4:  BSF    03.6
02D5:  MOVWF  47
02D6:  BCF    03.6
02D7:  CALL   176
....................    for(i=0;i<=3;++i) 
02D8:  BSF    03.6
02D9:  CLRF   16
02DA:  MOVF   16,W
02DB:  SUBLW  03
02DC:  BTFSS  03.0
02DD:  GOTO   2EC
....................       lcd_send_byte(0,LCD_INIT_STRING[i]); 
02DE:  MOVLW  17
02DF:  ADDWF  16,W
02E0:  MOVWF  04
02E1:  BSF    03.7
02E2:  MOVF   00,W
02E3:  MOVWF  1B
02E4:  CLRF   4B
02E5:  MOVF   1B,W
02E6:  MOVWF  4C
02E7:  BCF    03.6
02E8:  CALL   211
....................  
....................   #if defined(LCD_EXTENDED_NEWLINE) 
02E9:  BSF    03.6
02EA:  INCF   16,F
02EB:  GOTO   2DA
02EC:  BCF    03.6
02ED:  BCF    0A.3
02EE:  BSF    0A.4
02EF:  GOTO   563 (RETURN)
....................    g_LcdX = 0; 
....................    g_LcdY = 0; 
....................   #endif 
.................... } 
....................  
.................... void lcd_gotoxy(unsigned int8 x, unsigned int8 y) 
.................... { 
....................    unsigned int8 address; 
....................     
....................    if(y!=1) 
02F0:  BSF    03.6
02F1:  DECFSZ 48,W
02F2:  GOTO   2F4
02F3:  GOTO   2F7
....................       address=LCD_LINE_TWO; 
02F4:  MOVLW  40
02F5:  MOVWF  49
02F6:  GOTO   2F8
....................    else 
....................       address=0; 
02F7:  CLRF   49
....................       
....................    address+=x-1; 
02F8:  MOVLW  01
02F9:  SUBWF  47,W
02FA:  ADDWF  49,F
....................    lcd_send_byte(0,0x80|address); 
02FB:  MOVF   49,W
02FC:  IORLW  80
02FD:  MOVWF  4A
02FE:  CLRF   4B
02FF:  MOVF   4A,W
0300:  MOVWF  4C
0301:  BCF    03.6
0302:  CALL   211
....................  
....................   #if defined(LCD_EXTENDED_NEWLINE) 
0303:  RETURN
....................    g_LcdX = x - 1; 
....................    g_LcdY = y - 1; 
....................   #endif 
.................... } 
....................  
.................... void lcd_putc(char c) 
.................... { 
....................    switch (c) 
0304:  BSF    03.6
0305:  MOVF   46,W
0306:  XORLW  07
0307:  BCF    03.6
0308:  BTFSC  03.2
0309:  GOTO   314
030A:  XORLW  0B
030B:  BTFSC  03.2
030C:  GOTO   31B
030D:  XORLW  06
030E:  BTFSC  03.2
030F:  GOTO   327
0310:  XORLW  02
0311:  BTFSC  03.2
0312:  GOTO   32F
0313:  GOTO   336
....................    { 
....................       case '\a'   :  lcd_gotoxy(1,1);     break; 
0314:  MOVLW  01
0315:  BSF    03.6
0316:  MOVWF  47
0317:  MOVWF  48
0318:  BCF    03.6
0319:  CALL   2F0
031A:  GOTO   33D
....................  
....................       case '\f'   :  lcd_send_byte(0,1); 
031B:  BSF    03.6
031C:  CLRF   4B
031D:  MOVLW  01
031E:  MOVWF  4C
031F:  BCF    03.6
0320:  CALL   211
....................                      delay_ms(2); 
0321:  MOVLW  02
0322:  BSF    03.6
0323:  MOVWF  47
0324:  BCF    03.6
0325:  CALL   176
....................                     #if defined(LCD_EXTENDED_NEWLINE) 
....................                      g_LcdX = 0; 
....................                      g_LcdY = 0; 
....................                     #endif 
....................                      break; 
0326:  GOTO   33D
....................  
....................      #if defined(LCD_EXTENDED_NEWLINE) 
....................       case '\r'   :  lcd_gotoxy(1, g_LcdY+1);   break; 
....................       case '\n'   : 
....................          while (g_LcdX++ < LCD_LINE_LENGTH) 
....................          { 
....................             lcd_send_byte(1, ' '); 
....................          } 
....................          lcd_gotoxy(1, g_LcdY+2); 
....................          break; 
....................      #else 
....................       case '\n'   : lcd_gotoxy(1,2);        break; 
0327:  MOVLW  01
0328:  BSF    03.6
0329:  MOVWF  47
032A:  MOVLW  02
032B:  MOVWF  48
032C:  BCF    03.6
032D:  CALL   2F0
032E:  GOTO   33D
....................      #endif 
....................       
....................       case '\b'   : lcd_send_byte(0,0x10);  break; 
032F:  BSF    03.6
0330:  CLRF   4B
0331:  MOVLW  10
0332:  MOVWF  4C
0333:  BCF    03.6
0334:  CALL   211
0335:  GOTO   33D
....................       
....................      #if defined(LCD_EXTENDED_NEWLINE) 
....................       default     :  
....................          if (g_LcdX < LCD_LINE_LENGTH) 
....................          { 
....................             lcd_send_byte(1, c); 
....................             g_LcdX++; 
....................          } 
....................          break; 
....................      #else 
....................       default     : lcd_send_byte(1,c);     break; 
0336:  MOVLW  01
0337:  BSF    03.6
0338:  MOVWF  4B
0339:  MOVF   46,W
033A:  MOVWF  4C
033B:  BCF    03.6
033C:  CALL   211
....................      #endif 
....................    } 
033D:  RETURN
.................... } 
....................   
.................... char lcd_getc(unsigned int8 x, unsigned int8 y) 
.................... { 
....................    char value; 
....................  
....................    lcd_gotoxy(x,y); 
....................    while ( bit_test(lcd_read_byte(),7) ); // wait until busy flag is low 
....................    lcd_output_rs(1); 
....................    value = lcd_read_byte(); 
....................    lcd_output_rs(0); 
....................     
....................    return(value); 
.................... } 
....................  
.................... // write a custom character to the ram 
.................... // which is 0-7 and specifies which character array we are modifying. 
.................... // ptr points to an array of 8 bytes, where each byte is the next row of 
.................... //    pixels.  only bits 0-4 are used.  the last row is the cursor row, and 
.................... //    usually you will want to leave this byte 0x00. 
.................... void lcd_set_cgram_char(unsigned int8 which, unsigned int8 *ptr) 
.................... { 
....................    unsigned int i; 
....................  
....................    which <<= 3; 
....................    which &= 0x38; 
....................  
....................    lcd_send_byte(0, 0x40 | which);  //set cgram address 
....................  
....................    for(i=0; i<8; i++) 
....................    { 
....................       lcd_send_byte(1, *ptr++); 
....................    } 
....................    
....................    #if defined(LCD_EXTENDED_NEWLINE) 
....................     lcd_gotoxy(g_LcdX+1, g_LcdY+1);  //set ddram address 
....................    #endif 
.................... } 
....................  
.................... void lcd_cursor_on(int1 on) 
.................... { 
....................    if (on) 
....................    { 
....................       lcd_send_byte(0,0x0F);           //turn LCD cursor ON 
....................    } 
....................    else 
....................    { 
....................       lcd_send_byte(0,0x0C);           //turn LCD cursor OFF 
....................    } 
.................... } 
....................  
.................... #endif 
....................  
.................... #BIT TMR1IF = 0x0C.0 //bit thu 0 (TMR1IF) cua PIR1 
....................  
.................... #INCLUDE <khaibaobien.c> // VARIABLE. 
....................  
.................... UNSIGNED INT16 KQADC; 
.................... UNSIGNED INT8 KET_QUA_ANALOG[]={0,0,0,0,0}; 
*
14C6:  CLRF   34
14C7:  CLRF   35
14C8:  CLRF   36
14C9:  CLRF   37
14CA:  CLRF   38
.................... UNSIGNED INT8 KET_QUA_ANALOG_TEMP[]={0,0,0,0,0}; 
14CB:  CLRF   39
14CC:  CLRF   3A
14CD:  CLRF   3B
14CE:  CLRF   3C
14CF:  CLRF   3D
.................... UNSIGNED INT8 CONFIG_FUN=0; 
.................... UNSIGNED INT8 VT=0, KYTU=0;// KYTU[30],  
.................... UNSIGNED INT8 LENH_DIEU_KHIEN = 0; 
.................... UNSIGNED INT8 ID_GATEWAY[6] = {3,8,6,9,0,7}; 
14D0:  MOVLW  03
14D1:  MOVWF  42
14D2:  MOVLW  08
14D3:  MOVWF  43
14D4:  MOVLW  06
14D5:  MOVWF  44
14D6:  MOVLW  09
14D7:  MOVWF  45
14D8:  CLRF   46
14D9:  MOVLW  07
14DA:  MOVWF  47
.................... UNSIGNED INT8 ID_NODE[4] = {0,1,5,2}; 
14DB:  CLRF   48
14DC:  MOVLW  01
14DD:  MOVWF  49
14DE:  MOVLW  05
14DF:  MOVWF  4A
14E0:  MOVLW  02
14E1:  MOVWF  4B
.................... UNSIGNED INT8 LEN_PACKAGES = 0; 
.................... UNSIGNED INT8 LENHDIEUKHIEN =0, DODAI_DATA_NHAN =0; 
.................... UNSIGNED INT8 SOLUONGTHIETBI_CONFIG=0, SOLUONGCAMBIEN_CONFIG = 3; 
.................... SIGNED INT8 SOSANH_IDNODE=0, SOSANH_IDGW=0; 
.................... //INT1 TT_THIETBI [8]={0,0,0,0,0,0,0,0}; 
.................... INT1 TT_THIETBI_TEMP [8]={0,0,0,0,0,0,0,0}; 
14E2:  CLRF   53
.................... INT1 TTNHAN = 0, TT_CONFIG=0, TT_CONTROL=0,TT_CONFIG_DONE=0, TT_FUN=0, TT_STT=0 , TT_CONFIG_OKE_UART = 0, TT_SW = 0,TT_SEND_ANALOG = 0; 
....................  
.................... CHAR *ID_NODE_CHAR[]= "0589"; 
14E3:  MOVLW  30
14E4:  MOVWF  58
14E5:  MOVLW  35
14E6:  MOVWF  59
14E7:  MOVLW  38
14E8:  MOVWF  5A
14E9:  MOVLW  39
14EA:  MOVWF  5B
14EB:  CLRF   5C
14EC:  CLRF   57
14ED:  MOVLW  58
14EE:  MOVWF  56
.................... CHAR *ID_GATEWAY_CHAR[]= "127102"; 
14EF:  MOVLW  31
14F0:  MOVWF  5F
14F1:  MOVLW  32
14F2:  MOVWF  60
14F3:  MOVLW  37
14F4:  MOVWF  61
14F5:  MOVLW  31
14F6:  MOVWF  62
14F7:  MOVLW  30
14F8:  MOVWF  63
14F9:  MOVLW  32
14FA:  MOVWF  64
14FB:  CLRF   65
14FC:  CLRF   5E
14FD:  MOVLW  5F
14FE:  MOVWF  5D
.................... CHAR *ID_NODE_NHAN[]= "0000"; 
14FF:  MOVLW  30
1500:  MOVWF  68
1501:  MOVWF  69
1502:  MOVWF  6A
1503:  MOVWF  6B
1504:  CLRF   6C
1505:  CLRF   67
1506:  MOVLW  68
1507:  MOVWF  66
.................... CHAR *ID_GW_NHAN[]= "000000"; 
1508:  MOVLW  30
1509:  MOVWF  6F
150A:  MOVWF  70
150B:  MOVWF  71
150C:  MOVWF  72
150D:  MOVWF  73
150E:  MOVWF  74
150F:  CLRF   75
1510:  CLRF   6E
1511:  MOVLW  6F
1512:  MOVWF  6D
.................... CHAR KYTUCHAR[50]="HIHI"; 
1513:  MOVLW  48
1514:  BSF    03.5
1515:  MOVWF  20
1516:  MOVLW  49
1517:  MOVWF  21
1518:  MOVLW  48
1519:  MOVWF  22
151A:  MOVLW  49
151B:  MOVWF  23
151C:  CLRF   24
.................... CHAR KYTUCHAR2[25]="HIHI"; 
151D:  MOVLW  48
151E:  MOVWF  52
151F:  MOVLW  49
1520:  MOVWF  53
1521:  MOVLW  48
1522:  MOVWF  54
1523:  MOVLW  49
1524:  MOVWF  55
1525:  CLRF   56
.................... //CHAR *DATA_NHANDUOC[]={"IDGW","IDNODE","COMMAN","DATA"}; 
.................... CHAR *TEMP_CHAR[]="0000";   
1526:  MOVLW  30
1527:  MOVWF  6B
1528:  MOVWF  6C
1529:  MOVWF  6D
152A:  MOVWF  6E
152B:  CLRF   6F
152C:  CLRF   7C
152D:  MOVLW  EB
152E:  MOVWF  7B
.................... CHAR *TEMP_CHAR2[]="2700";  
152F:  MOVLW  32
1530:  BCF    03.5
1531:  BSF    03.6
1532:  MOVWF  10
1533:  MOVLW  37
1534:  MOVWF  11
1535:  MOVLW  30
1536:  MOVWF  12
1537:  MOVWF  13
1538:  CLRF   14
1539:  MOVLW  01
153A:  MOVWF  7E
153B:  MOVLW  10
153C:  MOVWF  7D
.................... //CHAR *TEMP_CHAR3[]="000000";  
....................  
....................  
....................  
.................... //#INCLUDE <CONFIG_NODE.C> // CU HINH NODE. 
.................... #INCLUDE <config_1.C> // CU HINH NODE. 
.................... VOID READ_EEPROMP_DATA_NODE(){    
....................    FOR (int j = 0; j < 4; j++) 
*
038E:  BSF    03.6
038F:  CLRF   16
0390:  MOVF   16,W
0391:  SUBLW  03
0392:  BTFSS  03.0
0393:  GOTO   3A5
....................    { 
....................       ID_NODE[j] = read_eeprom(10+j); 
0394:  MOVLW  48
0395:  ADDWF  16,W
0396:  MOVWF  04
0397:  BCF    03.7
0398:  MOVLW  0A
0399:  ADDWF  16,W
039A:  MOVWF  19
039B:  MOVF   19,W
039C:  MOVWF  0D
039D:  BSF    03.5
039E:  BCF    0C.7
039F:  BSF    0C.0
03A0:  BCF    03.5
03A1:  MOVF   0C,W
03A2:  MOVWF  00
03A3:  INCF   16,F
03A4:  GOTO   390
....................    }   
....................    FOR (j = 0; j < 6; j++) 
03A5:  CLRF   16
03A6:  MOVF   16,W
03A7:  SUBLW  05
03A8:  BTFSS  03.0
03A9:  GOTO   3BB
....................    { 
....................       ID_GATEWAY[j] = read_eeprom(14+j); 
03AA:  MOVLW  42
03AB:  ADDWF  16,W
03AC:  MOVWF  04
03AD:  BCF    03.7
03AE:  MOVLW  0E
03AF:  ADDWF  16,W
03B0:  MOVWF  19
03B1:  MOVF   19,W
03B2:  MOVWF  0D
03B3:  BSF    03.5
03B4:  BCF    0C.7
03B5:  BSF    0C.0
03B6:  BCF    03.5
03B7:  MOVF   0C,W
03B8:  MOVWF  00
03B9:  INCF   16,F
03BA:  GOTO   3A6
....................    }   
03BB:  BCF    03.6
03BC:  BCF    0A.3
03BD:  BSF    0A.4
03BE:  GOTO   5AB (RETURN)
.................... } 
....................  
.................... //--------------------------------------------------------------------// 
.................... VOID CHON_ID() 
.................... { 
....................    // TT_CONFIG_DONE; 
....................    TT_CONFIG_DONE = 0; 
*
0893:  BCF    54.3
....................    TT_STT = 1; 
0894:  BSF    54.5
....................    UNSIGNED INT8 NUM = 0; 
0895:  BSF    03.6
0896:  CLRF   16
....................    TEMP_CHAR = "0"; 
0897:  CLRF   17
0898:  CLRF   18
0899:  MOVLW  7B
089A:  MOVWF  04
089B:  BCF    03.7
089C:  MOVF   17,W
089D:  ADDWF  04,F
089E:  MOVF   18,W
089F:  BCF    0A.3
08A0:  BCF    03.6
08A1:  CALL   058
08A2:  BSF    0A.3
08A3:  MOVWF  00
08A4:  IORLW  00
08A5:  BTFSC  03.2
08A6:  GOTO   0AC
08A7:  BSF    03.6
08A8:  INCF   18,F
08A9:  INCF   17,F
08AA:  GOTO   099
08AB:  BCF    03.6
....................    LCD_GOTOXY (1, 2) ; 
08AC:  MOVLW  01
08AD:  BSF    03.6
08AE:  MOVWF  47
08AF:  MOVLW  02
08B0:  MOVWF  48
08B1:  BCF    0A.3
08B2:  BCF    03.6
08B3:  CALL   2F0
08B4:  BSF    0A.3
....................    DELAY_MS (10); 
08B5:  MOVLW  0A
08B6:  BSF    03.6
08B7:  MOVWF  47
08B8:  BCF    0A.3
08B9:  BCF    03.6
08BA:  CALL   176
08BB:  BSF    0A.3
....................    PRINTF (LCD_PUTC, "NODE: "); 
08BC:  MOVLW  84
08BD:  BSF    03.6
08BE:  MOVWF  0D
08BF:  MOVLW  00
08C0:  MOVWF  0F
08C1:  BCF    0A.3
08C2:  BCF    03.6
08C3:  CALL   33E
08C4:  BSF    0A.3
....................    PRINTF (LCD_PUTC, ID_NODE_CHAR); 
08C5:  MOVLW  56
08C6:  MOVWF  04
08C7:  BCF    03.7
08C8:  BCF    0A.3
08C9:  CALL   715
08CA:  BSF    0A.3
....................    PRINTF (LCD_PUTC, "          "); 
08CB:  MOVLW  88
08CC:  BSF    03.6
08CD:  MOVWF  0D
08CE:  MOVLW  00
08CF:  MOVWF  0F
08D0:  BCF    0A.3
08D1:  BCF    03.6
08D2:  CALL   33E
08D3:  BSF    0A.3
....................    LCD_GOTOXY (1, 1) ; 
08D4:  MOVLW  01
08D5:  BSF    03.6
08D6:  MOVWF  47
08D7:  MOVWF  48
08D8:  BCF    0A.3
08D9:  BCF    03.6
08DA:  CALL   2F0
08DB:  BSF    0A.3
....................    PRINTF (LCD_PUTC, "      _              ");//6 SPACE PHIA TRUOC "_" 
08DC:  MOVLW  8E
08DD:  BSF    03.6
08DE:  MOVWF  0D
08DF:  MOVLW  00
08E0:  MOVWF  0F
08E1:  BCF    0A.3
08E2:  BCF    03.6
08E3:  CALL   33E
08E4:  BSF    0A.3
....................    //ID_GW = "1234";     
....................  
....................    WHILE (TT_STT) 
08E5:  BTFSS  54.5
08E6:  GOTO   175
....................    { 
....................       IF (!INPUT (BT2_PIN)) //NEU NUT BAM DUOC BAM 
08E7:  BSF    03.5
08E8:  BSF    06.2
08E9:  BCF    03.5
08EA:  BTFSC  06.2
08EB:  GOTO   110
....................       { 
....................           
....................          NUM++; 
08EC:  BSF    03.6
08ED:  INCF   16,F
....................          NUM = NUM % 4; 
08EE:  MOVLW  03
08EF:  ANDWF  16,F
....................          LCD_GOTOXY (3 + NUM, 1); 
08F0:  ADDWF  16,W
08F1:  MOVWF  17
08F2:  MOVWF  47
08F3:  MOVLW  01
08F4:  MOVWF  48
08F5:  BCF    0A.3
08F6:  BCF    03.6
08F7:  CALL   2F0
08F8:  BSF    0A.3
....................          PRINTF (LCD_PUTC, "    _    ");//4SPACE 
08F9:  MOVLW  99
08FA:  BSF    03.6
08FB:  MOVWF  0D
08FC:  MOVLW  00
08FD:  MOVWF  0F
08FE:  BCF    0A.3
08FF:  BCF    03.6
0900:  CALL   33E
0901:  BSF    0A.3
....................          DELAY_MS (300);  
0902:  MOVLW  02
0903:  BSF    03.6
0904:  MOVWF  17
0905:  MOVLW  96
0906:  MOVWF  47
0907:  BCF    0A.3
0908:  BCF    03.6
0909:  CALL   176
090A:  BSF    0A.3
090B:  BSF    03.6
090C:  DECFSZ 17,F
090D:  GOTO   105
....................       } 
090E:  GOTO   173
090F:  BCF    03.6
....................  
....................       ELSE IF (!INPUT (BT3_PIN)) 
0910:  BSF    03.5
0911:  BSF    06.3
0912:  BCF    03.5
0913:  BTFSC  06.3
0914:  GOTO   174
....................       { 
....................          ID_NODE[NUM]++; 
0915:  MOVLW  48
0916:  BSF    03.6
0917:  ADDWF  16,W
0918:  MOVWF  04
0919:  BCF    03.7
091A:  INCF   00,F
....................          ID_NODE[NUM] = ID_NODE[NUM] % 10; 
091B:  MOVLW  48
091C:  ADDWF  16,W
091D:  MOVWF  78
091E:  CLRF   7A
091F:  BTFSC  03.0
0920:  INCF   7A,F
0921:  MOVF   78,W
0922:  MOVWF  17
0923:  MOVF   7A,W
0924:  MOVWF  18
0925:  MOVLW  48
0926:  ADDWF  16,W
0927:  MOVWF  04
0928:  BCF    03.7
0929:  MOVF   00,W
092A:  MOVWF  1A
092B:  MOVLW  0A
092C:  MOVWF  1B
092D:  BCF    0A.3
092E:  BCF    03.6
092F:  CALL   732
0930:  BSF    0A.3
0931:  MOVF   77,W
0932:  BSF    03.6
0933:  MOVWF  19
0934:  MOVF   17,W
0935:  MOVWF  04
0936:  BCF    03.7
0937:  BTFSC  18.0
0938:  BSF    03.7
0939:  MOVF   19,W
093A:  MOVWF  00
....................          ITOA (ID_NODE[NUM], 10, TEMP_CHAR); 
093B:  MOVLW  48
093C:  ADDWF  16,W
093D:  MOVWF  04
093E:  BCF    03.7
093F:  MOVF   00,W
0940:  MOVWF  17
0941:  CLRF   48
0942:  CLRF   47
0943:  CLRF   46
0944:  MOVF   17,W
0945:  MOVWF  45
0946:  MOVLW  0A
0947:  MOVWF  49
0948:  CLRF   4B
0949:  MOVLW  7B
094A:  MOVWF  4A
094B:  BCF    0A.3
094C:  BCF    03.6
094D:  CALL   43B
094E:  BSF    0A.3
....................          LCD_GOTOXY (7 + NUM, 2); 
094F:  MOVLW  07
0950:  BSF    03.6
0951:  ADDWF  16,W
0952:  MOVWF  17
0953:  MOVWF  47
0954:  MOVLW  02
0955:  MOVWF  48
0956:  BCF    0A.3
0957:  BCF    03.6
0958:  CALL   2F0
0959:  BSF    0A.3
....................          DELAY_MS (10); 
095A:  MOVLW  0A
095B:  BSF    03.6
095C:  MOVWF  47
095D:  BCF    0A.3
095E:  BCF    03.6
095F:  CALL   176
0960:  BSF    0A.3
....................          PRINTF (LCD_PUTC, TEMP_CHAR); 
0961:  MOVLW  7B
0962:  MOVWF  04
0963:  BCF    03.7
0964:  BCF    0A.3
0965:  CALL   715
0966:  BSF    0A.3
....................          DELAY_MS (300); 
0967:  MOVLW  02
0968:  BSF    03.6
0969:  MOVWF  17
096A:  MOVLW  96
096B:  MOVWF  47
096C:  BCF    0A.3
096D:  BCF    03.6
096E:  CALL   176
096F:  BSF    0A.3
0970:  BSF    03.6
0971:  DECFSZ 17,F
0972:  GOTO   16A
0973:  BCF    03.6
....................       } 
0974:  GOTO   0E5
....................    } 
.................... } 
....................  
.................... VOID NHAPID_GW() 
*
0976:  BSF    03.6
0977:  CLRF   16
.................... { 
....................    UNSIGNED INT8 NUM = 0; 
....................    TEMP_CHAR = "0"; 
0978:  CLRF   17
0979:  CLRF   18
097A:  MOVLW  7B
097B:  MOVWF  04
097C:  BCF    03.7
097D:  MOVF   17,W
097E:  ADDWF  04,F
097F:  MOVF   18,W
0980:  BCF    0A.3
0981:  BCF    03.6
0982:  CALL   058
0983:  BSF    0A.3
0984:  MOVWF  00
0985:  IORLW  00
0986:  BTFSC  03.2
0987:  GOTO   18D
0988:  BSF    03.6
0989:  INCF   18,F
098A:  INCF   17,F
098B:  GOTO   17A
098C:  BCF    03.6
....................    TT_CONFIG_DONE = 0; 
098D:  BCF    54.3
....................    TT_STT = 1; 
098E:  BSF    54.5
....................    LCD_GOTOXY (1, 2) ; 
098F:  MOVLW  01
0990:  BSF    03.6
0991:  MOVWF  47
0992:  MOVLW  02
0993:  MOVWF  48
0994:  BCF    0A.3
0995:  BCF    03.6
0996:  CALL   2F0
0997:  BSF    0A.3
....................    DELAY_MS (10); 
0998:  MOVLW  0A
0999:  BSF    03.6
099A:  MOVWF  47
099B:  BCF    0A.3
099C:  BCF    03.6
099D:  CALL   176
099E:  BSF    0A.3
....................    PRINTF (LCD_PUTC, "ID_GW:"); 
099F:  MOVLW  9E
09A0:  BSF    03.6
09A1:  MOVWF  0D
09A2:  MOVLW  00
09A3:  MOVWF  0F
09A4:  BCF    0A.3
09A5:  BCF    03.6
09A6:  CALL   33E
09A7:  BSF    0A.3
....................    PRINTF (LCD_PUTC, ID_GATEWAY_CHAR); 
09A8:  MOVLW  5D
09A9:  MOVWF  04
09AA:  BCF    03.7
09AB:  BCF    0A.3
09AC:  CALL   715
09AD:  BSF    0A.3
....................    PRINTF (LCD_PUTC, "          "); 
09AE:  MOVLW  A2
09AF:  BSF    03.6
09B0:  MOVWF  0D
09B1:  MOVLW  00
09B2:  MOVWF  0F
09B3:  BCF    0A.3
09B4:  BCF    03.6
09B5:  CALL   33E
09B6:  BSF    0A.3
....................    LCD_GOTOXY (1, 1) ; 
09B7:  MOVLW  01
09B8:  BSF    03.6
09B9:  MOVWF  47
09BA:  MOVWF  48
09BB:  BCF    0A.3
09BC:  BCF    03.6
09BD:  CALL   2F0
09BE:  BSF    0A.3
....................    PRINTF (LCD_PUTC, "      _                ");//6 SPACE PHIA TRUOC "_" 
09BF:  MOVLW  A8
09C0:  BSF    03.6
09C1:  MOVWF  0D
09C2:  MOVLW  00
09C3:  MOVWF  0F
09C4:  BCF    0A.3
09C5:  BCF    03.6
09C6:  CALL   33E
09C7:  BSF    0A.3
....................    //ID_GW = "1234";     
....................  
....................    WHILE (TT_STT) 
09C8:  BTFSS  54.5
09C9:  GOTO   262
....................    { 
....................       IF (!INPUT (BT2_PIN)) //NEU NUT BAM DUOC BAM 
09CA:  BSF    03.5
09CB:  BSF    06.2
09CC:  BCF    03.5
09CD:  BTFSC  06.2
09CE:  GOTO   1FD
....................       { 
....................           
....................          NUM++; 
09CF:  BSF    03.6
09D0:  INCF   16,F
....................          NUM = NUM % 6; 
09D1:  MOVF   16,W
09D2:  MOVWF  1A
09D3:  MOVLW  06
09D4:  MOVWF  1B
09D5:  BCF    0A.3
09D6:  BCF    03.6
09D7:  CALL   732
09D8:  BSF    0A.3
09D9:  MOVF   77,W
09DA:  BSF    03.6
09DB:  MOVWF  16
....................          LCD_GOTOXY (3 + NUM, 1); 
09DC:  MOVLW  03
09DD:  ADDWF  16,W
09DE:  MOVWF  17
09DF:  MOVWF  47
09E0:  MOVLW  01
09E1:  MOVWF  48
09E2:  BCF    0A.3
09E3:  BCF    03.6
09E4:  CALL   2F0
09E5:  BSF    0A.3
....................          PRINTF (LCD_PUTC, "    _        ");//4SPACE 
09E6:  MOVLW  B4
09E7:  BSF    03.6
09E8:  MOVWF  0D
09E9:  MOVLW  00
09EA:  MOVWF  0F
09EB:  BCF    0A.3
09EC:  BCF    03.6
09ED:  CALL   33E
09EE:  BSF    0A.3
....................          DELAY_MS (300);  
09EF:  MOVLW  02
09F0:  BSF    03.6
09F1:  MOVWF  17
09F2:  MOVLW  96
09F3:  MOVWF  47
09F4:  BCF    0A.3
09F5:  BCF    03.6
09F6:  CALL   176
09F7:  BSF    0A.3
09F8:  BSF    03.6
09F9:  DECFSZ 17,F
09FA:  GOTO   1F2
....................       } 
09FB:  GOTO   260
09FC:  BCF    03.6
....................  
....................       ELSE IF (!INPUT (BT3_PIN)) 
09FD:  BSF    03.5
09FE:  BSF    06.3
09FF:  BCF    03.5
0A00:  BTFSC  06.3
0A01:  GOTO   261
....................       { 
....................          ID_GATEWAY[NUM]++; 
0A02:  MOVLW  42
0A03:  BSF    03.6
0A04:  ADDWF  16,W
0A05:  MOVWF  04
0A06:  BCF    03.7
0A07:  INCF   00,F
....................          ID_GATEWAY[NUM] = ID_GATEWAY[NUM] % 10; 
0A08:  MOVLW  42
0A09:  ADDWF  16,W
0A0A:  MOVWF  78
0A0B:  CLRF   7A
0A0C:  BTFSC  03.0
0A0D:  INCF   7A,F
0A0E:  MOVF   78,W
0A0F:  MOVWF  17
0A10:  MOVF   7A,W
0A11:  MOVWF  18
0A12:  MOVLW  42
0A13:  ADDWF  16,W
0A14:  MOVWF  04
0A15:  BCF    03.7
0A16:  MOVF   00,W
0A17:  MOVWF  1A
0A18:  MOVLW  0A
0A19:  MOVWF  1B
0A1A:  BCF    0A.3
0A1B:  BCF    03.6
0A1C:  CALL   732
0A1D:  BSF    0A.3
0A1E:  MOVF   77,W
0A1F:  BSF    03.6
0A20:  MOVWF  19
0A21:  MOVF   17,W
0A22:  MOVWF  04
0A23:  BCF    03.7
0A24:  BTFSC  18.0
0A25:  BSF    03.7
0A26:  MOVF   19,W
0A27:  MOVWF  00
....................          ITOA (ID_GATEWAY[NUM], 10, TEMP_CHAR); 
0A28:  MOVLW  42
0A29:  ADDWF  16,W
0A2A:  MOVWF  04
0A2B:  BCF    03.7
0A2C:  MOVF   00,W
0A2D:  MOVWF  17
0A2E:  CLRF   48
0A2F:  CLRF   47
0A30:  CLRF   46
0A31:  MOVF   17,W
0A32:  MOVWF  45
0A33:  MOVLW  0A
0A34:  MOVWF  49
0A35:  CLRF   4B
0A36:  MOVLW  7B
0A37:  MOVWF  4A
0A38:  BCF    0A.3
0A39:  BCF    03.6
0A3A:  CALL   43B
0A3B:  BSF    0A.3
....................          LCD_GOTOXY (7 + NUM, 2); 
0A3C:  MOVLW  07
0A3D:  BSF    03.6
0A3E:  ADDWF  16,W
0A3F:  MOVWF  17
0A40:  MOVWF  47
0A41:  MOVLW  02
0A42:  MOVWF  48
0A43:  BCF    0A.3
0A44:  BCF    03.6
0A45:  CALL   2F0
0A46:  BSF    0A.3
....................          DELAY_MS (10); 
0A47:  MOVLW  0A
0A48:  BSF    03.6
0A49:  MOVWF  47
0A4A:  BCF    0A.3
0A4B:  BCF    03.6
0A4C:  CALL   176
0A4D:  BSF    0A.3
....................          PRINTF (LCD_PUTC, TEMP_CHAR); 
0A4E:  MOVLW  7B
0A4F:  MOVWF  04
0A50:  BCF    03.7
0A51:  BCF    0A.3
0A52:  CALL   715
0A53:  BSF    0A.3
....................          DELAY_MS (300); 
0A54:  MOVLW  02
0A55:  BSF    03.6
0A56:  MOVWF  17
0A57:  MOVLW  96
0A58:  MOVWF  47
0A59:  BCF    0A.3
0A5A:  BCF    03.6
0A5B:  CALL   176
0A5C:  BSF    0A.3
0A5D:  BSF    03.6
0A5E:  DECFSZ 17,F
0A5F:  GOTO   257
0A60:  BCF    03.6
....................       } 
0A61:  GOTO   1C8
....................    } 
.................... } 
....................  
.................... VOID BUTT_OKE() 
.................... { 
....................    TT_CONFIG_DONE = 0; 
*
013C:  BCF    03.6
013D:  BCF    54.3
....................    TT_FUN = 0;//BREAK WHILE BUTT_FUN 
013E:  BCF    54.4
....................    TT_STT = 0;// BREAK WHILE CHONID/NHAPID_GW 
013F:  BCF    54.5
.................... } 
....................  
.................... VOID SELLECT_FUN() 
.................... { 
....................    TT_CONFIG_DONE = 0; 
*
088B:  BCF    54.3
....................  
....................    SWITCH (CONFIG_FUN) 
088C:  MOVF   3E,W
088D:  BTFSC  03.2
088E:  GOTO   093
088F:  XORLW  01
0890:  BTFSC  03.2
0891:  GOTO   176
0892:  GOTO   262
....................    { 
....................       CASE 0: 
....................       CHON_ID (); 
....................       BREAK; 
*
0975:  GOTO   262
....................  
....................       CASE 1:     
....................       NHAPID_GW (); 
....................       BREAK; 
....................    } 
.................... } 
....................  
.................... VOID BUTT_FUN() 
.................... { 
....................    TT_FUN = 1; 
*
0800:  BSF    54.4
....................    LCD_GOTOXY (1, 1) ; 
0801:  MOVLW  01
0802:  BSF    03.6
0803:  MOVWF  47
0804:  MOVWF  48
0805:  BCF    0A.3
0806:  BCF    03.6
0807:  CALL   2F0
0808:  BSF    0A.3
....................    DELAY_MS (10); 
0809:  MOVLW  0A
080A:  BSF    03.6
080B:  MOVWF  47
080C:  BCF    0A.3
080D:  BCF    03.6
080E:  CALL   176
080F:  BSF    0A.3
....................    PRINTF (LCD_PUTC, "CONFIG:        "); 
0810:  MOVLW  BB
0811:  BSF    03.6
0812:  MOVWF  0D
0813:  MOVLW  00
0814:  MOVWF  0F
0815:  BCF    0A.3
0816:  BCF    03.6
0817:  CALL   33E
0818:  BSF    0A.3
....................  
....................    // HIEN THI LCD 
....................    LCD_GOTOXY (1, 2) ; 
0819:  MOVLW  01
081A:  BSF    03.6
081B:  MOVWF  47
081C:  MOVLW  02
081D:  MOVWF  48
081E:  BCF    0A.3
081F:  BCF    03.6
0820:  CALL   2F0
0821:  BSF    0A.3
....................    DELAY_MS (10); 
0822:  MOVLW  0A
0823:  BSF    03.6
0824:  MOVWF  47
0825:  BCF    0A.3
0826:  BCF    03.6
0827:  CALL   176
0828:  BSF    0A.3
....................    PRINTF (LCD_PUTC, "CASE:          ") ; 
0829:  MOVLW  C3
082A:  BSF    03.6
082B:  MOVWF  0D
082C:  MOVLW  00
082D:  MOVWF  0F
082E:  BCF    0A.3
082F:  BCF    03.6
0830:  CALL   33E
0831:  BSF    0A.3
....................  
....................    WHILE (TT_FUN) 
0832:  BTFSS  54.4
0833:  GOTO   089
....................    { 
....................       IF (INPUT (BT2_PIN) == 0) //NEU NUT BAM DUOC BAM 
0834:  BSF    03.5
0835:  BSF    06.2
0836:  BCF    03.5
0837:  BTFSC  06.2
0838:  GOTO   088
....................       { 
....................          CONFIG_FUN ++; 
0839:  INCF   3E,F
....................          CONFIG_FUN = CONFIG_FUN % 2; 
083A:  MOVLW  01
083B:  ANDWF  3E,F
....................          DELAY_MS (300); 
083C:  MOVLW  02
083D:  BSF    03.6
083E:  MOVWF  16
083F:  MOVLW  96
0840:  MOVWF  47
0841:  BCF    0A.3
0842:  BCF    03.6
0843:  CALL   176
0844:  BSF    0A.3
0845:  BSF    03.6
0846:  DECFSZ 16,F
0847:  GOTO   03F
....................          //HIEN THI 
....................          LCD_GOTOXY (6, 2) ; 
0848:  MOVLW  06
0849:  MOVWF  47
084A:  MOVLW  02
084B:  MOVWF  48
084C:  BCF    0A.3
084D:  BCF    03.6
084E:  CALL   2F0
084F:  BSF    0A.3
....................          ITOA (CONFIG_FUN, 10, TEMP_CHAR); 
0850:  BSF    03.6
0851:  CLRF   48
0852:  CLRF   47
0853:  CLRF   46
0854:  BCF    03.6
0855:  MOVF   3E,W
0856:  BSF    03.6
0857:  MOVWF  45
0858:  MOVLW  0A
0859:  MOVWF  49
085A:  CLRF   4B
085B:  MOVLW  7B
085C:  MOVWF  4A
085D:  BCF    0A.3
085E:  BCF    03.6
085F:  CALL   43B
0860:  BSF    0A.3
....................          DELAY_MS (10); 
0861:  MOVLW  0A
0862:  BSF    03.6
0863:  MOVWF  47
0864:  BCF    0A.3
0865:  BCF    03.6
0866:  CALL   176
0867:  BSF    0A.3
....................          PRINTF (LCD_PUTC, TEMP_CHAR); 
0868:  MOVLW  7B
0869:  MOVWF  04
086A:  BCF    03.7
086B:  BCF    0A.3
086C:  CALL   715
086D:  BSF    0A.3
....................  
....................          SWITCH (CONFIG_FUN) 
086E:  MOVF   3E,W
086F:  BTFSC  03.2
0870:  GOTO   075
0871:  XORLW  01
0872:  BTFSC  03.2
0873:  GOTO   07F
0874:  GOTO   088
....................          { 
....................             CASE 0: 
....................             PRINTF (LCD_PUTC, " - ID-NODE      "); 
0875:  MOVLW  CB
0876:  BSF    03.6
0877:  MOVWF  0D
0878:  MOVLW  00
0879:  MOVWF  0F
087A:  BCF    0A.3
087B:  BCF    03.6
087C:  CALL   33E
087D:  BSF    0A.3
....................             BREAK; 
087E:  GOTO   088
....................  
....................             CASE 1: 
....................             PRINTF (LCD_PUTC, " - ID-GW       "); 
087F:  MOVLW  D4
0880:  BSF    03.6
0881:  MOVWF  0D
0882:  MOVLW  00
0883:  MOVWF  0F
0884:  BCF    0A.3
0885:  BCF    03.6
0886:  CALL   33E
0887:  BSF    0A.3
....................             BREAK;             
....................          } 
....................       } 
0888:  GOTO   032
....................    } 
....................  
....................    ////// 
....................    IF (!TT_CONFIG_DONE) 
0889:  BTFSC  54.3
088A:  GOTO   262
....................    { 
....................       SELLECT_FUN (); 
....................    } 
*
0A62:  BCF    0A.3
0A63:  BSF    0A.4
0A64:  GOTO   5B4 (RETURN)
.................... } 
.................... VOID XULY_IDNODE_NHAP(){ 
....................    //*TEMP_CHAR3 = "\0"; 
....................    *ID_NODE_CHAR = "\0"; 
*
0664:  CLRF   7A
0665:  MOVLW  56
0666:  MOVWF  44
0667:  MOVF   7A,W
0668:  MOVWF  45
0669:  MOVF   44,W
066A:  MOVWF  04
066B:  BCF    03.7
066C:  BTFSC  45.0
066D:  BSF    03.7
066E:  CLRF   00
....................    FOR (int j = 0; j < 4; j++) 
066F:  CLRF   43
0670:  MOVF   43,W
0671:  SUBLW  03
0672:  BTFSS  03.0
0673:  GOTO   6B9
....................    { 
....................       write_eeprom(10+j, ID_NODE[j]); 
0674:  MOVLW  0A
0675:  ADDWF  43,W
0676:  MOVWF  44
0677:  MOVLW  48
0678:  ADDWF  43,W
0679:  MOVWF  04
067A:  BCF    03.7
067B:  MOVF   00,W
067C:  MOVWF  45
067D:  BCF    03.6
067E:  MOVF   0B,W
067F:  MOVWF  77
0680:  BCF    0B.7
0681:  BSF    03.6
0682:  MOVF   44,W
0683:  MOVWF  0D
0684:  MOVF   45,W
0685:  MOVWF  0C
0686:  BSF    03.5
0687:  BCF    0C.7
0688:  BSF    0C.2
0689:  MOVLW  55
068A:  MOVWF  0D
068B:  MOVLW  AA
068C:  MOVWF  0D
068D:  BSF    0C.1
068E:  BTFSC  0C.1
068F:  GOTO   68E
0690:  BCF    0C.2
0691:  MOVF   77,W
0692:  BCF    03.5
0693:  BCF    03.6
0694:  IORWF  0B,F
....................       ITOA (ID_NODE[j], 10, TEMP_CHAR); 
0695:  MOVLW  48
0696:  BSF    03.6
0697:  ADDWF  43,W
0698:  MOVWF  04
0699:  BCF    03.7
069A:  MOVF   00,W
069B:  MOVWF  44
069C:  CLRF   48
069D:  CLRF   47
069E:  CLRF   46
069F:  MOVF   44,W
06A0:  MOVWF  45
06A1:  MOVLW  0A
06A2:  MOVWF  49
06A3:  CLRF   4B
06A4:  MOVLW  7B
06A5:  MOVWF  4A
06A6:  BCF    03.6
06A7:  CALL   43B
....................       DELAY_MS (1); 
06A8:  MOVLW  01
06A9:  BSF    03.6
06AA:  MOVWF  47
06AB:  BCF    03.6
06AC:  CALL   176
....................       STRCAT (ID_NODE_CHAR, TEMP_CHAR); 
06AD:  BSF    03.6
06AE:  CLRF   45
06AF:  MOVLW  56
06B0:  MOVWF  44
06B1:  CLRF   47
06B2:  MOVLW  7B
06B3:  MOVWF  46
06B4:  BCF    03.6
06B5:  CALL   55B
06B6:  BSF    03.6
06B7:  INCF   43,F
06B8:  GOTO   670
....................    }   
....................    //ID_NODE_CHAR = TEMP_CHAR3;    
....................    //STRCPY(ID_NODE_CHAR,TEMP_CHAR3); 
....................    //strcpy 
.................... } 
.................... VOID XULY_IDGW_NHAP(){ 
....................  
....................    *ID_GATEWAY_CHAR = "\0"; 
*
060C:  CLRF   7A
060D:  MOVLW  5D
060E:  MOVWF  44
060F:  MOVF   7A,W
0610:  MOVWF  45
0611:  MOVF   44,W
0612:  MOVWF  04
0613:  BCF    03.7
0614:  BTFSC  45.0
0615:  BSF    03.7
0616:  CLRF   00
....................    FOR (int j = 0; j < 6; j++) 
0617:  CLRF   43
0618:  MOVF   43,W
0619:  SUBLW  05
061A:  BTFSS  03.0
061B:  GOTO   661
....................    { 
....................       write_eeprom(14+j, ID_GATEWAY[j]); 
061C:  MOVLW  0E
061D:  ADDWF  43,W
061E:  MOVWF  44
061F:  MOVLW  42
0620:  ADDWF  43,W
0621:  MOVWF  04
0622:  BCF    03.7
0623:  MOVF   00,W
0624:  MOVWF  45
0625:  BCF    03.6
0626:  MOVF   0B,W
0627:  MOVWF  77
0628:  BCF    0B.7
0629:  BSF    03.6
062A:  MOVF   44,W
062B:  MOVWF  0D
062C:  MOVF   45,W
062D:  MOVWF  0C
062E:  BSF    03.5
062F:  BCF    0C.7
0630:  BSF    0C.2
0631:  MOVLW  55
0632:  MOVWF  0D
0633:  MOVLW  AA
0634:  MOVWF  0D
0635:  BSF    0C.1
0636:  BTFSC  0C.1
0637:  GOTO   636
0638:  BCF    0C.2
0639:  MOVF   77,W
063A:  BCF    03.5
063B:  BCF    03.6
063C:  IORWF  0B,F
....................       ITOA (ID_GATEWAY[j], 10, TEMP_CHAR); 
063D:  MOVLW  42
063E:  BSF    03.6
063F:  ADDWF  43,W
0640:  MOVWF  04
0641:  BCF    03.7
0642:  MOVF   00,W
0643:  MOVWF  44
0644:  CLRF   48
0645:  CLRF   47
0646:  CLRF   46
0647:  MOVF   44,W
0648:  MOVWF  45
0649:  MOVLW  0A
064A:  MOVWF  49
064B:  CLRF   4B
064C:  MOVLW  7B
064D:  MOVWF  4A
064E:  BCF    03.6
064F:  CALL   43B
....................       DELAY_MS (1); 
0650:  MOVLW  01
0651:  BSF    03.6
0652:  MOVWF  47
0653:  BCF    03.6
0654:  CALL   176
....................       STRCAT (ID_GATEWAY_CHAR, TEMP_CHAR); 
0655:  BSF    03.6
0656:  CLRF   45
0657:  MOVLW  5D
0658:  MOVWF  44
0659:  CLRF   47
065A:  MOVLW  7B
065B:  MOVWF  46
065C:  BCF    03.6
065D:  CALL   55B
065E:  BSF    03.6
065F:  INCF   43,F
0660:  GOTO   618
....................    }   
.................... } 
....................  
....................  
.................... VOID CONFIG_DONE() 
.................... { 
....................    TT_FUN = 0; 
*
05B7:  BCF    54.4
....................    TT_STT = 0; 
05B8:  BCF    54.5
....................    CHAR *PACKAGE_CONFIG[]={"*", "LENGHT","CF", "ID_GW1234" ,"ID_NODE","#"}; 
05B9:  MOVLW  2A
05BA:  BSF    03.6
05BB:  MOVWF  22
05BC:  CLRF   23
05BD:  MOVLW  4C
05BE:  MOVWF  24
05BF:  MOVLW  45
05C0:  MOVWF  25
05C1:  MOVLW  4E
05C2:  MOVWF  26
05C3:  MOVLW  47
05C4:  MOVWF  27
05C5:  MOVLW  48
05C6:  MOVWF  28
05C7:  MOVLW  54
05C8:  MOVWF  29
05C9:  CLRF   2A
05CA:  MOVLW  43
05CB:  MOVWF  2B
05CC:  MOVLW  46
05CD:  MOVWF  2C
05CE:  CLRF   2D
05CF:  MOVLW  49
05D0:  MOVWF  2E
05D1:  MOVLW  44
05D2:  MOVWF  2F
05D3:  MOVLW  5F
05D4:  MOVWF  30
05D5:  MOVLW  47
05D6:  MOVWF  31
05D7:  MOVLW  57
05D8:  MOVWF  32
05D9:  MOVLW  31
05DA:  MOVWF  33
05DB:  MOVLW  32
05DC:  MOVWF  34
05DD:  MOVLW  33
05DE:  MOVWF  35
05DF:  MOVLW  34
05E0:  MOVWF  36
05E1:  CLRF   37
05E2:  MOVLW  49
05E3:  MOVWF  38
05E4:  MOVLW  44
05E5:  MOVWF  39
05E6:  MOVLW  5F
05E7:  MOVWF  3A
05E8:  MOVLW  4E
05E9:  MOVWF  3B
05EA:  MOVLW  4F
05EB:  MOVWF  3C
05EC:  MOVLW  44
05ED:  MOVWF  3D
05EE:  MOVLW  45
05EF:  MOVWF  3E
05F0:  CLRF   3F
05F1:  MOVLW  23
05F2:  MOVWF  40
05F3:  CLRF   41
05F4:  MOVLW  01
05F5:  MOVWF  17
05F6:  MOVLW  22
05F7:  MOVWF  16
05F8:  MOVLW  01
05F9:  MOVWF  19
05FA:  MOVLW  24
05FB:  MOVWF  18
05FC:  MOVLW  01
05FD:  MOVWF  1B
05FE:  MOVLW  2B
05FF:  MOVWF  1A
0600:  MOVLW  01
0601:  MOVWF  1D
0602:  MOVLW  2E
0603:  MOVWF  1C
0604:  MOVLW  01
0605:  MOVWF  1F
0606:  MOVLW  38
0607:  MOVWF  1E
0608:  MOVLW  01
0609:  MOVWF  21
060A:  MOVLW  40
060B:  MOVWF  20
....................    XULY_IDGW_NHAP(); 
....................    PACKAGE_CONFIG[3] = ID_GATEWAY_CHAR; 
*
0661:  CLRF   1D
0662:  MOVLW  5D
0663:  MOVWF  1C
....................     
....................     
....................    XULY_IDNODE_NHAP(); 
....................  
....................    PACKAGE_CONFIG[4] = ID_NODE_CHAR;     
*
06B9:  CLRF   1F
06BA:  MOVLW  56
06BB:  MOVWF  1E
....................       /*     
....................    LEN_PACKAGES = 0; 
....................    PACKAGE_CONFIG[1] = "12"; //DO DAI CUA LENGHT CO DO DAI = 2 
....................    FOR (int J = 0; J < 5; J++) 
....................    { 
....................       LEN_PACKAGES += strlen(PACKAGE_CONFIG[J]); 
....................    }    
....................    */ 
....................    LEN_PACKAGES = 20; //5 @ 
06BC:  MOVLW  14
06BD:  BCF    03.6
06BE:  MOVWF  4C
....................    ITOA (LEN_PACKAGES, 10, TEMP_CHAR); 
06BF:  BSF    03.6
06C0:  CLRF   48
06C1:  CLRF   47
06C2:  CLRF   46
06C3:  BCF    03.6
06C4:  MOVF   4C,W
06C5:  BSF    03.6
06C6:  MOVWF  45
06C7:  MOVLW  0A
06C8:  MOVWF  49
06C9:  CLRF   4B
06CA:  MOVLW  7B
06CB:  MOVWF  4A
06CC:  BCF    03.6
06CD:  CALL   43B
....................     
....................    PACKAGE_CONFIG[1] = TEMP_CHAR; 
06CE:  BSF    03.6
06CF:  CLRF   19
06D0:  MOVLW  7B
06D1:  MOVWF  18
....................     
....................    FOR (INT J = 0; J < 6; J++) 
06D2:  CLRF   42
06D3:  MOVF   42,W
06D4:  SUBLW  05
06D5:  BTFSS  03.0
06D6:  GOTO   6EF
....................    { 
....................       PRINTF (PACKAGE_CONFIG[J]); 
06D7:  BCF    03.0
06D8:  RLF    42,W
06D9:  ADDLW  16
06DA:  MOVWF  04
06DB:  BSF    03.7
06DC:  INCF   04,F
06DD:  MOVF   00,W
06DE:  MOVWF  44
06DF:  DECF   04,F
06E0:  MOVF   00,W
06E1:  MOVWF  43
06E2:  MOVWF  04
06E3:  BCF    03.7
06E4:  BTFSC  44.0
06E5:  BSF    03.7
06E6:  BCF    03.6
06E7:  CALL   599
....................       PRINTF ("@"); 
06E8:  MOVLW  40
06E9:  BTFSS  0C.4
06EA:  GOTO   6E9
06EB:  MOVWF  19
06EC:  BSF    03.6
06ED:  INCF   42,F
06EE:  GOTO   6D3
....................    } 
....................  
....................  
....................    LCD_GOTOXY (1, 1) ; 
06EF:  MOVLW  01
06F0:  MOVWF  47
06F1:  MOVWF  48
06F2:  BCF    03.6
06F3:  CALL   2F0
....................    DELAY_MS (10); 
06F4:  MOVLW  0A
06F5:  BSF    03.6
06F6:  MOVWF  47
06F7:  BCF    03.6
06F8:  CALL   176
....................    PRINTF (LCD_PUTC, "WAITING ....        ") ; 
06F9:  MOVLW  DC
06FA:  BSF    03.6
06FB:  MOVWF  0D
06FC:  MOVLW  00
06FD:  MOVWF  0F
06FE:  BCF    03.6
06FF:  CALL   33E
....................    LCD_GOTOXY (1, 2) ; 
0700:  MOVLW  01
0701:  BSF    03.6
0702:  MOVWF  47
0703:  MOVLW  02
0704:  MOVWF  48
0705:  BCF    03.6
0706:  CALL   2F0
....................    DELAY_MS (10); 
0707:  MOVLW  0A
0708:  BSF    03.6
0709:  MOVWF  47
070A:  BCF    03.6
070B:  CALL   176
....................    PRINTF (LCD_PUTC, "WAITING ....        ") ;    
070C:  MOVLW  E7
070D:  BSF    03.6
070E:  MOVWF  0D
070F:  MOVLW  00
0710:  MOVWF  0F
0711:  BCF    03.6
0712:  CALL   33E
....................    TT_CONFIG_DONE = 0; 
0713:  BCF    54.3
0714:  RETURN
.................... } 
....................  
....................  
....................  VOID XACNHANCONFIG() 
....................  {    
....................    KYTU=0;          
*
111D:  CLRF   40
....................    LCD_GOTOXY (1, 1) ; 
111E:  MOVLW  01
111F:  BSF    03.6
1120:  MOVWF  47
1121:  MOVWF  48
1122:  BCF    0A.4
1123:  BCF    03.6
1124:  CALL   2F0
1125:  BSF    0A.4
....................    DELAY_MS (10); 
1126:  MOVLW  0A
1127:  BSF    03.6
1128:  MOVWF  47
1129:  BCF    0A.4
112A:  BCF    03.6
112B:  CALL   176
112C:  BSF    0A.4
....................    TEMP_CHAR = "_"; 
112D:  BSF    03.6
112E:  CLRF   1E
112F:  CLRF   1F
1130:  MOVLW  7B
1131:  MOVWF  04
1132:  BCF    03.7
1133:  MOVF   1E,W
1134:  ADDWF  04,F
1135:  MOVF   1F,W
1136:  BCF    0A.4
1137:  BCF    03.6
1138:  CALL   05E
1139:  BSF    0A.4
113A:  MOVWF  00
113B:  IORLW  00
113C:  BTFSC  03.2
113D:  GOTO   143
113E:  BSF    03.6
113F:  INCF   1F,F
1140:  INCF   1E,F
1141:  GOTO   130
1142:  BCF    03.6
....................    CHAR * TOKEN; 
....................    TOKEN = STRTOK (KYTUCHAR2, TEMP_CHAR);    
1143:  BSF    03.6
1144:  CLRF   1F
1145:  MOVLW  D2
1146:  MOVWF  1E
1147:  CLRF   21
1148:  MOVLW  7B
1149:  MOVWF  20
114A:  BCF    0A.4
114B:  BSF    0A.3
114C:  BCF    03.6
114D:  CALL   265
114E:  BSF    0A.4
114F:  BCF    0A.3
1150:  MOVF   79,W
1151:  BSF    03.6
1152:  MOVWF  1D
1153:  MOVF   78,W
1154:  MOVWF  1C
....................     WHILE (TOKEN != NULL) 
1155:  MOVF   1C,F
1156:  BTFSS  03.2
1157:  GOTO   15B
1158:  MOVF   1D,F
1159:  BTFSC  03.2
115A:  GOTO   1B0
....................     {                 
....................        SWITCH(KYTU) 
115B:  BCF    03.6
115C:  MOVF   40,W
115D:  BTFSC  03.2
115E:  GOTO   166
115F:  XORLW  01
1160:  BTFSC  03.2
1161:  GOTO   180
1162:  XORLW  03
1163:  BTFSC  03.2
1164:  GOTO   18E
1165:  GOTO   19B
....................        { 
....................          CASE 0: 
....................          DELAY_MS (1); 
1166:  MOVLW  01
1167:  BSF    03.6
1168:  MOVWF  47
1169:  BCF    0A.4
116A:  BCF    03.6
116B:  CALL   176
116C:  BSF    0A.4
....................          PRINTF (LCD_PUTC,TOKEN); 
116D:  BSF    03.6
116E:  MOVF   1C,W
116F:  MOVWF  04
1170:  BCF    03.7
1171:  BTFSC  1D.0
1172:  BSF    03.7
1173:  BCF    0A.4
1174:  BCF    03.6
1175:  CALL   715
1176:  BSF    0A.4
....................          PRINTF (LCD_PUTC,"            "); 
1177:  MOVLW  F2
1178:  BSF    03.6
1179:  MOVWF  0D
117A:  MOVLW  00
117B:  MOVWF  0F
117C:  BCF    0A.4
117D:  BCF    03.6
117E:  CALL   33E
117F:  BSF    0A.4
....................          CASE 1:  
....................          SOLUONGTHIETBI_CONFIG = ATOI(TOKEN); 
1180:  BSF    03.6
1181:  MOVF   1D,W
1182:  MOVWF  1F
1183:  MOVF   1C,W
1184:  MOVWF  1E
1185:  BCF    0A.4
1186:  BSF    0A.3
1187:  BCF    03.6
1188:  CALL   356
1189:  BSF    0A.4
118A:  BCF    0A.3
118B:  MOVF   78,W
118C:  MOVWF  4F
....................          BREAK;                      
118D:  GOTO   19B
....................          CASE 2: 
....................          SOLUONGCAMBIEN_CONFIG = ATOI(TOKEN); 
118E:  BSF    03.6
118F:  MOVF   1D,W
1190:  MOVWF  1F
1191:  MOVF   1C,W
1192:  MOVWF  1E
1193:  BCF    0A.4
1194:  BSF    0A.3
1195:  BCF    03.6
1196:  CALL   356
1197:  BSF    0A.4
1198:  BCF    0A.3
1199:  MOVF   78,W
119A:  MOVWF  50
....................          BREAK;               
....................        }  
....................       TOKEN = STRTOK(NULL, TEMP_CHAR); 
119B:  BSF    03.6
119C:  CLRF   1F
119D:  CLRF   1E
119E:  CLRF   21
119F:  MOVLW  7B
11A0:  MOVWF  20
11A1:  BCF    0A.4
11A2:  BSF    0A.3
11A3:  BCF    03.6
11A4:  CALL   265
11A5:  BSF    0A.4
11A6:  BCF    0A.3
11A7:  MOVF   79,W
11A8:  BSF    03.6
11A9:  MOVWF  1D
11AA:  MOVF   78,W
11AB:  MOVWF  1C
....................       KYTU++;         
11AC:  BCF    03.6
11AD:  INCF   40,F
11AE:  BSF    03.6
11AF:  GOTO   155
....................     }           
....................    DELAY_MS (1);       
11B0:  MOVLW  01
11B1:  MOVWF  47
11B2:  BCF    0A.4
11B3:  BCF    03.6
11B4:  CALL   176
11B5:  BSF    0A.4
....................    LCD_GOTOXY (1, 2) ; 
11B6:  MOVLW  01
11B7:  BSF    03.6
11B8:  MOVWF  47
11B9:  MOVLW  02
11BA:  MOVWF  48
11BB:  BCF    0A.4
11BC:  BCF    03.6
11BD:  CALL   2F0
11BE:  BSF    0A.4
....................    DELAY_MS (10); 
11BF:  MOVLW  0A
11C0:  BSF    03.6
11C1:  MOVWF  47
11C2:  BCF    0A.4
11C3:  BCF    03.6
11C4:  CALL   176
11C5:  BSF    0A.4
....................    PRINTF (LCD_PUTC,"TB: ");    
11C6:  MOVLW  F9
11C7:  BSF    03.6
11C8:  MOVWF  0D
11C9:  MOVLW  00
11CA:  MOVWF  0F
11CB:  BCF    0A.4
11CC:  BCF    03.6
11CD:  CALL   33E
11CE:  BSF    0A.4
....................    ITOA (SOLUONGTHIETBI_CONFIG, 10, TEMP_CHAR);    
11CF:  BSF    03.6
11D0:  CLRF   48
11D1:  CLRF   47
11D2:  CLRF   46
11D3:  BCF    03.6
11D4:  MOVF   4F,W
11D5:  BSF    03.6
11D6:  MOVWF  45
11D7:  MOVLW  0A
11D8:  MOVWF  49
11D9:  CLRF   4B
11DA:  MOVLW  7B
11DB:  MOVWF  4A
11DC:  BCF    0A.4
11DD:  BCF    03.6
11DE:  CALL   43B
11DF:  BSF    0A.4
....................    PRINTF (LCD_PUTC,TEMP_CHAR);    
11E0:  MOVLW  7B
11E1:  MOVWF  04
11E2:  BCF    03.7
11E3:  BCF    0A.4
11E4:  CALL   715
11E5:  BSF    0A.4
....................    PRINTF (LCD_PUTC,"    CB:");    
11E6:  MOVLW  FC
11E7:  BSF    03.6
11E8:  MOVWF  0D
11E9:  MOVLW  00
11EA:  MOVWF  0F
11EB:  BCF    0A.4
11EC:  BCF    03.6
11ED:  CALL   33E
11EE:  BSF    0A.4
....................    ITOA (SOLUONGCAMBIEN_CONFIG, 10, TEMP_CHAR);    
11EF:  BSF    03.6
11F0:  CLRF   48
11F1:  CLRF   47
11F2:  CLRF   46
11F3:  BCF    03.6
11F4:  MOVF   50,W
11F5:  BSF    03.6
11F6:  MOVWF  45
11F7:  MOVLW  0A
11F8:  MOVWF  49
11F9:  CLRF   4B
11FA:  MOVLW  7B
11FB:  MOVWF  4A
11FC:  BCF    0A.4
11FD:  BCF    03.6
11FE:  CALL   43B
11FF:  BSF    0A.4
....................    PRINTF (LCD_PUTC,TEMP_CHAR);       
1200:  MOVLW  7B
1201:  MOVWF  04
1202:  BCF    03.7
1203:  BCF    0A.4
1204:  CALL   715
1205:  BSF    0A.4
....................    TT_CONFIG_OKE_UART = 1; 
1206:  BSF    54.6
....................     
....................  }  
.................... //--------------------------------------------------------------------// 
....................  
.................... #INCLUDE <DIEU_KHIEN.C> 
.................... VOID READ_BTN_STATE() 
*
0E20:  BSF    03.6
0E21:  CLRF   16
0E22:  MOVLW  34
0E23:  MOVWF  17
.................... { 
....................     
....................    INT TB = 0; 
....................    INT ID_TB =52; 
....................    FOR (TB = 0; TB < SOLUONGTHIETBI_CONFIG; TB++) 
0E24:  CLRF   16
0E25:  BCF    03.6
0E26:  MOVF   4F,W
0E27:  BSF    03.6
0E28:  SUBWF  16,W
0E29:  BTFSC  03.0
0E2A:  GOTO   669
....................    {   IF (TB>3) ID_TB = 64; 
0E2B:  MOVF   16,W
0E2C:  SUBLW  03
0E2D:  BTFSC  03.0
0E2E:  GOTO   631
0E2F:  MOVLW  40
0E30:  MOVWF  17
....................        IF (!INPUT (ID_TB + TB)) 
0E31:  MOVF   16,W
0E32:  ADDWF  17,W
0E33:  MOVWF  18
0E34:  MOVWF  1F
0E35:  MOVLW  01
0E36:  MOVWF  20
0E37:  CLRF   22
0E38:  MOVLW  80
0E39:  MOVWF  21
0E3A:  BCF    0A.3
0E3B:  BCF    03.6
0E3C:  CALL   7D6
0E3D:  BSF    0A.3
0E3E:  BSF    03.6
0E3F:  MOVF   18,W
0E40:  MOVWF  22
0E41:  CLRF   24
0E42:  CLRF   23
0E43:  BCF    03.6
0E44:  CALL   439
0E45:  BTFSC  78.0
0E46:  GOTO   666
....................       {   
....................          DELAY_MS(200); 
0E47:  MOVLW  C8
0E48:  BSF    03.6
0E49:  MOVWF  47
0E4A:  BCF    0A.3
0E4B:  BCF    03.6
0E4C:  CALL   176
0E4D:  BSF    0A.3
....................          TT_THIETBI_TEMP[TB] = ~TT_THIETBI_TEMP[TB];          
0E4E:  BSF    03.6
0E4F:  MOVF   16,W
0E50:  MOVWF  22
0E51:  CLRF   24
0E52:  MOVLW  53
0E53:  MOVWF  23
0E54:  BCF    03.6
0E55:  CALL   439
0E56:  MOVLW  00
0E57:  BTFSS  78.0
0E58:  MOVLW  01
0E59:  BSF    03.6
0E5A:  MOVWF  18
0E5B:  MOVF   16,W
0E5C:  MOVWF  1F
0E5D:  MOVF   18,W
0E5E:  MOVWF  20
0E5F:  CLRF   22
0E60:  MOVLW  53
0E61:  MOVWF  21
0E62:  BCF    0A.3
0E63:  BCF    03.6
0E64:  CALL   7D6
0E65:  BSF    0A.3
....................       } 
0E66:  BSF    03.6
0E67:  INCF   16,F
0E68:  GOTO   625
....................    } 
0E69:  BCF    03.6
0E6A:  BCF    0A.3
0E6B:  BSF    0A.4
0E6C:  GOTO   5CA (RETURN)
.................... /* 
....................    FOR (TB = 0; TB < 4; TB++) 
....................    { 
....................  
....................       IF (!INPUT (68 + TB)) 
....................       { 
....................           DELAY_MS(200); 
....................           TT_THIETBI_TEMP[TB + 4] = ~TT_THIETBI_TEMP[TB + 4];            
....................       } 
....................    } 
.................... */ 
.................... } 
.................... INT BIN_TO_DEC() 
*
0CA4:  BSF    03.6
0CA5:  CLRF   1F
0CA6:  MOVLW  01
0CA7:  MOVWF  20
.................... { 
....................    INT8 DEC_VL = 0 ;  
....................    INT8 BASE = 1; 
....................    INT8 I; 
....................    FOR (I=0;I<8;I++) 
0CA8:  CLRF   21
0CA9:  MOVF   21,W
0CAA:  SUBLW  07
0CAB:  BTFSS  03.0
0CAC:  GOTO   4C8
....................    { 
....................    DEC_VL = DEC_VL+ BASE*TT_THIETBI_TEMP[I]; 
0CAD:  MOVF   21,W
0CAE:  MOVWF  22
0CAF:  CLRF   24
0CB0:  MOVLW  53
0CB1:  MOVWF  23
0CB2:  BCF    03.6
0CB3:  CALL   439
0CB4:  MOVLW  00
0CB5:  BTFSC  78.0
0CB6:  MOVLW  01
0CB7:  BSF    03.6
0CB8:  MOVWF  22
0CB9:  MOVF   20,W
0CBA:  MOVWF  25
0CBB:  MOVF   22,W
0CBC:  MOVWF  26
0CBD:  BCF    0A.3
0CBE:  BCF    03.6
0CBF:  CALL   769
0CC0:  BSF    0A.3
0CC1:  MOVF   78,W
0CC2:  BSF    03.6
0CC3:  ADDWF  1F,F
....................    BASE = BASE*2; 
0CC4:  BCF    03.0
0CC5:  RLF    20,F
0CC6:  INCF   21,F
0CC7:  GOTO   4A9
....................    } 
....................    RETURN DEC_VL; 
0CC8:  MOVF   1F,W
0CC9:  MOVWF  78
....................  
.................... } 
....................   
....................  VOID XUAT_DIEU_KHIEN() 
....................  { 
....................    LENH_DIEU_KHIEN = BIN_TO_DEC(); 
0CCA:  MOVF   78,W
0CCB:  BCF    03.6
0CCC:  MOVWF  41
....................    XUATTRANGTHAI (LENH_DIEU_KHIEN) ;   
0CCD:  MOVF   41,W
0CCE:  BSF    03.6
0CCF:  MOVWF  1F
....................    FOR (INT ST=0;ST<8;ST++){ 
*
0CF4:  BSF    03.6
0CF5:  CLRF   1E
0CF6:  MOVF   1E,W
0CF7:  SUBLW  07
0CF8:  BTFSS  03.0
0CF9:  GOTO   52D
....................       TEMP_CHAR = "0"; 
0CFA:  CLRF   1F
0CFB:  CLRF   20
0CFC:  MOVLW  7B
0CFD:  MOVWF  04
0CFE:  BCF    03.7
0CFF:  MOVF   1F,W
0D00:  ADDWF  04,F
0D01:  MOVF   20,W
0D02:  BCF    0A.3
0D03:  BCF    03.6
0D04:  CALL   058
0D05:  BSF    0A.3
0D06:  MOVWF  00
0D07:  IORLW  00
0D08:  BTFSC  03.2
0D09:  GOTO   50F
0D0A:  BSF    03.6
0D0B:  INCF   20,F
0D0C:  INCF   1F,F
0D0D:  GOTO   4FC
0D0E:  BCF    03.6
....................       ITOA(TT_THIETBI_TEMP[ST],10,TEMP_CHAR);       
0D0F:  BSF    03.6
0D10:  MOVF   1E,W
0D11:  MOVWF  22
0D12:  CLRF   24
0D13:  MOVLW  53
0D14:  MOVWF  23
0D15:  BCF    03.6
0D16:  CALL   439
0D17:  MOVLW  00
0D18:  BTFSC  78.0
0D19:  MOVLW  01
0D1A:  BSF    03.6
0D1B:  MOVWF  1F
0D1C:  CLRF   48
0D1D:  CLRF   47
0D1E:  CLRF   46
0D1F:  MOVF   1F,W
0D20:  MOVWF  45
0D21:  MOVLW  0A
0D22:  MOVWF  49
0D23:  CLRF   4B
0D24:  MOVLW  7B
0D25:  MOVWF  4A
0D26:  BCF    0A.3
0D27:  BCF    03.6
0D28:  CALL   43B
0D29:  BSF    0A.3
0D2A:  BSF    03.6
0D2B:  INCF   1E,F
0D2C:  GOTO   4F6
....................    } 
....................    //CHAR *PACKAGE_CONFIG[]={"*", "LENGHT","CF", "ID_GW1234" ,"ID_NODE","#"}; 
....................    IF(LENH_DIEU_KHIEN<10) TEMP_CHAR ="22"; 
0D2D:  BCF    03.6
0D2E:  MOVF   41,W
0D2F:  SUBLW  09
0D30:  BTFSS  03.0
0D31:  GOTO   549
0D32:  BSF    03.6
0D33:  CLRF   1F
0D34:  CLRF   20
0D35:  MOVLW  7B
0D36:  MOVWF  04
0D37:  BCF    03.7
0D38:  MOVF   1F,W
0D39:  ADDWF  04,F
0D3A:  MOVF   20,W
0D3B:  BCF    0A.3
0D3C:  BCF    03.6
0D3D:  CALL   064
0D3E:  BSF    0A.3
0D3F:  MOVWF  00
0D40:  IORLW  00
0D41:  BTFSC  03.2
0D42:  GOTO   548
0D43:  BSF    03.6
0D44:  INCF   20,F
0D45:  INCF   1F,F
0D46:  GOTO   535
0D47:  BCF    03.6
0D48:  GOTO   57E
....................    ELSE IF(LENH_DIEU_KHIEN>=10 && LENH_DIEU_KHIEN <100) TEMP_CHAR ="23"; 
0D49:  MOVF   41,W
0D4A:  SUBLW  09
0D4B:  BTFSC  03.0
0D4C:  GOTO   568
0D4D:  MOVF   41,W
0D4E:  SUBLW  63
0D4F:  BTFSS  03.0
0D50:  GOTO   568
0D51:  BSF    03.6
0D52:  CLRF   1F
0D53:  CLRF   20
0D54:  MOVLW  7B
0D55:  MOVWF  04
0D56:  BCF    03.7
0D57:  MOVF   1F,W
0D58:  ADDWF  04,F
0D59:  MOVF   20,W
0D5A:  BCF    0A.3
0D5B:  BCF    03.6
0D5C:  CALL   06B
0D5D:  BSF    0A.3
0D5E:  MOVWF  00
0D5F:  IORLW  00
0D60:  BTFSC  03.2
0D61:  GOTO   567
0D62:  BSF    03.6
0D63:  INCF   20,F
0D64:  INCF   1F,F
0D65:  GOTO   554
0D66:  BCF    03.6
0D67:  GOTO   57E
....................    ELSE TEMP_CHAR ="24";     
0D68:  BSF    03.6
0D69:  CLRF   1F
0D6A:  CLRF   20
0D6B:  MOVLW  7B
0D6C:  MOVWF  04
0D6D:  BCF    03.7
0D6E:  MOVF   1F,W
0D6F:  ADDWF  04,F
0D70:  MOVF   20,W
0D71:  BCF    0A.3
0D72:  BCF    03.6
0D73:  CALL   072
0D74:  BSF    0A.3
0D75:  MOVWF  00
0D76:  IORLW  00
0D77:  BTFSC  03.2
0D78:  GOTO   57E
0D79:  BSF    03.6
0D7A:  INCF   20,F
0D7B:  INCF   1F,F
0D7C:  GOTO   56B
0D7D:  BCF    03.6
....................    PRINTF ("*@"); 
0D7E:  MOVLW  2A
0D7F:  BTFSS  0C.4
0D80:  GOTO   57F
0D81:  MOVWF  19
0D82:  MOVLW  40
0D83:  BTFSS  0C.4
0D84:  GOTO   583
0D85:  MOVWF  19
....................    PRINTF (TEMP_CHAR); 
0D86:  MOVLW  7B
0D87:  MOVWF  04
0D88:  BCF    03.7
0D89:  BCF    0A.3
0D8A:  CALL   599
0D8B:  BSF    0A.3
....................    PRINTF ("@DK@"); 
0D8C:  MOVLW  00
0D8D:  BSF    03.6
0D8E:  MOVWF  0D
0D8F:  MOVLW  01
0D90:  MOVWF  0F
0D91:  BCF    03.6
0D92:  CALL   452
....................    PRINTF (ID_GATEWAY_CHAR); 
0D93:  MOVLW  5D
0D94:  MOVWF  04
0D95:  BCF    03.7
0D96:  BCF    0A.3
0D97:  CALL   599
0D98:  BSF    0A.3
....................    PRINTF ("@"); 
0D99:  MOVLW  40
0D9A:  BTFSS  0C.4
0D9B:  GOTO   59A
0D9C:  MOVWF  19
....................    PRINTF (ID_NODE_CHAR); 
0D9D:  MOVLW  56
0D9E:  MOVWF  04
0D9F:  BCF    03.7
0DA0:  BCF    0A.3
0DA1:  CALL   599
0DA2:  BSF    0A.3
....................    PRINTF ("@"); 
0DA3:  MOVLW  40
0DA4:  BTFSS  0C.4
0DA5:  GOTO   5A4
0DA6:  MOVWF  19
....................    ITOA(LENH_DIEU_KHIEN,10,TEMP_CHAR); 
0DA7:  BSF    03.6
0DA8:  CLRF   48
0DA9:  CLRF   47
0DAA:  CLRF   46
0DAB:  BCF    03.6
0DAC:  MOVF   41,W
0DAD:  BSF    03.6
0DAE:  MOVWF  45
0DAF:  MOVLW  0A
0DB0:  MOVWF  49
0DB1:  CLRF   4B
0DB2:  MOVLW  7B
0DB3:  MOVWF  4A
0DB4:  BCF    0A.3
0DB5:  BCF    03.6
0DB6:  CALL   43B
0DB7:  BSF    0A.3
....................    PRINTF (TEMP_CHAR); 
0DB8:  MOVLW  7B
0DB9:  MOVWF  04
0DBA:  BCF    03.7
0DBB:  BCF    0A.3
0DBC:  CALL   599
0DBD:  BSF    0A.3
....................    PRINTF ("@#"); 
0DBE:  MOVLW  40
0DBF:  BTFSS  0C.4
0DC0:  GOTO   5BF
0DC1:  MOVWF  19
0DC2:  MOVLW  23
0DC3:  BTFSS  0C.4
0DC4:  GOTO   5C3
0DC5:  MOVWF  19
....................     
....................     
....................    LCD_GOTOXY (1, 2) ; 
0DC6:  MOVLW  01
0DC7:  BSF    03.6
0DC8:  MOVWF  47
0DC9:  MOVLW  02
0DCA:  MOVWF  48
0DCB:  BCF    0A.3
0DCC:  BCF    03.6
0DCD:  CALL   2F0
0DCE:  BSF    0A.3
....................    DELAY_MS (10); 
0DCF:  MOVLW  0A
0DD0:  BSF    03.6
0DD1:  MOVWF  47
0DD2:  BCF    0A.3
0DD3:  BCF    03.6
0DD4:  CALL   176
0DD5:  BSF    0A.3
....................    PRINTF (LCD_PUTC, "SW: ");     
0DD6:  MOVLW  03
0DD7:  BSF    03.6
0DD8:  MOVWF  0D
0DD9:  MOVLW  01
0DDA:  MOVWF  0F
0DDB:  BCF    0A.3
0DDC:  BCF    03.6
0DDD:  CALL   33E
0DDE:  BSF    0A.3
....................    FOR (ST=0;ST<8;ST++){ 
0DDF:  BSF    03.6
0DE0:  CLRF   1E
0DE1:  MOVF   1E,W
0DE2:  SUBLW  07
0DE3:  BTFSS  03.0
0DE4:  GOTO   61E
....................       TEMP_CHAR = "0"; 
0DE5:  CLRF   1F
0DE6:  CLRF   20
0DE7:  MOVLW  7B
0DE8:  MOVWF  04
0DE9:  BCF    03.7
0DEA:  MOVF   1F,W
0DEB:  ADDWF  04,F
0DEC:  MOVF   20,W
0DED:  BCF    0A.3
0DEE:  BCF    03.6
0DEF:  CALL   058
0DF0:  BSF    0A.3
0DF1:  MOVWF  00
0DF2:  IORLW  00
0DF3:  BTFSC  03.2
0DF4:  GOTO   5FA
0DF5:  BSF    03.6
0DF6:  INCF   20,F
0DF7:  INCF   1F,F
0DF8:  GOTO   5E7
0DF9:  BCF    03.6
....................       ITOA(TT_THIETBI_TEMP[ST],10,TEMP_CHAR); 
0DFA:  BSF    03.6
0DFB:  MOVF   1E,W
0DFC:  MOVWF  22
0DFD:  CLRF   24
0DFE:  MOVLW  53
0DFF:  MOVWF  23
0E00:  BCF    03.6
0E01:  CALL   439
0E02:  MOVLW  00
0E03:  BTFSC  78.0
0E04:  MOVLW  01
0E05:  BSF    03.6
0E06:  MOVWF  1F
0E07:  CLRF   48
0E08:  CLRF   47
0E09:  CLRF   46
0E0A:  MOVF   1F,W
0E0B:  MOVWF  45
0E0C:  MOVLW  0A
0E0D:  MOVWF  49
0E0E:  CLRF   4B
0E0F:  MOVLW  7B
0E10:  MOVWF  4A
0E11:  BCF    0A.3
0E12:  BCF    03.6
0E13:  CALL   43B
0E14:  BSF    0A.3
....................       PRINTF (LCD_PUTC, TEMP_CHAR); 
0E15:  MOVLW  7B
0E16:  MOVWF  04
0E17:  BCF    03.7
0E18:  BCF    0A.3
0E19:  CALL   715
0E1A:  BSF    0A.3
0E1B:  BSF    03.6
0E1C:  INCF   1E,F
0E1D:  GOTO   5E1
....................    }    
0E1E:  BCF    03.6
0E1F:  RETURN
....................     
....................  } 
....................  VOID DIEUKHIENTHIETBI () 
*
1208:  BSF    03.6
1209:  CLRF   1C
....................  { 
....................     INT MA_DEC = 0; 
....................     MA_DEC = ATOI (KYTUCHAR2); 
120A:  CLRF   1F
120B:  MOVLW  D2
120C:  MOVWF  1E
120D:  BCF    0A.4
120E:  BSF    0A.3
120F:  BCF    03.6
1210:  CALL   356
1211:  BSF    0A.4
1212:  BCF    0A.3
1213:  MOVF   78,W
1214:  BSF    03.6
1215:  MOVWF  1C
....................  
....................    UNSIGNED INT8   SB;    
....................    #BIT BSERI  = MA_DEC.0 
....................     
....................    FOR (SB=0;SB<8;SB++) 
1216:  CLRF   1D
1217:  MOVF   1D,W
1218:  SUBLW  07
1219:  BTFSS  03.0
121A:  GOTO   22F
....................       {                                                     
....................          TT_THIETBI_TEMP[SB] = BSERI; 
121B:  MOVLW  00
121C:  BTFSC  1C.0
121D:  MOVLW  01
121E:  MOVWF  1E
121F:  MOVF   1D,W
1220:  MOVWF  1F
1221:  MOVF   1E,W
1222:  MOVWF  20
1223:  CLRF   22
1224:  MOVLW  53
1225:  MOVWF  21
1226:  BCF    0A.4
1227:  BCF    03.6
1228:  CALL   7D6
1229:  BSF    0A.4
....................          MA_DEC=MA_DEC>>1;  
122A:  BCF    03.0
122B:  BSF    03.6
122C:  RRF    1C,F
122D:  INCF   1D,F
122E:  GOTO   217
....................      }     
....................     XUAT_DIEU_KHIEN(); 
122F:  BCF    0A.4
1230:  BSF    0A.3
1231:  BCF    03.6
1232:  CALL   4A4
1233:  BSF    0A.4
1234:  BCF    0A.3
....................  } 
....................  
....................  
.................... #INCLUDE <analog.C> 
....................  
....................   INT ADC_READ (INT KENH) 
....................  { 
....................     UNSIGNED INT8 ANALOG_PORT[] = {1,2,4,8,16,32,64};  
*
125B:  MOVLW  01
125C:  MOVWF  1B
125D:  MOVLW  02
125E:  MOVWF  1C
125F:  MOVLW  04
1260:  MOVWF  1D
1261:  MOVLW  08
1262:  MOVWF  1E
1263:  MOVLW  10
1264:  MOVWF  1F
1265:  MOVLW  20
1266:  MOVWF  20
1267:  MOVLW  40
1268:  MOVWF  21
....................     SETUP_ADC_PORTS (ANALOG_PORT[KENH]); 
1269:  MOVLW  1B
126A:  ADDWF  1A,W
126B:  MOVWF  04
126C:  BSF    03.7
126D:  MOVF   00,W
126E:  MOVWF  23
126F:  MOVWF  24
1270:  CLRF   25
1271:  CLRF   26
1272:  CLRF   27
1273:  MOVLW  89
1274:  MOVWF  04
1275:  BSF    03.7
1276:  MOVLW  C0
1277:  ANDWF  00,F
1278:  MOVF   26,W
1279:  IORWF  00,F
127A:  MOVLW  9F
127B:  MOVWF  04
127C:  BCF    03.7
127D:  MOVLW  CF
127E:  ANDWF  00,F
127F:  MOVF   25,W
1280:  IORWF  00,F
1281:  MOVLW  88
1282:  MOVWF  04
1283:  BSF    03.7
1284:  MOVF   24,W
1285:  MOVWF  00
....................     DELAY_MS(3); 
1286:  MOVLW  03
1287:  MOVWF  47
1288:  BCF    0A.4
1289:  BCF    03.6
128A:  CALL   176
128B:  BSF    0A.4
....................     SET_ADC_CHANNEL (KENH); 
128C:  BSF    03.6
128D:  RLF    1A,W
128E:  MOVWF  77
128F:  RLF    77,F
1290:  MOVLW  FC
1291:  ANDWF  77,F
1292:  BCF    03.6
1293:  MOVF   1F,W
1294:  ANDLW  C3
1295:  IORWF  77,W
1296:  MOVWF  1F
....................     DELAY_MS(3); 
1297:  MOVLW  03
1298:  BSF    03.6
1299:  MOVWF  47
129A:  BCF    0A.4
129B:  BCF    03.6
129C:  CALL   176
129D:  BSF    0A.4
....................     KQADC = 0; 
129E:  CLRF   33
129F:  CLRF   32
....................     FOR (INT I = 0; I < 100; I++) 
12A0:  BSF    03.6
12A1:  CLRF   22
12A2:  MOVF   22,W
12A3:  SUBLW  63
12A4:  BTFSS  03.0
12A5:  GOTO   2BC
....................     { 
....................        KQADC = KQADC + READ_ADC () ; 
12A6:  BCF    03.6
12A7:  BSF    1F.1
12A8:  BTFSC  1F.1
12A9:  GOTO   2A8
12AA:  BSF    03.5
12AB:  MOVF   1E,W
12AC:  BCF    03.5
12AD:  ADDWF  32,F
12AE:  MOVF   1E,W
12AF:  BTFSC  03.0
12B0:  INCFSZ 1E,W
12B1:  ADDWF  33,F
....................        DELAY_MS (1); 
12B2:  MOVLW  01
12B3:  BSF    03.6
12B4:  MOVWF  47
12B5:  BCF    0A.4
12B6:  BCF    03.6
12B7:  CALL   176
12B8:  BSF    0A.4
12B9:  BSF    03.6
12BA:  INCF   22,F
12BB:  GOTO   2A2
....................     } 
....................  
....................     KQADC = KQADC / (100 * 2.046); 
12BC:  BCF    03.6
12BD:  MOVF   33,W
12BE:  BSF    03.6
12BF:  MOVWF  24
12C0:  BCF    03.6
12C1:  MOVF   32,W
12C2:  BSF    03.6
12C3:  MOVWF  23
*
12E0:  MOVF   7A,W
12E1:  MOVWF  26
12E2:  MOVF   79,W
12E3:  MOVWF  25
12E4:  MOVF   78,W
12E5:  MOVWF  24
12E6:  MOVF   77,W
12E7:  MOVWF  23
12E8:  MOVLW  9A
12E9:  MOVWF  2A
12EA:  MOVLW  99
12EB:  MOVWF  29
12EC:  MOVLW  4C
12ED:  MOVWF  28
12EE:  MOVLW  86
12EF:  MOVWF  27
*
13B9:  MOVF   7A,W
13BA:  MOVWF  26
13BB:  MOVF   79,W
13BC:  MOVWF  25
13BD:  MOVF   78,W
13BE:  MOVWF  24
13BF:  MOVF   77,W
13C0:  MOVWF  23
*
13DF:  MOVF   79,W
13E0:  BCF    03.6
13E1:  MOVWF  33
13E2:  MOVF   78,W
13E3:  MOVWF  32
....................     RETURN KQADC; 
13E4:  MOVF   32,W
13E5:  MOVWF  78
....................  } 
....................  
....................  
....................  VOID READ_ANALOG ( ) 
*
124A:  BSF    03.6
124B:  CLRF   16
....................  { 
....................    SIGNED INT8 CHENH_LECH = 0; 
....................    FOR(INT K = 0; K<SOLUONGCAMBIEN_CONFIG; K++){ 
124C:  CLRF   17
124D:  BCF    03.6
124E:  MOVF   50,W
124F:  BSF    03.6
1250:  SUBWF  17,W
1251:  BTFSC  03.0
1252:  GOTO   48A
....................       KET_QUA_ANALOG[K] = ADC_READ (K);   
1253:  MOVLW  34
1254:  ADDWF  17,W
1255:  MOVWF  18
1256:  CLRF   19
1257:  BTFSC  03.0
1258:  INCF   19,F
1259:  MOVF   17,W
125A:  MOVWF  1A
*
13E6:  BSF    03.6
13E7:  MOVF   18,W
13E8:  MOVWF  04
13E9:  BCF    03.7
13EA:  BTFSC  19.0
13EB:  BSF    03.7
13EC:  MOVF   78,W
13ED:  MOVWF  00
....................       CHENH_LECH = ABS( KET_QUA_ANALOG[K] -KET_QUA_ANALOG_TEMP[K] ); 
13EE:  MOVLW  34
13EF:  ADDWF  17,W
13F0:  MOVWF  04
13F1:  BCF    03.7
13F2:  MOVF   00,W
13F3:  MOVWF  18
13F4:  MOVLW  39
13F5:  ADDWF  17,W
13F6:  MOVWF  04
13F7:  BCF    03.7
13F8:  MOVF   00,W
13F9:  SUBWF  18,F
13FA:  MOVF   18,W
13FB:  MOVWF  16
....................       IF (CHENH_LECH>0.5){ 
13FC:  CLRF   19
13FD:  MOVF   16,W
13FE:  MOVWF  18
13FF:  BTFSC  18.7
1400:  DECF   19,F
*
1425:  CLRF   1B
1426:  CLRF   1A
1427:  CLRF   19
1428:  MOVLW  7E
1429:  MOVWF  18
142A:  MOVF   7A,W
142B:  MOVWF  1F
142C:  MOVF   79,W
142D:  MOVWF  1E
142E:  MOVF   78,W
142F:  MOVWF  1D
1430:  MOVF   77,W
1431:  MOVWF  1C
*
1470:  BTFSS  03.0
1471:  GOTO   475
....................       TT_SEND_ANALOG = 1; 
1472:  BCF    03.6
1473:  BSF    55.0
1474:  BSF    03.6
....................       } 
....................       KET_QUA_ANALOG_TEMP[K] = KET_QUA_ANALOG[K]; 
1475:  MOVLW  39
1476:  ADDWF  17,W
1477:  MOVWF  18
1478:  CLRF   19
1479:  BTFSC  03.0
147A:  INCF   19,F
147B:  MOVLW  34
147C:  ADDWF  17,W
147D:  MOVWF  04
147E:  BCF    03.7
147F:  MOVF   00,W
1480:  MOVWF  1A
1481:  MOVF   18,W
1482:  MOVWF  04
1483:  BCF    03.7
1484:  BTFSC  19.0
1485:  BSF    03.7
1486:  MOVF   1A,W
1487:  MOVWF  00
1488:  INCF   17,F
1489:  GOTO   24D
....................    } 
148A:  BCF    03.6
148B:  BCF    0A.3
148C:  BSF    0A.4
148D:  GOTO   5DA (RETURN)
....................  } 
.................... /* 
....................  VOID SEND_ANALOG_UART() 
....................  { 
....................    OUTPUT_TOGGLE(PIN_C4); 
....................    //CHAR *PACKAGE_SS[]={"*", "26","SS", "IDGW12" ,"NODE","ZZ","AA","VV","CC","SS"}; 
....................    CHAR *PACKAGE_SS[]={"ZZ","AA","VV","CC","SS"};    
....................    PACKAGE_SS[0] = ID_GATEWAY_CHAR; 
....................    PACKAGE_SS[1] = ID_NODE_CHAR; 
....................    UNSIGNED INT8 DO_DAI =20; 
....................     
....................    FOR(INT I = 0; I<SOLUONGCAMBIEN_CONFIG; I++) 
....................    { 
....................       ITOA(KET_QUA_ANALOG[I],10,PACKAGE_SS[I]); 
....................       DO_DAI = DO_DAI + 3; 
....................    }       
....................    ITOA(DO_DAI,10,TEMP_CHAR2); 
....................    PRINTF ("*@");    
....................    PRINTF (TEMP_CHAR2); 
....................    PRINTF ("@SS@");    
....................    PRINTF (ID_GATEWAY_CHAR); 
....................    PRINTF ("@"); 
....................    PRINTF (ID_NODE_CHAR); 
....................    PRINTF ("@");    
....................    FOR ( I = 0; I < SOLUONGCAMBIEN_CONFIG; I++) 
....................    { 
....................       PRINTF (PACKAGE_SS[I]); 
....................       PRINTF ("@"); 
....................    } 
....................    PRINTF ("#"); 
....................    OUTPUT_TOGGLE(PIN_C4); 
....................     
....................  } 
....................   
....................   
....................  */ 
....................   
....................  /* 
....................  INT ADC_READ (INT KENH) 
....................  { 
....................     UNSIGNED INT8 ANALOG_PORT[] = {1, 2, 4, 8, 16, 32, 64}; 
....................     SETUP_ADC_PORTS (ANALOG_PORT[KENH]); 
....................     DELAY_MS (3) ; 
....................     SET_ADC_CHANNEL (KENH); 
....................     DELAY_MS (3) ; 
....................     KQADC = 0; 
....................     FOR (INT I = 0; I < 100; I++) 
....................     { 
....................        KQADC = KQADC + READ_ADC () ; 
....................        DELAY_MS (1); 
....................     } 
....................  
....................     KQADC = KQADC / (100 * 2.046); 
....................     RETURN KQADC; 
....................  } 
....................  
....................  VOID READ_ANALOG () 
....................  { 
....................     FOR (INT K = 0; K < SOLUONGCAMBIEN_CONFIG; K++) 
....................     { 
....................        KET_QUA_ANALOG[K] = ADC_READ (K); 
....................     } 
....................  } 
.................... */ 
....................  VOID SEND_ANALOG_UART () 
....................  { 
....................     OUTPUT_TOGGLE (PIN_C4) ; 
*
0E6D:  BCF    31.4
0E6E:  MOVF   31,W
0E6F:  BSF    03.5
0E70:  MOVWF  07
0E71:  MOVLW  10
0E72:  BCF    03.5
0E73:  XORWF  07,F
....................     //CHAR * PACKAGE_SS[] ={" * ", "26", "SS", "IDGW12", "NODE", "ZZ", "AA", "VV", "CC", "SS"}; 
....................     CHAR * PACKAGE_SS[] ={"IDGW12", "NODE", "ZZ", "AA", "VV", "CC", "SS"}; 
0E74:  MOVLW  49
0E75:  BSF    03.6
0E76:  MOVWF  24
0E77:  MOVLW  44
0E78:  MOVWF  25
0E79:  MOVLW  47
0E7A:  MOVWF  26
0E7B:  MOVLW  57
0E7C:  MOVWF  27
0E7D:  MOVLW  31
0E7E:  MOVWF  28
0E7F:  MOVLW  32
0E80:  MOVWF  29
0E81:  CLRF   2A
0E82:  MOVLW  4E
0E83:  MOVWF  2B
0E84:  MOVLW  4F
0E85:  MOVWF  2C
0E86:  MOVLW  44
0E87:  MOVWF  2D
0E88:  MOVLW  45
0E89:  MOVWF  2E
0E8A:  CLRF   2F
0E8B:  MOVLW  5A
0E8C:  MOVWF  30
0E8D:  MOVWF  31
0E8E:  CLRF   32
0E8F:  MOVLW  41
0E90:  MOVWF  33
0E91:  MOVWF  34
0E92:  CLRF   35
0E93:  MOVLW  56
0E94:  MOVWF  36
0E95:  MOVWF  37
0E96:  CLRF   38
0E97:  MOVLW  43
0E98:  MOVWF  39
0E99:  MOVWF  3A
0E9A:  CLRF   3B
0E9B:  MOVLW  53
0E9C:  MOVWF  3C
0E9D:  MOVWF  3D
0E9E:  CLRF   3E
0E9F:  MOVLW  01
0EA0:  MOVWF  17
0EA1:  MOVLW  24
0EA2:  MOVWF  16
0EA3:  MOVLW  01
0EA4:  MOVWF  19
0EA5:  MOVLW  2B
0EA6:  MOVWF  18
0EA7:  MOVLW  01
0EA8:  MOVWF  1B
0EA9:  MOVLW  30
0EAA:  MOVWF  1A
0EAB:  MOVLW  01
0EAC:  MOVWF  1D
0EAD:  MOVLW  33
0EAE:  MOVWF  1C
0EAF:  MOVLW  01
0EB0:  MOVWF  1F
0EB1:  MOVLW  36
0EB2:  MOVWF  1E
0EB3:  MOVLW  01
0EB4:  MOVWF  21
0EB5:  MOVLW  39
0EB6:  MOVWF  20
0EB7:  MOVLW  01
0EB8:  MOVWF  23
0EB9:  MOVLW  3C
0EBA:  MOVWF  22
....................     PACKAGE_SS[0] = ID_GATEWAY_CHAR; 
0EBB:  CLRF   17
0EBC:  MOVLW  5D
0EBD:  MOVWF  16
....................     PACKAGE_SS[1] = ID_NODE_CHAR; 
0EBE:  CLRF   19
0EBF:  MOVLW  56
0EC0:  MOVWF  18
....................     UNSIGNED INT8 DO_DAI = 20; 
0EC1:  MOVLW  14
0EC2:  MOVWF  3F
....................      
....................     FOR (INT I = 0; I < SOLUONGCAMBIEN_CONFIG; I++) 
0EC3:  CLRF   40
0EC4:  BCF    03.6
0EC5:  MOVF   50,W
0EC6:  BSF    03.6
0EC7:  SUBWF  40,W
0EC8:  BTFSC  03.0
0EC9:  GOTO   70D
....................     { 
....................        ITOA (KET_QUA_ANALOG[I], 10, PACKAGE_SS[2 + I]) ; 
0ECA:  MOVLW  34
0ECB:  ADDWF  40,W
0ECC:  MOVWF  04
0ECD:  BCF    03.7
0ECE:  MOVF   00,W
0ECF:  MOVWF  41
0ED0:  MOVLW  02
0ED1:  ADDWF  40,W
0ED2:  MOVWF  77
0ED3:  BCF    03.0
0ED4:  RLF    77,F
0ED5:  MOVF   77,W
0ED6:  ADDLW  16
0ED7:  MOVWF  04
0ED8:  BSF    03.7
0ED9:  INCF   04,F
0EDA:  MOVF   00,W
0EDB:  MOVWF  43
0EDC:  DECF   04,F
0EDD:  MOVF   00,W
0EDE:  MOVWF  42
0EDF:  CLRF   48
0EE0:  CLRF   47
0EE1:  CLRF   46
0EE2:  MOVF   41,W
0EE3:  MOVWF  45
0EE4:  MOVLW  0A
0EE5:  MOVWF  49
0EE6:  MOVF   43,W
0EE7:  MOVWF  4B
0EE8:  MOVF   42,W
0EE9:  MOVWF  4A
0EEA:  BCF    0A.3
0EEB:  BCF    03.6
0EEC:  CALL   43B
0EED:  BSF    0A.3
....................        DO_DAI = DO_DAI + strlen(PACKAGE_SS[2 + I])+1; 
0EEE:  MOVLW  02
0EEF:  BSF    03.6
0EF0:  ADDWF  40,W
0EF1:  MOVWF  77
0EF2:  BCF    03.0
0EF3:  RLF    77,F
0EF4:  MOVF   77,W
0EF5:  ADDLW  16
0EF6:  MOVWF  04
0EF7:  BSF    03.7
0EF8:  INCF   04,F
0EF9:  MOVF   00,W
0EFA:  MOVWF  42
0EFB:  DECF   04,F
0EFC:  MOVF   00,W
0EFD:  MOVWF  41
0EFE:  MOVF   42,W
0EFF:  MOVWF  44
0F00:  MOVF   41,W
0F01:  MOVWF  43
0F02:  BCF    0A.3
0F03:  BCF    03.6
0F04:  CALL   749
0F05:  BSF    0A.3
0F06:  MOVF   78,W
0F07:  BSF    03.6
0F08:  ADDWF  3F,W
0F09:  ADDLW  01
0F0A:  MOVWF  3F
0F0B:  INCF   40,F
0F0C:  GOTO   6C4
....................     } 
....................  
....................     ITOA (DO_DAI, 10, TEMP_CHAR2) ; 
0F0D:  CLRF   48
0F0E:  CLRF   47
0F0F:  CLRF   46
0F10:  MOVF   3F,W
0F11:  MOVWF  45
0F12:  MOVLW  0A
0F13:  MOVWF  49
0F14:  CLRF   4B
0F15:  MOVLW  7D
0F16:  MOVWF  4A
0F17:  BCF    0A.3
0F18:  BCF    03.6
0F19:  CALL   43B
0F1A:  BSF    0A.3
....................     PRINTF ("*@"); 
0F1B:  MOVLW  2A
0F1C:  BTFSS  0C.4
0F1D:  GOTO   71C
0F1E:  MOVWF  19
0F1F:  MOVLW  40
0F20:  BTFSS  0C.4
0F21:  GOTO   720
0F22:  MOVWF  19
....................     PRINTF (TEMP_CHAR2); 
0F23:  MOVLW  7D
0F24:  MOVWF  04
0F25:  BCF    03.7
0F26:  BCF    0A.3
0F27:  CALL   599
0F28:  BSF    0A.3
....................     PRINTF ("@SS@"); 
0F29:  MOVLW  06
0F2A:  BSF    03.6
0F2B:  MOVWF  0D
0F2C:  MOVLW  01
0F2D:  MOVWF  0F
0F2E:  BCF    03.6
0F2F:  CALL   452
....................     FOR (I = 0; I < 2 + SOLUONGCAMBIEN_CONFIG; I++) 
0F30:  BSF    03.6
0F31:  CLRF   40
0F32:  MOVLW  02
0F33:  BCF    03.6
0F34:  ADDWF  50,W
0F35:  BSF    03.6
0F36:  SUBWF  40,W
0F37:  BTFSC  03.0
0F38:  GOTO   753
....................     { 
....................        PRINTF (PACKAGE_SS[I]); 
0F39:  BCF    03.0
0F3A:  RLF    40,W
0F3B:  ADDLW  16
0F3C:  MOVWF  04
0F3D:  BSF    03.7
0F3E:  INCF   04,F
0F3F:  MOVF   00,W
0F40:  MOVWF  42
0F41:  DECF   04,F
0F42:  MOVF   00,W
0F43:  MOVWF  41
0F44:  MOVWF  04
0F45:  BCF    03.7
0F46:  BTFSC  42.0
0F47:  BSF    03.7
0F48:  BCF    0A.3
0F49:  BCF    03.6
0F4A:  CALL   599
0F4B:  BSF    0A.3
....................        PRINTF ("@"); 
0F4C:  MOVLW  40
0F4D:  BTFSS  0C.4
0F4E:  GOTO   74D
0F4F:  MOVWF  19
0F50:  BSF    03.6
0F51:  INCF   40,F
0F52:  GOTO   732
....................     } 
....................  
....................     PRINTF ("#"); 
0F53:  MOVLW  23
0F54:  BCF    03.6
0F55:  BTFSS  0C.4
0F56:  GOTO   755
0F57:  MOVWF  19
....................     OUTPUT_TOGGLE (PIN_C4) ; 
0F58:  BCF    31.4
0F59:  MOVF   31,W
0F5A:  BSF    03.5
0F5B:  MOVWF  07
0F5C:  MOVLW  10
0F5D:  BCF    03.5
0F5E:  XORWF  07,F
0F5F:  BCF    0A.3
0F60:  BSF    0A.4
0F61:  GOTO   5E0 (RETURN)
....................  } 
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
.................... VOID QUET_PHIM() 
*
0109:  BSF    03.6
010A:  CLRF   6A
.................... { 
....................    INT BDT = 0; 
....................    WHILE (!INPUT (BT1_PIN)) //NEU NUT BAM DUOC BAM 
010B:  BSF    03.5
010C:  BCF    03.6
010D:  BSF    06.1
010E:  BCF    03.5
010F:  BTFSC  06.1
0110:  GOTO   126
....................    { 
....................       IF (TMR1IF) 
0111:  BTFSS  0C.0
0112:  GOTO   123
....................       { 
....................          OUTPUT_TOGGLE (PIN_C4); 
0113:  BCF    31.4
0114:  MOVF   31,W
0115:  BSF    03.5
0116:  MOVWF  07
0117:  MOVLW  10
0118:  BCF    03.5
0119:  XORWF  07,F
....................          TMR1IF = 0; SET_TIMER1 (3036); BDT++; 
011A:  BCF    0C.0
011B:  CLRF   0E
011C:  MOVLW  0B
011D:  MOVWF  0F
011E:  MOVLW  DC
011F:  MOVWF  0E
0120:  BSF    03.6
0121:  INCF   6A,F
0122:  BCF    03.6
....................       } 
0123:  BSF    03.6
0124:  GOTO   10B
0125:  BCF    03.6
....................    } 
....................  
....................    IF (BDT > 10) 
0126:  BSF    03.6
0127:  MOVF   6A,W
0128:  SUBLW  0A
0129:  BTFSC  03.0
012A:  GOTO   134
....................    { 
....................       //CONFIG NODE 
....................       TT_CONFIG = ~TT_CONFIG; // VAO TRANG THAI CONFIG 
012B:  MOVLW  02
012C:  BCF    03.6
012D:  XORWF  54,F
....................       TT_CONTROL = ~TT_CONTROL; 
012E:  MOVLW  04
012F:  XORWF  54,F
....................       //CONFIG_DONE (); 
....................       TT_CONFIG_DONE = 1; 
0130:  BSF    54.3
....................       TT_FUN = 0; 
0131:  BCF    54.4
....................    } 
0132:  GOTO   14B
0133:  BSF    03.6
....................  
....................    ELSE IF (BDT > 1&&BDT < 10) 
0134:  MOVF   6A,W
0135:  SUBLW  01
0136:  BTFSC  03.0
0137:  GOTO   142
0138:  MOVF   6A,W
0139:  SUBLW  09
013A:  BTFSS  03.0
013B:  GOTO   142
....................    { 
....................       BUTT_OKE (); //OKE 
....................    } 
*
0140:  GOTO   14B
0141:  BSF    03.6
....................  
....................    ELSE 
....................    {             
....................       //TMR1IF = 0; SET_TIMER1 (0);       
....................       TT_SW = 1; 
0142:  BCF    03.6
0143:  BSF    54.7
....................       OUTPUT_TOGGLE (PIN_C4); 
0144:  BCF    31.4
0145:  MOVF   31,W
0146:  BSF    03.5
0147:  MOVWF  07
0148:  MOVLW  10
0149:  BCF    03.5
014A:  XORWF  07,F
....................       //READ_BTN_STATE () ;       
....................    } 
.................... } 
....................  
.................... #INT_EXT 
....................  
....................  VOID NGAT_NGOAI  () 
....................  { 
....................     QUET_PHIM (); 
....................  } 
....................  
014B:  BCF    0B.1
014C:  BCF    0A.3
014D:  BCF    0A.4
014E:  GOTO   031
....................  #INT_RDA 
....................  VOID NGAT  () 
....................  { 
....................     KYTUCHAR[VT] = GETCH (); 
014F:  MOVLW  A0
0150:  ADDWF  3F,W
0151:  MOVWF  04
0152:  BCF    03.7
0153:  BTFSS  0C.5
0154:  GOTO   153
0155:  MOVF   1A,W
0156:  MOVWF  00
....................  
....................     IF (KYTUCHAR[VT] == '.') 
0157:  MOVLW  A0
0158:  ADDWF  3F,W
0159:  MOVWF  04
015A:  BCF    03.7
015B:  MOVF   00,W
015C:  SUBLW  2E
015D:  BTFSS  03.2
015E:  GOTO   167
....................     { 
....................        KYTUCHAR[VT] = '\0'; 
015F:  MOVLW  A0
0160:  ADDWF  3F,W
0161:  MOVWF  04
0162:  BCF    03.7
0163:  CLRF   00
....................        VT = 0; 
0164:  CLRF   3F
....................        TTNHAN = 1; 
0165:  BSF    54.0
....................     } 
0166:  GOTO   168
....................  
....................     ELSE 
....................     VT++; 
0167:  INCF   3F,F
0168:  BCF    0C.5
0169:  BCF    0A.3
016A:  BCF    0A.4
016B:  GOTO   031
....................  } 
....................  
....................  VOID XU_LY_UART () 
*
1000:  MOVLW  2A
1001:  BSF    03.6
1002:  MOVWF  16
....................  { 
....................     //ID_NODE_NHAN = KYTU[1] - 48; 
....................     //ID_DEVICE_NHAN = KYTU[2] - 48 + 64; 
....................     //TT_DEVICE_NHAN = KYTU[3] - 48; // - 48 ASCII -- > S?. + 64 -- > PORT_D (D0 = 64) 
....................     /* TINH DO DAI*/ 
....................     
....................     CHAR CH = '*'; 
....................     CHAR * RET; 
....................     * ID_NODE_NHAN = '\0'; 
1003:  CLRF   7A
1004:  MOVLW  66
1005:  MOVWF  04
1006:  BCF    03.7
1007:  BTFSC  7A.0
1008:  BSF    03.7
1009:  CLRF   00
....................     * ID_GW_NHAN = '\0'; 
100A:  CLRF   7A
100B:  MOVLW  6D
100C:  MOVWF  04
100D:  BCF    03.7
100E:  BTFSC  7A.0
100F:  BSF    03.7
1010:  CLRF   00
....................     KYTUCHAR2 = ""; 
1011:  CLRF   1C
1012:  CLRF   1D
1013:  MOVLW  D2
1014:  MOVWF  04
1015:  BCF    03.7
1016:  MOVF   1C,W
1017:  ADDWF  04,F
1018:  MOVF   1D,W
1019:  BCF    0A.4
101A:  BCF    03.6
101B:  CALL   07F
101C:  BSF    0A.4
101D:  MOVWF  00
101E:  IORLW  00
101F:  BTFSC  03.2
1020:  GOTO   026
1021:  BSF    03.6
1022:  INCF   1D,F
1023:  INCF   1C,F
1024:  GOTO   013
1025:  BCF    03.6
....................     UNSIGNED INT8 LEN_RET; 
....................     RET = STRCHR (KYTUCHAR, CH); 
1026:  BSF    03.6
1027:  CLRF   1D
1028:  MOVLW  A0
1029:  MOVWF  1C
102A:  MOVF   16,W
102B:  MOVWF  1E
*
104D:  MOVF   79,W
104E:  MOVWF  18
104F:  MOVF   78,W
1050:  MOVWF  17
....................     LEN_RET = STRLEN (RET); 
1051:  MOVF   18,W
1052:  MOVWF  44
1053:  MOVF   17,W
1054:  MOVWF  43
1055:  BCF    0A.4
1056:  BCF    03.6
1057:  CALL   749
1058:  BSF    0A.4
1059:  MOVF   78,W
105A:  BSF    03.6
105B:  MOVWF  19
....................  
....................     /* LAY TOKEN DAU TIEN */ 
....................     KYTU = 0; 
105C:  BCF    03.6
105D:  CLRF   40
....................     TEMP_CHAR = "#"; 
105E:  BSF    03.6
105F:  CLRF   1C
1060:  CLRF   1D
1061:  MOVLW  7B
1062:  MOVWF  04
1063:  BCF    03.7
1064:  MOVF   1C,W
1065:  ADDWF  04,F
1066:  MOVF   1D,W
1067:  BCF    0A.4
1068:  BCF    03.6
1069:  CALL   079
106A:  BSF    0A.4
106B:  MOVWF  00
106C:  IORLW  00
106D:  BTFSC  03.2
106E:  GOTO   074
106F:  BSF    03.6
1070:  INCF   1D,F
1071:  INCF   1C,F
1072:  GOTO   061
1073:  BCF    03.6
....................     CHAR * TOKEN; 
....................     TOKEN = STRTOK (KYTUCHAR, TEMP_CHAR); 
1074:  BSF    03.6
1075:  CLRF   1F
1076:  MOVLW  A0
1077:  MOVWF  1E
1078:  CLRF   21
1079:  MOVLW  7B
107A:  MOVWF  20
107B:  BCF    0A.4
107C:  BSF    0A.3
107D:  BCF    03.6
107E:  CALL   265
107F:  BSF    0A.4
1080:  BCF    0A.3
1081:  MOVF   79,W
1082:  BSF    03.6
1083:  MOVWF  1B
1084:  MOVF   78,W
1085:  MOVWF  1A
....................  
....................     /* DUYET QUA CAC TOKEN CON LAI */ 
....................     WHILE (TOKEN != NULL) 
1086:  MOVF   1A,F
1087:  BTFSS  03.2
1088:  GOTO   08C
1089:  MOVF   1B,F
108A:  BTFSC  03.2
108B:  GOTO   0EB
....................     { 
....................        SWITCH (KYTU) 
108C:  BCF    03.6
108D:  MOVF   40,W
108E:  ADDLW  FA
108F:  BTFSC  03.0
1090:  GOTO   0D6
1091:  ADDLW  06
1092:  GOTO   240
....................        { 
....................           CASE 0: 
....................           BREAK; 
1093:  GOTO   0D6
....................  
....................           CASE 1: 
....................           STRCAT (ID_GW_NHAN, TOKEN); 
1094:  BSF    03.6
1095:  CLRF   45
1096:  MOVLW  6D
1097:  MOVWF  44
1098:  MOVF   1B,W
1099:  MOVWF  47
109A:  MOVF   1A,W
109B:  MOVWF  46
109C:  BCF    0A.4
109D:  BCF    03.6
109E:  CALL   55B
109F:  BSF    0A.4
....................           BREAK; 
10A0:  GOTO   0D6
....................  
....................           CASE 2: 
....................           STRCAT (ID_NODE_NHAN, TOKEN); 
10A1:  BSF    03.6
10A2:  CLRF   45
10A3:  MOVLW  66
10A4:  MOVWF  44
10A5:  MOVF   1B,W
10A6:  MOVWF  47
10A7:  MOVF   1A,W
10A8:  MOVWF  46
10A9:  BCF    0A.4
10AA:  BCF    03.6
10AB:  CALL   55B
10AC:  BSF    0A.4
....................           BREAK; 
10AD:  GOTO   0D6
....................  
....................           CASE 3: 
....................           LENHDIEUKHIEN = ATOI (TOKEN); 
10AE:  BSF    03.6
10AF:  MOVF   1B,W
10B0:  MOVWF  1F
10B1:  MOVF   1A,W
10B2:  MOVWF  1E
10B3:  BCF    0A.4
10B4:  BSF    0A.3
10B5:  BCF    03.6
10B6:  CALL   356
10B7:  BSF    0A.4
10B8:  BCF    0A.3
10B9:  MOVF   78,W
10BA:  MOVWF  4D
....................           BREAK; 
10BB:  GOTO   0D6
....................  
....................           CASE 4: 
....................           DODAI_DATA_NHAN = ATOI (TOKEN); 
10BC:  BSF    03.6
10BD:  MOVF   1B,W
10BE:  MOVWF  1F
10BF:  MOVF   1A,W
10C0:  MOVWF  1E
10C1:  BCF    0A.4
10C2:  BSF    0A.3
10C3:  BCF    03.6
10C4:  CALL   356
10C5:  BSF    0A.4
10C6:  BCF    0A.3
10C7:  MOVF   78,W
10C8:  MOVWF  4E
....................           BREAK; 
10C9:  GOTO   0D6
....................  
....................           CASE 5: 
....................           STRCAT (KYTUCHAR2, TOKEN); 
10CA:  BSF    03.6
10CB:  CLRF   45
10CC:  MOVLW  D2
10CD:  MOVWF  44
10CE:  MOVF   1B,W
10CF:  MOVWF  47
10D0:  MOVF   1A,W
10D1:  MOVWF  46
10D2:  BCF    0A.4
10D3:  BCF    03.6
10D4:  CALL   55B
10D5:  BSF    0A.4
....................           BREAK; 
....................        } 
....................  
....................        TOKEN = STRTOK (NULL, TEMP_CHAR); 
10D6:  BSF    03.6
10D7:  CLRF   1F
10D8:  CLRF   1E
10D9:  CLRF   21
10DA:  MOVLW  7B
10DB:  MOVWF  20
10DC:  BCF    0A.4
10DD:  BSF    0A.3
10DE:  BCF    03.6
10DF:  CALL   265
10E0:  BSF    0A.4
10E1:  BCF    0A.3
10E2:  MOVF   79,W
10E3:  BSF    03.6
10E4:  MOVWF  1B
10E5:  MOVF   78,W
10E6:  MOVWF  1A
....................        KYTU++; 
10E7:  BCF    03.6
10E8:  INCF   40,F
10E9:  BSF    03.6
10EA:  GOTO   086
....................     } 
....................  
....................     /* SO SANH ID returns - 1 IF s1 < s2, 0 if s1 = s2, 1 if s1 > s2 */ 
....................     SOSANH_IDGW = STRCMP (ID_GW_NHAN, ID_GATEWAY_CHAR); 
10EB:  CLRF   1D
10EC:  MOVLW  6D
10ED:  MOVWF  1C
10EE:  CLRF   1F
10EF:  MOVLW  5D
10F0:  MOVWF  1E
10F1:  BCF    0A.4
10F2:  BCF    03.6
10F3:  CALL   790
10F4:  BSF    0A.4
10F5:  MOVF   78,W
10F6:  MOVWF  52
....................     SOSANH_IDNODE = STRCMP (ID_NODE_NHAN, ID_NODE_CHAR); 
10F7:  BSF    03.6
10F8:  CLRF   1D
10F9:  MOVLW  66
10FA:  MOVWF  1C
10FB:  CLRF   1F
10FC:  MOVLW  56
10FD:  MOVWF  1E
10FE:  BCF    0A.4
10FF:  BCF    03.6
1100:  CALL   790
1101:  BSF    0A.4
1102:  MOVF   78,W
1103:  MOVWF  51
....................      
....................     IF (SOSANH_IDGW == 0&&SOSANH_IDNODE == 0&&LEN_RET == DODAI_DATA_NHAN) 
1104:  MOVF   52,F
1105:  BTFSS  03.2
1106:  GOTO   236
1107:  MOVF   51,F
1108:  BTFSS  03.2
1109:  GOTO   236
110A:  MOVF   4E,W
110B:  BSF    03.6
110C:  SUBWF  19,W
110D:  BTFSC  03.2
110E:  GOTO   111
110F:  BCF    03.6
1110:  GOTO   236
....................     { 
....................        SWITCH (LENHDIEUKHIEN) 
1111:  BCF    03.6
1112:  MOVF   4D,W
1113:  BTFSC  03.2
1114:  GOTO   11C
1115:  XORLW  01
1116:  BTFSC  03.2
1117:  GOTO   11D
1118:  XORLW  03
1119:  BTFSC  03.2
111A:  GOTO   208
111B:  GOTO   235
....................        { 
....................           CASE 0: 
....................           BREAK; 
111C:  GOTO   235
....................  
....................           CASE 1: 
....................           XACNHANCONFIG () ; 
....................           BREAK; 
*
1207:  GOTO   235
....................  
....................           CASE 2: 
....................           DIEUKHIENTHIETBI () ; 
....................           BREAK; 
....................        } 
....................     } 
*
1235:  GOTO   23D
....................  
....................     ELSE 
....................     { 
....................        DELAY_MS (10); 
1236:  MOVLW  0A
1237:  BSF    03.6
1238:  MOVWF  47
1239:  BCF    0A.4
123A:  BCF    03.6
123B:  CALL   176
123C:  BSF    0A.4
....................  
....................        /* DATA RCV SAI ID NODE, ID GW HOAC LA SAI DO DAI*/ 
....................     } 
123D:  BCF    0A.3
123E:  BSF    0A.4
123F:  GOTO   5C3 (RETURN)
....................  
....................  } 
....................   
....................  
....................  VOID MAIN () 
*
148E:  MOVF   03,W
148F:  ANDLW  1F
1490:  MOVWF  03
1491:  BSF    03.5
1492:  BSF    03.6
1493:  BCF    07.3
1494:  MOVLW  19
1495:  BCF    03.6
1496:  MOVWF  19
1497:  MOVLW  A6
1498:  MOVWF  18
1499:  MOVLW  90
149A:  BCF    03.5
149B:  MOVWF  18
149C:  MOVLW  FF
149D:  MOVWF  31
149E:  CLRF   3E
149F:  CLRF   3F
14A0:  CLRF   40
14A1:  CLRF   41
14A2:  CLRF   4C
14A3:  CLRF   4D
14A4:  CLRF   4E
14A5:  CLRF   4F
14A6:  MOVLW  03
14A7:  MOVWF  50
14A8:  CLRF   51
14A9:  CLRF   52
14AA:  BCF    54.0
14AB:  BCF    54.1
14AC:  BCF    54.2
14AD:  BCF    54.3
14AE:  BCF    54.4
14AF:  BCF    54.5
14B0:  BCF    54.6
14B1:  BCF    54.7
14B2:  BCF    55.0
14B3:  BSF    03.5
14B4:  BSF    03.6
14B5:  MOVF   09,W
14B6:  ANDLW  C0
14B7:  MOVWF  09
14B8:  BCF    03.6
14B9:  BCF    1F.4
14BA:  BCF    1F.5
14BB:  MOVLW  00
14BC:  BSF    03.6
14BD:  MOVWF  08
14BE:  BCF    03.5
14BF:  CLRF   07
14C0:  CLRF   08
14C1:  CLRF   09
14C2:  BCF    03.7
....................  { 
....................     SET_TRIS_D (0XF0); 
*
153D:  MOVLW  F0
153E:  BSF    03.5
153F:  BCF    03.6
1540:  MOVWF  08
....................     SET_TRIS_B (0XFF); 
1541:  MOVLW  FF
1542:  MOVWF  06
....................     SET_TRIS_E (0); 
1543:  BCF    09.0
1544:  BCF    09.1
1545:  BCF    09.2
1546:  BCF    09.3
....................     SET_TRIS_C (0X80); 
1547:  MOVLW  80
1548:  MOVWF  07
1549:  BCF    03.5
154A:  MOVWF  31
....................     SETUP_ADC (ADC_CLOCK_DIV_8); 
154B:  BSF    1F.6
154C:  BCF    1F.7
154D:  BSF    03.5
154E:  BSF    1F.7
154F:  BCF    03.5
1550:  BSF    1F.0
....................     //SETUP_TIMER_0(T0_INTERNAL | T0_DIV_1); 
....................     //ENABLE_INTERRUPTS (INT_TIMER0); 
....................      
....................     ENABLE_INTERRUPTS (INT_EXT); //CHO PHEP NGAT NGOAI 
1551:  BSF    0B.4
....................     ENABLE_INTERRUPTS (INT_EXT_H2L); //NGAT XAY RA KHI CO XUNG TU CAO XUONG THAP 
1552:  BSF    0B.4
1553:  BSF    03.5
1554:  BCF    01.6
....................     ENABLE_INTERRUPTS (INT_RDA); 
1555:  BSF    0C.5
....................     ENABLE_INTERRUPTS (GLOBAL); 
1556:  MOVLW  C0
1557:  BCF    03.5
1558:  IORWF  0B,F
....................      
....................     SETUP_TIMER_1 (T1_INTERNAL|T1_DIV_BY_8); 
1559:  MOVLW  35
155A:  MOVWF  10
....................     //SET_TIMER1 (0); 
....................     SET_TIMER1 (3036); 
155B:  CLRF   0E
155C:  MOVLW  0B
155D:  MOVWF  0F
155E:  MOVLW  DC
155F:  MOVWF  0E
....................     TMR1IF = 0; 
1560:  BCF    0C.0
....................     LCD_INIT (); // KHOI TAO LCD 
1561:  BCF    0A.4
1562:  GOTO   28A
1563:  BSF    0A.4
....................     TT_CONFIG = 0; 
1564:  BCF    54.1
....................     TT_CONFIG_DONE = 0; 
1565:  BCF    54.3
....................     TT_CONTROL = 1; 
1566:  BSF    54.2
....................     OUTPUT_HIGH (PIN_D3) ; 
1567:  BSF    03.5
1568:  BCF    08.3
1569:  BCF    03.5
156A:  BSF    08.3
....................     TTNHAN = 0;       
156B:  BCF    54.0
....................       LCD_GOTOXY (1, 2) ; 
156C:  MOVLW  01
156D:  BSF    03.6
156E:  MOVWF  47
156F:  MOVLW  02
1570:  MOVWF  48
1571:  BCF    0A.4
1572:  BCF    03.6
1573:  CALL   2F0
1574:  BSF    0A.4
....................       DELAY_MS (10); 
1575:  MOVLW  0A
1576:  BSF    03.6
1577:  MOVWF  47
1578:  BCF    0A.4
1579:  BCF    03.6
157A:  CALL   176
157B:  BSF    0A.4
....................       PRINTF (LCD_PUTC, "hihihoang");     
157C:  MOVLW  6C
157D:  BSF    03.6
157E:  MOVWF  0D
157F:  MOVLW  01
1580:  MOVWF  0F
1581:  BCF    0A.4
1582:  BCF    03.6
1583:  CALL   33E
1584:  BSF    0A.4
....................       FOR (INT ABCD = 0; ABCD <10; ABCD ++){ 
1585:  BSF    03.6
1586:  CLRF   15
1587:  MOVF   15,W
1588:  SUBLW  09
1589:  BTFSS  03.0
158A:  GOTO   5A1
....................           
....................          OUTPUT_TOGGLE (PIN_C4); 
158B:  BCF    03.6
158C:  BCF    31.4
158D:  MOVF   31,W
158E:  BSF    03.5
158F:  MOVWF  07
1590:  MOVLW  10
1591:  BCF    03.5
1592:  XORWF  07,F
....................          DELAY_MS(500); 
1593:  MOVLW  02
1594:  BSF    03.6
1595:  MOVWF  16
1596:  MOVLW  FA
1597:  MOVWF  47
1598:  BCF    0A.4
1599:  BCF    03.6
159A:  CALL   176
159B:  BSF    0A.4
159C:  BSF    03.6
159D:  DECFSZ 16,F
159E:  GOTO   596
159F:  INCF   15,F
15A0:  GOTO   587
....................       } 
....................     PRINTF (LCD_PUTC, "CHAOHOANG");         
15A1:  MOVLW  71
15A2:  MOVWF  0D
15A3:  MOVLW  01
15A4:  MOVWF  0F
15A5:  BCF    0A.4
15A6:  BCF    03.6
15A7:  CALL   33E
15A8:  BSF    0A.4
....................     READ_EEPROMP_DATA_NODE(); 
15A9:  BCF    0A.4
15AA:  GOTO   38E
15AB:  BSF    0A.4
....................     CONFIG_DONE(); 
15AC:  BCF    0A.4
15AD:  CALL   5B7
15AE:  BSF    0A.4
....................  
....................     WHILE (TRUE) 
....................     { 
....................        IF (TT_CONFIG)   {BUTT_FUN (); } // GOI HAM CHON LENH (SWITCH CASE) 
15AF:  BTFSS  54.1
15B0:  GOTO   5B7
15B1:  BCF    0A.4
15B2:  BSF    0A.3
15B3:  GOTO   000
15B4:  BSF    0A.4
15B5:  BCF    0A.3
15B6:  GOTO   5EA
....................        ELSE IF (TT_CONFIG_DONE) { CONFIG_DONE (); } 
15B7:  BTFSS  54.3
15B8:  GOTO   5BD
15B9:  BCF    0A.4
15BA:  CALL   5B7
15BB:  BSF    0A.4
15BC:  GOTO   5EA
....................        ELSE 
....................        { 
....................           WHILE (!TT_CONFIG) 
15BD:  BTFSC  54.1
15BE:  GOTO   5EA
....................           {              
....................              IF (TTNHAN == 1) 
15BF:  BTFSS  54.0
15C0:  GOTO   5C3
....................              { 
....................                 TTNHAN = 0; 
15C1:  BCF    54.0
....................                 XU_LY_UART () ; 
15C2:  GOTO   000
....................              } 
....................              IF (TT_CONFIG_OKE_UART == 1) 
15C3:  BTFSS  54.6
15C4:  GOTO   5E9
....................              { 
....................                  
....................                IF (TT_SW) 
15C5:  BTFSS  54.7
15C6:  GOTO   5D2
....................                { 
....................                   READ_BTN_STATE(); 
15C7:  BCF    0A.4
15C8:  BSF    0A.3
15C9:  GOTO   620
15CA:  BSF    0A.4
15CB:  BCF    0A.3
....................                   TT_SW = 0;              
15CC:  BCF    54.7
....................                   XUAT_DIEU_KHIEN();               
15CD:  BCF    0A.4
15CE:  BSF    0A.3
15CF:  CALL   4A4
15D0:  BSF    0A.4
15D1:  BCF    0A.3
....................                }                 
....................                 DELAY_MS (100) ; 
15D2:  MOVLW  64
15D3:  BSF    03.6
15D4:  MOVWF  47
15D5:  BCF    0A.4
15D6:  BCF    03.6
15D7:  CALL   176
15D8:  BSF    0A.4
....................                 READ_ANALOG () ; 
15D9:  GOTO   24A
....................  
....................                 IF (TT_SEND_ANALOG) 
15DA:  BTFSS  55.0
15DB:  GOTO   5E9
....................                 { 
....................                   TT_SEND_ANALOG = 0; 
15DC:  BCF    55.0
....................                    SEND_ANALOG_UART () ; 
15DD:  BCF    0A.4
15DE:  BSF    0A.3
15DF:  GOTO   66D
15E0:  BSF    0A.4
15E1:  BCF    0A.3
....................                    DELAY_MS (200) ; 
15E2:  MOVLW  C8
15E3:  BSF    03.6
15E4:  MOVWF  47
15E5:  BCF    0A.4
15E6:  BCF    03.6
15E7:  CALL   176
15E8:  BSF    0A.4
....................                 } 
....................              } 
15E9:  GOTO   5BD
....................           } 
....................        } 
15EA:  GOTO   5AF
....................     } 
....................  } 
....................  
15EB:  SLEEP

Configuration Fuses:
   Word  1: 2FE2   HS NOWDT PUT MCLR NOPROTECT NOCPD BROWNOUT IESO FCMEN NOLVP NODEBUG
   Word  2: 3FFF   BORV40 NOWRT
