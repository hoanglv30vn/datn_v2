CCS PCM C Compiler, Version 5.015, 5967               29-Oct-21 16:30

               Filename:   E:\DATN\NODE\pic\pic16f887\hellopic.lst

               ROM used:   3622 words (44%)
                           Largest free fragment is 2048
               RAM used:   139 (38%) at main() level
                           248 (67%) worst case
               Stack used: 7 locations (6 in main + 1 for interrupts)
               Stack size: 8

*
0000:  MOVLW  0D
0001:  MOVWF  0A
0002:  GOTO   580
0003:  NOP
0004:  MOVWF  7F
0005:  SWAPF  03,W
0006:  CLRF   03
0007:  MOVWF  21
0008:  MOVF   0A,W
0009:  MOVWF  20
000A:  CLRF   0A
000B:  MOVF   04,W
000C:  MOVWF  22
000D:  MOVF   77,W
000E:  MOVWF  23
000F:  MOVF   78,W
0010:  MOVWF  24
0011:  MOVF   79,W
0012:  MOVWF  25
0013:  MOVF   7A,W
0014:  MOVWF  26
0015:  BSF    03.6
0016:  MOVF   0D,W
0017:  BCF    03.6
0018:  MOVWF  27
0019:  BSF    03.6
001A:  MOVF   0F,W
001B:  BCF    03.6
001C:  MOVWF  28
001D:  BSF    03.6
001E:  MOVF   0C,W
001F:  BCF    03.6
0020:  MOVWF  29
0021:  BSF    03.6
0022:  MOVF   0E,W
0023:  BCF    03.6
0024:  MOVWF  2A
0025:  BCF    03.7
0026:  BCF    03.5
0027:  BTFSS  0B.4
0028:  GOTO   02B
0029:  BTFSC  0B.1
002A:  GOTO   052
002B:  MOVLW  8C
002C:  MOVWF  04
002D:  BTFSS  00.5
002E:  GOTO   031
002F:  BTFSC  0C.5
0030:  GOTO   055
0031:  MOVF   22,W
0032:  MOVWF  04
0033:  MOVF   23,W
0034:  MOVWF  77
0035:  MOVF   24,W
0036:  MOVWF  78
0037:  MOVF   25,W
0038:  MOVWF  79
0039:  MOVF   26,W
003A:  MOVWF  7A
003B:  MOVF   27,W
003C:  BSF    03.6
003D:  MOVWF  0D
003E:  BCF    03.6
003F:  MOVF   28,W
0040:  BSF    03.6
0041:  MOVWF  0F
0042:  BCF    03.6
0043:  MOVF   29,W
0044:  BSF    03.6
0045:  MOVWF  0C
0046:  BCF    03.6
0047:  MOVF   2A,W
0048:  BSF    03.6
0049:  MOVWF  0E
004A:  BCF    03.6
004B:  MOVF   20,W
004C:  MOVWF  0A
004D:  SWAPF  21,W
004E:  MOVWF  03
004F:  SWAPF  7F,F
0050:  SWAPF  7F,W
0051:  RETFIE
0052:  BCF    0A.3
0053:  BCF    0A.4
0054:  GOTO   0DB
0055:  BCF    0A.3
0056:  BCF    0A.4
0057:  GOTO   10C
....................  
.................... #INCLUDE <thuvien.c> 
.................... #INCLUDE <16F887.H> 
.................... //////////// Standard Header file for the PIC16F887 device //////////////// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2013 Custom Computer Services          //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... #device PIC16F887 
0058:  BCF    0A.0
0059:  BCF    0A.1
005A:  BCF    0A.2
005B:  ADDWF  02,F
005C:  RETLW  30
005D:  RETLW  00
005E:  BCF    0A.0
005F:  BCF    0A.1
0060:  BCF    0A.2
0061:  ADDWF  02,F
0062:  RETLW  00
0063:  BCF    0A.0
0064:  BCF    0A.1
0065:  BCF    0A.2
0066:  ADDWF  02,F
0067:  RETLW  23
0068:  RETLW  00
0069:  DATA CE,27
006A:  DATA C4,22
006B:  DATA 3A,10
006C:  DATA 00,00
006D:  DATA 30,18
006E:  DATA 30,18
006F:  DATA 20,10
0070:  DATA 20,10
0071:  DATA 20,10
0072:  DATA 20,10
0073:  DATA 20,10
0074:  DATA 00,01
0075:  DATA 20,10
0076:  DATA 20,10
0077:  DATA 20,10
0078:  DATA 5F,10
0079:  DATA 20,10
007A:  DATA 20,10
007B:  DATA 20,10
007C:  DATA 20,10
007D:  DATA 20,10
007E:  DATA 20,10
007F:  DATA 20,00
0080:  DATA 20,10
0081:  DATA 20,10
0082:  DATA 5F,10
0083:  DATA 20,10
0084:  DATA 20,00
0085:  DATA 49,22
0086:  DATA DF,23
0087:  DATA 57,1D
0088:  DATA 00,01
0089:  DATA 30,18
008A:  DATA 30,18
008B:  DATA 30,18
008C:  DATA 20,10
008D:  DATA 20,10
008E:  DATA 20,10
008F:  DATA 20,10
0090:  DATA 00,01
0091:  DATA 20,10
0092:  DATA 20,10
0093:  DATA 20,10
0094:  DATA 5F,10
0095:  DATA 20,10
0096:  DATA 20,10
0097:  DATA 20,10
0098:  DATA 20,10
0099:  DATA 20,10
009A:  DATA 20,10
009B:  DATA 20,10
009C:  DATA 20,00
009D:  DATA 20,10
009E:  DATA 20,10
009F:  DATA 5F,10
00A0:  DATA 20,10
00A1:  DATA 20,10
00A2:  DATA 20,10
00A3:  DATA 20,00
00A4:  DATA C3,27
00A5:  DATA 4E,23
00A6:  DATA C9,23
00A7:  DATA 3A,10
00A8:  DATA 20,10
00A9:  DATA 20,10
00AA:  DATA 20,10
00AB:  DATA 20,00
00AC:  DATA C3,20
00AD:  DATA D3,22
00AE:  DATA 3A,10
00AF:  DATA 20,10
00B0:  DATA 20,10
00B1:  DATA 20,10
00B2:  DATA 20,10
00B3:  DATA 20,00
00B4:  DATA A0,16
00B5:  DATA A0,24
00B6:  DATA C4,16
00B7:  DATA CE,27
00B8:  DATA C4,22
00B9:  DATA 20,10
00BA:  DATA 20,10
00BB:  DATA 20,10
00BC:  DATA 00,01
00BD:  DATA A0,16
00BE:  DATA A0,24
00BF:  DATA C4,16
00C0:  DATA C7,2B
00C1:  DATA 20,10
00C2:  DATA 20,10
00C3:  DATA 20,10
00C4:  DATA 20,00
00C5:  DATA D7,20
00C6:  DATA 49,2A
00C7:  DATA 49,27
00C8:  DATA 47,10
00C9:  DATA 2E,17
00CA:  DATA 2E,17
00CB:  DATA 20,10
00CC:  DATA 20,10
00CD:  DATA 20,10
00CE:  DATA 20,10
00CF:  DATA 00,01
00D0:  DATA D7,20
00D1:  DATA 49,2A
00D2:  DATA 49,27
00D3:  DATA 47,10
00D4:  DATA 2E,17
00D5:  DATA 2E,17
00D6:  DATA 20,10
00D7:  DATA 20,10
00D8:  DATA 20,10
00D9:  DATA 20,10
00DA:  DATA 00,00
*
0129:  DATA 20,10
012A:  DATA 20,10
012B:  DATA 20,10
012C:  DATA 20,10
012D:  DATA 20,10
012E:  DATA 20,10
012F:  DATA 00,01
0130:  DATA 20,10
0131:  DATA 20,10
0132:  DATA 20,10
0133:  DATA 20,10
0134:  DATA 20,10
0135:  DATA 20,10
0136:  DATA 20,10
0137:  DATA 20,10
0138:  DATA 00,00
*
0311:  MOVF   0B,W
0312:  BSF    03.6
0313:  MOVWF  32
0314:  BCF    03.6
0315:  BCF    0B.7
0316:  BSF    03.5
0317:  BSF    03.6
0318:  BSF    0C.7
0319:  BSF    0C.0
031A:  NOP
031B:  NOP
031C:  BCF    03.5
031D:  BTFSS  32.7
031E:  GOTO   322
031F:  BCF    03.6
0320:  BSF    0B.7
0321:  BSF    03.6
0322:  MOVF   0C,W
0323:  ANDLW  7F
0324:  BTFSC  03.2
0325:  GOTO   35F
0326:  MOVWF  32
0327:  MOVF   0D,W
0328:  MOVWF  33
0329:  MOVF   0F,W
032A:  MOVWF  34
032B:  MOVF   32,W
032C:  MOVWF  35
032D:  BCF    03.6
032E:  CALL   2D7
032F:  BSF    03.6
0330:  MOVF   33,W
0331:  MOVWF  0D
0332:  MOVF   34,W
0333:  MOVWF  0F
0334:  BCF    03.6
0335:  MOVF   0B,W
0336:  BSF    03.6
0337:  MOVWF  35
0338:  BCF    03.6
0339:  BCF    0B.7
033A:  BSF    03.5
033B:  BSF    03.6
033C:  BSF    0C.7
033D:  BSF    0C.0
033E:  NOP
033F:  NOP
0340:  BCF    03.5
0341:  BTFSS  35.7
0342:  GOTO   346
0343:  BCF    03.6
0344:  BSF    0B.7
0345:  BSF    03.6
0346:  RLF    0C,W
0347:  RLF    0E,W
0348:  ANDLW  7F
0349:  BTFSC  03.2
034A:  GOTO   35F
034B:  MOVWF  32
034C:  MOVF   0D,W
034D:  MOVWF  33
034E:  MOVF   0F,W
034F:  MOVWF  34
0350:  MOVF   32,W
0351:  MOVWF  35
0352:  BCF    03.6
0353:  CALL   2D7
0354:  BSF    03.6
0355:  MOVF   33,W
0356:  MOVWF  0D
0357:  MOVF   34,W
0358:  MOVWF  0F
0359:  INCF   0D,F
035A:  BTFSC  03.2
035B:  INCF   0F,F
035C:  BCF    03.6
035D:  GOTO   311
035E:  BSF    03.6
035F:  BCF    03.6
0360:  RETURN
0361:  BTFSC  03.1
0362:  GOTO   366
0363:  MOVLW  53
0364:  MOVWF  04
0365:  BSF    03.7
0366:  BSF    03.6
0367:  MOVF   4E,W
0368:  XORWF  52,W
0369:  ANDLW  80
036A:  MOVWF  58
036B:  BTFSS  4E.7
036C:  GOTO   378
036D:  COMF   4B,F
036E:  COMF   4C,F
036F:  COMF   4D,F
0370:  COMF   4E,F
0371:  INCF   4B,F
0372:  BTFSC  03.2
0373:  INCF   4C,F
0374:  BTFSC  03.2
0375:  INCF   4D,F
0376:  BTFSC  03.2
0377:  INCF   4E,F
0378:  BTFSS  52.7
0379:  GOTO   385
037A:  COMF   4F,F
037B:  COMF   50,F
037C:  COMF   51,F
037D:  COMF   52,F
037E:  INCF   4F,F
037F:  BTFSC  03.2
0380:  INCF   50,F
0381:  BTFSC  03.2
0382:  INCF   51,F
0383:  BTFSC  03.2
0384:  INCF   52,F
0385:  CLRF   77
0386:  CLRF   78
0387:  CLRF   79
0388:  CLRF   7A
0389:  CLRF   53
038A:  CLRF   54
038B:  CLRF   55
038C:  CLRF   56
038D:  MOVF   52,W
038E:  IORWF  51,W
038F:  IORWF  50,W
0390:  IORWF  4F,W
0391:  BTFSC  03.2
0392:  GOTO   3C3
0393:  MOVLW  20
0394:  MOVWF  57
0395:  BCF    03.0
0396:  RLF    4B,F
0397:  RLF    4C,F
0398:  RLF    4D,F
0399:  RLF    4E,F
039A:  RLF    53,F
039B:  RLF    54,F
039C:  RLF    55,F
039D:  RLF    56,F
039E:  MOVF   52,W
039F:  SUBWF  56,W
03A0:  BTFSS  03.2
03A1:  GOTO   3AC
03A2:  MOVF   51,W
03A3:  SUBWF  55,W
03A4:  BTFSS  03.2
03A5:  GOTO   3AC
03A6:  MOVF   50,W
03A7:  SUBWF  54,W
03A8:  BTFSS  03.2
03A9:  GOTO   3AC
03AA:  MOVF   4F,W
03AB:  SUBWF  53,W
03AC:  BTFSS  03.0
03AD:  GOTO   3BD
03AE:  MOVF   4F,W
03AF:  SUBWF  53,F
03B0:  MOVF   50,W
03B1:  BTFSS  03.0
03B2:  INCFSZ 50,W
03B3:  SUBWF  54,F
03B4:  MOVF   51,W
03B5:  BTFSS  03.0
03B6:  INCFSZ 51,W
03B7:  SUBWF  55,F
03B8:  MOVF   52,W
03B9:  BTFSS  03.0
03BA:  INCFSZ 52,W
03BB:  SUBWF  56,F
03BC:  BSF    03.0
03BD:  RLF    77,F
03BE:  RLF    78,F
03BF:  RLF    79,F
03C0:  RLF    7A,F
03C1:  DECFSZ 57,F
03C2:  GOTO   395
03C3:  BTFSS  58.7
03C4:  GOTO   3D0
03C5:  COMF   77,F
03C6:  COMF   78,F
03C7:  COMF   79,F
03C8:  COMF   7A,F
03C9:  INCF   77,F
03CA:  BTFSC  03.2
03CB:  INCF   78,F
03CC:  BTFSC  03.2
03CD:  INCF   79,F
03CE:  BTFSC  03.2
03CF:  INCF   7A,F
03D0:  MOVF   53,W
03D1:  MOVWF  00
03D2:  INCF   04,F
03D3:  MOVF   54,W
03D4:  MOVWF  00
03D5:  INCF   04,F
03D6:  MOVF   55,W
03D7:  MOVWF  00
03D8:  INCF   04,F
03D9:  MOVF   56,W
03DA:  MOVWF  00
03DB:  BCF    03.6
03DC:  RETURN
*
03F6:  MOVLW  20
03F7:  MOVWF  4F
03F8:  CLRF   4B
03F9:  CLRF   4C
03FA:  CLRF   4D
03FB:  CLRF   4E
03FC:  MOVF   46,W
03FD:  MOVWF  7A
03FE:  MOVF   45,W
03FF:  MOVWF  79
0400:  MOVF   44,W
0401:  MOVWF  78
0402:  MOVF   43,W
0403:  MOVWF  77
0404:  BCF    03.0
0405:  BTFSS  77.0
0406:  GOTO   415
0407:  MOVF   47,W
0408:  ADDWF  4B,F
0409:  MOVF   48,W
040A:  BTFSC  03.0
040B:  INCFSZ 48,W
040C:  ADDWF  4C,F
040D:  MOVF   49,W
040E:  BTFSC  03.0
040F:  INCFSZ 49,W
0410:  ADDWF  4D,F
0411:  MOVF   4A,W
0412:  BTFSC  03.0
0413:  INCFSZ 4A,W
0414:  ADDWF  4E,F
0415:  RRF    4E,F
0416:  RRF    4D,F
0417:  RRF    4C,F
0418:  RRF    4B,F
0419:  RRF    7A,F
041A:  RRF    79,F
041B:  RRF    78,F
041C:  RRF    77,F
041D:  DECFSZ 4F,F
041E:  GOTO   404
*
04FD:  MOVF   00,F
04FE:  BTFSC  03.2
04FF:  GOTO   51B
0500:  BSF    03.5
0501:  CLRF   54
0502:  MOVF   04,W
0503:  MOVWF  53
0504:  BCF    54.0
0505:  BTFSC  03.7
0506:  BSF    54.0
0507:  MOVF   00,W
0508:  BCF    03.5
0509:  BSF    03.6
050A:  MOVWF  35
050B:  BCF    03.6
050C:  CALL   2D7
050D:  BSF    03.5
050E:  MOVF   53,W
050F:  MOVWF  04
0510:  BCF    03.7
0511:  BTFSC  54.0
0512:  BSF    03.7
0513:  INCF   04,F
0514:  BTFSS  03.2
0515:  GOTO   519
0516:  BCF    03.5
0517:  INCF   05,F
0518:  BSF    03.5
0519:  BCF    03.5
051A:  GOTO   4FD
051B:  RETURN
051C:  BSF    03.5
051D:  MOVF   52,W
051E:  CLRF   78
051F:  SUBWF  51,W
0520:  BTFSC  03.0
0521:  GOTO   525
0522:  MOVF   51,W
0523:  MOVWF  77
0524:  GOTO   531
0525:  CLRF   77
0526:  MOVLW  08
0527:  MOVWF  53
0528:  RLF    51,F
0529:  RLF    77,F
052A:  MOVF   52,W
052B:  SUBWF  77,W
052C:  BTFSC  03.0
052D:  MOVWF  77
052E:  RLF    78,F
052F:  DECFSZ 53,F
0530:  GOTO   528
0531:  BCF    03.5
0532:  RETURN
*
0930:  MOVF   00,F
0931:  BTFSC  03.2
0932:  GOTO   14F
0933:  BCF    03.5
0934:  BSF    03.6
0935:  CLRF   35
0936:  MOVF   04,W
0937:  MOVWF  34
0938:  BCF    35.0
0939:  BTFSC  03.7
093A:  BSF    35.0
093B:  MOVF   00,W
093C:  BCF    03.6
093D:  BTFSS  0C.4
093E:  GOTO   13D
093F:  MOVWF  19
0940:  BSF    03.6
0941:  MOVF   34,W
0942:  MOVWF  04
0943:  BCF    03.7
0944:  BTFSC  35.0
0945:  BSF    03.7
0946:  INCF   04,F
0947:  BTFSS  03.2
0948:  GOTO   14C
0949:  BCF    03.6
094A:  INCF   05,F
094B:  BSF    03.6
094C:  BSF    03.5
094D:  BCF    03.6
094E:  GOTO   130
*
0AEC:  CLRF   77
0AED:  CLRF   78
0AEE:  MOVF   5A,W
0AEF:  BCF    03.0
0AF0:  BTFSC  5B.0
0AF1:  ADDWF  77,F
0AF2:  RRF    77,F
0AF3:  RRF    78,F
0AF4:  BTFSC  5B.1
0AF5:  ADDWF  77,F
0AF6:  RRF    77,F
0AF7:  RRF    78,F
0AF8:  BTFSC  5B.2
0AF9:  ADDWF  77,F
0AFA:  RRF    77,F
0AFB:  RRF    78,F
0AFC:  BTFSC  5B.3
0AFD:  ADDWF  77,F
0AFE:  RRF    77,F
0AFF:  RRF    78,F
0B00:  BTFSC  5B.4
0B01:  ADDWF  77,F
0B02:  RRF    77,F
0B03:  RRF    78,F
0B04:  BTFSC  5B.5
0B05:  ADDWF  77,F
0B06:  RRF    77,F
0B07:  RRF    78,F
0B08:  BTFSC  5B.6
0B09:  ADDWF  77,F
0B0A:  RRF    77,F
0B0B:  RRF    78,F
0B0C:  BTFSC  5B.7
0B0D:  ADDWF  77,F
0B0E:  RRF    77,F
0B0F:  RRF    78,F
*
0D76:  BSF    0A.0
0D77:  BCF    0A.1
0D78:  BSF    0A.2
0D79:  ADDWF  02,F
0D7A:  GOTO   45A
0D7B:  GOTO   45B
0D7C:  GOTO   470
0D7D:  GOTO   485
0D7E:  GOTO   48F
0D7F:  GOTO   499
....................  
.................... #list 
....................  
.................... #DEVICE ADC=10 
.................... #INCLUDE <STRING.H> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
*
0750:  BSF    03.6
0751:  MOVF   34,W
0752:  MOVWF  38
0753:  MOVF   33,W
0754:  MOVWF  37
0755:  MOVF   38,W
0756:  MOVWF  7A
0757:  MOVF   37,W
0758:  MOVWF  04
0759:  BCF    03.7
075A:  BTFSC  7A.0
075B:  BSF    03.7
075C:  MOVF   00,F
075D:  BTFSC  03.2
075E:  GOTO   763
075F:  INCF   37,F
0760:  BTFSC  03.2
0761:  INCF   38,F
0762:  GOTO   755
....................    while(*s2 != '\0') 
0763:  MOVF   36,W
0764:  MOVWF  7A
0765:  MOVF   35,W
0766:  MOVWF  04
0767:  BCF    03.7
0768:  BTFSC  7A.0
0769:  BSF    03.7
076A:  MOVF   00,F
076B:  BTFSC  03.2
076C:  GOTO   782
....................    { 
....................       *s = *s2; 
076D:  MOVF   35,W
076E:  MOVWF  04
076F:  BCF    03.7
0770:  BTFSC  36.0
0771:  BSF    03.7
0772:  MOVF   00,W
0773:  MOVWF  3B
0774:  MOVF   37,W
0775:  MOVWF  04
0776:  BCF    03.7
0777:  BTFSC  38.0
0778:  BSF    03.7
0779:  MOVF   3B,W
077A:  MOVWF  00
....................       ++s; 
077B:  INCF   37,F
077C:  BTFSC  03.2
077D:  INCF   38,F
....................       ++s2; 
077E:  INCF   35,F
077F:  BTFSC  03.2
0780:  INCF   36,F
0781:  GOTO   763
....................    } 
....................  
....................    *s = '\0'; 
0782:  MOVF   37,W
0783:  MOVWF  04
0784:  BCF    03.7
0785:  BTFSC  38.0
0786:  BSF    03.7
0787:  CLRF   00
....................    return(s1); 
0788:  MOVF   33,W
0789:  MOVWF  78
078A:  MOVF   34,W
078B:  MOVWF  79
078C:  BCF    03.6
078D:  RETURN
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
*
0B7F:  BSF    03.5
0B80:  MOVF   54,W
0B81:  MOVWF  7A
0B82:  MOVF   53,W
0B83:  MOVWF  04
0B84:  BCF    03.7
0B85:  BTFSC  7A.0
0B86:  BSF    03.7
0B87:  MOVF   00,W
0B88:  MOVWF  57
0B89:  MOVF   56,W
0B8A:  MOVWF  7A
0B8B:  MOVF   55,W
0B8C:  MOVWF  04
0B8D:  BCF    03.7
0B8E:  BTFSC  7A.0
0B8F:  BSF    03.7
0B90:  MOVF   00,W
0B91:  SUBWF  57,W
0B92:  BTFSS  03.2
0B93:  GOTO   3AB
....................       if (*s1 == '\0') 
0B94:  MOVF   54,W
0B95:  MOVWF  7A
0B96:  MOVF   53,W
0B97:  MOVWF  04
0B98:  BCF    03.7
0B99:  BTFSC  7A.0
0B9A:  BSF    03.7
0B9B:  MOVF   00,F
0B9C:  BTFSS  03.2
0B9D:  GOTO   3A1
....................          return(0); 
0B9E:  MOVLW  00
0B9F:  MOVWF  78
0BA0:  GOTO   3C3
0BA1:  MOVF   54,W
0BA2:  MOVWF  7A
0BA3:  MOVF   53,W
0BA4:  INCF   53,F
0BA5:  BTFSC  03.2
0BA6:  INCF   54,F
0BA7:  INCF   55,F
0BA8:  BTFSC  03.2
0BA9:  INCF   56,F
0BAA:  GOTO   380
....................    return((*s1 < *s2) ? -1: 1); 
0BAB:  MOVF   54,W
0BAC:  MOVWF  7A
0BAD:  MOVF   53,W
0BAE:  MOVWF  04
0BAF:  BCF    03.7
0BB0:  BTFSC  54.0
0BB1:  BSF    03.7
0BB2:  MOVF   00,W
0BB3:  MOVWF  57
0BB4:  MOVF   56,W
0BB5:  MOVWF  7A
0BB6:  MOVF   55,W
0BB7:  MOVWF  04
0BB8:  BCF    03.7
0BB9:  BTFSC  56.0
0BBA:  BSF    03.7
0BBB:  MOVF   00,W
0BBC:  SUBWF  57,W
0BBD:  BTFSC  03.0
0BBE:  GOTO   3C1
0BBF:  MOVLW  FF
0BC0:  GOTO   3C2
0BC1:  MOVLW  01
0BC2:  MOVWF  78
0BC3:  BCF    03.5
0BC4:  RETURN
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
*
0BF1:  MOVF   54,W
0BF2:  MOVWF  7A
0BF3:  MOVF   53,W
0BF4:  MOVWF  04
0BF5:  BCF    03.7
0BF6:  BTFSC  7A.0
0BF7:  BSF    03.7
0BF8:  MOVF   55,W
0BF9:  SUBWF  00,W
0BFA:  BTFSC  03.2
0BFB:  GOTO   40E
....................       if (*s == '\0') 
0BFC:  MOVF   54,W
0BFD:  MOVWF  7A
0BFE:  MOVF   53,W
0BFF:  MOVWF  04
0C00:  BCF    03.7
0C01:  BTFSC  7A.0
0C02:  BSF    03.7
0C03:  MOVF   00,F
0C04:  BTFSS  03.2
0C05:  GOTO   40A
....................          return(0); 
0C06:  MOVLW  00
0C07:  MOVWF  78
0C08:  MOVWF  79
0C09:  GOTO   412
0C0A:  INCF   53,F
0C0B:  BTFSC  03.2
0C0C:  INCF   54,F
0C0D:  GOTO   3F1
....................    return(s); 
0C0E:  MOVF   53,W
0C0F:  MOVWF  78
0C10:  MOVF   54,W
0C11:  MOVWF  79
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
*
0A18:  MOVF   5C,W
0A19:  MOVWF  60
0A1A:  MOVF   5B,W
0A1B:  MOVWF  5F
0A1C:  MOVF   60,W
0A1D:  MOVWF  7A
0A1E:  MOVF   5F,W
0A1F:  MOVWF  04
0A20:  BCF    03.7
0A21:  BTFSC  7A.0
0A22:  BSF    03.7
0A23:  MOVF   00,F
0A24:  BTFSC  03.2
0A25:  GOTO   255
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
0A26:  MOVF   5E,W
0A27:  MOVWF  62
0A28:  MOVF   5D,W
0A29:  MOVWF  61
0A2A:  MOVF   62,W
0A2B:  MOVWF  7A
0A2C:  MOVF   61,W
0A2D:  MOVWF  04
0A2E:  BCF    03.7
0A2F:  BTFSC  7A.0
0A30:  BSF    03.7
0A31:  MOVF   00,F
0A32:  BTFSC  03.2
0A33:  GOTO   251
....................          if (*sc1 == *sc2) 
0A34:  MOVF   60,W
0A35:  MOVWF  7A
0A36:  MOVF   5F,W
0A37:  MOVWF  04
0A38:  BCF    03.7
0A39:  BTFSC  7A.0
0A3A:  BSF    03.7
0A3B:  MOVF   00,W
0A3C:  MOVWF  63
0A3D:  MOVF   62,W
0A3E:  MOVWF  7A
0A3F:  MOVF   61,W
0A40:  MOVWF  04
0A41:  BCF    03.7
0A42:  BTFSC  7A.0
0A43:  BSF    03.7
0A44:  MOVF   00,W
0A45:  SUBWF  63,W
0A46:  BTFSS  03.2
0A47:  GOTO   24D
....................             return(sc1); 
0A48:  MOVF   5F,W
0A49:  MOVWF  78
0A4A:  MOVF   60,W
0A4B:  MOVWF  79
0A4C:  GOTO   258
0A4D:  INCF   61,F
0A4E:  BTFSC  03.2
0A4F:  INCF   62,F
0A50:  GOTO   22A
0A51:  INCF   5F,F
0A52:  BTFSC  03.2
0A53:  INCF   60,F
0A54:  GOTO   21C
....................    return(0); 
0A55:  MOVLW  00
0A56:  MOVWF  78
0A57:  MOVWF  79
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
*
09A5:  MOVF   5C,W
09A6:  MOVWF  60
09A7:  MOVF   5B,W
09A8:  MOVWF  5F
09A9:  MOVF   60,W
09AA:  MOVWF  7A
09AB:  MOVF   5F,W
09AC:  MOVWF  04
09AD:  BCF    03.7
09AE:  BTFSC  7A.0
09AF:  BSF    03.7
09B0:  MOVF   00,F
09B1:  BTFSC  03.2
09B2:  GOTO   1EA
....................       for (sc2 = s2; ; sc2++) 
09B3:  MOVF   5E,W
09B4:  MOVWF  62
09B5:  MOVF   5D,W
09B6:  MOVWF  61
....................     if (*sc2 == '\0') 
09B7:  MOVF   62,W
09B8:  MOVWF  7A
09B9:  MOVF   61,W
09BA:  MOVWF  04
09BB:  BCF    03.7
09BC:  BTFSC  7A.0
09BD:  BSF    03.7
09BE:  MOVF   00,F
09BF:  BTFSS  03.2
09C0:  GOTO   1CE
....................        return(sc1 - s1); 
09C1:  MOVF   5B,W
09C2:  SUBWF  5F,W
09C3:  MOVWF  77
09C4:  MOVF   60,W
09C5:  MOVWF  7A
09C6:  MOVF   5C,W
09C7:  BTFSS  03.0
09C8:  INCFSZ 5C,W
09C9:  SUBWF  7A,F
09CA:  MOVF   77,W
09CB:  MOVWF  78
09CC:  GOTO   1F5
09CD:  GOTO   1E2
....................          else if (*sc1 == *sc2) 
09CE:  MOVF   60,W
09CF:  MOVWF  7A
09D0:  MOVF   5F,W
09D1:  MOVWF  04
09D2:  BCF    03.7
09D3:  BTFSC  7A.0
09D4:  BSF    03.7
09D5:  MOVF   00,W
09D6:  MOVWF  63
09D7:  MOVF   62,W
09D8:  MOVWF  7A
09D9:  MOVF   61,W
09DA:  MOVWF  04
09DB:  BCF    03.7
09DC:  BTFSC  7A.0
09DD:  BSF    03.7
09DE:  MOVF   00,W
09DF:  SUBWF  63,W
09E0:  BTFSC  03.2
....................             break; 
09E1:  GOTO   1E6
09E2:  INCF   61,F
09E3:  BTFSC  03.2
09E4:  INCF   62,F
09E5:  GOTO   1B7
09E6:  INCF   5F,F
09E7:  BTFSC  03.2
09E8:  INCF   60,F
09E9:  GOTO   1A9
....................    return(sc1 - s1); 
09EA:  MOVF   5B,W
09EB:  SUBWF  5F,W
09EC:  MOVWF  77
09ED:  MOVF   60,W
09EE:  MOVWF  7A
09EF:  MOVF   5C,W
09F0:  BTFSS  03.0
09F1:  INCFSZ 5C,W
09F2:  SUBWF  7A,F
09F3:  MOVF   77,W
09F4:  MOVWF  78
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
*
0DB1:  BCF    03.6
0DB2:  CLRF   2B
0DB3:  CLRF   2C
....................  
....................    beg = (s1)? s1: save; 
*
098C:  BSF    03.5
098D:  MOVF   53,W
098E:  IORWF  54,W
098F:  BTFSC  03.2
0990:  GOTO   195
0991:  MOVF   54,W
0992:  MOVWF  7A
0993:  MOVF   53,W
0994:  GOTO   19A
0995:  BCF    03.5
0996:  MOVF   2C,W
0997:  MOVWF  7A
0998:  MOVF   2B,W
0999:  BSF    03.5
099A:  MOVWF  57
099B:  MOVF   7A,W
099C:  MOVWF  58
....................    beg += strspn(beg, s2); 
099D:  MOVF   58,W
099E:  MOVWF  5C
099F:  MOVF   57,W
09A0:  MOVWF  5B
09A1:  MOVF   56,W
09A2:  MOVWF  5E
09A3:  MOVF   55,W
09A4:  MOVWF  5D
*
09F5:  MOVF   78,W
09F6:  ADDWF  57,F
09F7:  BTFSC  03.0
09F8:  INCF   58,F
....................    if (*beg == '\0') 
09F9:  MOVF   58,W
09FA:  MOVWF  7A
09FB:  MOVF   57,W
09FC:  MOVWF  04
09FD:  BCF    03.7
09FE:  BTFSC  7A.0
09FF:  BSF    03.7
0A00:  MOVF   00,F
0A01:  BTFSS  03.2
0A02:  GOTO   210
....................    { 
....................       *save = ' '; 
0A03:  BCF    03.5
0A04:  MOVF   2B,W
0A05:  MOVWF  04
0A06:  BCF    03.7
0A07:  BTFSC  2C.0
0A08:  BSF    03.7
0A09:  MOVLW  20
0A0A:  MOVWF  00
....................       return(0); 
0A0B:  MOVLW  00
0A0C:  MOVWF  78
0A0D:  MOVWF  79
0A0E:  GOTO   27C
0A0F:  BSF    03.5
....................    } 
....................    end = strpbrk(beg, s2); 
0A10:  MOVF   58,W
0A11:  MOVWF  5C
0A12:  MOVF   57,W
0A13:  MOVWF  5B
0A14:  MOVF   56,W
0A15:  MOVWF  5E
0A16:  MOVF   55,W
0A17:  MOVWF  5D
*
0A58:  MOVF   79,W
0A59:  MOVWF  5A
0A5A:  MOVF   78,W
0A5B:  MOVWF  59
....................    if (*end != '\0') 
0A5C:  MOVF   5A,W
0A5D:  MOVWF  7A
0A5E:  MOVF   59,W
0A5F:  MOVWF  04
0A60:  BCF    03.7
0A61:  BTFSC  7A.0
0A62:  BSF    03.7
0A63:  MOVF   00,F
0A64:  BTFSC  03.2
0A65:  GOTO   26F
....................    { 
....................       *end = '\0'; 
0A66:  MOVF   59,W
0A67:  MOVWF  04
0A68:  BCF    03.7
0A69:  BTFSC  5A.0
0A6A:  BSF    03.7
0A6B:  CLRF   00
....................       end++; 
0A6C:  INCF   59,F
0A6D:  BTFSC  03.2
0A6E:  INCF   5A,F
....................    } 
....................    save = end; 
0A6F:  MOVF   5A,W
0A70:  BCF    03.5
0A71:  MOVWF  2C
0A72:  BSF    03.5
0A73:  MOVF   59,W
0A74:  BCF    03.5
0A75:  MOVWF  2B
....................    return(beg); 
0A76:  BSF    03.5
0A77:  MOVF   57,W
0A78:  MOVWF  78
0A79:  MOVF   58,W
0A7A:  MOVWF  79
0A7B:  BCF    03.5
0A7C:  RETURN
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
*
078E:  BSF    03.6
078F:  MOVF   35,W
0790:  MOVWF  37
0791:  MOVF   34,W
0792:  MOVWF  36
0793:  MOVF   37,W
0794:  MOVWF  7A
0795:  MOVF   36,W
0796:  MOVWF  04
0797:  BCF    03.7
0798:  BTFSC  7A.0
0799:  BSF    03.7
079A:  MOVF   00,F
079B:  BTFSC  03.2
079C:  GOTO   7A1
079D:  INCF   36,F
079E:  BTFSC  03.2
079F:  INCF   37,F
07A0:  GOTO   793
....................    return(sc - s); 
07A1:  MOVF   34,W
07A2:  SUBWF  36,W
07A3:  MOVWF  77
07A4:  MOVF   37,W
07A5:  MOVWF  7A
07A6:  MOVF   35,W
07A7:  BTFSS  03.0
07A8:  INCFSZ 35,W
07A9:  SUBWF  7A,F
07AA:  MOVF   77,W
07AB:  MOVWF  78
07AC:  BCF    03.6
07AD:  RETURN
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #INCLUDE <STDLIB.H> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... /* Standart template: float strtof(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... float strtof(char *s,char *endptr); 
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s,char *endptr); 
.................... float64 strtod(char *s,char *endptr); 
.................... #else 
.................... //provided for compatibility 
.................... #define strtof48(s, e) strtof(s, e) 
.................... #define strtod(s, e) strtof(s, e) 
.................... #endif 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof(s)   strtof(s, 0) 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof48(s) strtof48(s, 0) 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof64(s) strtod(s, 0) 
.................... #endif 
....................  
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float atoe(char * s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s); 
.................... #endif 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... unsigned int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................  
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
*
0A7D:  BSF    03.5
0A7E:  CLRF   58
....................    sign = 0; 
0A7F:  CLRF   56
....................    base = 10; 
0A80:  MOVLW  0A
0A81:  MOVWF  57
....................    result = 0; 
0A82:  CLRF   55
....................  
....................    if (!s) 
0A83:  MOVF   53,W
0A84:  IORWF  54,W
0A85:  BTFSS  03.2
0A86:  GOTO   28A
....................       return 0; 
0A87:  MOVLW  00
0A88:  MOVWF  78
0A89:  GOTO   37D
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
0A8A:  MOVF   58,W
0A8B:  INCF   58,F
0A8C:  ADDWF  53,W
0A8D:  MOVWF  04
0A8E:  BCF    03.7
0A8F:  BTFSC  54.0
0A90:  BSF    03.7
0A91:  MOVF   00,W
0A92:  MOVWF  59
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
0A93:  MOVF   59,W
0A94:  SUBLW  2D
0A95:  BTFSS  03.2
0A96:  GOTO   2A3
....................    { 
....................       sign = 1;         // Set the sign to negative 
0A97:  MOVLW  01
0A98:  MOVWF  56
....................       c = s[index++]; 
0A99:  MOVF   58,W
0A9A:  INCF   58,F
0A9B:  ADDWF  53,W
0A9C:  MOVWF  04
0A9D:  BCF    03.7
0A9E:  BTFSC  54.0
0A9F:  BSF    03.7
0AA0:  MOVF   00,W
0AA1:  MOVWF  59
....................    } 
0AA2:  GOTO   2B0
....................    else if (c == '+') 
0AA3:  MOVF   59,W
0AA4:  SUBLW  2B
0AA5:  BTFSS  03.2
0AA6:  GOTO   2B0
....................    { 
....................       c = s[index++]; 
0AA7:  MOVF   58,W
0AA8:  INCF   58,F
0AA9:  ADDWF  53,W
0AAA:  MOVWF  04
0AAB:  BCF    03.7
0AAC:  BTFSC  54.0
0AAD:  BSF    03.7
0AAE:  MOVF   00,W
0AAF:  MOVWF  59
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
0AB0:  MOVF   59,W
0AB1:  SUBLW  2F
0AB2:  BTFSC  03.0
0AB3:  GOTO   373
0AB4:  MOVF   59,W
0AB5:  SUBLW  39
0AB6:  BTFSS  03.0
0AB7:  GOTO   373
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
0AB8:  MOVF   59,W
0AB9:  SUBLW  30
0ABA:  BTFSS  03.2
0ABB:  GOTO   2DC
0ABC:  MOVF   58,W
0ABD:  ADDWF  53,W
0ABE:  MOVWF  04
0ABF:  BCF    03.7
0AC0:  BTFSC  54.0
0AC1:  BSF    03.7
0AC2:  MOVF   00,W
0AC3:  SUBLW  78
0AC4:  BTFSC  03.2
0AC5:  GOTO   2D0
0AC6:  MOVF   58,W
0AC7:  ADDWF  53,W
0AC8:  MOVWF  04
0AC9:  BCF    03.7
0ACA:  BTFSC  54.0
0ACB:  BSF    03.7
0ACC:  MOVF   00,W
0ACD:  SUBLW  58
0ACE:  BTFSS  03.2
0ACF:  GOTO   2DC
....................       { 
....................          base = 16; 
0AD0:  MOVLW  10
0AD1:  MOVWF  57
....................          index++; 
0AD2:  INCF   58,F
....................          c = s[index++]; 
0AD3:  MOVF   58,W
0AD4:  INCF   58,F
0AD5:  ADDWF  53,W
0AD6:  MOVWF  04
0AD7:  BCF    03.7
0AD8:  BTFSC  54.0
0AD9:  BSF    03.7
0ADA:  MOVF   00,W
0ADB:  MOVWF  59
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
0ADC:  MOVF   57,W
0ADD:  SUBLW  0A
0ADE:  BTFSS  03.2
0ADF:  GOTO   321
....................       { 
....................          while (c >= '0' && c <= '9') 
0AE0:  MOVF   59,W
0AE1:  SUBLW  2F
0AE2:  BTFSC  03.0
0AE3:  GOTO   320
0AE4:  MOVF   59,W
0AE5:  SUBLW  39
0AE6:  BTFSS  03.0
0AE7:  GOTO   320
....................          { 
....................             result = 10*result + (c - '0'); 
0AE8:  MOVLW  0A
0AE9:  MOVWF  5A
0AEA:  MOVF   55,W
0AEB:  MOVWF  5B
*
0B10:  MOVF   78,W
0B11:  MOVWF  5A
0B12:  MOVLW  30
0B13:  SUBWF  59,W
0B14:  ADDWF  5A,W
0B15:  MOVWF  55
....................             c = s[index++]; 
0B16:  MOVF   58,W
0B17:  INCF   58,F
0B18:  ADDWF  53,W
0B19:  MOVWF  04
0B1A:  BCF    03.7
0B1B:  BTFSC  54.0
0B1C:  BSF    03.7
0B1D:  MOVF   00,W
0B1E:  MOVWF  59
0B1F:  GOTO   2E0
....................          } 
....................       } 
0B20:  GOTO   373
....................       else if (base == 16)    // The number is a hexa number 
0B21:  MOVF   57,W
0B22:  SUBLW  10
0B23:  BTFSS  03.2
0B24:  GOTO   373
....................       { 
....................          c = toupper(c); 
0B25:  MOVF   59,W
0B26:  SUBLW  60
0B27:  BTFSC  03.0
0B28:  GOTO   330
0B29:  MOVF   59,W
0B2A:  SUBLW  7A
0B2B:  BTFSS  03.0
0B2C:  GOTO   330
0B2D:  MOVF   59,W
0B2E:  ANDLW  DF
0B2F:  GOTO   331
0B30:  MOVF   59,W
0B31:  MOVWF  59
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
0B32:  MOVF   59,W
0B33:  SUBLW  2F
0B34:  BTFSC  03.0
0B35:  GOTO   33A
0B36:  MOVF   59,W
0B37:  SUBLW  39
0B38:  BTFSC  03.0
0B39:  GOTO   342
0B3A:  MOVF   59,W
0B3B:  SUBLW  40
0B3C:  BTFSC  03.0
0B3D:  GOTO   373
0B3E:  MOVF   59,W
0B3F:  SUBLW  46
0B40:  BTFSS  03.0
0B41:  GOTO   373
....................          { 
....................             if (c >= '0' && c <= '9') 
0B42:  MOVF   59,W
0B43:  SUBLW  2F
0B44:  BTFSC  03.0
0B45:  GOTO   353
0B46:  MOVF   59,W
0B47:  SUBLW  39
0B48:  BTFSS  03.0
0B49:  GOTO   353
....................                result = (result << 4) + (c - '0'); 
0B4A:  SWAPF  55,W
0B4B:  MOVWF  5A
0B4C:  MOVLW  F0
0B4D:  ANDWF  5A,F
0B4E:  MOVLW  30
0B4F:  SUBWF  59,W
0B50:  ADDWF  5A,W
0B51:  MOVWF  55
0B52:  GOTO   35C
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
0B53:  SWAPF  55,W
0B54:  MOVWF  5A
0B55:  MOVLW  F0
0B56:  ANDWF  5A,F
0B57:  MOVLW  41
0B58:  SUBWF  59,W
0B59:  ADDLW  0A
0B5A:  ADDWF  5A,W
0B5B:  MOVWF  55
....................  
....................             c = s[index++]; 
0B5C:  MOVF   58,W
0B5D:  INCF   58,F
0B5E:  ADDWF  53,W
0B5F:  MOVWF  04
0B60:  BCF    03.7
0B61:  BTFSC  54.0
0B62:  BSF    03.7
0B63:  MOVF   00,W
0B64:  MOVWF  59
....................             c = toupper(c); 
0B65:  MOVF   59,W
0B66:  SUBLW  60
0B67:  BTFSC  03.0
0B68:  GOTO   370
0B69:  MOVF   59,W
0B6A:  SUBLW  7A
0B6B:  BTFSS  03.0
0B6C:  GOTO   370
0B6D:  MOVF   59,W
0B6E:  ANDLW  DF
0B6F:  GOTO   371
0B70:  MOVF   59,W
0B71:  MOVWF  59
0B72:  GOTO   332
....................          } 
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
0B73:  DECFSZ 56,W
0B74:  GOTO   37B
0B75:  MOVF   57,W
0B76:  SUBLW  0A
0B77:  BTFSS  03.2
0B78:  GOTO   37B
....................        result = -result; 
0B79:  COMF   55,F
0B7A:  INCF   55,F
....................  
....................    return(result); 
0B7B:  MOVF   55,W
0B7C:  MOVWF  78
0B7D:  BCF    03.5
0B7E:  RETURN
.................... } 
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
*
03DD:  BSF    03.6
03DE:  CLRF   3E
03DF:  CLRF   3D
03E0:  CLRF   3C
03E1:  MOVLW  01
03E2:  MOVWF  3B
03E3:  CLRF   40
03E4:  CLRF   41
.................... { 
....................      unsigned int32 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
03E5:  BTFSS  37.7
03E6:  GOTO   427
....................          sign=1;        // Check for negative number 
03E7:  MOVLW  01
03E8:  MOVWF  40
....................          num*=-1; 
03E9:  MOVF   37,W
03EA:  MOVWF  46
03EB:  MOVF   36,W
03EC:  MOVWF  45
03ED:  MOVF   35,W
03EE:  MOVWF  44
03EF:  MOVF   34,W
03F0:  MOVWF  43
03F1:  MOVLW  FF
03F2:  MOVWF  4A
03F3:  MOVWF  49
03F4:  MOVWF  48
03F5:  MOVWF  47
*
041F:  MOVF   7A,W
0420:  MOVWF  37
0421:  MOVF   79,W
0422:  MOVWF  36
0423:  MOVF   78,W
0424:  MOVWF  35
0425:  MOVF   77,W
0426:  MOVWF  34
....................      } 
....................  
....................      while(temp>0) { 
0427:  MOVF   3B,F
0428:  BTFSS  03.2
0429:  GOTO   433
042A:  MOVF   3C,F
042B:  BTFSS  03.2
042C:  GOTO   433
042D:  MOVF   3D,F
042E:  BTFSS  03.2
042F:  GOTO   433
0430:  MOVF   3E,F
0431:  BTFSC  03.2
0432:  GOTO   4AF
....................          temp=(num/base); 
0433:  BCF    03.1
0434:  MOVF   37,W
0435:  MOVWF  4E
0436:  MOVF   36,W
0437:  MOVWF  4D
0438:  MOVF   35,W
0439:  MOVWF  4C
043A:  MOVF   34,W
043B:  MOVWF  4B
043C:  CLRF   52
043D:  CLRF   51
043E:  CLRF   50
043F:  MOVF   38,W
0440:  MOVWF  4F
0441:  BCF    03.6
0442:  CALL   361
0443:  MOVF   7A,W
0444:  BSF    03.6
0445:  MOVWF  3E
0446:  MOVF   79,W
0447:  MOVWF  3D
0448:  MOVF   78,W
0449:  MOVWF  3C
044A:  MOVF   77,W
044B:  MOVWF  3B
....................          s[cnt]=(num%base)+'0';    // Conversion 
044C:  MOVF   41,W
044D:  ADDWF  39,W
044E:  MOVWF  78
044F:  MOVF   3A,W
0450:  MOVWF  7A
0451:  BTFSC  03.0
0452:  INCF   7A,F
0453:  MOVF   78,W
0454:  MOVWF  43
0455:  MOVF   7A,W
0456:  MOVWF  44
0457:  CLRF   46
0458:  MOVF   04,W
0459:  MOVWF  45
045A:  BCF    46.0
045B:  BTFSC  03.7
045C:  BSF    46.0
045D:  BSF    03.1
045E:  MOVLW  47
045F:  MOVWF  04
0460:  BSF    03.7
0461:  MOVF   37,W
0462:  MOVWF  4E
0463:  MOVF   36,W
0464:  MOVWF  4D
0465:  MOVF   35,W
0466:  MOVWF  4C
0467:  MOVF   34,W
0468:  MOVWF  4B
0469:  CLRF   52
046A:  CLRF   51
046B:  CLRF   50
046C:  MOVF   38,W
046D:  MOVWF  4F
046E:  BCF    03.6
046F:  CALL   361
0470:  BSF    03.6
0471:  MOVF   45,W
0472:  MOVWF  04
0473:  BCF    03.7
0474:  BTFSC  46.0
0475:  BSF    03.7
0476:  MOVLW  30
0477:  ADDWF  47,W
0478:  MOVWF  77
0479:  MOVF   48,W
047A:  MOVWF  78
047B:  MOVLW  00
047C:  BTFSC  03.0
047D:  MOVLW  01
047E:  ADDWF  78,F
047F:  MOVF   49,W
0480:  MOVWF  79
0481:  MOVLW  00
0482:  BTFSC  03.0
0483:  MOVLW  01
0484:  ADDWF  79,F
0485:  MOVF   4A,W
0486:  MOVWF  7A
0487:  MOVLW  00
0488:  BTFSC  03.0
0489:  MOVLW  01
048A:  ADDWF  7A,F
048B:  MOVF   43,W
048C:  MOVWF  04
048D:  BCF    03.7
048E:  BTFSC  44.0
048F:  BSF    03.7
0490:  MOVF   77,W
0491:  MOVWF  00
....................  
....................          if(s[cnt]>0x39) 
0492:  MOVF   41,W
0493:  ADDWF  39,W
0494:  MOVWF  04
0495:  BCF    03.7
0496:  BTFSC  3A.0
0497:  BSF    03.7
0498:  MOVF   00,W
0499:  SUBLW  39
049A:  BTFSC  03.0
049B:  GOTO   4A5
....................             s[cnt]+=0x7; 
049C:  MOVF   41,W
049D:  ADDWF  39,W
049E:  MOVWF  04
049F:  BCF    03.7
04A0:  BTFSC  3A.0
04A1:  BSF    03.7
04A2:  MOVLW  07
04A3:  ADDWF  00,W
04A4:  MOVWF  00
....................  
....................          cnt++; 
04A5:  INCF   41,F
....................          num=temp; 
04A6:  MOVF   3E,W
04A7:  MOVWF  37
04A8:  MOVF   3D,W
04A9:  MOVWF  36
04AA:  MOVF   3C,W
04AB:  MOVWF  35
04AC:  MOVF   3B,W
04AD:  MOVWF  34
04AE:  GOTO   427
....................      } 
....................  
....................      if(sign==1) { 
04AF:  DECFSZ 40,W
04B0:  GOTO   4BA
....................          s[cnt]=0x2D;      // Negative sign 
04B1:  MOVF   41,W
04B2:  ADDWF  39,W
04B3:  MOVWF  04
04B4:  BCF    03.7
04B5:  BTFSC  3A.0
04B6:  BSF    03.7
04B7:  MOVLW  2D
04B8:  MOVWF  00
....................          cnt++; 
04B9:  INCF   41,F
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
04BA:  CLRF   3F
04BB:  BCF    03.0
04BC:  RRF    41,W
04BD:  SUBWF  3F,W
04BE:  BTFSC  03.0
04BF:  GOTO   4F0
....................  
....................          c=s[i]; 
04C0:  MOVF   3F,W
04C1:  ADDWF  39,W
04C2:  MOVWF  04
04C3:  BCF    03.7
04C4:  BTFSC  3A.0
04C5:  BSF    03.7
04C6:  MOVF   00,W
04C7:  MOVWF  42
....................          s[i]=s[cnt-i-1];        // Reverse the number 
04C8:  MOVF   3F,W
04C9:  ADDWF  39,W
04CA:  MOVWF  78
04CB:  MOVF   3A,W
04CC:  MOVWF  7A
04CD:  BTFSC  03.0
04CE:  INCF   7A,F
04CF:  MOVF   78,W
04D0:  MOVWF  43
04D1:  MOVF   7A,W
04D2:  MOVWF  44
04D3:  MOVF   3F,W
04D4:  SUBWF  41,W
04D5:  ADDLW  FF
04D6:  ADDWF  39,W
04D7:  MOVWF  04
04D8:  BCF    03.7
04D9:  BTFSC  3A.0
04DA:  BSF    03.7
04DB:  MOVF   00,W
04DC:  MOVWF  45
04DD:  MOVF   43,W
04DE:  MOVWF  04
04DF:  BCF    03.7
04E0:  BTFSC  44.0
04E1:  BSF    03.7
04E2:  MOVF   45,W
04E3:  MOVWF  00
....................          s[cnt-i-1]=c; 
04E4:  MOVF   3F,W
04E5:  SUBWF  41,W
04E6:  ADDLW  FF
04E7:  ADDWF  39,W
04E8:  MOVWF  04
04E9:  BCF    03.7
04EA:  BTFSC  3A.0
04EB:  BSF    03.7
04EC:  MOVF   42,W
04ED:  MOVWF  00
04EE:  INCF   3F,F
04EF:  GOTO   4BB
....................      } 
....................      s[cnt]='\0';     // End the string 
04F0:  MOVF   41,W
04F1:  ADDWF  39,W
04F2:  MOVWF  04
04F3:  BCF    03.7
04F4:  BTFSC  3A.0
04F5:  BSF    03.7
04F6:  CLRF   00
....................      return s; 
04F7:  MOVF   39,W
04F8:  MOVWF  78
04F9:  MOVF   3A,W
04FA:  MOVWF  79
04FB:  BCF    03.6
04FC:  RETURN
.................... } 
....................  
.................... #if defined(__PCD__) 
....................  
.................... char * itoa(signed int48 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int48 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... char * itoa(signed int64 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int64 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................       
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1;         
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................              
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #endif 
....................  
.................... float strtof(char *s, char *endptr) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s, char *endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float48)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float48)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s, char *endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float64)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float64)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtoulGO; 
....................  
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................    { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... int8 mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #if !defined(__PCD__) 
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2);  
.................... #else  
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2);  
.................... #endif 
....................  
....................  
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    unsigned int8 t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=1; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = 0; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
.................... #INCLUDE <STDIO.H> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDIO 
.................... #define _STDIO 
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #ifndef getc 
.................... #define getc getch 
.................... #define getchar getch 
.................... #define puts(s) {printf(s); putchar(13); putchar(10);} 
.................... #define putc putchar 
.................... #endif 
.................... /* maps error number to an error message. Writes a sequence of characters to 
.................... stderr stream thus: if s is not null then string pointed to by s follwed by 
.................... a colon (:) and a space and the appropriate error message returned by strerror 
.................... function with argument errno 
....................  
.................... Returns: no value 
.................... */ 
....................  
.................... #ifdef _ERRNO 
.................... void perror(char *s) 
.................... { 
....................   if(s) 
....................   fprintf(STDERR,"%s: ",s); 
....................   fprintf(STDERR,"%s\r\n",strerror(errno)); 
.................... } 
.................... #endif 
.................... #endif 
....................  
.................... #FUSES NOWDT, PUT, HS 
.................... #USE DELAY(CLOCK=20M) 
*
0139:  MOVLW  36
013A:  MOVWF  04
013B:  BSF    03.7
013C:  MOVF   00,W
013D:  BTFSC  03.2
013E:  GOTO   14C
013F:  MOVLW  06
0140:  MOVWF  78
0141:  CLRF   77
0142:  DECFSZ 77,F
0143:  GOTO   142
0144:  DECFSZ 78,F
0145:  GOTO   141
0146:  MOVLW  7B
0147:  MOVWF  77
0148:  DECFSZ 77,F
0149:  GOTO   148
014A:  DECFSZ 00,F
014B:  GOTO   13F
014C:  RETURN
.................... #USE RS232(BAUD=9600,XMIT=PIN_C6,RCV=PIN_C7) 
.................... #DEFINE BT1_PIN PIN_B1 
.................... #DEFINE BT2_PIN PIN_B2 
.................... #DEFINE BT3_PIN PIN_B3 
.................... #DEFINE LCD_ENABLE_PIN  PIN_E0                                    
.................... #DEFINE LCD_RS_PIN      PIN_E1                                 
.................... #DEFINE LCD_RW_PIN      PIN_E2   
.................... #DEFINE LCD_DATA4       PIN_C0                                
.................... #DEFINE LCD_DATA5       PIN_C1                                  
.................... #DEFINE LCD_DATA6       PIN_C2                                    
.................... #DEFINE LCD_DATA7       PIN_C3   
.................... #INCLUDE <LCD.C> 
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... ////                             LCD.C                                     //// 
.................... ////                 Driver for common LCD modules                         //// 
.................... ////                                                                       //// 
.................... ////  lcd_init()   Must be called before any other function.               //// 
.................... ////                                                                       //// 
.................... ////  lcd_putc(c)  Will display c on the next position of the LCD.         //// 
.................... ////                 \a  Set cursor position to upper left                 //// 
.................... ////                 \f  Clear display, set cursor to upper left           //// 
.................... ////                 \n  Go to start of second line                        //// 
.................... ////                 \b  Move back one position                            //// 
.................... ////              If LCD_EXTENDED_NEWLINE is defined, the \n character     //// 
.................... ////              will erase all remanining characters on the current      //// 
.................... ////              line, and move the cursor to the beginning of the next   //// 
.................... ////              line.                                                    //// 
.................... ////              If LCD_EXTENDED_NEWLINE is defined, the \r character     //// 
.................... ////              will move the cursor to the start of the current         //// 
.................... ////              line.                                                    //// 
.................... ////                                                                       //// 
.................... ////  lcd_gotoxy(x,y) Set write position on LCD (upper left is 1,1)        //// 
.................... ////                                                                       //// 
.................... ////  lcd_getc(x,y)   Returns character at position x,y on LCD             //// 
.................... ////                                                                       //// 
.................... ////  lcd_cursor_on(int1 on)   Turn the cursor on (on=TRUE) or off         //// 
.................... ////              (on=FALSE).                                              //// 
.................... ////                                                                       //// 
.................... ////  lcd_set_cgram_char(w, *p)   Write a custom character to the CGRAM.   //// 
.................... ////                                                                       //// 
.................... ////                                                                       //// 
.................... ////  CONFIGURATION                                                        //// 
.................... ////  The LCD can be configured in one of two ways: a.) port access or     //// 
.................... ////  b.) pin access.  Port access requires the entire 7 bit interface     //// 
.................... ////  connected to one GPIO port, and the data bits (D4:D7 of the LCD)     //// 
.................... ////  connected to sequential pins on the GPIO.  Pin access                //// 
.................... ////  has no requirements, all 7 bits of the control interface can         //// 
.................... ////  can be connected to any GPIO using several ports.                    //// 
.................... ////                                                                       //// 
.................... ////  To use port access, #define LCD_DATA_PORT to the SFR location of     //// 
.................... ////  of the GPIO port that holds the interface, -AND- edit LCD_PIN_MAP    //// 
.................... ////  of this file to configure the pin order.  If you are using a         //// 
.................... ////  baseline PIC (PCB), then LCD_OUTPUT_MAP and LCD_INPUT_MAP also must  //// 
.................... ////  be defined.                                                          //// 
.................... ////                                                                       //// 
.................... ////  Example of port access:                                              //// 
.................... ////     #define LCD_DATA_PORT getenv("SFR:PORTD")                         //// 
.................... ////                                                                       //// 
.................... ////  To use pin access, the following pins must be defined:               //// 
.................... ////     LCD_ENABLE_PIN                                                    //// 
.................... ////     LCD_RS_PIN                                                        //// 
.................... ////     LCD_RW_PIN                                                        //// 
.................... ////     LCD_DATA4                                                         //// 
.................... ////     LCD_DATA5                                                         //// 
.................... ////     LCD_DATA6                                                         //// 
.................... ////     LCD_DATA7                                                         //// 
.................... ////                                                                       //// 
.................... ////  Example of pin access:                                               //// 
.................... ////     #define LCD_ENABLE_PIN  PIN_E0                                    //// 
.................... ////     #define LCD_RS_PIN      PIN_E1                                    //// 
.................... ////     #define LCD_RW_PIN      PIN_E2                                    //// 
.................... ////     #define LCD_DATA4       PIN_D4                                    //// 
.................... ////     #define LCD_DATA5       PIN_D5                                    //// 
.................... ////     #define LCD_DATA6       PIN_D6                                    //// 
.................... ////     #define LCD_DATA7       PIN_D7                                    //// 
.................... ////                                                                       //// 
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2010 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef __LCD_C__ 
.................... #define __LCD_C__ 
....................  
.................... // define the pinout. 
.................... // only required if port access is being used. 
.................... typedef struct   
.................... {                            // This structure is overlayed 
....................    int1 enable;           // on to an I/O port to gain 
....................    int1 rs;               // access to the LCD pins. 
....................    int1 rw;               // The bits are allocated from 
....................    int1 unused;           // low order up.  ENABLE will 
....................    unsigned int     data : 4;         // be LSB pin of that port. 
....................   #if defined(__PCD__)       // The port used will be LCD_DATA_PORT. 
....................    unsigned int    reserved: 8; 
....................   #endif 
.................... } LCD_PIN_MAP; 
....................  
.................... // this is to improve compatability with previous LCD drivers that accepted 
.................... // a define labeled 'use_portb_lcd' that configured the LCD onto port B. 
.................... #if ((defined(use_portb_lcd)) && (use_portb_lcd==TRUE)) 
....................  #define LCD_DATA_PORT getenv("SFR:PORTB") 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
....................    // these definitions only need to be modified for baseline PICs. 
....................    // all other PICs use LCD_PIN_MAP or individual LCD_xxx pin definitions. 
.................... /*                                    EN, RS,   RW,   UNUSED,  DATA  */ 
....................  const LCD_PIN_MAP LCD_OUTPUT_MAP =  {0,  0,    0,    0,       0}; 
....................  const LCD_PIN_MAP LCD_INPUT_MAP =   {0,  0,    0,    0,       0xF}; 
.................... #endif 
....................  
.................... ////////////////////// END CONFIGURATION /////////////////////////////////// 
....................  
.................... #ifndef LCD_ENABLE_PIN 
....................    #define lcd_output_enable(x) lcdlat.enable=x 
....................    #define lcd_enable_tris()   lcdtris.enable=0 
.................... #else 
....................    #define lcd_output_enable(x) output_bit(LCD_ENABLE_PIN, x) 
....................    #define lcd_enable_tris()  output_drive(LCD_ENABLE_PIN) 
.................... #endif 
....................  
.................... #ifndef LCD_RS_PIN 
....................    #define lcd_output_rs(x) lcdlat.rs=x 
....................    #define lcd_rs_tris()   lcdtris.rs=0 
.................... #else 
....................    #define lcd_output_rs(x) output_bit(LCD_RS_PIN, x) 
....................    #define lcd_rs_tris()  output_drive(LCD_RS_PIN) 
.................... #endif 
....................  
.................... #ifndef LCD_RW_PIN 
....................    #define lcd_output_rw(x) lcdlat.rw=x 
....................    #define lcd_rw_tris()   lcdtris.rw=0 
.................... #else 
....................    #define lcd_output_rw(x) output_bit(LCD_RW_PIN, x) 
....................    #define lcd_rw_tris()  output_drive(LCD_RW_PIN) 
.................... #endif 
....................  
.................... // original version of this library incorrectly labeled LCD_DATA0 as LCD_DATA4, 
.................... // LCD_DATA1 as LCD_DATA5, and so on.  this block of code makes the driver 
.................... // compatible with any code written for the original library 
.................... #if (defined(LCD_DATA0) && defined(LCD_DATA1) && defined(LCD_DATA2) && defined(LCD_DATA3) && !defined(LCD_DATA4) && !defined(LCD_DATA5) && !defined(LCD_DATA6) && !defined(LCD_DATA7)) 
....................    #define  LCD_DATA4    LCD_DATA0 
....................    #define  LCD_DATA5    LCD_DATA1 
....................    #define  LCD_DATA6    LCD_DATA2 
....................    #define  LCD_DATA7    LCD_DATA3 
.................... #endif 
....................  
.................... #ifndef LCD_DATA4 
.................... #ifndef LCD_DATA_PORT 
....................    #if defined(__PCB__) 
....................       #define LCD_DATA_PORT      0x06     //portb 
....................       #define set_tris_lcd(x)   set_tris_b(x) 
....................    #else 
....................      #if defined(PIN_D0) 
....................       #define LCD_DATA_PORT      getenv("SFR:PORTD")     //portd 
....................      #else 
....................       #define LCD_DATA_PORT      getenv("SFR:PORTB")     //portb 
....................      #endif 
....................    #endif    
.................... #endif 
....................  
.................... #if defined(__PCB__) 
....................    LCD_PIN_MAP lcd, lcdlat; 
....................    #byte lcd = LCD_DATA_PORT 
....................    #byte lcdlat = LCD_DATA_PORT 
.................... #elif defined(__PCM__) 
....................    LCD_PIN_MAP lcd, lcdlat, lcdtris; 
....................    #byte lcd = LCD_DATA_PORT 
....................    #byte lcdlat = LCD_DATA_PORT 
....................    #byte lcdtris = LCD_DATA_PORT+0x80 
.................... #elif defined(__PCH__) 
....................    LCD_PIN_MAP lcd, lcdlat, lcdtris; 
....................    #byte lcd = LCD_DATA_PORT 
....................    #byte lcdlat = LCD_DATA_PORT+9 
....................    #byte lcdtris = LCD_DATA_PORT+0x12 
.................... #elif defined(__PCD__) 
....................    LCD_PIN_MAP lcd, lcdlat, lcdtris; 
....................    #word lcd = LCD_DATA_PORT 
....................    #word lcdlat = LCD_DATA_PORT+2 
....................    #word lcdtris = LCD_DATA_PORT-0x02 
.................... #endif 
.................... #endif   //LCD_DATA4 not defined 
....................  
.................... #ifndef LCD_TYPE 
....................    #define LCD_TYPE 2           // 0=5x7, 1=5x10, 2=2 lines 
.................... #endif 
....................  
.................... #ifndef LCD_LINE_TWO 
....................    #define LCD_LINE_TWO 0x40    // LCD RAM address for the second line 
.................... #endif 
....................  
.................... #ifndef LCD_LINE_LENGTH 
....................    #define LCD_LINE_LENGTH 20 
.................... #endif 
....................  
.................... unsigned int8 lcd_read_nibble(void); 
....................  
.................... unsigned int8 lcd_read_byte(void) 
.................... { 
....................    unsigned int8 low,high; 
....................  
....................  #if defined(__PCB__) 
....................    set_tris_lcd(LCD_INPUT_MAP); 
....................  #else 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    output_float(LCD_DATA4); 
*
01E0:  BSF    07.0
....................    output_float(LCD_DATA5); 
01E1:  BSF    07.1
....................    output_float(LCD_DATA6); 
01E2:  BSF    07.2
....................    output_float(LCD_DATA7); 
01E3:  BSF    07.3
....................   #else 
....................    lcdtris.data = 0xF; 
....................   #endif 
....................  #endif 
....................          
....................    lcd_output_rw(1); 
01E4:  BCF    03.5
01E5:  BSF    09.2
01E6:  BSF    03.5
01E7:  BCF    09.2
....................    delay_cycles(1); 
01E8:  NOP
....................    lcd_output_enable(1); 
01E9:  BCF    03.5
01EA:  BSF    09.0
01EB:  BSF    03.5
01EC:  BCF    09.0
....................    delay_cycles(1); 
01ED:  NOP
....................    high = lcd_read_nibble(); 
01EE:  BCF    03.5
01EF:  CALL   195
01F0:  MOVF   78,W
01F1:  BSF    03.6
01F2:  MOVWF  3D
....................        
....................    lcd_output_enable(0); 
01F3:  BCF    03.6
01F4:  BCF    09.0
01F5:  BSF    03.5
01F6:  BCF    09.0
....................    delay_cycles(1); 
01F7:  NOP
....................    lcd_output_enable(1); 
01F8:  BCF    03.5
01F9:  BSF    09.0
01FA:  BSF    03.5
01FB:  BCF    09.0
....................    delay_us(1); 
01FC:  GOTO   1FD
01FD:  GOTO   1FE
01FE:  NOP
....................    low = lcd_read_nibble(); 
01FF:  BCF    03.5
0200:  CALL   195
0201:  MOVF   78,W
0202:  BSF    03.6
0203:  MOVWF  3C
....................        
....................    lcd_output_enable(0); 
0204:  BCF    03.6
0205:  BCF    09.0
0206:  BSF    03.5
0207:  BCF    09.0
....................  
....................  #if defined(__PCB__) 
....................    set_tris_lcd(LCD_OUTPUT_MAP); 
....................  #else 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    output_drive(LCD_DATA4); 
0208:  BCF    03.5
0209:  BCF    31.0
020A:  MOVF   31,W
020B:  BSF    03.5
020C:  MOVWF  07
....................    output_drive(LCD_DATA5); 
020D:  BCF    03.5
020E:  BCF    31.1
020F:  MOVF   31,W
0210:  BSF    03.5
0211:  MOVWF  07
....................    output_drive(LCD_DATA6); 
0212:  BCF    03.5
0213:  BCF    31.2
0214:  MOVF   31,W
0215:  BSF    03.5
0216:  MOVWF  07
....................    output_drive(LCD_DATA7); 
0217:  BCF    03.5
0218:  BCF    31.3
0219:  MOVF   31,W
021A:  BSF    03.5
021B:  MOVWF  07
....................   #else 
....................    lcdtris.data = 0x0; 
....................   #endif 
....................  #endif 
....................  
....................    return( (high<<4) | low); 
021C:  BCF    03.5
021D:  BSF    03.6
021E:  SWAPF  3D,W
021F:  MOVWF  77
0220:  MOVLW  F0
0221:  ANDWF  77,F
0222:  MOVF   77,W
0223:  IORWF  3C,W
0224:  MOVWF  78
.................... } 
....................  
.................... unsigned int8 lcd_read_nibble(void) 
.................... { 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
*
0195:  BSF    03.6
0196:  CLRF   3E
....................    unsigned int8 n = 0x00; 
....................  
....................    /* Read the data port */ 
....................    n |= input(LCD_DATA4); 
0197:  BCF    03.6
0198:  BSF    31.0
0199:  MOVF   31,W
019A:  BSF    03.5
019B:  MOVWF  07
019C:  MOVLW  00
019D:  BCF    03.5
019E:  BTFSC  07.0
019F:  MOVLW  01
01A0:  BSF    03.6
01A1:  IORWF  3E,F
....................    n |= input(LCD_DATA5) << 1; 
01A2:  BCF    03.6
01A3:  BSF    31.1
01A4:  MOVF   31,W
01A5:  BSF    03.5
01A6:  MOVWF  07
01A7:  MOVLW  00
01A8:  BCF    03.5
01A9:  BTFSC  07.1
01AA:  MOVLW  01
01AB:  MOVWF  77
01AC:  BCF    03.0
01AD:  RLF    77,F
01AE:  MOVF   77,W
01AF:  BSF    03.6
01B0:  IORWF  3E,F
....................    n |= input(LCD_DATA6) << 2; 
01B1:  BCF    03.6
01B2:  BSF    31.2
01B3:  MOVF   31,W
01B4:  BSF    03.5
01B5:  MOVWF  07
01B6:  MOVLW  00
01B7:  BCF    03.5
01B8:  BTFSC  07.2
01B9:  MOVLW  01
01BA:  MOVWF  77
01BB:  RLF    77,F
01BC:  RLF    77,F
01BD:  MOVLW  FC
01BE:  ANDWF  77,F
01BF:  MOVF   77,W
01C0:  BSF    03.6
01C1:  IORWF  3E,F
....................    n |= input(LCD_DATA7) << 3; 
01C2:  BCF    03.6
01C3:  BSF    31.3
01C4:  MOVF   31,W
01C5:  BSF    03.5
01C6:  MOVWF  07
01C7:  MOVLW  00
01C8:  BCF    03.5
01C9:  BTFSC  07.3
01CA:  MOVLW  01
01CB:  MOVWF  77
01CC:  RLF    77,F
01CD:  RLF    77,F
01CE:  RLF    77,F
01CF:  MOVLW  F8
01D0:  ANDWF  77,F
01D1:  MOVF   77,W
01D2:  BSF    03.6
01D3:  IORWF  3E,F
....................     
....................    return(n); 
01D4:  MOVF   3E,W
01D5:  MOVWF  78
....................   #else 
01D6:  BCF    03.6
01D7:  RETURN
....................    return(lcd.data); 
....................   #endif 
.................... } 
....................  
.................... void lcd_send_nibble(unsigned int8 n) 
.................... { 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    /* Write to the data port */ 
....................    output_bit(LCD_DATA4, bit_test(n, 0)); 
*
014D:  BSF    03.6
014E:  BTFSC  3D.0
014F:  GOTO   154
0150:  BCF    03.6
0151:  BCF    07.0
0152:  GOTO   156
0153:  BSF    03.6
0154:  BCF    03.6
0155:  BSF    07.0
0156:  BCF    31.0
0157:  MOVF   31,W
0158:  BSF    03.5
0159:  MOVWF  07
....................    output_bit(LCD_DATA5, bit_test(n, 1)); 
015A:  BCF    03.5
015B:  BSF    03.6
015C:  BTFSC  3D.1
015D:  GOTO   162
015E:  BCF    03.6
015F:  BCF    07.1
0160:  GOTO   164
0161:  BSF    03.6
0162:  BCF    03.6
0163:  BSF    07.1
0164:  BCF    31.1
0165:  MOVF   31,W
0166:  BSF    03.5
0167:  MOVWF  07
....................    output_bit(LCD_DATA6, bit_test(n, 2)); 
0168:  BCF    03.5
0169:  BSF    03.6
016A:  BTFSC  3D.2
016B:  GOTO   170
016C:  BCF    03.6
016D:  BCF    07.2
016E:  GOTO   172
016F:  BSF    03.6
0170:  BCF    03.6
0171:  BSF    07.2
0172:  BCF    31.2
0173:  MOVF   31,W
0174:  BSF    03.5
0175:  MOVWF  07
....................    output_bit(LCD_DATA7, bit_test(n, 3)); 
0176:  BCF    03.5
0177:  BSF    03.6
0178:  BTFSC  3D.3
0179:  GOTO   17E
017A:  BCF    03.6
017B:  BCF    07.3
017C:  GOTO   180
017D:  BSF    03.6
017E:  BCF    03.6
017F:  BSF    07.3
0180:  BCF    31.3
0181:  MOVF   31,W
0182:  BSF    03.5
0183:  MOVWF  07
....................   #else       
....................    lcdlat.data = n; 
....................   #endif 
....................        
....................    delay_cycles(1); 
0184:  NOP
....................    lcd_output_enable(1); 
0185:  BCF    03.5
0186:  BSF    09.0
0187:  BSF    03.5
0188:  BCF    09.0
....................    delay_us(2); 
0189:  MOVLW  02
018A:  MOVWF  77
018B:  DECFSZ 77,F
018C:  GOTO   18B
018D:  GOTO   18E
018E:  NOP
....................    lcd_output_enable(0); 
018F:  BCF    03.5
0190:  BCF    09.0
0191:  BSF    03.5
0192:  BCF    09.0
0193:  BCF    03.5
0194:  RETURN
.................... } 
....................  
.................... void lcd_send_byte(unsigned int8 address, unsigned int8 n) 
.................... { 
....................   #if defined(__PCB__) 
....................    set_tris_lcd(LCD_OUTPUT_MAP); 
....................   #else 
....................    lcd_enable_tris(); 
*
01D8:  BSF    03.5
01D9:  BCF    09.0
....................    lcd_rs_tris(); 
01DA:  BCF    09.1
....................    lcd_rw_tris(); 
01DB:  BCF    09.2
....................   #endif 
....................  
....................    lcd_output_rs(0); 
01DC:  BCF    03.5
01DD:  BCF    09.1
01DE:  BSF    03.5
01DF:  BCF    09.1
....................    while ( bit_test(lcd_read_byte(),7) ) ; 
*
0225:  MOVF   78,W
0226:  MOVWF  3C
0227:  BTFSS  3C.7
0228:  GOTO   22C
0229:  BSF    03.5
022A:  BCF    03.6
022B:  GOTO   1E0
....................    lcd_output_rs(address); 
022C:  MOVF   3A,F
022D:  BTFSS  03.2
022E:  GOTO   233
022F:  BCF    03.6
0230:  BCF    09.1
0231:  GOTO   235
0232:  BSF    03.6
0233:  BCF    03.6
0234:  BSF    09.1
0235:  BSF    03.5
0236:  BCF    09.1
....................    delay_cycles(1); 
0237:  NOP
....................    lcd_output_rw(0); 
0238:  BCF    03.5
0239:  BCF    09.2
023A:  BSF    03.5
023B:  BCF    09.2
....................    delay_cycles(1); 
023C:  NOP
....................    lcd_output_enable(0); 
023D:  BCF    03.5
023E:  BCF    09.0
023F:  BSF    03.5
0240:  BCF    09.0
....................    lcd_send_nibble(n >> 4); 
0241:  BCF    03.5
0242:  BSF    03.6
0243:  SWAPF  3B,W
0244:  MOVWF  3C
0245:  MOVLW  0F
0246:  ANDWF  3C,F
0247:  MOVF   3C,W
0248:  MOVWF  3D
0249:  BCF    03.6
024A:  CALL   14D
....................    lcd_send_nibble(n & 0xf); 
024B:  BSF    03.6
024C:  MOVF   3B,W
024D:  ANDLW  0F
024E:  MOVWF  3C
024F:  MOVWF  3D
0250:  BCF    03.6
0251:  CALL   14D
0252:  RETURN
.................... } 
....................  
.................... #if defined(LCD_EXTENDED_NEWLINE) 
.................... unsigned int8 g_LcdX, g_LcdY; 
.................... #endif 
....................  
.................... void lcd_init(void)  
.................... { 
....................    unsigned int8 i; 
....................    unsigned int8 LCD_INIT_STRING[4] = {0x20 | (LCD_TYPE << 2), 0xc, 1, 6}; 
0253:  MOVLW  28
0254:  BSF    03.5
0255:  MOVWF  4E
0256:  MOVLW  0C
0257:  MOVWF  4F
0258:  MOVLW  01
0259:  MOVWF  50
025A:  MOVLW  06
025B:  MOVWF  51
....................                              // These bytes need to be sent to the LCD 
....................                              // to start it up. 
....................     
....................  
....................    lcd_output_enable(0); 
025C:  BCF    03.5
025D:  BCF    09.0
025E:  BSF    03.5
025F:  BCF    09.0
....................    lcd_output_rs(0); 
0260:  BCF    03.5
0261:  BCF    09.1
0262:  BSF    03.5
0263:  BCF    09.1
....................    lcd_output_rw(0); 
0264:  BCF    03.5
0265:  BCF    09.2
0266:  BSF    03.5
0267:  BCF    09.2
....................  
....................  #if defined(__PCB__) 
....................    set_tris_lcd(LCD_OUTPUT_MAP); 
....................  #else 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    output_drive(LCD_DATA4); 
0268:  BCF    03.5
0269:  BCF    31.0
026A:  MOVF   31,W
026B:  BSF    03.5
026C:  MOVWF  07
....................    output_drive(LCD_DATA5); 
026D:  BCF    03.5
026E:  BCF    31.1
026F:  MOVF   31,W
0270:  BSF    03.5
0271:  MOVWF  07
....................    output_drive(LCD_DATA6); 
0272:  BCF    03.5
0273:  BCF    31.2
0274:  MOVF   31,W
0275:  BSF    03.5
0276:  MOVWF  07
....................    output_drive(LCD_DATA7); 
0277:  BCF    03.5
0278:  BCF    31.3
0279:  MOVF   31,W
027A:  BSF    03.5
027B:  MOVWF  07
....................   #else 
....................    lcdtris.data = 0x0; 
....................   #endif 
....................    lcd_enable_tris(); 
027C:  BCF    09.0
....................    lcd_rs_tris(); 
027D:  BCF    09.1
....................    lcd_rw_tris(); 
027E:  BCF    09.2
....................  #endif 
....................      
....................    delay_ms(15); 
027F:  MOVLW  0F
0280:  BCF    03.5
0281:  BSF    03.6
0282:  MOVWF  36
0283:  BCF    03.6
0284:  CALL   139
....................    for(i=1;i<=3;++i) 
0285:  MOVLW  01
0286:  BSF    03.5
0287:  MOVWF  4D
0288:  MOVF   4D,W
0289:  SUBLW  03
028A:  BTFSS  03.0
028B:  GOTO   29A
....................    { 
....................        lcd_send_nibble(3); 
028C:  MOVLW  03
028D:  BCF    03.5
028E:  BSF    03.6
028F:  MOVWF  3D
0290:  BCF    03.6
0291:  CALL   14D
....................        delay_ms(5); 
0292:  MOVLW  05
0293:  BSF    03.6
0294:  MOVWF  36
0295:  BCF    03.6
0296:  CALL   139
0297:  BSF    03.5
0298:  INCF   4D,F
0299:  GOTO   288
....................    } 
....................     
....................    lcd_send_nibble(2); 
029A:  MOVLW  02
029B:  BCF    03.5
029C:  BSF    03.6
029D:  MOVWF  3D
029E:  BCF    03.6
029F:  CALL   14D
....................    delay_ms(5); 
02A0:  MOVLW  05
02A1:  BSF    03.6
02A2:  MOVWF  36
02A3:  BCF    03.6
02A4:  CALL   139
....................    for(i=0;i<=3;++i) 
02A5:  BSF    03.5
02A6:  CLRF   4D
02A7:  MOVF   4D,W
02A8:  SUBLW  03
02A9:  BTFSS  03.0
02AA:  GOTO   2BF
....................       lcd_send_byte(0,LCD_INIT_STRING[i]); 
02AB:  MOVLW  CE
02AC:  ADDWF  4D,W
02AD:  MOVWF  04
02AE:  BCF    03.7
02AF:  MOVF   00,W
02B0:  MOVWF  52
02B1:  BCF    03.5
02B2:  BSF    03.6
02B3:  CLRF   3A
02B4:  BSF    03.5
02B5:  BCF    03.6
02B6:  MOVF   52,W
02B7:  BCF    03.5
02B8:  BSF    03.6
02B9:  MOVWF  3B
02BA:  BCF    03.6
02BB:  CALL   1D8
....................  
....................   #if defined(LCD_EXTENDED_NEWLINE) 
02BC:  BSF    03.5
02BD:  INCF   4D,F
02BE:  GOTO   2A7
02BF:  BCF    03.5
02C0:  BSF    0A.3
02C1:  BCF    0A.4
02C2:  GOTO   643 (RETURN)
....................    g_LcdX = 0; 
....................    g_LcdY = 0; 
....................   #endif 
.................... } 
....................  
.................... void lcd_gotoxy(unsigned int8 x, unsigned int8 y) 
.................... { 
....................    unsigned int8 address; 
....................     
....................    if(y!=1) 
02C3:  BSF    03.6
02C4:  DECFSZ 37,W
02C5:  GOTO   2C7
02C6:  GOTO   2CA
....................       address=LCD_LINE_TWO; 
02C7:  MOVLW  40
02C8:  MOVWF  38
02C9:  GOTO   2CB
....................    else 
....................       address=0; 
02CA:  CLRF   38
....................       
....................    address+=x-1; 
02CB:  MOVLW  01
02CC:  SUBWF  36,W
02CD:  ADDWF  38,F
....................    lcd_send_byte(0,0x80|address); 
02CE:  MOVF   38,W
02CF:  IORLW  80
02D0:  MOVWF  39
02D1:  CLRF   3A
02D2:  MOVF   39,W
02D3:  MOVWF  3B
02D4:  BCF    03.6
02D5:  CALL   1D8
....................  
....................   #if defined(LCD_EXTENDED_NEWLINE) 
02D6:  RETURN
....................    g_LcdX = x - 1; 
....................    g_LcdY = y - 1; 
....................   #endif 
.................... } 
....................  
.................... void lcd_putc(char c) 
.................... { 
....................    switch (c) 
02D7:  BSF    03.6
02D8:  MOVF   35,W
02D9:  XORLW  07
02DA:  BCF    03.6
02DB:  BTFSC  03.2
02DC:  GOTO   2E7
02DD:  XORLW  0B
02DE:  BTFSC  03.2
02DF:  GOTO   2EE
02E0:  XORLW  06
02E1:  BTFSC  03.2
02E2:  GOTO   2FA
02E3:  XORLW  02
02E4:  BTFSC  03.2
02E5:  GOTO   302
02E6:  GOTO   309
....................    { 
....................       case '\a'   :  lcd_gotoxy(1,1);     break; 
02E7:  MOVLW  01
02E8:  BSF    03.6
02E9:  MOVWF  36
02EA:  MOVWF  37
02EB:  BCF    03.6
02EC:  CALL   2C3
02ED:  GOTO   310
....................  
....................       case '\f'   :  lcd_send_byte(0,1); 
02EE:  BSF    03.6
02EF:  CLRF   3A
02F0:  MOVLW  01
02F1:  MOVWF  3B
02F2:  BCF    03.6
02F3:  CALL   1D8
....................                      delay_ms(2); 
02F4:  MOVLW  02
02F5:  BSF    03.6
02F6:  MOVWF  36
02F7:  BCF    03.6
02F8:  CALL   139
....................                     #if defined(LCD_EXTENDED_NEWLINE) 
....................                      g_LcdX = 0; 
....................                      g_LcdY = 0; 
....................                     #endif 
....................                      break; 
02F9:  GOTO   310
....................  
....................      #if defined(LCD_EXTENDED_NEWLINE) 
....................       case '\r'   :  lcd_gotoxy(1, g_LcdY+1);   break; 
....................       case '\n'   : 
....................          while (g_LcdX++ < LCD_LINE_LENGTH) 
....................          { 
....................             lcd_send_byte(1, ' '); 
....................          } 
....................          lcd_gotoxy(1, g_LcdY+2); 
....................          break; 
....................      #else 
....................       case '\n'   : lcd_gotoxy(1,2);        break; 
02FA:  MOVLW  01
02FB:  BSF    03.6
02FC:  MOVWF  36
02FD:  MOVLW  02
02FE:  MOVWF  37
02FF:  BCF    03.6
0300:  CALL   2C3
0301:  GOTO   310
....................      #endif 
....................       
....................       case '\b'   : lcd_send_byte(0,0x10);  break; 
0302:  BSF    03.6
0303:  CLRF   3A
0304:  MOVLW  10
0305:  MOVWF  3B
0306:  BCF    03.6
0307:  CALL   1D8
0308:  GOTO   310
....................       
....................      #if defined(LCD_EXTENDED_NEWLINE) 
....................       default     :  
....................          if (g_LcdX < LCD_LINE_LENGTH) 
....................          { 
....................             lcd_send_byte(1, c); 
....................             g_LcdX++; 
....................          } 
....................          break; 
....................      #else 
....................       default     : lcd_send_byte(1,c);     break; 
0309:  MOVLW  01
030A:  BSF    03.6
030B:  MOVWF  3A
030C:  MOVF   35,W
030D:  MOVWF  3B
030E:  BCF    03.6
030F:  CALL   1D8
....................      #endif 
....................    } 
0310:  RETURN
.................... } 
....................   
.................... char lcd_getc(unsigned int8 x, unsigned int8 y) 
.................... { 
....................    char value; 
....................  
....................    lcd_gotoxy(x,y); 
....................    while ( bit_test(lcd_read_byte(),7) ); // wait until busy flag is low 
....................    lcd_output_rs(1); 
....................    value = lcd_read_byte(); 
....................    lcd_output_rs(0); 
....................     
....................    return(value); 
.................... } 
....................  
.................... // write a custom character to the ram 
.................... // which is 0-7 and specifies which character array we are modifying. 
.................... // ptr points to an array of 8 bytes, where each byte is the next row of 
.................... //    pixels.  only bits 0-4 are used.  the last row is the cursor row, and 
.................... //    usually you will want to leave this byte 0x00. 
.................... void lcd_set_cgram_char(unsigned int8 which, unsigned int8 *ptr) 
.................... { 
....................    unsigned int i; 
....................  
....................    which <<= 3; 
....................    which &= 0x38; 
....................  
....................    lcd_send_byte(0, 0x40 | which);  //set cgram address 
....................  
....................    for(i=0; i<8; i++) 
....................    { 
....................       lcd_send_byte(1, *ptr++); 
....................    } 
....................    
....................    #if defined(LCD_EXTENDED_NEWLINE) 
....................     lcd_gotoxy(g_LcdX+1, g_LcdY+1);  //set ddram address 
....................    #endif 
.................... } 
....................  
.................... void lcd_cursor_on(int1 on) 
.................... { 
....................    if (on) 
....................    { 
....................       lcd_send_byte(0,0x0F);           //turn LCD cursor ON 
....................    } 
....................    else 
....................    { 
....................       lcd_send_byte(0,0x0C);           //turn LCD cursor OFF 
....................    } 
.................... } 
....................  
.................... #endif 
....................  
.................... #BIT TMR1IF = 0x0C.0 //bit thu 0 (TMR1IF) cua PIR1 
....................  
.................... #INCLUDE <khaibaobien.c> // VARIABLE. 
.................... UNSIGNED INT16 KQADC,AN0, AN1; 
.................... UNSIGNED INT8 CONFIG_FUN=0; 
.................... UNSIGNED INT8 VT=0, KYTU=0;// KYTU[30],  
.................... UNSIGNED INT8 ID_DEVICE_NHAN,TT_DEVICE_NHAN; 
.................... UNSIGNED INT8 ID_GATEWAY[6] = {1,2,7,1,0,2}; 
*
0DB4:  MOVLW  01
0DB5:  MOVWF  3D
0DB6:  MOVLW  02
0DB7:  MOVWF  3E
0DB8:  MOVLW  07
0DB9:  MOVWF  3F
0DBA:  MOVLW  01
0DBB:  MOVWF  40
0DBC:  CLRF   41
0DBD:  MOVLW  02
0DBE:  MOVWF  42
.................... UNSIGNED INT8 ID_NODE[4] = {0,5,8,9}; 
0DBF:  CLRF   43
0DC0:  MOVLW  05
0DC1:  MOVWF  44
0DC2:  MOVLW  08
0DC3:  MOVWF  45
0DC4:  MOVLW  09
0DC5:  MOVWF  46
.................... UNSIGNED INT8 LEN_PACKAGES = 0; 
.................... UNSIGNED INT8 LENHDIEUKHIEN =0, DODAI_DATA_NHAN =0; 
.................... SIGNED INT8 SOSANH_IDNODE=0, SOSANH_IDGW=0, SOSANH_DODAICHUOI=0; 
....................  
.................... INT1 TTNHAN = 0, TT_CONFIG=0, TT_CONTROL=0,TT_CONFIG_DONE=0, TT_FUN=0, TT_STT=0; 
....................  
.................... CHAR *ID_NODE_CHAR[]= "0000"; 
0DC6:  MOVLW  30
0DC7:  MOVWF  50
0DC8:  MOVWF  51
0DC9:  MOVWF  52
0DCA:  MOVWF  53
0DCB:  CLRF   54
0DCC:  CLRF   4F
0DCD:  MOVLW  50
0DCE:  MOVWF  4E
.................... CHAR *ID_GATEWAY_CHAR[]= "000000"; 
0DCF:  MOVLW  30
0DD0:  MOVWF  57
0DD1:  MOVWF  58
0DD2:  MOVWF  59
0DD3:  MOVWF  5A
0DD4:  MOVWF  5B
0DD5:  MOVWF  5C
0DD6:  CLRF   5D
0DD7:  CLRF   56
0DD8:  MOVLW  57
0DD9:  MOVWF  55
.................... CHAR *ID_NODE_NHAN[]= "0000"; 
0DDA:  MOVLW  30
0DDB:  MOVWF  60
0DDC:  MOVWF  61
0DDD:  MOVWF  62
0DDE:  MOVWF  63
0DDF:  CLRF   64
0DE0:  CLRF   5F
0DE1:  MOVLW  60
0DE2:  MOVWF  5E
.................... CHAR *ID_GW_NHAN[]= "000000"; 
0DE3:  MOVLW  30
0DE4:  MOVWF  67
0DE5:  MOVWF  68
0DE6:  MOVWF  69
0DE7:  MOVWF  6A
0DE8:  MOVWF  6B
0DE9:  MOVWF  6C
0DEA:  CLRF   6D
0DEB:  CLRF   66
0DEC:  MOVLW  67
0DED:  MOVWF  65
.................... CHAR KYTUCHAR[30]="HIHI"; 
0DEE:  MOVLW  48
0DEF:  BSF    03.5
0DF0:  MOVWF  20
0DF1:  MOVLW  49
0DF2:  MOVWF  21
0DF3:  MOVLW  48
0DF4:  MOVWF  22
0DF5:  MOVLW  49
0DF6:  MOVWF  23
0DF7:  CLRF   24
.................... CHAR KYTUCHAR2[15]="HIHI"; 
0DF8:  MOVLW  48
0DF9:  MOVWF  3E
0DFA:  MOVLW  49
0DFB:  MOVWF  3F
0DFC:  MOVLW  48
0DFD:  MOVWF  40
0DFE:  MOVLW  49
0DFF:  MOVWF  41
0E00:  CLRF   42
.................... //CHAR *DATA_NHANDUOC[]={"IDGW","IDNODE","COMMAN","DATA"}; 
.................... CHAR *TEMP_CHAR[]="00";  
0E01:  MOVLW  30
0E02:  MOVWF  70
0E03:  MOVWF  71
0E04:  CLRF   72
0E05:  BCF    03.5
0E06:  CLRF   6F
0E07:  MOVLW  70
0E08:  MOVWF  6E
.................... CHAR *TEMP_CHAR2[]="00";  
0E09:  MOVLW  30
0E0A:  MOVWF  7B
0E0B:  MOVWF  7C
0E0C:  CLRF   7D
0E0D:  CLRF   74
0E0E:  MOVLW  7B
0E0F:  MOVWF  73
.................... //CHAR *TEMP_CHAR3[]="000000";  
....................  
....................  
....................  
.................... //#INCLUDE <CONFIG_NODE.C> // CU HINH NODE. 
.................... #INCLUDE <config_1.C> // CU HINH NODE. 
....................  
.................... //--------------------------------------------------------------------// 
.................... VOID CHON_ID() 
.................... { 
....................    // TT_CONFIG_DONE; 
....................    TT_CONFIG_DONE = 0; 
*
05B0:  BCF    4D.3
....................    TT_STT = 1; 
05B1:  BSF    4D.5
....................    UNSIGNED INT8 NUM = 0; 
05B2:  BSF    03.5
05B3:  CLRF   4D
....................    TEMP_CHAR = "0"; 
05B4:  CLRF   4E
05B5:  CLRF   4F
05B6:  MOVLW  6E
05B7:  MOVWF  04
05B8:  BCF    03.7
05B9:  MOVF   4E,W
05BA:  ADDWF  04,F
05BB:  MOVF   4F,W
05BC:  BCF    03.5
05BD:  CALL   058
05BE:  MOVWF  00
05BF:  IORLW  00
05C0:  BTFSC  03.2
05C1:  GOTO   5C7
05C2:  BSF    03.5
05C3:  INCF   4F,F
05C4:  INCF   4E,F
05C5:  GOTO   5B6
05C6:  BCF    03.5
....................    LCD_GOTOXY (1, 2) ; 
05C7:  MOVLW  01
05C8:  BSF    03.6
05C9:  MOVWF  36
05CA:  MOVLW  02
05CB:  MOVWF  37
05CC:  BCF    03.6
05CD:  CALL   2C3
....................    DELAY_MS (10); 
05CE:  MOVLW  0A
05CF:  BSF    03.6
05D0:  MOVWF  36
05D1:  BCF    03.6
05D2:  CALL   139
....................    PRINTF (LCD_PUTC, "NODE: "); 
05D3:  MOVLW  69
05D4:  BSF    03.6
05D5:  MOVWF  0D
05D6:  MOVLW  00
05D7:  MOVWF  0F
05D8:  BCF    03.6
05D9:  CALL   311
....................    PRINTF (LCD_PUTC, "0000          "); 
05DA:  MOVLW  6D
05DB:  BSF    03.6
05DC:  MOVWF  0D
05DD:  MOVLW  00
05DE:  MOVWF  0F
05DF:  BCF    03.6
05E0:  CALL   311
....................    LCD_GOTOXY (1, 1) ; 
05E1:  MOVLW  01
05E2:  BSF    03.6
05E3:  MOVWF  36
05E4:  MOVWF  37
05E5:  BCF    03.6
05E6:  CALL   2C3
....................    PRINTF (LCD_PUTC, "      _              ");//6 SPACE PHIA TRUOC "_" 
05E7:  MOVLW  75
05E8:  BSF    03.6
05E9:  MOVWF  0D
05EA:  MOVLW  00
05EB:  MOVWF  0F
05EC:  BCF    03.6
05ED:  CALL   311
....................    //ID_GW = "1234";     
....................  
....................    WHILE (TT_STT) 
05EE:  BTFSS  4D.5
05EF:  GOTO   67A
....................    { 
....................       IF (!INPUT (BT2_PIN)) //NEU NUT BAM DUOC BAM 
05F0:  BSF    03.5
05F1:  BSF    06.2
05F2:  BCF    03.5
05F3:  BTFSC  06.2
05F4:  GOTO   617
....................       { 
....................           
....................          NUM++; 
05F5:  BSF    03.5
05F6:  INCF   4D,F
....................          NUM = NUM % 4; 
05F7:  MOVLW  03
05F8:  ANDWF  4D,F
....................          LCD_GOTOXY (3 + NUM, 1); 
05F9:  ADDWF  4D,W
05FA:  MOVWF  4E
05FB:  BCF    03.5
05FC:  BSF    03.6
05FD:  MOVWF  36
05FE:  MOVLW  01
05FF:  MOVWF  37
0600:  BCF    03.6
0601:  CALL   2C3
....................          PRINTF (LCD_PUTC, "    _    ");//4SPACE 
0602:  MOVLW  80
0603:  BSF    03.6
0604:  MOVWF  0D
0605:  MOVLW  00
0606:  MOVWF  0F
0607:  BCF    03.6
0608:  CALL   311
....................          DELAY_MS (300);  
0609:  MOVLW  02
060A:  BSF    03.5
060B:  MOVWF  4E
060C:  MOVLW  96
060D:  BCF    03.5
060E:  BSF    03.6
060F:  MOVWF  36
0610:  BCF    03.6
0611:  CALL   139
0612:  BSF    03.5
0613:  DECFSZ 4E,F
0614:  GOTO   60C
....................       } 
0615:  GOTO   678
0616:  BCF    03.5
....................  
....................       ELSE IF (!INPUT (BT3_PIN)) 
0617:  BSF    03.5
0618:  BSF    06.3
0619:  BCF    03.5
061A:  BTFSC  06.3
061B:  GOTO   679
....................       { 
....................          ID_NODE[NUM]++; 
061C:  MOVLW  43
061D:  BSF    03.5
061E:  ADDWF  4D,W
061F:  MOVWF  04
0620:  BCF    03.7
0621:  INCF   00,F
....................          ID_NODE[NUM] = ID_NODE[NUM] % 10; 
0622:  MOVLW  43
0623:  ADDWF  4D,W
0624:  MOVWF  78
0625:  CLRF   7A
0626:  BTFSC  03.0
0627:  INCF   7A,F
0628:  MOVF   78,W
0629:  MOVWF  4E
062A:  MOVF   7A,W
062B:  MOVWF  4F
062C:  MOVLW  43
062D:  ADDWF  4D,W
062E:  MOVWF  04
062F:  BCF    03.7
0630:  MOVF   00,W
0631:  MOVWF  51
0632:  MOVLW  0A
0633:  MOVWF  52
0634:  BCF    03.5
0635:  CALL   51C
0636:  MOVF   77,W
0637:  BSF    03.5
0638:  MOVWF  50
0639:  MOVF   4E,W
063A:  MOVWF  04
063B:  BCF    03.7
063C:  BTFSC  4F.0
063D:  BSF    03.7
063E:  MOVF   50,W
063F:  MOVWF  00
....................          ITOA (ID_NODE[NUM], 10, TEMP_CHAR); 
0640:  MOVLW  43
0641:  ADDWF  4D,W
0642:  MOVWF  04
0643:  BCF    03.7
0644:  MOVF   00,W
0645:  MOVWF  4E
0646:  BCF    03.5
0647:  BSF    03.6
0648:  CLRF   37
0649:  CLRF   36
064A:  CLRF   35
064B:  BSF    03.5
064C:  BCF    03.6
064D:  MOVF   4E,W
064E:  BCF    03.5
064F:  BSF    03.6
0650:  MOVWF  34
0651:  MOVLW  0A
0652:  MOVWF  38
0653:  CLRF   3A
0654:  MOVLW  6E
0655:  MOVWF  39
0656:  BCF    03.6
0657:  CALL   3DD
....................          LCD_GOTOXY (7 + NUM, 2); 
0658:  MOVLW  07
0659:  BSF    03.5
065A:  ADDWF  4D,W
065B:  MOVWF  4E
065C:  BCF    03.5
065D:  BSF    03.6
065E:  MOVWF  36
065F:  MOVLW  02
0660:  MOVWF  37
0661:  BCF    03.6
0662:  CALL   2C3
....................          DELAY_MS (10); 
0663:  MOVLW  0A
0664:  BSF    03.6
0665:  MOVWF  36
0666:  BCF    03.6
0667:  CALL   139
....................          PRINTF (LCD_PUTC, TEMP_CHAR); 
0668:  MOVLW  6E
0669:  MOVWF  04
066A:  BCF    03.7
066B:  CALL   4FD
....................          DELAY_MS (300); 
066C:  MOVLW  02
066D:  BSF    03.5
066E:  MOVWF  4E
066F:  MOVLW  96
0670:  BCF    03.5
0671:  BSF    03.6
0672:  MOVWF  36
0673:  BCF    03.6
0674:  CALL   139
0675:  BSF    03.5
0676:  DECFSZ 4E,F
0677:  GOTO   66F
0678:  BCF    03.5
....................       } 
0679:  GOTO   5EE
....................    } 
.................... } 
....................  
.................... VOID NHAPID_GW() 
*
067B:  BSF    03.5
067C:  CLRF   4D
.................... { 
....................    UNSIGNED INT8 NUM = 0; 
....................    TEMP_CHAR = "0"; 
067D:  CLRF   4E
067E:  CLRF   4F
067F:  MOVLW  6E
0680:  MOVWF  04
0681:  BCF    03.7
0682:  MOVF   4E,W
0683:  ADDWF  04,F
0684:  MOVF   4F,W
0685:  BCF    03.5
0686:  CALL   058
0687:  MOVWF  00
0688:  IORLW  00
0689:  BTFSC  03.2
068A:  GOTO   690
068B:  BSF    03.5
068C:  INCF   4F,F
068D:  INCF   4E,F
068E:  GOTO   67F
068F:  BCF    03.5
....................    TT_CONFIG_DONE = 0; 
0690:  BCF    4D.3
....................    TT_STT = 1; 
0691:  BSF    4D.5
....................    LCD_GOTOXY (1, 2) ; 
0692:  MOVLW  01
0693:  BSF    03.6
0694:  MOVWF  36
0695:  MOVLW  02
0696:  MOVWF  37
0697:  BCF    03.6
0698:  CALL   2C3
....................    DELAY_MS (10); 
0699:  MOVLW  0A
069A:  BSF    03.6
069B:  MOVWF  36
069C:  BCF    03.6
069D:  CALL   139
....................    PRINTF (LCD_PUTC, "ID_GW:"); 
069E:  MOVLW  85
069F:  BSF    03.6
06A0:  MOVWF  0D
06A1:  MOVLW  00
06A2:  MOVWF  0F
06A3:  BCF    03.6
06A4:  CALL   311
....................    PRINTF (LCD_PUTC, "000000        "); 
06A5:  MOVLW  89
06A6:  BSF    03.6
06A7:  MOVWF  0D
06A8:  MOVLW  00
06A9:  MOVWF  0F
06AA:  BCF    03.6
06AB:  CALL   311
....................    LCD_GOTOXY (1, 1) ; 
06AC:  MOVLW  01
06AD:  BSF    03.6
06AE:  MOVWF  36
06AF:  MOVWF  37
06B0:  BCF    03.6
06B1:  CALL   2C3
....................    PRINTF (LCD_PUTC, "      _                ");//6 SPACE PHIA TRUOC "_" 
06B2:  MOVLW  91
06B3:  BSF    03.6
06B4:  MOVWF  0D
06B5:  MOVLW  00
06B6:  MOVWF  0F
06B7:  BCF    03.6
06B8:  CALL   311
....................    //ID_GW = "1234";     
....................  
....................    WHILE (TT_STT) 
06B9:  BTFSS  4D.5
06BA:  GOTO   74D
....................    { 
....................       IF (!INPUT (BT2_PIN)) //NEU NUT BAM DUOC BAM 
06BB:  BSF    03.5
06BC:  BSF    06.2
06BD:  BCF    03.5
06BE:  BTFSC  06.2
06BF:  GOTO   6EA
....................       { 
....................           
....................          NUM++; 
06C0:  BSF    03.5
06C1:  INCF   4D,F
....................          NUM = NUM % 6; 
06C2:  MOVF   4D,W
06C3:  MOVWF  51
06C4:  MOVLW  06
06C5:  MOVWF  52
06C6:  BCF    03.5
06C7:  CALL   51C
06C8:  MOVF   77,W
06C9:  BSF    03.5
06CA:  MOVWF  4D
....................          LCD_GOTOXY (3 + NUM, 1); 
06CB:  MOVLW  03
06CC:  ADDWF  4D,W
06CD:  MOVWF  4E
06CE:  BCF    03.5
06CF:  BSF    03.6
06D0:  MOVWF  36
06D1:  MOVLW  01
06D2:  MOVWF  37
06D3:  BCF    03.6
06D4:  CALL   2C3
....................          PRINTF (LCD_PUTC, "    _        ");//4SPACE 
06D5:  MOVLW  9D
06D6:  BSF    03.6
06D7:  MOVWF  0D
06D8:  MOVLW  00
06D9:  MOVWF  0F
06DA:  BCF    03.6
06DB:  CALL   311
....................          DELAY_MS (300);  
06DC:  MOVLW  02
06DD:  BSF    03.5
06DE:  MOVWF  4E
06DF:  MOVLW  96
06E0:  BCF    03.5
06E1:  BSF    03.6
06E2:  MOVWF  36
06E3:  BCF    03.6
06E4:  CALL   139
06E5:  BSF    03.5
06E6:  DECFSZ 4E,F
06E7:  GOTO   6DF
....................       } 
06E8:  GOTO   74B
06E9:  BCF    03.5
....................  
....................       ELSE IF (!INPUT (BT3_PIN)) 
06EA:  BSF    03.5
06EB:  BSF    06.3
06EC:  BCF    03.5
06ED:  BTFSC  06.3
06EE:  GOTO   74C
....................       { 
....................          ID_GATEWAY[NUM]++; 
06EF:  MOVLW  3D
06F0:  BSF    03.5
06F1:  ADDWF  4D,W
06F2:  MOVWF  04
06F3:  BCF    03.7
06F4:  INCF   00,F
....................          ID_GATEWAY[NUM] = ID_GATEWAY[NUM] % 10; 
06F5:  MOVLW  3D
06F6:  ADDWF  4D,W
06F7:  MOVWF  78
06F8:  CLRF   7A
06F9:  BTFSC  03.0
06FA:  INCF   7A,F
06FB:  MOVF   78,W
06FC:  MOVWF  4E
06FD:  MOVF   7A,W
06FE:  MOVWF  4F
06FF:  MOVLW  3D
0700:  ADDWF  4D,W
0701:  MOVWF  04
0702:  BCF    03.7
0703:  MOVF   00,W
0704:  MOVWF  51
0705:  MOVLW  0A
0706:  MOVWF  52
0707:  BCF    03.5
0708:  CALL   51C
0709:  MOVF   77,W
070A:  BSF    03.5
070B:  MOVWF  50
070C:  MOVF   4E,W
070D:  MOVWF  04
070E:  BCF    03.7
070F:  BTFSC  4F.0
0710:  BSF    03.7
0711:  MOVF   50,W
0712:  MOVWF  00
....................          ITOA (ID_GATEWAY[NUM], 10, TEMP_CHAR); 
0713:  MOVLW  3D
0714:  ADDWF  4D,W
0715:  MOVWF  04
0716:  BCF    03.7
0717:  MOVF   00,W
0718:  MOVWF  4E
0719:  BCF    03.5
071A:  BSF    03.6
071B:  CLRF   37
071C:  CLRF   36
071D:  CLRF   35
071E:  BSF    03.5
071F:  BCF    03.6
0720:  MOVF   4E,W
0721:  BCF    03.5
0722:  BSF    03.6
0723:  MOVWF  34
0724:  MOVLW  0A
0725:  MOVWF  38
0726:  CLRF   3A
0727:  MOVLW  6E
0728:  MOVWF  39
0729:  BCF    03.6
072A:  CALL   3DD
....................          LCD_GOTOXY (7 + NUM, 2); 
072B:  MOVLW  07
072C:  BSF    03.5
072D:  ADDWF  4D,W
072E:  MOVWF  4E
072F:  BCF    03.5
0730:  BSF    03.6
0731:  MOVWF  36
0732:  MOVLW  02
0733:  MOVWF  37
0734:  BCF    03.6
0735:  CALL   2C3
....................          DELAY_MS (10); 
0736:  MOVLW  0A
0737:  BSF    03.6
0738:  MOVWF  36
0739:  BCF    03.6
073A:  CALL   139
....................          PRINTF (LCD_PUTC, TEMP_CHAR); 
073B:  MOVLW  6E
073C:  MOVWF  04
073D:  BCF    03.7
073E:  CALL   4FD
....................          DELAY_MS (300); 
073F:  MOVLW  02
0740:  BSF    03.5
0741:  MOVWF  4E
0742:  MOVLW  96
0743:  BCF    03.5
0744:  BSF    03.6
0745:  MOVWF  36
0746:  BCF    03.6
0747:  CALL   139
0748:  BSF    03.5
0749:  DECFSZ 4E,F
074A:  GOTO   742
074B:  BCF    03.5
....................       } 
074C:  GOTO   6B9
....................    } 
.................... } 
....................  
.................... VOID BUTT_OKE() 
.................... { 
....................    TT_CONFIG_DONE = 0; 
*
0104:  BCF    03.6
0105:  BCF    4D.3
....................    TT_FUN = 0;//BREAK WHILE BUTT_FUN 
0106:  BCF    4D.4
....................    TT_STT = 0;// BREAK WHILE CHONID/NHAPID_GW 
0107:  BCF    4D.5
.................... } 
....................  
.................... VOID SELLECT_FUN() 
.................... { 
....................    TT_CONFIG_DONE = 0; 
*
05A8:  BCF    4D.3
....................  
....................    SWITCH (CONFIG_FUN) 
05A9:  MOVF   38,W
05AA:  BTFSC  03.2
05AB:  GOTO   5B0
05AC:  XORLW  01
05AD:  BTFSC  03.2
05AE:  GOTO   67B
05AF:  GOTO   74D
....................    { 
....................       CASE 0: 
....................       CHON_ID (); 
....................       BREAK; 
*
067A:  GOTO   74D
....................  
....................       CASE 1:     
....................       NHAPID_GW (); 
....................       BREAK; 
....................    } 
.................... } 
....................  
.................... VOID BUTT_FUN() 
.................... { 
....................    TT_FUN = 1; 
*
0533:  BSF    4D.4
....................    LCD_GOTOXY (1, 1) ; 
0534:  MOVLW  01
0535:  BSF    03.6
0536:  MOVWF  36
0537:  MOVWF  37
0538:  BCF    03.6
0539:  CALL   2C3
....................    DELAY_MS (10); 
053A:  MOVLW  0A
053B:  BSF    03.6
053C:  MOVWF  36
053D:  BCF    03.6
053E:  CALL   139
....................    PRINTF (LCD_PUTC, "CONFIG:        "); 
053F:  MOVLW  A4
0540:  BSF    03.6
0541:  MOVWF  0D
0542:  MOVLW  00
0543:  MOVWF  0F
0544:  BCF    03.6
0545:  CALL   311
....................  
....................    // HIEN THI LCD 
....................    LCD_GOTOXY (1, 2) ; 
0546:  MOVLW  01
0547:  BSF    03.6
0548:  MOVWF  36
0549:  MOVLW  02
054A:  MOVWF  37
054B:  BCF    03.6
054C:  CALL   2C3
....................    DELAY_MS (10); 
054D:  MOVLW  0A
054E:  BSF    03.6
054F:  MOVWF  36
0550:  BCF    03.6
0551:  CALL   139
....................    PRINTF (LCD_PUTC, "CASE:          ") ; 
0552:  MOVLW  AC
0553:  BSF    03.6
0554:  MOVWF  0D
0555:  MOVLW  00
0556:  MOVWF  0F
0557:  BCF    03.6
0558:  CALL   311
....................  
....................    WHILE (TT_FUN) 
0559:  BTFSS  4D.4
055A:  GOTO   5A6
....................    { 
....................       IF (INPUT (BT2_PIN) == 0) //NEU NUT BAM DUOC BAM 
055B:  BSF    03.5
055C:  BSF    06.2
055D:  BCF    03.5
055E:  BTFSC  06.2
055F:  GOTO   5A5
....................       { 
....................          CONFIG_FUN ++; 
0560:  INCF   38,F
....................          CONFIG_FUN = CONFIG_FUN % 2; 
0561:  MOVLW  01
0562:  ANDWF  38,F
....................          DELAY_MS (300); 
0563:  MOVLW  02
0564:  BSF    03.5
0565:  MOVWF  4D
0566:  MOVLW  96
0567:  BCF    03.5
0568:  BSF    03.6
0569:  MOVWF  36
056A:  BCF    03.6
056B:  CALL   139
056C:  BSF    03.5
056D:  DECFSZ 4D,F
056E:  GOTO   566
....................          //HIEN THI 
....................          LCD_GOTOXY (6, 2) ; 
056F:  MOVLW  06
0570:  BCF    03.5
0571:  BSF    03.6
0572:  MOVWF  36
0573:  MOVLW  02
0574:  MOVWF  37
0575:  BCF    03.6
0576:  CALL   2C3
....................          ITOA (CONFIG_FUN, 10, TEMP_CHAR); 
0577:  BSF    03.6
0578:  CLRF   37
0579:  CLRF   36
057A:  CLRF   35
057B:  BCF    03.6
057C:  MOVF   38,W
057D:  BSF    03.6
057E:  MOVWF  34
057F:  MOVLW  0A
0580:  MOVWF  38
0581:  CLRF   3A
0582:  MOVLW  6E
0583:  MOVWF  39
0584:  BCF    03.6
0585:  CALL   3DD
....................          DELAY_MS (10); 
0586:  MOVLW  0A
0587:  BSF    03.6
0588:  MOVWF  36
0589:  BCF    03.6
058A:  CALL   139
....................          PRINTF (LCD_PUTC, TEMP_CHAR); 
058B:  MOVLW  6E
058C:  MOVWF  04
058D:  BCF    03.7
058E:  CALL   4FD
....................  
....................          SWITCH (CONFIG_FUN) 
058F:  MOVF   38,W
0590:  BTFSC  03.2
0591:  GOTO   596
0592:  XORLW  01
0593:  BTFSC  03.2
0594:  GOTO   59E
0595:  GOTO   5A5
....................          { 
....................             CASE 0: 
....................             PRINTF (LCD_PUTC, " - ID-NODE      "); 
0596:  MOVLW  B4
0597:  BSF    03.6
0598:  MOVWF  0D
0599:  MOVLW  00
059A:  MOVWF  0F
059B:  BCF    03.6
059C:  CALL   311
....................             BREAK; 
059D:  GOTO   5A5
....................  
....................             CASE 1: 
....................             PRINTF (LCD_PUTC, " - ID-GW       "); 
059E:  MOVLW  BD
059F:  BSF    03.6
05A0:  MOVWF  0D
05A1:  MOVLW  00
05A2:  MOVWF  0F
05A3:  BCF    03.6
05A4:  CALL   311
....................             BREAK;             
....................          } 
....................       } 
05A5:  GOTO   559
....................    } 
....................  
....................    ////// 
....................    IF (!TT_CONFIG_DONE) 
05A6:  BTFSC  4D.3
05A7:  GOTO   74D
....................    { 
....................       SELLECT_FUN (); 
....................    } 
*
074D:  BSF    0A.3
074E:  BCF    0A.4
074F:  GOTO   650 (RETURN)
.................... } 
.................... VOID XULY_IDNODE_NHAP(){ 
....................    //*TEMP_CHAR3 = "\0"; 
....................    *ID_NODE_CHAR = "\0"; 
*
0899:  CLRF   7A
089A:  MOVLW  4E
089B:  BCF    03.5
089C:  BSF    03.6
089D:  MOVWF  33
089E:  MOVF   7A,W
089F:  MOVWF  34
08A0:  MOVF   33,W
08A1:  MOVWF  04
08A2:  BCF    03.7
08A3:  BTFSC  34.0
08A4:  BSF    03.7
08A5:  CLRF   00
....................    FOR (int j = 0; j < 4; j++) 
08A6:  CLRF   32
08A7:  MOVF   32,W
08A8:  SUBLW  03
08A9:  BTFSS  03.0
08AA:  GOTO   0D4
....................    { 
....................       ITOA (ID_NODE[j], 10, TEMP_CHAR); 
08AB:  MOVLW  43
08AC:  ADDWF  32,W
08AD:  MOVWF  04
08AE:  BCF    03.7
08AF:  MOVF   00,W
08B0:  MOVWF  33
08B1:  CLRF   37
08B2:  CLRF   36
08B3:  CLRF   35
08B4:  MOVF   33,W
08B5:  MOVWF  34
08B6:  MOVLW  0A
08B7:  MOVWF  38
08B8:  CLRF   3A
08B9:  MOVLW  6E
08BA:  MOVWF  39
08BB:  BCF    0A.3
08BC:  BCF    03.6
08BD:  CALL   3DD
08BE:  BSF    0A.3
....................       DELAY_MS (1); 
08BF:  MOVLW  01
08C0:  BSF    03.6
08C1:  MOVWF  36
08C2:  BCF    0A.3
08C3:  BCF    03.6
08C4:  CALL   139
08C5:  BSF    0A.3
....................       STRCAT (ID_NODE_CHAR, TEMP_CHAR); 
08C6:  BSF    03.6
08C7:  CLRF   34
08C8:  MOVLW  4E
08C9:  MOVWF  33
08CA:  CLRF   36
08CB:  MOVLW  6E
08CC:  MOVWF  35
08CD:  BCF    0A.3
08CE:  BCF    03.6
08CF:  CALL   750
08D0:  BSF    0A.3
08D1:  BSF    03.6
08D2:  INCF   32,F
08D3:  GOTO   0A7
....................    }   
....................    //ID_NODE_CHAR = TEMP_CHAR3;    
....................    //STRCPY(ID_NODE_CHAR,TEMP_CHAR3); 
....................    //strcpy 
.................... } 
.................... VOID XULY_IDGW_NHAP(){ 
....................  
....................    *ID_GATEWAY_CHAR = "\0"; 
*
0859:  CLRF   7A
085A:  MOVLW  55
085B:  BCF    03.5
085C:  BSF    03.6
085D:  MOVWF  33
085E:  MOVF   7A,W
085F:  MOVWF  34
0860:  MOVF   33,W
0861:  MOVWF  04
0862:  BCF    03.7
0863:  BTFSC  34.0
0864:  BSF    03.7
0865:  CLRF   00
....................    FOR (int j = 0; j < 6; j++) 
0866:  CLRF   32
0867:  MOVF   32,W
0868:  SUBLW  05
0869:  BTFSS  03.0
086A:  GOTO   094
....................    { 
....................       ITOA (ID_GATEWAY[j], 10, TEMP_CHAR); 
086B:  MOVLW  3D
086C:  ADDWF  32,W
086D:  MOVWF  04
086E:  BCF    03.7
086F:  MOVF   00,W
0870:  MOVWF  33
0871:  CLRF   37
0872:  CLRF   36
0873:  CLRF   35
0874:  MOVF   33,W
0875:  MOVWF  34
0876:  MOVLW  0A
0877:  MOVWF  38
0878:  CLRF   3A
0879:  MOVLW  6E
087A:  MOVWF  39
087B:  BCF    0A.3
087C:  BCF    03.6
087D:  CALL   3DD
087E:  BSF    0A.3
....................       DELAY_MS (1); 
087F:  MOVLW  01
0880:  BSF    03.6
0881:  MOVWF  36
0882:  BCF    0A.3
0883:  BCF    03.6
0884:  CALL   139
0885:  BSF    0A.3
....................       STRCAT (ID_GATEWAY_CHAR, TEMP_CHAR); 
0886:  BSF    03.6
0887:  CLRF   34
0888:  MOVLW  55
0889:  MOVWF  33
088A:  CLRF   36
088B:  MOVLW  6E
088C:  MOVWF  35
088D:  BCF    0A.3
088E:  BCF    03.6
088F:  CALL   750
0890:  BSF    0A.3
0891:  BSF    03.6
0892:  INCF   32,F
0893:  GOTO   067
....................    }   
.................... } 
....................  
....................  
.................... VOID CONFIG_DONE() 
.................... { 
....................    TT_FUN = 0; 
*
0800:  BCF    4D.4
....................    TT_STT = 0; 
0801:  BCF    4D.5
....................    CHAR *PACKAGE_CONFIG[]={"*", "LENGHT","C_F", "ID_GW1234" ,"ID_NODE","#"}; 
0802:  MOVLW  2A
0803:  BSF    03.6
0804:  MOVWF  10
0805:  CLRF   11
0806:  MOVLW  4C
0807:  MOVWF  12
0808:  MOVLW  45
0809:  MOVWF  13
080A:  MOVLW  4E
080B:  MOVWF  14
080C:  MOVLW  47
080D:  MOVWF  15
080E:  MOVLW  48
080F:  MOVWF  16
0810:  MOVLW  54
0811:  MOVWF  17
0812:  CLRF   18
0813:  MOVLW  43
0814:  MOVWF  19
0815:  MOVLW  5F
0816:  MOVWF  1A
0817:  MOVLW  46
0818:  MOVWF  1B
0819:  CLRF   1C
081A:  MOVLW  49
081B:  MOVWF  1D
081C:  MOVLW  44
081D:  MOVWF  1E
081E:  MOVLW  5F
081F:  MOVWF  1F
0820:  MOVLW  47
0821:  MOVWF  20
0822:  MOVLW  57
0823:  MOVWF  21
0824:  MOVLW  31
0825:  MOVWF  22
0826:  MOVLW  32
0827:  MOVWF  23
0828:  MOVLW  33
0829:  MOVWF  24
082A:  MOVLW  34
082B:  MOVWF  25
082C:  CLRF   26
082D:  MOVLW  49
082E:  MOVWF  27
082F:  MOVLW  44
0830:  MOVWF  28
0831:  MOVLW  5F
0832:  MOVWF  29
0833:  MOVLW  4E
0834:  MOVWF  2A
0835:  MOVLW  4F
0836:  MOVWF  2B
0837:  MOVLW  44
0838:  MOVWF  2C
0839:  MOVLW  45
083A:  MOVWF  2D
083B:  CLRF   2E
083C:  MOVLW  23
083D:  MOVWF  2F
083E:  CLRF   30
083F:  MOVLW  01
0840:  BSF    03.5
0841:  BCF    03.6
0842:  MOVWF  4E
0843:  MOVLW  10
0844:  MOVWF  4D
0845:  MOVLW  01
0846:  MOVWF  50
0847:  MOVLW  12
0848:  MOVWF  4F
0849:  MOVLW  01
084A:  MOVWF  52
084B:  MOVLW  19
084C:  MOVWF  51
084D:  MOVLW  01
084E:  MOVWF  54
084F:  MOVLW  1D
0850:  MOVWF  53
0851:  MOVLW  01
0852:  MOVWF  56
0853:  MOVLW  27
0854:  MOVWF  55
0855:  MOVLW  01
0856:  MOVWF  58
0857:  MOVLW  2F
0858:  MOVWF  57
....................    XULY_IDGW_NHAP(); 
....................    PACKAGE_CONFIG[3] = ID_GATEWAY_CHAR; 
*
0894:  BSF    03.5
0895:  BCF    03.6
0896:  CLRF   54
0897:  MOVLW  55
0898:  MOVWF  53
....................     
....................    XULY_IDNODE_NHAP(); 
....................    PACKAGE_CONFIG[4] = ID_NODE_CHAR;          
*
08D4:  BSF    03.5
08D5:  BCF    03.6
08D6:  CLRF   56
08D7:  MOVLW  4E
08D8:  MOVWF  55
....................    LEN_PACKAGES = 0; 
08D9:  BCF    03.5
08DA:  CLRF   47
....................    PACKAGE_CONFIG[1] = "12"; //DO DAI CUA LENGHT CO DO DAI = 2 
08DB:  MOVLW  31
08DC:  BSF    03.5
08DD:  MOVWF  4F
08DE:  MOVLW  32
08DF:  MOVWF  50
....................    FOR (int J = 0; J < 6; J++) 
08E0:  CLRF   59
08E1:  MOVF   59,W
08E2:  SUBLW  05
08E3:  BTFSS  03.0
08E4:  GOTO   103
....................    { 
....................       LEN_PACKAGES += strlen(PACKAGE_CONFIG[J]); 
08E5:  BCF    03.0
08E6:  RLF    59,W
08E7:  ADDLW  CD
08E8:  MOVWF  04
08E9:  BCF    03.7
08EA:  INCF   04,F
08EB:  MOVF   00,W
08EC:  MOVWF  5B
08ED:  DECF   04,F
08EE:  MOVF   00,W
08EF:  MOVWF  5A
08F0:  MOVF   5B,W
08F1:  BCF    03.5
08F2:  BSF    03.6
08F3:  MOVWF  35
08F4:  BSF    03.5
08F5:  BCF    03.6
08F6:  MOVF   5A,W
08F7:  BCF    03.5
08F8:  BSF    03.6
08F9:  MOVWF  34
08FA:  BCF    0A.3
08FB:  BCF    03.6
08FC:  CALL   78E
08FD:  BSF    0A.3
08FE:  MOVF   78,W
08FF:  ADDWF  47,F
0900:  BSF    03.5
0901:  INCF   59,F
0902:  GOTO   0E1
....................    }    
....................    LEN_PACKAGES = LEN_PACKAGES+5; //5 @ 
0903:  MOVLW  05
0904:  BCF    03.5
0905:  ADDWF  47,F
....................    ITOA (LEN_PACKAGES, 10, TEMP_CHAR); 
0906:  BSF    03.6
0907:  CLRF   37
0908:  CLRF   36
0909:  CLRF   35
090A:  BCF    03.6
090B:  MOVF   47,W
090C:  BSF    03.6
090D:  MOVWF  34
090E:  MOVLW  0A
090F:  MOVWF  38
0910:  CLRF   3A
0911:  MOVLW  6E
0912:  MOVWF  39
0913:  BCF    0A.3
0914:  BCF    03.6
0915:  CALL   3DD
0916:  BSF    0A.3
....................    PACKAGE_CONFIG[1] = TEMP_CHAR; 
0917:  BSF    03.5
0918:  CLRF   50
0919:  MOVLW  6E
091A:  MOVWF  4F
....................     
....................    FOR ( J = 0; J < 6; J++) 
091B:  CLRF   59
091C:  MOVF   59,W
091D:  SUBLW  05
091E:  BTFSS  03.0
091F:  GOTO   157
....................    { 
....................       PRINTF (PACKAGE_CONFIG[J]); 
0920:  BCF    03.0
0921:  RLF    59,W
0922:  ADDLW  CD
0923:  MOVWF  04
0924:  BCF    03.7
0925:  INCF   04,F
0926:  MOVF   00,W
0927:  MOVWF  5B
0928:  DECF   04,F
0929:  MOVF   00,W
092A:  MOVWF  5A
092B:  MOVF   5A,W
092C:  MOVWF  04
092D:  BCF    03.7
092E:  BTFSC  5B.0
092F:  BSF    03.7
....................       PRINTF ("@"); 
*
094F:  MOVLW  40
0950:  BCF    03.5
0951:  BTFSS  0C.4
0952:  GOTO   151
0953:  MOVWF  19
0954:  BSF    03.5
0955:  INCF   59,F
0956:  GOTO   11C
....................    } 
....................  
....................  
....................    LCD_GOTOXY (1, 1) ; 
0957:  MOVLW  01
0958:  BCF    03.5
0959:  BSF    03.6
095A:  MOVWF  36
095B:  MOVWF  37
095C:  BCF    0A.3
095D:  BCF    03.6
095E:  CALL   2C3
095F:  BSF    0A.3
....................    DELAY_MS (10); 
0960:  MOVLW  0A
0961:  BSF    03.6
0962:  MOVWF  36
0963:  BCF    0A.3
0964:  BCF    03.6
0965:  CALL   139
0966:  BSF    0A.3
....................    PRINTF (LCD_PUTC, "WAITING ....        ") ; 
0967:  MOVLW  C5
0968:  BSF    03.6
0969:  MOVWF  0D
096A:  MOVLW  00
096B:  MOVWF  0F
096C:  BCF    0A.3
096D:  BCF    03.6
096E:  CALL   311
096F:  BSF    0A.3
....................    LCD_GOTOXY (1, 1) ; 
0970:  MOVLW  01
0971:  BSF    03.6
0972:  MOVWF  36
0973:  MOVWF  37
0974:  BCF    0A.3
0975:  BCF    03.6
0976:  CALL   2C3
0977:  BSF    0A.3
....................    DELAY_MS (10); 
0978:  MOVLW  0A
0979:  BSF    03.6
097A:  MOVWF  36
097B:  BCF    0A.3
097C:  BCF    03.6
097D:  CALL   139
097E:  BSF    0A.3
....................    PRINTF (LCD_PUTC, "WAITING ....        ") ;    
097F:  MOVLW  D0
0980:  BSF    03.6
0981:  MOVWF  0D
0982:  MOVLW  00
0983:  MOVWF  0F
0984:  BCF    0A.3
0985:  BCF    03.6
0986:  CALL   311
0987:  BSF    0A.3
....................    TT_CONFIG_DONE = 0; 
0988:  BCF    4D.3
0989:  BSF    0A.3
098A:  BCF    0A.4
098B:  GOTO   655 (RETURN)
.................... } 
....................  
.................... //--------------------------------------------------------------------// 
....................  
....................  
....................  
....................  
....................  
.................... VOID QUET_PHIM() 
*
00DB:  BSF    03.6
00DC:  CLRF   59
.................... { 
....................    INT BDT = 0; 
....................  
....................    WHILE (!INPUT (BT1_PIN)) //NEU NUT BAM DUOC BAM 
00DD:  BSF    03.5
00DE:  BCF    03.6
00DF:  BSF    06.1
00E0:  BCF    03.5
00E1:  BTFSC  06.1
00E2:  GOTO   0F6
....................    { 
....................       IF (TMR1IF) 
00E3:  BTFSS  0C.0
00E4:  GOTO   0F3
....................       { 
....................          OUTPUT_TOGGLE (PIN_D2); 
00E5:  BSF    03.5
00E6:  BCF    08.2
00E7:  MOVLW  04
00E8:  BCF    03.5
00E9:  XORWF  08,F
....................          TMR1IF = 0; SET_TIMER1 (3036); BDT++; 
00EA:  BCF    0C.0
00EB:  CLRF   0E
00EC:  MOVLW  0B
00ED:  MOVWF  0F
00EE:  MOVLW  DC
00EF:  MOVWF  0E
00F0:  BSF    03.6
00F1:  INCF   59,F
00F2:  BCF    03.6
....................       } 
00F3:  BSF    03.6
00F4:  GOTO   0DD
00F5:  BCF    03.6
....................    } 
....................  
....................    IF (BDT > 20) 
00F6:  BSF    03.6
00F7:  MOVF   59,W
00F8:  SUBLW  14
00F9:  BTFSC  03.0
00FA:  GOTO   104
....................    { 
....................       //CONFIG NODE 
....................       TT_CONFIG = ~TT_CONFIG; // VAO TRANG THAI CONFIG 
00FB:  MOVLW  02
00FC:  BCF    03.6
00FD:  XORWF  4D,F
....................       TT_CONTROL = ~TT_CONTROL; 
00FE:  MOVLW  04
00FF:  XORWF  4D,F
....................       //CONFIG_DONE (); 
....................       TT_CONFIG_DONE = 1; 
0100:  BSF    4D.3
....................       TT_FUN = 0; 
0101:  BCF    4D.4
....................    } 
0102:  GOTO   108
0103:  BSF    03.6
....................  
....................    ELSE 
....................    { 
....................       BUTT_OKE (); //OKE 
....................    } 
.................... } 
....................  
.................... #INT_EXT 
....................  
....................  VOID NGAT_NGOAI () 
....................  { 
....................     QUET_PHIM (); 
....................  } 
....................  
*
0108:  BCF    0B.1
0109:  BCF    0A.3
010A:  BCF    0A.4
010B:  GOTO   031
....................  #INT_RDA 
....................  VOID NGAT () 
....................  { 
....................     KYTUCHAR[VT] = GETCH (); 
010C:  MOVLW  A0
010D:  ADDWF  39,W
010E:  MOVWF  04
010F:  BCF    03.7
0110:  BTFSS  0C.5
0111:  GOTO   110
0112:  MOVF   1A,W
0113:  MOVWF  00
....................  
....................     IF (KYTUCHAR[VT] == '.') 
0114:  MOVLW  A0
0115:  ADDWF  39,W
0116:  MOVWF  04
0117:  BCF    03.7
0118:  MOVF   00,W
0119:  SUBLW  2E
011A:  BTFSS  03.2
011B:  GOTO   124
....................     { 
....................        KYTUCHAR[VT] = '\0'; 
011C:  MOVLW  A0
011D:  ADDWF  39,W
011E:  MOVWF  04
011F:  BCF    03.7
0120:  CLRF   00
....................        VT = 0; 
0121:  CLRF   39
....................        TTNHAN = 1; 
0122:  BSF    4D.0
....................     } 
0123:  GOTO   125
....................  
....................     ELSE 
....................     VT++; 
0124:  INCF   39,F
0125:  BCF    0C.5
0126:  BCF    0A.3
0127:  BCF    0A.4
0128:  GOTO   031
....................  } 
....................  
....................  VOID XUATLCD ( CHAR CHUOI_PRINT[]) 
....................  { 
....................     LCD_GOTOXY (1, 1) ; 
....................     DELAY_MS (10); 
....................     PRINTF (LCD_PUTC, CHUOI_PRINT); 
....................     DELAY_MS (1); 
....................  } 
....................  VOID XACNHANCONFIG() 
....................  { 
....................    OUTPUT_D (0XFF);     
*
0CEC:  BSF    03.5
0CED:  CLRF   08
0CEE:  MOVLW  FF
0CEF:  BCF    03.5
0CF0:  MOVWF  08
....................    DELAY_MS(500); 
0CF1:  MOVLW  02
0CF2:  BSF    03.5
0CF3:  MOVWF  53
0CF4:  MOVLW  FA
0CF5:  BCF    03.5
0CF6:  BSF    03.6
0CF7:  MOVWF  36
0CF8:  BCF    0A.3
0CF9:  BCF    03.6
0CFA:  CALL   139
0CFB:  BSF    0A.3
0CFC:  BSF    03.5
0CFD:  DECFSZ 53,F
0CFE:  GOTO   4F4
....................    LCD_GOTOXY (1, 1) ; 
0CFF:  MOVLW  01
0D00:  BCF    03.5
0D01:  BSF    03.6
0D02:  MOVWF  36
0D03:  MOVWF  37
0D04:  BCF    0A.3
0D05:  BCF    03.6
0D06:  CALL   2C3
0D07:  BSF    0A.3
....................    DELAY_MS (10); 
0D08:  MOVLW  0A
0D09:  BSF    03.6
0D0A:  MOVWF  36
0D0B:  BCF    0A.3
0D0C:  BCF    03.6
0D0D:  CALL   139
0D0E:  BSF    0A.3
....................    PRINTF (LCD_PUTC,KYTUCHAR2); 
0D0F:  MOVLW  BE
0D10:  MOVWF  04
0D11:  BCF    03.7
0D12:  BCF    0A.3
0D13:  CALL   4FD
0D14:  BSF    0A.3
....................    PRINTF (LCD_PUTC,"            "); 
0D15:  MOVLW  29
0D16:  BSF    03.6
0D17:  MOVWF  0D
0D18:  MOVLW  01
0D19:  MOVWF  0F
0D1A:  BCF    0A.3
0D1B:  BCF    03.6
0D1C:  CALL   311
0D1D:  BSF    0A.3
....................    DELAY_MS (1);  
0D1E:  MOVLW  01
0D1F:  BSF    03.6
0D20:  MOVWF  36
0D21:  BCF    0A.3
0D22:  BCF    03.6
0D23:  CALL   139
0D24:  BSF    0A.3
....................    OUTPUT_D (0XFF);   
0D25:  BSF    03.5
0D26:  CLRF   08
0D27:  MOVLW  FF
0D28:  BCF    03.5
0D29:  MOVWF  08
....................    LCD_GOTOXY (1, 2) ; 
0D2A:  MOVLW  01
0D2B:  BSF    03.6
0D2C:  MOVWF  36
0D2D:  MOVLW  02
0D2E:  MOVWF  37
0D2F:  BCF    0A.3
0D30:  BCF    03.6
0D31:  CALL   2C3
0D32:  BSF    0A.3
....................    DELAY_MS (10); 
0D33:  MOVLW  0A
0D34:  BSF    03.6
0D35:  MOVWF  36
0D36:  BCF    0A.3
0D37:  BCF    03.6
0D38:  CALL   139
0D39:  BSF    0A.3
....................    PRINTF (LCD_PUTC,"                ");    
0D3A:  MOVLW  30
0D3B:  BSF    03.6
0D3C:  MOVWF  0D
0D3D:  MOVLW  01
0D3E:  MOVWF  0F
0D3F:  BCF    0A.3
0D40:  BCF    03.6
0D41:  CALL   311
0D42:  BSF    0A.3
....................    OUTPUT_D (0X00); 
0D43:  BSF    03.5
0D44:  CLRF   08
0D45:  BCF    03.5
0D46:  CLRF   08
....................    DELAY_MS(500); 
0D47:  MOVLW  02
0D48:  BSF    03.5
0D49:  MOVWF  53
0D4A:  MOVLW  FA
0D4B:  BCF    03.5
0D4C:  BSF    03.6
0D4D:  MOVWF  36
0D4E:  BCF    0A.3
0D4F:  BCF    03.6
0D50:  CALL   139
0D51:  BSF    0A.3
0D52:  BSF    03.5
0D53:  DECFSZ 53,F
0D54:  GOTO   54A
....................    OUTPUT_D (0XFF);     
0D55:  CLRF   08
0D56:  MOVLW  FF
0D57:  BCF    03.5
0D58:  MOVWF  08
....................    DELAY_MS(500); 
0D59:  MOVLW  02
0D5A:  BSF    03.5
0D5B:  MOVWF  53
0D5C:  MOVLW  FA
0D5D:  BCF    03.5
0D5E:  BSF    03.6
0D5F:  MOVWF  36
0D60:  BCF    0A.3
0D61:  BCF    03.6
0D62:  CALL   139
0D63:  BSF    0A.3
0D64:  BSF    03.5
0D65:  DECFSZ 53,F
0D66:  GOTO   55C
....................    OUTPUT_D (0X00); 
0D67:  CLRF   08
0D68:  BCF    03.5
0D69:  CLRF   08
....................     
....................  }  
....................  VOID DIEUKHIENTHIETBI() 
....................  { 
....................   
....................  } 
....................  
....................  VOID XU_LY_UART() 
*
0BC5:  MOVLW  2A
0BC6:  BSF    03.5
0BC7:  MOVWF  4D
....................  { 
....................      //ID_NODE_NHAN = KYTU[1] - 48; 
....................     //ID_DEVICE_NHAN = KYTU[2] - 48 + 64; 
....................     //TT_DEVICE_NHAN = KYTU[3] - 48; // - 48 ASCII -- > S?. + 64 -- > PORT_D (D0 = 64)                
....................  
....................     /*TINH DO DAI*/ 
....................     CHAR CH = '*'; 
....................     CHAR *RET; 
....................     *ID_NODE_NHAN = '\0'; 
0BC8:  CLRF   7A
0BC9:  MOVLW  5E
0BCA:  MOVWF  04
0BCB:  BCF    03.7
0BCC:  BTFSC  7A.0
0BCD:  BSF    03.7
0BCE:  CLRF   00
....................     *ID_GW_NHAN = '\0'; 
0BCF:  CLRF   7A
0BD0:  MOVLW  65
0BD1:  MOVWF  04
0BD2:  BCF    03.7
0BD3:  BTFSC  7A.0
0BD4:  BSF    03.7
0BD5:  CLRF   00
....................     KYTUCHAR2 = ""; 
0BD6:  CLRF   53
0BD7:  CLRF   54
0BD8:  MOVLW  BE
0BD9:  MOVWF  04
0BDA:  BCF    03.7
0BDB:  MOVF   53,W
0BDC:  ADDWF  04,F
0BDD:  MOVF   54,W
0BDE:  BCF    0A.3
0BDF:  BCF    03.5
0BE0:  CALL   05E
0BE1:  BSF    0A.3
0BE2:  MOVWF  00
0BE3:  IORLW  00
0BE4:  BTFSC  03.2
0BE5:  GOTO   3EB
0BE6:  BSF    03.5
0BE7:  INCF   54,F
0BE8:  INCF   53,F
0BE9:  GOTO   3D8
0BEA:  BCF    03.5
....................     UNSIGNED INT8 LEN_RET;     
....................     RET = STRCHR(KYTUCHAR,CH); 
0BEB:  BSF    03.5
0BEC:  CLRF   54
0BED:  MOVLW  A0
0BEE:  MOVWF  53
0BEF:  MOVF   4D,W
0BF0:  MOVWF  55
*
0C12:  MOVF   79,W
0C13:  MOVWF  4F
0C14:  MOVF   78,W
0C15:  MOVWF  4E
....................     LEN_RET = STRLEN(RET);  
0C16:  MOVF   4F,W
0C17:  BCF    03.5
0C18:  BSF    03.6
0C19:  MOVWF  35
0C1A:  BSF    03.5
0C1B:  BCF    03.6
0C1C:  MOVF   4E,W
0C1D:  BCF    03.5
0C1E:  BSF    03.6
0C1F:  MOVWF  34
0C20:  BCF    0A.3
0C21:  BCF    03.6
0C22:  CALL   78E
0C23:  BSF    0A.3
0C24:  MOVF   78,W
0C25:  BSF    03.5
0C26:  MOVWF  50
....................     /* LAY TOKEN DAU TIEN */     
....................     KYTU = 0; 
0C27:  BCF    03.5
0C28:  CLRF   3A
....................     TEMP_CHAR = "#"; 
0C29:  BSF    03.5
0C2A:  CLRF   53
0C2B:  CLRF   54
0C2C:  MOVLW  6E
0C2D:  MOVWF  04
0C2E:  BCF    03.7
0C2F:  MOVF   53,W
0C30:  ADDWF  04,F
0C31:  MOVF   54,W
0C32:  BCF    0A.3
0C33:  BCF    03.5
0C34:  CALL   063
0C35:  BSF    0A.3
0C36:  MOVWF  00
0C37:  IORLW  00
0C38:  BTFSC  03.2
0C39:  GOTO   43F
0C3A:  BSF    03.5
0C3B:  INCF   54,F
0C3C:  INCF   53,F
0C3D:  GOTO   42C
0C3E:  BCF    03.5
....................     CHAR * TOKEN; 
....................     TOKEN = STRTOK (KYTUCHAR, TEMP_CHAR);                 
0C3F:  BSF    03.5
0C40:  CLRF   54
0C41:  MOVLW  A0
0C42:  MOVWF  53
0C43:  CLRF   56
0C44:  MOVLW  6E
0C45:  MOVWF  55
0C46:  BCF    03.5
0C47:  CALL   18C
0C48:  MOVF   79,W
0C49:  BSF    03.5
0C4A:  MOVWF  52
0C4B:  MOVF   78,W
0C4C:  MOVWF  51
....................     /* DUYET QUA CAC TOKEN CON LAI */                 
....................     WHILE (TOKEN != NULL) 
0C4D:  MOVF   51,F
0C4E:  BTFSS  03.2
0C4F:  GOTO   453
0C50:  MOVF   52,F
0C51:  BTFSC  03.2
0C52:  GOTO   4BE
....................     {                 
....................        SWITCH(KYTU) 
0C53:  BCF    03.5
0C54:  MOVF   3A,W
0C55:  ADDLW  FA
0C56:  BTFSC  03.0
0C57:  GOTO   4AD
0C58:  ADDLW  06
0C59:  GOTO   576
....................        { 
....................          CASE 0: 
....................          BREAK; 
0C5A:  GOTO   4AD
....................          CASE 1:  
....................          STRCAT (ID_GW_NHAN, TOKEN); 
0C5B:  BSF    03.6
0C5C:  CLRF   34
0C5D:  MOVLW  65
0C5E:  MOVWF  33
0C5F:  BSF    03.5
0C60:  BCF    03.6
0C61:  MOVF   52,W
0C62:  BCF    03.5
0C63:  BSF    03.6
0C64:  MOVWF  36
0C65:  BSF    03.5
0C66:  BCF    03.6
0C67:  MOVF   51,W
0C68:  BCF    03.5
0C69:  BSF    03.6
0C6A:  MOVWF  35
0C6B:  BCF    0A.3
0C6C:  BCF    03.6
0C6D:  CALL   750
0C6E:  BSF    0A.3
....................          BREAK;                      
0C6F:  GOTO   4AD
....................          CASE 2: 
....................          STRCAT (ID_NODE_NHAN, TOKEN); 
0C70:  BSF    03.6
0C71:  CLRF   34
0C72:  MOVLW  5E
0C73:  MOVWF  33
0C74:  BSF    03.5
0C75:  BCF    03.6
0C76:  MOVF   52,W
0C77:  BCF    03.5
0C78:  BSF    03.6
0C79:  MOVWF  36
0C7A:  BSF    03.5
0C7B:  BCF    03.6
0C7C:  MOVF   51,W
0C7D:  BCF    03.5
0C7E:  BSF    03.6
0C7F:  MOVWF  35
0C80:  BCF    0A.3
0C81:  BCF    03.6
0C82:  CALL   750
0C83:  BSF    0A.3
....................          BREAK;       
0C84:  GOTO   4AD
....................          CASE 3: 
....................          LENHDIEUKHIEN =  ATOI(TOKEN);                  
0C85:  BSF    03.5
0C86:  MOVF   52,W
0C87:  MOVWF  54
0C88:  MOVF   51,W
0C89:  MOVWF  53
0C8A:  BCF    03.5
0C8B:  CALL   27D
0C8C:  MOVF   78,W
0C8D:  MOVWF  48
....................          BREAK;     
0C8E:  GOTO   4AD
....................          CASE 4: 
....................          DODAI_DATA_NHAN =  ATOI(TOKEN);                  
0C8F:  BSF    03.5
0C90:  MOVF   52,W
0C91:  MOVWF  54
0C92:  MOVF   51,W
0C93:  MOVWF  53
0C94:  BCF    03.5
0C95:  CALL   27D
0C96:  MOVF   78,W
0C97:  MOVWF  49
....................          BREAK;   
0C98:  GOTO   4AD
....................          CASE 5:   
....................          STRCAT (KYTUCHAR2, TOKEN); 
0C99:  BSF    03.6
0C9A:  CLRF   34
0C9B:  MOVLW  BE
0C9C:  MOVWF  33
0C9D:  BSF    03.5
0C9E:  BCF    03.6
0C9F:  MOVF   52,W
0CA0:  BCF    03.5
0CA1:  BSF    03.6
0CA2:  MOVWF  36
0CA3:  BSF    03.5
0CA4:  BCF    03.6
0CA5:  MOVF   51,W
0CA6:  BCF    03.5
0CA7:  BSF    03.6
0CA8:  MOVWF  35
0CA9:  BCF    0A.3
0CAA:  BCF    03.6
0CAB:  CALL   750
0CAC:  BSF    0A.3
....................          BREAK;          
....................        }          
....................       TOKEN = STRTOK(NULL, TEMP_CHAR); 
0CAD:  BSF    03.5
0CAE:  CLRF   54
0CAF:  CLRF   53
0CB0:  CLRF   56
0CB1:  MOVLW  6E
0CB2:  MOVWF  55
0CB3:  BCF    03.5
0CB4:  CALL   18C
0CB5:  MOVF   79,W
0CB6:  BSF    03.5
0CB7:  MOVWF  52
0CB8:  MOVF   78,W
0CB9:  MOVWF  51
....................       KYTU++;         
0CBA:  BCF    03.5
0CBB:  INCF   3A,F
0CBC:  BSF    03.5
0CBD:  GOTO   44D
....................     }               
....................       /* SO SANH ID returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................       SOSANH_IDGW = STRCMP(ID_GW_NHAN,ID_GATEWAY_CHAR);       
0CBE:  CLRF   54
0CBF:  MOVLW  65
0CC0:  MOVWF  53
0CC1:  CLRF   56
0CC2:  MOVLW  55
0CC3:  MOVWF  55
0CC4:  BCF    03.5
0CC5:  CALL   37F
0CC6:  MOVF   78,W
0CC7:  MOVWF  4B
....................       SOSANH_IDNODE = STRCMP(ID_NODE_NHAN,ID_NODE_CHAR);     
0CC8:  BSF    03.5
0CC9:  CLRF   54
0CCA:  MOVLW  5E
0CCB:  MOVWF  53
0CCC:  CLRF   56
0CCD:  MOVLW  4E
0CCE:  MOVWF  55
0CCF:  BCF    03.5
0CD0:  CALL   37F
0CD1:  MOVF   78,W
0CD2:  MOVWF  4A
....................     IF ( SOSANH_IDGW == 0 && SOSANH_IDNODE == 0 && LEN_RET == DODAI_DATA_NHAN) 
0CD3:  MOVF   4B,F
0CD4:  BTFSS  03.2
0CD5:  GOTO   56C
0CD6:  MOVF   4A,F
0CD7:  BTFSS  03.2
0CD8:  GOTO   56C
0CD9:  MOVF   49,W
0CDA:  BSF    03.5
0CDB:  SUBWF  50,W
0CDC:  BTFSC  03.2
0CDD:  GOTO   4E0
0CDE:  BCF    03.5
0CDF:  GOTO   56C
....................     {                       
....................       SWITCH(LENHDIEUKHIEN) 
0CE0:  BCF    03.5
0CE1:  MOVF   48,W
0CE2:  BTFSC  03.2
0CE3:  GOTO   4EB
0CE4:  XORLW  01
0CE5:  BTFSC  03.2
0CE6:  GOTO   4EC
0CE7:  XORLW  03
0CE8:  BTFSC  03.2
0CE9:  GOTO   56B
0CEA:  GOTO   56B
....................        { 
....................          CASE 0: 
....................          BREAK; 
0CEB:  GOTO   56B
....................          CASE 1: 
....................          XACNHANCONFIG(); 
....................          BREAK;                      
*
0D6A:  GOTO   56B
....................          CASE 2: 
....................          //DIEUKHIENTHIETBI(); 
....................          BREAK;               
....................        }  
....................     } 
0D6B:  GOTO   573
....................     ELSE{ 
....................       DELAY_MS (10); 
0D6C:  MOVLW  0A
0D6D:  BSF    03.6
0D6E:  MOVWF  36
0D6F:  BCF    0A.3
0D70:  BCF    03.6
0D71:  CALL   139
0D72:  BSF    0A.3
....................       /*DATA RCV SAI ID NODE, ID GW HOAC LA SAI DO DAI*/ 
....................     } 
0D73:  BSF    0A.3
0D74:  BCF    0A.4
0D75:  GOTO   65F (RETURN)
....................      
....................  } 
....................  
....................  INT ADC_READ (INT KENH) 
....................  { 
....................     SET_ADC_CHANNEL (KENH); 
....................     KQADC = 0; 
....................     FOR (INT I = 0; I < 100; I++) 
....................     { 
....................        KQADC = KQADC + READ_ADC () ; 
....................        DELAY_MS (1); 
....................     } 
....................  
....................     KQADC = KQADC / (100 * 2.046); 
....................     RETURN KQADC; 
....................  } 
....................  
....................  VOID CHUONG_TRINH_CON () 
....................  { 
....................     FOR (INT I = 0; I <= 30; I++) 
*
07AE:  BSF    03.5
07AF:  CLRF   4D
07B0:  MOVF   4D,W
07B1:  SUBLW  1E
07B2:  BTFSS  03.0
07B3:  GOTO   7C0
....................     { 
....................        OUTPUT_TOGGLE (PIN_D1); 
07B4:  BCF    08.1
07B5:  MOVLW  02
07B6:  BCF    03.5
07B7:  XORWF  08,F
....................        DELAY_MS (100); 
07B8:  MOVLW  64
07B9:  BSF    03.6
07BA:  MOVWF  36
07BB:  BCF    03.6
07BC:  CALL   139
07BD:  BSF    03.5
07BE:  INCF   4D,F
07BF:  GOTO   7B0
....................     } 
07C0:  BCF    03.5
07C1:  BSF    0A.3
07C2:  BCF    0A.4
07C3:  GOTO   65A (RETURN)
....................  } 
....................  
....................  VOID MAIN  () 
*
0D80:  MOVF   03,W
0D81:  ANDLW  1F
0D82:  MOVWF  03
0D83:  BSF    03.5
0D84:  BSF    03.6
0D85:  BSF    07.3
0D86:  MOVLW  08
0D87:  BCF    03.6
0D88:  MOVWF  19
0D89:  MOVLW  02
0D8A:  MOVWF  1A
0D8B:  MOVLW  A6
0D8C:  MOVWF  18
0D8D:  MOVLW  90
0D8E:  BCF    03.5
0D8F:  MOVWF  18
0D90:  MOVLW  FF
0D91:  MOVWF  31
0D92:  CLRF   38
0D93:  CLRF   39
0D94:  CLRF   3A
0D95:  CLRF   47
0D96:  CLRF   48
0D97:  CLRF   49
0D98:  CLRF   4A
0D99:  CLRF   4B
0D9A:  CLRF   4C
0D9B:  BCF    4D.0
0D9C:  BCF    4D.1
0D9D:  BCF    4D.2
0D9E:  BCF    4D.3
0D9F:  BCF    4D.4
0DA0:  BCF    4D.5
0DA1:  BSF    03.5
0DA2:  BSF    03.6
0DA3:  MOVF   09,W
0DA4:  ANDLW  C0
0DA5:  MOVWF  09
0DA6:  BCF    03.6
0DA7:  BCF    1F.4
0DA8:  BCF    1F.5
0DA9:  MOVLW  00
0DAA:  BSF    03.6
0DAB:  MOVWF  08
0DAC:  BCF    03.5
0DAD:  CLRF   07
0DAE:  CLRF   08
0DAF:  CLRF   09
0DB0:  BCF    03.7
....................  { 
....................     SET_TRIS_D (0X00); 
*
0E10:  MOVLW  00
0E11:  BSF    03.5
0E12:  MOVWF  08
....................     SET_TRIS_B (0XFF); 
0E13:  MOVLW  FF
0E14:  MOVWF  06
....................     SET_TRIS_E (0); 
0E15:  BCF    09.0
0E16:  BCF    09.1
0E17:  BCF    09.2
0E18:  BCF    09.3
....................     SET_TRIS_C (0X80); 
0E19:  MOVLW  80
0E1A:  MOVWF  07
0E1B:  BCF    03.5
0E1C:  MOVWF  31
....................     SETUP_ADC (ADC_CLOCK_DIV_8); 
0E1D:  BSF    1F.6
0E1E:  BCF    1F.7
0E1F:  BSF    03.5
0E20:  BSF    1F.7
0E21:  BCF    03.5
0E22:  BSF    1F.0
....................     SETUP_ADC_PORTS (SAN0); 
0E23:  BSF    03.5
0E24:  BSF    03.6
0E25:  MOVF   09,W
0E26:  ANDLW  C0
0E27:  MOVWF  09
0E28:  BCF    03.6
0E29:  BCF    1F.4
0E2A:  BCF    1F.5
0E2B:  MOVLW  01
0E2C:  BSF    03.6
0E2D:  MOVWF  08
....................     ENABLE_INTERRUPTS (INT_TIMER0); 
0E2E:  BCF    03.5
0E2F:  BCF    03.6
0E30:  BSF    0B.5
....................     ENABLE_INTERRUPTS (INT_EXT); //CHO PHEP NGAT NGOAI 
0E31:  BSF    0B.4
....................     ENABLE_INTERRUPTS (INT_EXT_H2L); //NGAT XAY RA KHI CO XUNG TU CAO XUONG THAP 
0E32:  BSF    0B.4
0E33:  BSF    03.5
0E34:  BCF    01.6
....................     ENABLE_INTERRUPTS (INT_RDA); 
0E35:  BSF    0C.5
....................     ENABLE_INTERRUPTS (GLOBAL); 
0E36:  MOVLW  C0
0E37:  BCF    03.5
0E38:  IORWF  0B,F
....................      
....................     SETUP_TIMER_1 (T1_INTERNAL|T1_DIV_BY_8); 
0E39:  MOVLW  35
0E3A:  MOVWF  10
....................     //SET_TIMER1 (0); 
....................     SET_TIMER1 (3036); 
0E3B:  CLRF   0E
0E3C:  MOVLW  0B
0E3D:  MOVWF  0F
0E3E:  MOVLW  DC
0E3F:  MOVWF  0E
....................     TMR1IF = 0; 
0E40:  BCF    0C.0
....................     LCD_INIT (); // KHOI TAO LCD 
0E41:  BCF    0A.3
0E42:  GOTO   253
0E43:  BSF    0A.3
....................  
....................     TT_CONFIG = 0; 
0E44:  BCF    4D.1
....................     TT_CONFIG_DONE = 0; 
0E45:  BCF    4D.3
....................     TT_CONTROL = 1; 
0E46:  BSF    4D.2
....................     OUTPUT_D (0X00); 
0E47:  BSF    03.5
0E48:  CLRF   08
0E49:  BCF    03.5
0E4A:  CLRF   08
....................     TTNHAN = 0; 
0E4B:  BCF    4D.0
....................      
....................     
....................     WHILE (TRUE) 
....................     { 
....................        IF (TT_CONFIG)             {BUTT_FUN (); } // GOI HAM CHON LENH (SWITCH CASE) 
0E4C:  BTFSS  4D.1
0E4D:  GOTO   652
0E4E:  BCF    0A.3
0E4F:  GOTO   533
0E50:  BSF    0A.3
0E51:  GOTO   660
....................        ELSE IF (TT_CONFIG_DONE)   { CONFIG_DONE ();}        
0E52:  BTFSS  4D.3
0E53:  GOTO   656
0E54:  GOTO   000
0E55:  GOTO   660
....................        ELSE 
....................        { 
....................           WHILE (!TT_CONFIG) 
0E56:  BTFSC  4D.1
0E57:  GOTO   660
....................           { 
....................              CHUONG_TRINH_CON ();              
0E58:  BCF    0A.3
0E59:  GOTO   7AE
0E5A:  BSF    0A.3
....................              IF (TTNHAN == 1) 
0E5B:  BTFSS  4D.0
0E5C:  GOTO   65F
....................              { 
....................                 TTNHAN = 0; 
0E5D:  BCF    4D.0
....................                 XU_LY_UART(); 
0E5E:  GOTO   3C5
....................              } 
0E5F:  GOTO   656
....................           } 
....................        } 
0E60:  GOTO   64C
....................     } 
....................  } 
....................  
0E61:  SLEEP

Configuration Fuses:
   Word  1: 2FE2   HS NOWDT PUT MCLR NOPROTECT NOCPD BROWNOUT IESO FCMEN NOLVP NODEBUG
   Word  2: 3FFF   BORV40 NOWRT
