CCS PCM C Compiler, Version 5.015, 5967               03-Nov-21 00:20

               Filename:   E:\DATN_V2\NODE\pic\pic16f887\hellopic.lst

               ROM used:   4930 words (60%)
                           Largest free fragment is 2048
               RAM used:   148 (40%) at main() level
                           263 (71%) worst case
               Stack used: 7 locations (6 in main + 1 for interrupts)
               Stack size: 8

*
0000:  MOVLW  13
0001:  MOVWF  0A
0002:  GOTO   340
0003:  NOP
0004:  MOVWF  7F
0005:  SWAPF  03,W
0006:  CLRF   03
0007:  MOVWF  21
0008:  MOVF   0A,W
0009:  MOVWF  20
000A:  CLRF   0A
000B:  MOVF   04,W
000C:  MOVWF  22
000D:  MOVF   77,W
000E:  MOVWF  23
000F:  MOVF   78,W
0010:  MOVWF  24
0011:  MOVF   79,W
0012:  MOVWF  25
0013:  MOVF   7A,W
0014:  MOVWF  26
0015:  BSF    03.6
0016:  MOVF   0D,W
0017:  BCF    03.6
0018:  MOVWF  27
0019:  BSF    03.6
001A:  MOVF   0F,W
001B:  BCF    03.6
001C:  MOVWF  28
001D:  BSF    03.6
001E:  MOVF   0C,W
001F:  BCF    03.6
0020:  MOVWF  29
0021:  BSF    03.6
0022:  MOVF   0E,W
0023:  BCF    03.6
0024:  MOVWF  2A
0025:  BCF    03.7
0026:  BCF    03.5
0027:  BTFSS  0B.4
0028:  GOTO   02B
0029:  BTFSC  0B.1
002A:  GOTO   052
002B:  MOVLW  8C
002C:  MOVWF  04
002D:  BTFSS  00.5
002E:  GOTO   031
002F:  BTFSC  0C.5
0030:  GOTO   055
0031:  MOVF   22,W
0032:  MOVWF  04
0033:  MOVF   23,W
0034:  MOVWF  77
0035:  MOVF   24,W
0036:  MOVWF  78
0037:  MOVF   25,W
0038:  MOVWF  79
0039:  MOVF   26,W
003A:  MOVWF  7A
003B:  MOVF   27,W
003C:  BSF    03.6
003D:  MOVWF  0D
003E:  BCF    03.6
003F:  MOVF   28,W
0040:  BSF    03.6
0041:  MOVWF  0F
0042:  BCF    03.6
0043:  MOVF   29,W
0044:  BSF    03.6
0045:  MOVWF  0C
0046:  BCF    03.6
0047:  MOVF   2A,W
0048:  BSF    03.6
0049:  MOVWF  0E
004A:  BCF    03.6
004B:  MOVF   20,W
004C:  MOVWF  0A
004D:  SWAPF  21,W
004E:  MOVWF  03
004F:  SWAPF  7F,F
0050:  SWAPF  7F,W
0051:  RETFIE
0052:  BCF    0A.3
0053:  BCF    0A.4
0054:  GOTO   0EF
0055:  BCF    0A.3
0056:  BCF    0A.4
0057:  GOTO   120
....................  
.................... #INCLUDE <thuvien.c> 
.................... #INCLUDE <16F887.H> 
.................... //////////// Standard Header file for the PIC16F887 device //////////////// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2013 Custom Computer Services          //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... #device PIC16F887 
0058:  BCF    0A.0
0059:  BCF    0A.1
005A:  BCF    0A.2
005B:  ADDWF  02,F
005C:  RETLW  30
005D:  RETLW  00
005E:  BCF    0A.0
005F:  BCF    0A.1
0060:  BCF    0A.2
0061:  ADDWF  02,F
0062:  RETLW  5F
0063:  RETLW  00
0064:  BCF    0A.0
0065:  BCF    0A.1
0066:  BCF    0A.2
0067:  ADDWF  02,F
0068:  RETLW  23
0069:  RETLW  00
006A:  BCF    0A.0
006B:  BCF    0A.1
006C:  BCF    0A.2
006D:  ADDWF  02,F
006E:  RETLW  00
006F:  DATA CE,27
0070:  DATA C4,22
0071:  DATA 3A,10
0072:  DATA 00,00
0073:  DATA 30,18
0074:  DATA 30,18
0075:  DATA 20,10
0076:  DATA 20,10
0077:  DATA 20,10
0078:  DATA 20,10
0079:  DATA 20,10
007A:  DATA 00,01
007B:  DATA 20,10
007C:  DATA 20,10
007D:  DATA 20,10
007E:  DATA 5F,10
007F:  DATA 20,10
0080:  DATA 20,10
0081:  DATA 20,10
0082:  DATA 20,10
0083:  DATA 20,10
0084:  DATA 20,10
0085:  DATA 20,00
0086:  DATA 20,10
0087:  DATA 20,10
0088:  DATA 5F,10
0089:  DATA 20,10
008A:  DATA 20,00
008B:  DATA 49,22
008C:  DATA DF,23
008D:  DATA 57,1D
008E:  DATA 00,01
008F:  DATA 30,18
0090:  DATA 30,18
0091:  DATA 30,18
0092:  DATA 20,10
0093:  DATA 20,10
0094:  DATA 20,10
0095:  DATA 20,10
0096:  DATA 00,01
0097:  DATA 20,10
0098:  DATA 20,10
0099:  DATA 20,10
009A:  DATA 5F,10
009B:  DATA 20,10
009C:  DATA 20,10
009D:  DATA 20,10
009E:  DATA 20,10
009F:  DATA 20,10
00A0:  DATA 20,10
00A1:  DATA 20,10
00A2:  DATA 20,00
00A3:  DATA 20,10
00A4:  DATA 20,10
00A5:  DATA 5F,10
00A6:  DATA 20,10
00A7:  DATA 20,10
00A8:  DATA 20,10
00A9:  DATA 20,00
00AA:  DATA C3,27
00AB:  DATA 4E,23
00AC:  DATA C9,23
00AD:  DATA 3A,10
00AE:  DATA 20,10
00AF:  DATA 20,10
00B0:  DATA 20,10
00B1:  DATA 20,00
00B2:  DATA C3,20
00B3:  DATA D3,22
00B4:  DATA 3A,10
00B5:  DATA 20,10
00B6:  DATA 20,10
00B7:  DATA 20,10
00B8:  DATA 20,10
00B9:  DATA 20,00
00BA:  DATA A0,16
00BB:  DATA A0,24
00BC:  DATA C4,16
00BD:  DATA CE,27
00BE:  DATA C4,22
00BF:  DATA 20,10
00C0:  DATA 20,10
00C1:  DATA 20,10
00C2:  DATA 00,01
00C3:  DATA A0,16
00C4:  DATA A0,24
00C5:  DATA C4,16
00C6:  DATA C7,2B
00C7:  DATA 20,10
00C8:  DATA 20,10
00C9:  DATA 20,10
00CA:  DATA 20,00
00CB:  DATA D7,20
00CC:  DATA 49,2A
00CD:  DATA 49,27
00CE:  DATA 47,10
00CF:  DATA 2E,17
00D0:  DATA 2E,17
00D1:  DATA 20,10
00D2:  DATA 20,10
00D3:  DATA 20,10
00D4:  DATA 20,10
00D5:  DATA 00,01
00D6:  DATA D7,20
00D7:  DATA 49,2A
00D8:  DATA 49,27
00D9:  DATA 47,10
00DA:  DATA 2E,17
00DB:  DATA 2E,17
00DC:  DATA 20,10
00DD:  DATA 20,10
00DE:  DATA 20,10
00DF:  DATA 20,10
00E0:  DATA 00,00
00E1:  DATA 20,10
00E2:  DATA 20,10
00E3:  DATA 20,10
00E4:  DATA 20,10
00E5:  DATA 20,10
00E6:  DATA 20,10
00E7:  DATA 00,01
00E8:  DATA 54,21
00E9:  DATA 3A,10
00EA:  DATA 00,01
00EB:  DATA 20,10
00EC:  DATA 20,10
00ED:  DATA 43,21
00EE:  DATA 3A,00
*
013D:  DATA C0,29
013E:  DATA 53,20
013F:  DATA 00,00
0140:  DATA 20,10
0141:  DATA 20,10
0142:  DATA 20,10
0143:  DATA 20,10
0144:  DATA 20,10
0145:  DATA 20,10
0146:  DATA 20,10
0147:  DATA 20,10
0148:  DATA 20,00
0149:  DATA 20,10
014A:  DATA 20,10
014B:  DATA 20,10
014C:  DATA 20,10
014D:  DATA 20,10
014E:  DATA 20,10
014F:  DATA 20,10
0150:  DATA 20,10
0151:  DATA 20,00
*
032A:  MOVF   0B,W
032B:  BSF    03.6
032C:  MOVWF  32
032D:  BCF    03.6
032E:  BCF    0B.7
032F:  BSF    03.5
0330:  BSF    03.6
0331:  BSF    0C.7
0332:  BSF    0C.0
0333:  NOP
0334:  NOP
0335:  BCF    03.5
0336:  BTFSS  32.7
0337:  GOTO   33B
0338:  BCF    03.6
0339:  BSF    0B.7
033A:  BSF    03.6
033B:  MOVF   0C,W
033C:  ANDLW  7F
033D:  BTFSC  03.2
033E:  GOTO   378
033F:  MOVWF  32
0340:  MOVF   0D,W
0341:  MOVWF  33
0342:  MOVF   0F,W
0343:  MOVWF  34
0344:  MOVF   32,W
0345:  MOVWF  35
0346:  BCF    03.6
0347:  CALL   2F0
0348:  BSF    03.6
0349:  MOVF   33,W
034A:  MOVWF  0D
034B:  MOVF   34,W
034C:  MOVWF  0F
034D:  BCF    03.6
034E:  MOVF   0B,W
034F:  BSF    03.6
0350:  MOVWF  35
0351:  BCF    03.6
0352:  BCF    0B.7
0353:  BSF    03.5
0354:  BSF    03.6
0355:  BSF    0C.7
0356:  BSF    0C.0
0357:  NOP
0358:  NOP
0359:  BCF    03.5
035A:  BTFSS  35.7
035B:  GOTO   35F
035C:  BCF    03.6
035D:  BSF    0B.7
035E:  BSF    03.6
035F:  RLF    0C,W
0360:  RLF    0E,W
0361:  ANDLW  7F
0362:  BTFSC  03.2
0363:  GOTO   378
0364:  MOVWF  32
0365:  MOVF   0D,W
0366:  MOVWF  33
0367:  MOVF   0F,W
0368:  MOVWF  34
0369:  MOVF   32,W
036A:  MOVWF  35
036B:  BCF    03.6
036C:  CALL   2F0
036D:  BSF    03.6
036E:  MOVF   33,W
036F:  MOVWF  0D
0370:  MOVF   34,W
0371:  MOVWF  0F
0372:  INCF   0D,F
0373:  BTFSC  03.2
0374:  INCF   0F,F
0375:  BCF    03.6
0376:  GOTO   32A
0377:  BSF    03.6
0378:  BCF    03.6
0379:  RETURN
037A:  BTFSC  03.1
037B:  GOTO   37F
037C:  MOVLW  53
037D:  MOVWF  04
037E:  BSF    03.7
037F:  BSF    03.6
0380:  MOVF   4E,W
0381:  XORWF  52,W
0382:  ANDLW  80
0383:  MOVWF  58
0384:  BTFSS  4E.7
0385:  GOTO   391
0386:  COMF   4B,F
0387:  COMF   4C,F
0388:  COMF   4D,F
0389:  COMF   4E,F
038A:  INCF   4B,F
038B:  BTFSC  03.2
038C:  INCF   4C,F
038D:  BTFSC  03.2
038E:  INCF   4D,F
038F:  BTFSC  03.2
0390:  INCF   4E,F
0391:  BTFSS  52.7
0392:  GOTO   39E
0393:  COMF   4F,F
0394:  COMF   50,F
0395:  COMF   51,F
0396:  COMF   52,F
0397:  INCF   4F,F
0398:  BTFSC  03.2
0399:  INCF   50,F
039A:  BTFSC  03.2
039B:  INCF   51,F
039C:  BTFSC  03.2
039D:  INCF   52,F
039E:  CLRF   77
039F:  CLRF   78
03A0:  CLRF   79
03A1:  CLRF   7A
03A2:  CLRF   53
03A3:  CLRF   54
03A4:  CLRF   55
03A5:  CLRF   56
03A6:  MOVF   52,W
03A7:  IORWF  51,W
03A8:  IORWF  50,W
03A9:  IORWF  4F,W
03AA:  BTFSC  03.2
03AB:  GOTO   3DC
03AC:  MOVLW  20
03AD:  MOVWF  57
03AE:  BCF    03.0
03AF:  RLF    4B,F
03B0:  RLF    4C,F
03B1:  RLF    4D,F
03B2:  RLF    4E,F
03B3:  RLF    53,F
03B4:  RLF    54,F
03B5:  RLF    55,F
03B6:  RLF    56,F
03B7:  MOVF   52,W
03B8:  SUBWF  56,W
03B9:  BTFSS  03.2
03BA:  GOTO   3C5
03BB:  MOVF   51,W
03BC:  SUBWF  55,W
03BD:  BTFSS  03.2
03BE:  GOTO   3C5
03BF:  MOVF   50,W
03C0:  SUBWF  54,W
03C1:  BTFSS  03.2
03C2:  GOTO   3C5
03C3:  MOVF   4F,W
03C4:  SUBWF  53,W
03C5:  BTFSS  03.0
03C6:  GOTO   3D6
03C7:  MOVF   4F,W
03C8:  SUBWF  53,F
03C9:  MOVF   50,W
03CA:  BTFSS  03.0
03CB:  INCFSZ 50,W
03CC:  SUBWF  54,F
03CD:  MOVF   51,W
03CE:  BTFSS  03.0
03CF:  INCFSZ 51,W
03D0:  SUBWF  55,F
03D1:  MOVF   52,W
03D2:  BTFSS  03.0
03D3:  INCFSZ 52,W
03D4:  SUBWF  56,F
03D5:  BSF    03.0
03D6:  RLF    77,F
03D7:  RLF    78,F
03D8:  RLF    79,F
03D9:  RLF    7A,F
03DA:  DECFSZ 57,F
03DB:  GOTO   3AE
03DC:  BTFSS  58.7
03DD:  GOTO   3E9
03DE:  COMF   77,F
03DF:  COMF   78,F
03E0:  COMF   79,F
03E1:  COMF   7A,F
03E2:  INCF   77,F
03E3:  BTFSC  03.2
03E4:  INCF   78,F
03E5:  BTFSC  03.2
03E6:  INCF   79,F
03E7:  BTFSC  03.2
03E8:  INCF   7A,F
03E9:  MOVF   53,W
03EA:  MOVWF  00
03EB:  INCF   04,F
03EC:  MOVF   54,W
03ED:  MOVWF  00
03EE:  INCF   04,F
03EF:  MOVF   55,W
03F0:  MOVWF  00
03F1:  INCF   04,F
03F2:  MOVF   56,W
03F3:  MOVWF  00
03F4:  BCF    03.6
03F5:  RETURN
*
040F:  MOVLW  20
0410:  MOVWF  4F
0411:  CLRF   4B
0412:  CLRF   4C
0413:  CLRF   4D
0414:  CLRF   4E
0415:  MOVF   46,W
0416:  MOVWF  7A
0417:  MOVF   45,W
0418:  MOVWF  79
0419:  MOVF   44,W
041A:  MOVWF  78
041B:  MOVF   43,W
041C:  MOVWF  77
041D:  BCF    03.0
041E:  BTFSS  77.0
041F:  GOTO   42E
0420:  MOVF   47,W
0421:  ADDWF  4B,F
0422:  MOVF   48,W
0423:  BTFSC  03.0
0424:  INCFSZ 48,W
0425:  ADDWF  4C,F
0426:  MOVF   49,W
0427:  BTFSC  03.0
0428:  INCFSZ 49,W
0429:  ADDWF  4D,F
042A:  MOVF   4A,W
042B:  BTFSC  03.0
042C:  INCFSZ 4A,W
042D:  ADDWF  4E,F
042E:  RRF    4E,F
042F:  RRF    4D,F
0430:  RRF    4C,F
0431:  RRF    4B,F
0432:  RRF    7A,F
0433:  RRF    79,F
0434:  RRF    78,F
0435:  RRF    77,F
0436:  DECFSZ 4F,F
0437:  GOTO   41D
*
0516:  MOVF   00,F
0517:  BTFSC  03.2
0518:  GOTO   534
0519:  BSF    03.5
051A:  CLRF   60
051B:  MOVF   04,W
051C:  MOVWF  5F
051D:  BCF    60.0
051E:  BTFSC  03.7
051F:  BSF    60.0
0520:  MOVF   00,W
0521:  BCF    03.5
0522:  BSF    03.6
0523:  MOVWF  35
0524:  BCF    03.6
0525:  CALL   2F0
0526:  BSF    03.5
0527:  MOVF   5F,W
0528:  MOVWF  04
0529:  BCF    03.7
052A:  BTFSC  60.0
052B:  BSF    03.7
052C:  INCF   04,F
052D:  BTFSS  03.2
052E:  GOTO   532
052F:  BCF    03.5
0530:  INCF   05,F
0531:  BSF    03.5
0532:  BCF    03.5
0533:  GOTO   516
0534:  RETURN
0535:  BSF    03.5
0536:  MOVF   5C,W
0537:  CLRF   78
0538:  SUBWF  5B,W
0539:  BTFSC  03.0
053A:  GOTO   53E
053B:  MOVF   5B,W
053C:  MOVWF  77
053D:  GOTO   54A
053E:  CLRF   77
053F:  MOVLW  08
0540:  MOVWF  5D
0541:  RLF    5B,F
0542:  RLF    77,F
0543:  MOVF   5C,W
0544:  SUBWF  77,W
0545:  BTFSC  03.0
0546:  MOVWF  77
0547:  RLF    78,F
0548:  DECFSZ 5D,F
0549:  GOTO   541
054A:  BCF    03.5
054B:  RETURN
*
07C7:  MOVF   00,F
07C8:  BTFSC  03.2
07C9:  GOTO   7E4
07CA:  BSF    03.6
07CB:  CLRF   35
07CC:  MOVF   04,W
07CD:  MOVWF  34
07CE:  BCF    35.0
07CF:  BTFSC  03.7
07D0:  BSF    35.0
07D1:  MOVF   00,W
07D2:  BCF    03.6
07D3:  BTFSS  0C.4
07D4:  GOTO   7D3
07D5:  MOVWF  19
07D6:  BSF    03.6
07D7:  MOVF   34,W
07D8:  MOVWF  04
07D9:  BCF    03.7
07DA:  BTFSC  35.0
07DB:  BSF    03.7
07DC:  INCF   04,F
07DD:  BTFSS  03.2
07DE:  GOTO   7E2
07DF:  BCF    03.6
07E0:  INCF   05,F
07E1:  BSF    03.6
07E2:  BCF    03.6
07E3:  GOTO   7C7
07E4:  RETURN
*
0AD0:  CLRF   77
0AD1:  CLRF   78
0AD2:  MOVF   66,W
0AD3:  BCF    03.0
0AD4:  BTFSC  67.0
0AD5:  ADDWF  77,F
0AD6:  RRF    77,F
0AD7:  RRF    78,F
0AD8:  BTFSC  67.1
0AD9:  ADDWF  77,F
0ADA:  RRF    77,F
0ADB:  RRF    78,F
0ADC:  BTFSC  67.2
0ADD:  ADDWF  77,F
0ADE:  RRF    77,F
0ADF:  RRF    78,F
0AE0:  BTFSC  67.3
0AE1:  ADDWF  77,F
0AE2:  RRF    77,F
0AE3:  RRF    78,F
0AE4:  BTFSC  67.4
0AE5:  ADDWF  77,F
0AE6:  RRF    77,F
0AE7:  RRF    78,F
0AE8:  BTFSC  67.5
0AE9:  ADDWF  77,F
0AEA:  RRF    77,F
0AEB:  RRF    78,F
0AEC:  BTFSC  67.6
0AED:  ADDWF  77,F
0AEE:  RRF    77,F
0AEF:  RRF    78,F
0AF0:  BTFSC  67.7
0AF1:  ADDWF  77,F
0AF2:  RRF    77,F
0AF3:  RRF    78,F
*
0BA9:  BSF    03.5
0BAA:  MOVF   5F,W
0BAB:  ANDLW  07
0BAC:  MOVWF  77
0BAD:  RRF    5F,W
0BAE:  MOVWF  78
0BAF:  RRF    78,F
0BB0:  RRF    78,F
0BB1:  MOVLW  1F
0BB2:  ANDWF  78,F
0BB3:  MOVF   78,W
0BB4:  ADDWF  61,W
0BB5:  MOVWF  04
0BB6:  BCF    03.7
0BB7:  BTFSC  62.0
0BB8:  BSF    03.7
0BB9:  CLRF   78
0BBA:  INCF   78,F
0BBB:  INCF   77,F
0BBC:  GOTO   3BE
0BBD:  RLF    78,F
0BBE:  DECFSZ 77,F
0BBF:  GOTO   3BD
0BC0:  MOVF   60,F
0BC1:  BTFSC  03.2
0BC2:  GOTO   3C6
0BC3:  MOVF   78,W
0BC4:  IORWF  00,F
0BC5:  GOTO   3C9
0BC6:  COMF   78,F
0BC7:  MOVF   78,W
0BC8:  ANDWF  00,F
0BC9:  BCF    03.5
0BCA:  RETURN
*
0EF2:  BCF    0A.0
0EF3:  BSF    0A.1
0EF4:  BSF    0A.2
0EF5:  ADDWF  02,F
0EF6:  GOTO   460
0EF7:  GOTO   461
0EF8:  GOTO   476
0EF9:  GOTO   48B
0EFA:  GOTO   495
0EFB:  GOTO   49F
*
107B:  MOVLW  8E
107C:  MOVWF  77
107D:  MOVF   64,W
107E:  MOVWF  78
107F:  MOVF   63,W
1080:  MOVWF  79
1081:  CLRF   7A
1082:  MOVF   78,F
1083:  BTFSS  03.2
1084:  GOTO   08F
1085:  MOVF   79,W
1086:  MOVWF  78
1087:  CLRF   79
1088:  MOVLW  08
1089:  SUBWF  77,F
108A:  MOVF   78,F
108B:  BTFSS  03.2
108C:  GOTO   08F
108D:  CLRF   77
108E:  GOTO   097
108F:  BCF    03.0
1090:  BTFSC  78.7
1091:  GOTO   096
1092:  RLF    79,F
1093:  RLF    78,F
1094:  DECF   77,F
1095:  GOTO   08F
1096:  BCF    78.7
*
10A7:  MOVF   63,W
10A8:  BTFSC  03.2
10A9:  GOTO   1C2
10AA:  BCF    03.5
10AB:  BSF    03.6
10AC:  MOVWF  14
10AD:  BSF    03.5
10AE:  BCF    03.6
10AF:  MOVF   67,W
10B0:  BTFSC  03.2
10B1:  GOTO   1C2
10B2:  BCF    03.5
10B3:  BSF    03.6
10B4:  SUBWF  14,F
10B5:  BTFSS  03.0
10B6:  GOTO   0BF
10B7:  MOVLW  7F
10B8:  ADDWF  14,F
10B9:  BTFSS  03.0
10BA:  GOTO   0BE
10BB:  BSF    03.5
10BC:  BCF    03.6
10BD:  GOTO   1C2
10BE:  GOTO   0CB
10BF:  MOVLW  81
10C0:  SUBWF  14,F
10C1:  BTFSC  03.0
10C2:  GOTO   0C6
10C3:  BSF    03.5
10C4:  BCF    03.6
10C5:  GOTO   1C2
10C6:  BTFSS  03.2
10C7:  GOTO   0CB
10C8:  BSF    03.5
10C9:  BCF    03.6
10CA:  GOTO   1C2
10CB:  MOVF   14,W
10CC:  MOVWF  77
10CD:  CLRF   78
10CE:  CLRF   79
10CF:  CLRF   7A
10D0:  CLRF   13
10D1:  BSF    03.5
10D2:  BCF    03.6
10D3:  MOVF   64,W
10D4:  BCF    03.5
10D5:  BSF    03.6
10D6:  MOVWF  12
10D7:  BSF    12.7
10D8:  BSF    03.5
10D9:  BCF    03.6
10DA:  MOVF   65,W
10DB:  BCF    03.5
10DC:  BSF    03.6
10DD:  MOVWF  11
10DE:  BSF    03.5
10DF:  BCF    03.6
10E0:  MOVF   66,W
10E1:  BCF    03.5
10E2:  BSF    03.6
10E3:  MOVWF  10
10E4:  MOVLW  19
10E5:  MOVWF  14
10E6:  BSF    03.5
10E7:  BCF    03.6
10E8:  MOVF   6A,W
10E9:  BCF    03.5
10EA:  BSF    03.6
10EB:  SUBWF  10,F
10EC:  BTFSC  03.0
10ED:  GOTO   102
10EE:  MOVLW  01
10EF:  SUBWF  11,F
10F0:  BTFSC  03.0
10F1:  GOTO   102
10F2:  SUBWF  12,F
10F3:  BTFSC  03.0
10F4:  GOTO   102
10F5:  SUBWF  13,F
10F6:  BTFSC  03.0
10F7:  GOTO   102
10F8:  INCF   13,F
10F9:  INCF   12,F
10FA:  INCF   11,F
10FB:  BSF    03.5
10FC:  BCF    03.6
10FD:  MOVF   6A,W
10FE:  BCF    03.5
10FF:  BSF    03.6
1100:  ADDWF  10,F
1101:  GOTO   14C
1102:  BSF    03.5
1103:  BCF    03.6
1104:  MOVF   69,W
1105:  BCF    03.5
1106:  BSF    03.6
1107:  SUBWF  11,F
1108:  BTFSC  03.0
1109:  GOTO   129
110A:  MOVLW  01
110B:  SUBWF  12,F
110C:  BTFSC  03.0
110D:  GOTO   129
110E:  SUBWF  13,F
110F:  BTFSC  03.0
1110:  GOTO   129
1111:  INCF   13,F
1112:  INCF   12,F
1113:  BSF    03.5
1114:  BCF    03.6
1115:  MOVF   69,W
1116:  BCF    03.5
1117:  BSF    03.6
1118:  ADDWF  11,F
1119:  BSF    03.5
111A:  BCF    03.6
111B:  MOVF   6A,W
111C:  BCF    03.5
111D:  BSF    03.6
111E:  ADDWF  10,F
111F:  BTFSS  03.0
1120:  GOTO   14C
1121:  INCF   11,F
1122:  BTFSS  03.2
1123:  GOTO   14C
1124:  INCF   12,F
1125:  BTFSS  03.2
1126:  GOTO   14C
1127:  INCF   13,F
1128:  GOTO   14C
1129:  BSF    03.5
112A:  BCF    03.6
112B:  MOVF   68,W
112C:  IORLW  80
112D:  BCF    03.5
112E:  BSF    03.6
112F:  SUBWF  12,F
1130:  BTFSC  03.0
1131:  GOTO   14B
1132:  MOVLW  01
1133:  SUBWF  13,F
1134:  BTFSC  03.0
1135:  GOTO   14B
1136:  INCF   13,F
1137:  BSF    03.5
1138:  BCF    03.6
1139:  MOVF   68,W
113A:  IORLW  80
113B:  BCF    03.5
113C:  BSF    03.6
113D:  ADDWF  12,F
113E:  BSF    03.5
113F:  BCF    03.6
1140:  MOVF   69,W
1141:  BCF    03.5
1142:  BSF    03.6
1143:  ADDWF  11,F
1144:  BTFSS  03.0
1145:  GOTO   119
1146:  INCF   12,F
1147:  BTFSS  03.2
1148:  GOTO   119
1149:  INCF   13,F
114A:  GOTO   119
114B:  BSF    7A.0
114C:  DECFSZ 14,F
114D:  GOTO   14F
114E:  GOTO   15A
114F:  BCF    03.0
1150:  RLF    10,F
1151:  RLF    11,F
1152:  RLF    12,F
1153:  RLF    13,F
1154:  BCF    03.0
1155:  RLF    7A,F
1156:  RLF    79,F
1157:  RLF    78,F
1158:  RLF    15,F
1159:  GOTO   0E6
115A:  BTFSS  15.0
115B:  GOTO   162
115C:  BCF    03.0
115D:  RRF    78,F
115E:  RRF    79,F
115F:  RRF    7A,F
1160:  RRF    15,F
1161:  GOTO   167
1162:  DECFSZ 77,F
1163:  GOTO   167
1164:  BSF    03.5
1165:  BCF    03.6
1166:  GOTO   1C2
1167:  BTFSC  15.7
1168:  GOTO   19C
1169:  BCF    03.0
116A:  RLF    10,F
116B:  RLF    11,F
116C:  RLF    12,F
116D:  RLF    13,F
116E:  BSF    03.5
116F:  BCF    03.6
1170:  MOVF   6A,W
1171:  BCF    03.5
1172:  BSF    03.6
1173:  SUBWF  10,F
1174:  BTFSC  03.0
1175:  GOTO   180
1176:  MOVLW  01
1177:  SUBWF  11,F
1178:  BTFSC  03.0
1179:  GOTO   180
117A:  SUBWF  12,F
117B:  BTFSC  03.0
117C:  GOTO   180
117D:  SUBWF  13,F
117E:  BTFSS  03.0
117F:  GOTO   1AE
1180:  BSF    03.5
1181:  BCF    03.6
1182:  MOVF   69,W
1183:  BCF    03.5
1184:  BSF    03.6
1185:  SUBWF  11,F
1186:  BTFSC  03.0
1187:  GOTO   18F
1188:  MOVLW  01
1189:  SUBWF  12,F
118A:  BTFSC  03.0
118B:  GOTO   18F
118C:  SUBWF  13,F
118D:  BTFSS  03.0
118E:  GOTO   1AE
118F:  BSF    03.5
1190:  BCF    03.6
1191:  MOVF   68,W
1192:  IORLW  80
1193:  BCF    03.5
1194:  BSF    03.6
1195:  SUBWF  12,F
1196:  BTFSC  03.0
1197:  GOTO   19C
1198:  MOVLW  01
1199:  SUBWF  13,F
119A:  BTFSS  03.0
119B:  GOTO   1AE
119C:  INCF   7A,F
119D:  BTFSS  03.2
119E:  GOTO   1AE
119F:  INCF   79,F
11A0:  BTFSS  03.2
11A1:  GOTO   1AE
11A2:  INCF   78,F
11A3:  BTFSS  03.2
11A4:  GOTO   1AE
11A5:  INCF   77,F
11A6:  BTFSS  03.2
11A7:  GOTO   1AB
11A8:  BSF    03.5
11A9:  BCF    03.6
11AA:  GOTO   1C2
11AB:  RRF    78,F
11AC:  RRF    79,F
11AD:  RRF    7A,F
11AE:  BSF    03.5
11AF:  BCF    03.6
11B0:  MOVF   64,W
11B1:  BCF    03.5
11B2:  BSF    03.6
11B3:  MOVWF  14
11B4:  BSF    03.5
11B5:  BCF    03.6
11B6:  MOVF   68,W
11B7:  BCF    03.5
11B8:  BSF    03.6
11B9:  XORWF  14,F
11BA:  BTFSS  14.7
11BB:  GOTO   1BE
11BC:  BSF    78.7
11BD:  GOTO   1C8
11BE:  BCF    78.7
11BF:  GOTO   1C8
11C0:  BSF    03.5
11C1:  BCF    03.6
11C2:  CLRF   77
11C3:  CLRF   78
11C4:  CLRF   79
11C5:  CLRF   7A
11C6:  BCF    03.5
11C7:  BSF    03.6
*
11D2:  MOVLW  8E
11D3:  MOVWF  77
11D4:  MOVF   63,W
11D5:  SUBWF  77,F
11D6:  MOVF   64,W
11D7:  MOVWF  79
11D8:  MOVF   65,W
11D9:  MOVWF  78
11DA:  BSF    79.7
11DB:  MOVF   77,F
11DC:  BTFSC  03.2
11DD:  GOTO   1E9
11DE:  BCF    03.0
11DF:  MOVF   79,F
11E0:  BTFSS  03.2
11E1:  GOTO   1E5
11E2:  MOVF   78,F
11E3:  BTFSC  03.2
11E4:  GOTO   1E9
11E5:  RRF    79,F
11E6:  RRF    78,F
11E7:  DECFSZ 77,F
11E8:  GOTO   1DE
11E9:  BTFSS  64.7
11EA:  GOTO   1F0
11EB:  COMF   78,F
11EC:  COMF   79,F
11ED:  INCF   78,F
11EE:  BTFSC  03.2
11EF:  INCF   79,F
*
12C0:  BCF    03.6
12C1:  MOVF   0B,W
12C2:  BSF    03.6
12C3:  MOVWF  2D
12C4:  BCF    03.6
12C5:  BCF    0B.7
12C6:  BSF    03.5
12C7:  BSF    03.6
12C8:  BSF    0C.7
12C9:  BSF    0C.0
12CA:  NOP
12CB:  NOP
12CC:  BCF    03.5
12CD:  BTFSS  2D.7
12CE:  GOTO   2D2
12CF:  BCF    03.6
12D0:  BSF    0B.7
12D1:  BSF    03.6
12D2:  MOVF   0C,W
12D3:  ANDLW  7F
12D4:  BTFSC  03.2
12D5:  GOTO   30F
12D6:  MOVWF  2D
12D7:  MOVF   0D,W
12D8:  MOVWF  2E
12D9:  MOVF   0F,W
12DA:  MOVWF  2F
12DB:  MOVF   2D,W
12DC:  BCF    03.6
12DD:  BTFSS  0C.4
12DE:  GOTO   2DD
12DF:  MOVWF  19
12E0:  BSF    03.6
12E1:  MOVF   2E,W
12E2:  MOVWF  0D
12E3:  MOVF   2F,W
12E4:  MOVWF  0F
12E5:  BCF    03.6
12E6:  MOVF   0B,W
12E7:  BSF    03.6
12E8:  MOVWF  30
12E9:  BCF    03.6
12EA:  BCF    0B.7
12EB:  BSF    03.5
12EC:  BSF    03.6
12ED:  BSF    0C.7
12EE:  BSF    0C.0
12EF:  NOP
12F0:  NOP
12F1:  BCF    03.5
12F2:  BTFSS  30.7
12F3:  GOTO   2F7
12F4:  BCF    03.6
12F5:  BSF    0B.7
12F6:  BSF    03.6
12F7:  RLF    0C,W
12F8:  RLF    0E,W
12F9:  ANDLW  7F
12FA:  BTFSC  03.2
12FB:  GOTO   30F
12FC:  MOVWF  2D
12FD:  MOVF   0D,W
12FE:  MOVWF  2E
12FF:  MOVF   0F,W
1300:  MOVWF  2F
1301:  MOVF   2D,W
1302:  BCF    03.6
1303:  BTFSS  0C.4
1304:  GOTO   303
1305:  MOVWF  19
1306:  BSF    03.6
1307:  MOVF   2E,W
1308:  MOVWF  0D
1309:  MOVF   2F,W
130A:  MOVWF  0F
130B:  INCF   0D,F
130C:  BTFSC  03.2
130D:  INCF   0F,F
130E:  GOTO   2C0
....................  
.................... #list 
....................  
.................... #DEVICE ADC=10 
.................... #INCLUDE <STRING.H> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
*
0769:  BSF    03.6
076A:  MOVF   34,W
076B:  MOVWF  38
076C:  MOVF   33,W
076D:  MOVWF  37
076E:  MOVF   38,W
076F:  MOVWF  7A
0770:  MOVF   37,W
0771:  MOVWF  04
0772:  BCF    03.7
0773:  BTFSC  7A.0
0774:  BSF    03.7
0775:  MOVF   00,F
0776:  BTFSC  03.2
0777:  GOTO   77C
0778:  INCF   37,F
0779:  BTFSC  03.2
077A:  INCF   38,F
077B:  GOTO   76E
....................    while(*s2 != '\0') 
077C:  MOVF   36,W
077D:  MOVWF  7A
077E:  MOVF   35,W
077F:  MOVWF  04
0780:  BCF    03.7
0781:  BTFSC  7A.0
0782:  BSF    03.7
0783:  MOVF   00,F
0784:  BTFSC  03.2
0785:  GOTO   79B
....................    { 
....................       *s = *s2; 
0786:  MOVF   35,W
0787:  MOVWF  04
0788:  BCF    03.7
0789:  BTFSC  36.0
078A:  BSF    03.7
078B:  MOVF   00,W
078C:  MOVWF  3B
078D:  MOVF   37,W
078E:  MOVWF  04
078F:  BCF    03.7
0790:  BTFSC  38.0
0791:  BSF    03.7
0792:  MOVF   3B,W
0793:  MOVWF  00
....................       ++s; 
0794:  INCF   37,F
0795:  BTFSC  03.2
0796:  INCF   38,F
....................       ++s2; 
0797:  INCF   35,F
0798:  BTFSC  03.2
0799:  INCF   36,F
079A:  GOTO   77C
....................    } 
....................  
....................    *s = '\0'; 
079B:  MOVF   37,W
079C:  MOVWF  04
079D:  BCF    03.7
079E:  BTFSC  38.0
079F:  BSF    03.7
07A0:  CLRF   00
....................    return(s1); 
07A1:  MOVF   33,W
07A2:  MOVWF  78
07A3:  MOVF   34,W
07A4:  MOVWF  79
07A5:  BCF    03.6
07A6:  RETURN
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
*
0B63:  BSF    03.5
0B64:  MOVF   5E,W
0B65:  MOVWF  7A
0B66:  MOVF   5D,W
0B67:  MOVWF  04
0B68:  BCF    03.7
0B69:  BTFSC  7A.0
0B6A:  BSF    03.7
0B6B:  MOVF   00,W
0B6C:  MOVWF  61
0B6D:  MOVF   60,W
0B6E:  MOVWF  7A
0B6F:  MOVF   5F,W
0B70:  MOVWF  04
0B71:  BCF    03.7
0B72:  BTFSC  7A.0
0B73:  BSF    03.7
0B74:  MOVF   00,W
0B75:  SUBWF  61,W
0B76:  BTFSS  03.2
0B77:  GOTO   38F
....................       if (*s1 == '\0') 
0B78:  MOVF   5E,W
0B79:  MOVWF  7A
0B7A:  MOVF   5D,W
0B7B:  MOVWF  04
0B7C:  BCF    03.7
0B7D:  BTFSC  7A.0
0B7E:  BSF    03.7
0B7F:  MOVF   00,F
0B80:  BTFSS  03.2
0B81:  GOTO   385
....................          return(0); 
0B82:  MOVLW  00
0B83:  MOVWF  78
0B84:  GOTO   3A7
0B85:  MOVF   5E,W
0B86:  MOVWF  7A
0B87:  MOVF   5D,W
0B88:  INCF   5D,F
0B89:  BTFSC  03.2
0B8A:  INCF   5E,F
0B8B:  INCF   5F,F
0B8C:  BTFSC  03.2
0B8D:  INCF   60,F
0B8E:  GOTO   364
....................    return((*s1 < *s2) ? -1: 1); 
0B8F:  MOVF   5E,W
0B90:  MOVWF  7A
0B91:  MOVF   5D,W
0B92:  MOVWF  04
0B93:  BCF    03.7
0B94:  BTFSC  5E.0
0B95:  BSF    03.7
0B96:  MOVF   00,W
0B97:  MOVWF  61
0B98:  MOVF   60,W
0B99:  MOVWF  7A
0B9A:  MOVF   5F,W
0B9B:  MOVWF  04
0B9C:  BCF    03.7
0B9D:  BTFSC  60.0
0B9E:  BSF    03.7
0B9F:  MOVF   00,W
0BA0:  SUBWF  61,W
0BA1:  BTFSC  03.0
0BA2:  GOTO   3A5
0BA3:  MOVLW  FF
0BA4:  GOTO   3A6
0BA5:  MOVLW  01
0BA6:  MOVWF  78
0BA7:  BCF    03.5
0BA8:  RETURN
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
*
0BF7:  MOVF   5E,W
0BF8:  MOVWF  7A
0BF9:  MOVF   5D,W
0BFA:  MOVWF  04
0BFB:  BCF    03.7
0BFC:  BTFSC  7A.0
0BFD:  BSF    03.7
0BFE:  MOVF   5F,W
0BFF:  SUBWF  00,W
0C00:  BTFSC  03.2
0C01:  GOTO   414
....................       if (*s == '\0') 
0C02:  MOVF   5E,W
0C03:  MOVWF  7A
0C04:  MOVF   5D,W
0C05:  MOVWF  04
0C06:  BCF    03.7
0C07:  BTFSC  7A.0
0C08:  BSF    03.7
0C09:  MOVF   00,F
0C0A:  BTFSS  03.2
0C0B:  GOTO   410
....................          return(0); 
0C0C:  MOVLW  00
0C0D:  MOVWF  78
0C0E:  MOVWF  79
0C0F:  GOTO   418
0C10:  INCF   5D,F
0C11:  BTFSC  03.2
0C12:  INCF   5E,F
0C13:  GOTO   3F7
....................    return(s); 
0C14:  MOVF   5D,W
0C15:  MOVWF  78
0C16:  MOVF   5E,W
0C17:  MOVWF  79
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
*
09FC:  MOVF   68,W
09FD:  MOVWF  6C
09FE:  MOVF   67,W
09FF:  MOVWF  6B
0A00:  MOVF   6C,W
0A01:  MOVWF  7A
0A02:  MOVF   6B,W
0A03:  MOVWF  04
0A04:  BCF    03.7
0A05:  BTFSC  7A.0
0A06:  BSF    03.7
0A07:  MOVF   00,F
0A08:  BTFSC  03.2
0A09:  GOTO   239
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
0A0A:  MOVF   6A,W
0A0B:  MOVWF  6E
0A0C:  MOVF   69,W
0A0D:  MOVWF  6D
0A0E:  MOVF   6E,W
0A0F:  MOVWF  7A
0A10:  MOVF   6D,W
0A11:  MOVWF  04
0A12:  BCF    03.7
0A13:  BTFSC  7A.0
0A14:  BSF    03.7
0A15:  MOVF   00,F
0A16:  BTFSC  03.2
0A17:  GOTO   235
....................          if (*sc1 == *sc2) 
0A18:  MOVF   6C,W
0A19:  MOVWF  7A
0A1A:  MOVF   6B,W
0A1B:  MOVWF  04
0A1C:  BCF    03.7
0A1D:  BTFSC  7A.0
0A1E:  BSF    03.7
0A1F:  MOVF   00,W
0A20:  MOVWF  6F
0A21:  MOVF   6E,W
0A22:  MOVWF  7A
0A23:  MOVF   6D,W
0A24:  MOVWF  04
0A25:  BCF    03.7
0A26:  BTFSC  7A.0
0A27:  BSF    03.7
0A28:  MOVF   00,W
0A29:  SUBWF  6F,W
0A2A:  BTFSS  03.2
0A2B:  GOTO   231
....................             return(sc1); 
0A2C:  MOVF   6B,W
0A2D:  MOVWF  78
0A2E:  MOVF   6C,W
0A2F:  MOVWF  79
0A30:  GOTO   23C
0A31:  INCF   6D,F
0A32:  BTFSC  03.2
0A33:  INCF   6E,F
0A34:  GOTO   20E
0A35:  INCF   6B,F
0A36:  BTFSC  03.2
0A37:  INCF   6C,F
0A38:  GOTO   200
....................    return(0); 
0A39:  MOVLW  00
0A3A:  MOVWF  78
0A3B:  MOVWF  79
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
*
0989:  MOVF   68,W
098A:  MOVWF  6C
098B:  MOVF   67,W
098C:  MOVWF  6B
098D:  MOVF   6C,W
098E:  MOVWF  7A
098F:  MOVF   6B,W
0990:  MOVWF  04
0991:  BCF    03.7
0992:  BTFSC  7A.0
0993:  BSF    03.7
0994:  MOVF   00,F
0995:  BTFSC  03.2
0996:  GOTO   1CE
....................       for (sc2 = s2; ; sc2++) 
0997:  MOVF   6A,W
0998:  MOVWF  6E
0999:  MOVF   69,W
099A:  MOVWF  6D
....................     if (*sc2 == '\0') 
099B:  MOVF   6E,W
099C:  MOVWF  7A
099D:  MOVF   6D,W
099E:  MOVWF  04
099F:  BCF    03.7
09A0:  BTFSC  7A.0
09A1:  BSF    03.7
09A2:  MOVF   00,F
09A3:  BTFSS  03.2
09A4:  GOTO   1B2
....................        return(sc1 - s1); 
09A5:  MOVF   67,W
09A6:  SUBWF  6B,W
09A7:  MOVWF  77
09A8:  MOVF   6C,W
09A9:  MOVWF  7A
09AA:  MOVF   68,W
09AB:  BTFSS  03.0
09AC:  INCFSZ 68,W
09AD:  SUBWF  7A,F
09AE:  MOVF   77,W
09AF:  MOVWF  78
09B0:  GOTO   1D9
09B1:  GOTO   1C6
....................          else if (*sc1 == *sc2) 
09B2:  MOVF   6C,W
09B3:  MOVWF  7A
09B4:  MOVF   6B,W
09B5:  MOVWF  04
09B6:  BCF    03.7
09B7:  BTFSC  7A.0
09B8:  BSF    03.7
09B9:  MOVF   00,W
09BA:  MOVWF  6F
09BB:  MOVF   6E,W
09BC:  MOVWF  7A
09BD:  MOVF   6D,W
09BE:  MOVWF  04
09BF:  BCF    03.7
09C0:  BTFSC  7A.0
09C1:  BSF    03.7
09C2:  MOVF   00,W
09C3:  SUBWF  6F,W
09C4:  BTFSC  03.2
....................             break; 
09C5:  GOTO   1CA
09C6:  INCF   6D,F
09C7:  BTFSC  03.2
09C8:  INCF   6E,F
09C9:  GOTO   19B
09CA:  INCF   6B,F
09CB:  BTFSC  03.2
09CC:  INCF   6C,F
09CD:  GOTO   18D
....................    return(sc1 - s1); 
09CE:  MOVF   67,W
09CF:  SUBWF  6B,W
09D0:  MOVWF  77
09D1:  MOVF   6C,W
09D2:  MOVWF  7A
09D3:  MOVF   68,W
09D4:  BTFSS  03.0
09D5:  INCFSZ 68,W
09D6:  SUBWF  7A,F
09D7:  MOVF   77,W
09D8:  MOVWF  78
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
*
1374:  BCF    03.6
1375:  CLRF   2B
1376:  CLRF   2C
....................  
....................    beg = (s1)? s1: save; 
*
0970:  BSF    03.5
0971:  MOVF   5F,W
0972:  IORWF  60,W
0973:  BTFSC  03.2
0974:  GOTO   179
0975:  MOVF   60,W
0976:  MOVWF  7A
0977:  MOVF   5F,W
0978:  GOTO   17E
0979:  BCF    03.5
097A:  MOVF   2C,W
097B:  MOVWF  7A
097C:  MOVF   2B,W
097D:  BSF    03.5
097E:  MOVWF  63
097F:  MOVF   7A,W
0980:  MOVWF  64
....................    beg += strspn(beg, s2); 
0981:  MOVF   64,W
0982:  MOVWF  68
0983:  MOVF   63,W
0984:  MOVWF  67
0985:  MOVF   62,W
0986:  MOVWF  6A
0987:  MOVF   61,W
0988:  MOVWF  69
*
09D9:  MOVF   78,W
09DA:  ADDWF  63,F
09DB:  BTFSC  03.0
09DC:  INCF   64,F
....................    if (*beg == '\0') 
09DD:  MOVF   64,W
09DE:  MOVWF  7A
09DF:  MOVF   63,W
09E0:  MOVWF  04
09E1:  BCF    03.7
09E2:  BTFSC  7A.0
09E3:  BSF    03.7
09E4:  MOVF   00,F
09E5:  BTFSS  03.2
09E6:  GOTO   1F4
....................    { 
....................       *save = ' '; 
09E7:  BCF    03.5
09E8:  MOVF   2B,W
09E9:  MOVWF  04
09EA:  BCF    03.7
09EB:  BTFSC  2C.0
09EC:  BSF    03.7
09ED:  MOVLW  20
09EE:  MOVWF  00
....................       return(0); 
09EF:  MOVLW  00
09F0:  MOVWF  78
09F1:  MOVWF  79
09F2:  GOTO   260
09F3:  BSF    03.5
....................    } 
....................    end = strpbrk(beg, s2); 
09F4:  MOVF   64,W
09F5:  MOVWF  68
09F6:  MOVF   63,W
09F7:  MOVWF  67
09F8:  MOVF   62,W
09F9:  MOVWF  6A
09FA:  MOVF   61,W
09FB:  MOVWF  69
*
0A3C:  MOVF   79,W
0A3D:  MOVWF  66
0A3E:  MOVF   78,W
0A3F:  MOVWF  65
....................    if (*end != '\0') 
0A40:  MOVF   66,W
0A41:  MOVWF  7A
0A42:  MOVF   65,W
0A43:  MOVWF  04
0A44:  BCF    03.7
0A45:  BTFSC  7A.0
0A46:  BSF    03.7
0A47:  MOVF   00,F
0A48:  BTFSC  03.2
0A49:  GOTO   253
....................    { 
....................       *end = '\0'; 
0A4A:  MOVF   65,W
0A4B:  MOVWF  04
0A4C:  BCF    03.7
0A4D:  BTFSC  66.0
0A4E:  BSF    03.7
0A4F:  CLRF   00
....................       end++; 
0A50:  INCF   65,F
0A51:  BTFSC  03.2
0A52:  INCF   66,F
....................    } 
....................    save = end; 
0A53:  MOVF   66,W
0A54:  BCF    03.5
0A55:  MOVWF  2C
0A56:  BSF    03.5
0A57:  MOVF   65,W
0A58:  BCF    03.5
0A59:  MOVWF  2B
....................    return(beg); 
0A5A:  BSF    03.5
0A5B:  MOVF   63,W
0A5C:  MOVWF  78
0A5D:  MOVF   64,W
0A5E:  MOVWF  79
0A5F:  BCF    03.5
0A60:  RETURN
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
*
07A7:  BSF    03.6
07A8:  MOVF   35,W
07A9:  MOVWF  37
07AA:  MOVF   34,W
07AB:  MOVWF  36
07AC:  MOVF   37,W
07AD:  MOVWF  7A
07AE:  MOVF   36,W
07AF:  MOVWF  04
07B0:  BCF    03.7
07B1:  BTFSC  7A.0
07B2:  BSF    03.7
07B3:  MOVF   00,F
07B4:  BTFSC  03.2
07B5:  GOTO   7BA
07B6:  INCF   36,F
07B7:  BTFSC  03.2
07B8:  INCF   37,F
07B9:  GOTO   7AC
....................    return(sc - s); 
07BA:  MOVF   34,W
07BB:  SUBWF  36,W
07BC:  MOVWF  77
07BD:  MOVF   37,W
07BE:  MOVWF  7A
07BF:  MOVF   35,W
07C0:  BTFSS  03.0
07C1:  INCFSZ 35,W
07C2:  SUBWF  7A,F
07C3:  MOVF   77,W
07C4:  MOVWF  78
07C5:  BCF    03.6
07C6:  RETURN
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #INCLUDE <STDLIB.H> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... /* Standart template: float strtof(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... float strtof(char *s,char *endptr); 
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s,char *endptr); 
.................... float64 strtod(char *s,char *endptr); 
.................... #else 
.................... //provided for compatibility 
.................... #define strtof48(s, e) strtof(s, e) 
.................... #define strtod(s, e) strtof(s, e) 
.................... #endif 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof(s)   strtof(s, 0) 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof48(s) strtof48(s, 0) 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof64(s) strtod(s, 0) 
.................... #endif 
....................  
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float atoe(char * s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s); 
.................... #endif 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... unsigned int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................  
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
*
0A61:  BSF    03.5
0A62:  CLRF   64
....................    sign = 0; 
0A63:  CLRF   62
....................    base = 10; 
0A64:  MOVLW  0A
0A65:  MOVWF  63
....................    result = 0; 
0A66:  CLRF   61
....................  
....................    if (!s) 
0A67:  MOVF   5F,W
0A68:  IORWF  60,W
0A69:  BTFSS  03.2
0A6A:  GOTO   26E
....................       return 0; 
0A6B:  MOVLW  00
0A6C:  MOVWF  78
0A6D:  GOTO   361
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
0A6E:  MOVF   64,W
0A6F:  INCF   64,F
0A70:  ADDWF  5F,W
0A71:  MOVWF  04
0A72:  BCF    03.7
0A73:  BTFSC  60.0
0A74:  BSF    03.7
0A75:  MOVF   00,W
0A76:  MOVWF  65
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
0A77:  MOVF   65,W
0A78:  SUBLW  2D
0A79:  BTFSS  03.2
0A7A:  GOTO   287
....................    { 
....................       sign = 1;         // Set the sign to negative 
0A7B:  MOVLW  01
0A7C:  MOVWF  62
....................       c = s[index++]; 
0A7D:  MOVF   64,W
0A7E:  INCF   64,F
0A7F:  ADDWF  5F,W
0A80:  MOVWF  04
0A81:  BCF    03.7
0A82:  BTFSC  60.0
0A83:  BSF    03.7
0A84:  MOVF   00,W
0A85:  MOVWF  65
....................    } 
0A86:  GOTO   294
....................    else if (c == '+') 
0A87:  MOVF   65,W
0A88:  SUBLW  2B
0A89:  BTFSS  03.2
0A8A:  GOTO   294
....................    { 
....................       c = s[index++]; 
0A8B:  MOVF   64,W
0A8C:  INCF   64,F
0A8D:  ADDWF  5F,W
0A8E:  MOVWF  04
0A8F:  BCF    03.7
0A90:  BTFSC  60.0
0A91:  BSF    03.7
0A92:  MOVF   00,W
0A93:  MOVWF  65
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
0A94:  MOVF   65,W
0A95:  SUBLW  2F
0A96:  BTFSC  03.0
0A97:  GOTO   357
0A98:  MOVF   65,W
0A99:  SUBLW  39
0A9A:  BTFSS  03.0
0A9B:  GOTO   357
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
0A9C:  MOVF   65,W
0A9D:  SUBLW  30
0A9E:  BTFSS  03.2
0A9F:  GOTO   2C0
0AA0:  MOVF   64,W
0AA1:  ADDWF  5F,W
0AA2:  MOVWF  04
0AA3:  BCF    03.7
0AA4:  BTFSC  60.0
0AA5:  BSF    03.7
0AA6:  MOVF   00,W
0AA7:  SUBLW  78
0AA8:  BTFSC  03.2
0AA9:  GOTO   2B4
0AAA:  MOVF   64,W
0AAB:  ADDWF  5F,W
0AAC:  MOVWF  04
0AAD:  BCF    03.7
0AAE:  BTFSC  60.0
0AAF:  BSF    03.7
0AB0:  MOVF   00,W
0AB1:  SUBLW  58
0AB2:  BTFSS  03.2
0AB3:  GOTO   2C0
....................       { 
....................          base = 16; 
0AB4:  MOVLW  10
0AB5:  MOVWF  63
....................          index++; 
0AB6:  INCF   64,F
....................          c = s[index++]; 
0AB7:  MOVF   64,W
0AB8:  INCF   64,F
0AB9:  ADDWF  5F,W
0ABA:  MOVWF  04
0ABB:  BCF    03.7
0ABC:  BTFSC  60.0
0ABD:  BSF    03.7
0ABE:  MOVF   00,W
0ABF:  MOVWF  65
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
0AC0:  MOVF   63,W
0AC1:  SUBLW  0A
0AC2:  BTFSS  03.2
0AC3:  GOTO   305
....................       { 
....................          while (c >= '0' && c <= '9') 
0AC4:  MOVF   65,W
0AC5:  SUBLW  2F
0AC6:  BTFSC  03.0
0AC7:  GOTO   304
0AC8:  MOVF   65,W
0AC9:  SUBLW  39
0ACA:  BTFSS  03.0
0ACB:  GOTO   304
....................          { 
....................             result = 10*result + (c - '0'); 
0ACC:  MOVLW  0A
0ACD:  MOVWF  66
0ACE:  MOVF   61,W
0ACF:  MOVWF  67
*
0AF4:  MOVF   78,W
0AF5:  MOVWF  66
0AF6:  MOVLW  30
0AF7:  SUBWF  65,W
0AF8:  ADDWF  66,W
0AF9:  MOVWF  61
....................             c = s[index++]; 
0AFA:  MOVF   64,W
0AFB:  INCF   64,F
0AFC:  ADDWF  5F,W
0AFD:  MOVWF  04
0AFE:  BCF    03.7
0AFF:  BTFSC  60.0
0B00:  BSF    03.7
0B01:  MOVF   00,W
0B02:  MOVWF  65
0B03:  GOTO   2C4
....................          } 
....................       } 
0B04:  GOTO   357
....................       else if (base == 16)    // The number is a hexa number 
0B05:  MOVF   63,W
0B06:  SUBLW  10
0B07:  BTFSS  03.2
0B08:  GOTO   357
....................       { 
....................          c = toupper(c); 
0B09:  MOVF   65,W
0B0A:  SUBLW  60
0B0B:  BTFSC  03.0
0B0C:  GOTO   314
0B0D:  MOVF   65,W
0B0E:  SUBLW  7A
0B0F:  BTFSS  03.0
0B10:  GOTO   314
0B11:  MOVF   65,W
0B12:  ANDLW  DF
0B13:  GOTO   315
0B14:  MOVF   65,W
0B15:  MOVWF  65
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
0B16:  MOVF   65,W
0B17:  SUBLW  2F
0B18:  BTFSC  03.0
0B19:  GOTO   31E
0B1A:  MOVF   65,W
0B1B:  SUBLW  39
0B1C:  BTFSC  03.0
0B1D:  GOTO   326
0B1E:  MOVF   65,W
0B1F:  SUBLW  40
0B20:  BTFSC  03.0
0B21:  GOTO   357
0B22:  MOVF   65,W
0B23:  SUBLW  46
0B24:  BTFSS  03.0
0B25:  GOTO   357
....................          { 
....................             if (c >= '0' && c <= '9') 
0B26:  MOVF   65,W
0B27:  SUBLW  2F
0B28:  BTFSC  03.0
0B29:  GOTO   337
0B2A:  MOVF   65,W
0B2B:  SUBLW  39
0B2C:  BTFSS  03.0
0B2D:  GOTO   337
....................                result = (result << 4) + (c - '0'); 
0B2E:  SWAPF  61,W
0B2F:  MOVWF  66
0B30:  MOVLW  F0
0B31:  ANDWF  66,F
0B32:  MOVLW  30
0B33:  SUBWF  65,W
0B34:  ADDWF  66,W
0B35:  MOVWF  61
0B36:  GOTO   340
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
0B37:  SWAPF  61,W
0B38:  MOVWF  66
0B39:  MOVLW  F0
0B3A:  ANDWF  66,F
0B3B:  MOVLW  41
0B3C:  SUBWF  65,W
0B3D:  ADDLW  0A
0B3E:  ADDWF  66,W
0B3F:  MOVWF  61
....................  
....................             c = s[index++]; 
0B40:  MOVF   64,W
0B41:  INCF   64,F
0B42:  ADDWF  5F,W
0B43:  MOVWF  04
0B44:  BCF    03.7
0B45:  BTFSC  60.0
0B46:  BSF    03.7
0B47:  MOVF   00,W
0B48:  MOVWF  65
....................             c = toupper(c); 
0B49:  MOVF   65,W
0B4A:  SUBLW  60
0B4B:  BTFSC  03.0
0B4C:  GOTO   354
0B4D:  MOVF   65,W
0B4E:  SUBLW  7A
0B4F:  BTFSS  03.0
0B50:  GOTO   354
0B51:  MOVF   65,W
0B52:  ANDLW  DF
0B53:  GOTO   355
0B54:  MOVF   65,W
0B55:  MOVWF  65
0B56:  GOTO   316
....................          } 
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
0B57:  DECFSZ 62,W
0B58:  GOTO   35F
0B59:  MOVF   63,W
0B5A:  SUBLW  0A
0B5B:  BTFSS  03.2
0B5C:  GOTO   35F
....................        result = -result; 
0B5D:  COMF   61,F
0B5E:  INCF   61,F
....................  
....................    return(result); 
0B5F:  MOVF   61,W
0B60:  MOVWF  78
0B61:  BCF    03.5
0B62:  RETURN
.................... } 
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
*
03F6:  BSF    03.6
03F7:  CLRF   3E
03F8:  CLRF   3D
03F9:  CLRF   3C
03FA:  MOVLW  01
03FB:  MOVWF  3B
03FC:  CLRF   40
03FD:  CLRF   41
.................... { 
....................      unsigned int32 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
03FE:  BTFSS  37.7
03FF:  GOTO   440
....................          sign=1;        // Check for negative number 
0400:  MOVLW  01
0401:  MOVWF  40
....................          num*=-1; 
0402:  MOVF   37,W
0403:  MOVWF  46
0404:  MOVF   36,W
0405:  MOVWF  45
0406:  MOVF   35,W
0407:  MOVWF  44
0408:  MOVF   34,W
0409:  MOVWF  43
040A:  MOVLW  FF
040B:  MOVWF  4A
040C:  MOVWF  49
040D:  MOVWF  48
040E:  MOVWF  47
*
0438:  MOVF   7A,W
0439:  MOVWF  37
043A:  MOVF   79,W
043B:  MOVWF  36
043C:  MOVF   78,W
043D:  MOVWF  35
043E:  MOVF   77,W
043F:  MOVWF  34
....................      } 
....................  
....................      while(temp>0) { 
0440:  MOVF   3B,F
0441:  BTFSS  03.2
0442:  GOTO   44C
0443:  MOVF   3C,F
0444:  BTFSS  03.2
0445:  GOTO   44C
0446:  MOVF   3D,F
0447:  BTFSS  03.2
0448:  GOTO   44C
0449:  MOVF   3E,F
044A:  BTFSC  03.2
044B:  GOTO   4C8
....................          temp=(num/base); 
044C:  BCF    03.1
044D:  MOVF   37,W
044E:  MOVWF  4E
044F:  MOVF   36,W
0450:  MOVWF  4D
0451:  MOVF   35,W
0452:  MOVWF  4C
0453:  MOVF   34,W
0454:  MOVWF  4B
0455:  CLRF   52
0456:  CLRF   51
0457:  CLRF   50
0458:  MOVF   38,W
0459:  MOVWF  4F
045A:  BCF    03.6
045B:  CALL   37A
045C:  MOVF   7A,W
045D:  BSF    03.6
045E:  MOVWF  3E
045F:  MOVF   79,W
0460:  MOVWF  3D
0461:  MOVF   78,W
0462:  MOVWF  3C
0463:  MOVF   77,W
0464:  MOVWF  3B
....................          s[cnt]=(num%base)+'0';    // Conversion 
0465:  MOVF   41,W
0466:  ADDWF  39,W
0467:  MOVWF  78
0468:  MOVF   3A,W
0469:  MOVWF  7A
046A:  BTFSC  03.0
046B:  INCF   7A,F
046C:  MOVF   78,W
046D:  MOVWF  43
046E:  MOVF   7A,W
046F:  MOVWF  44
0470:  CLRF   46
0471:  MOVF   04,W
0472:  MOVWF  45
0473:  BCF    46.0
0474:  BTFSC  03.7
0475:  BSF    46.0
0476:  BSF    03.1
0477:  MOVLW  47
0478:  MOVWF  04
0479:  BSF    03.7
047A:  MOVF   37,W
047B:  MOVWF  4E
047C:  MOVF   36,W
047D:  MOVWF  4D
047E:  MOVF   35,W
047F:  MOVWF  4C
0480:  MOVF   34,W
0481:  MOVWF  4B
0482:  CLRF   52
0483:  CLRF   51
0484:  CLRF   50
0485:  MOVF   38,W
0486:  MOVWF  4F
0487:  BCF    03.6
0488:  CALL   37A
0489:  BSF    03.6
048A:  MOVF   45,W
048B:  MOVWF  04
048C:  BCF    03.7
048D:  BTFSC  46.0
048E:  BSF    03.7
048F:  MOVLW  30
0490:  ADDWF  47,W
0491:  MOVWF  77
0492:  MOVF   48,W
0493:  MOVWF  78
0494:  MOVLW  00
0495:  BTFSC  03.0
0496:  MOVLW  01
0497:  ADDWF  78,F
0498:  MOVF   49,W
0499:  MOVWF  79
049A:  MOVLW  00
049B:  BTFSC  03.0
049C:  MOVLW  01
049D:  ADDWF  79,F
049E:  MOVF   4A,W
049F:  MOVWF  7A
04A0:  MOVLW  00
04A1:  BTFSC  03.0
04A2:  MOVLW  01
04A3:  ADDWF  7A,F
04A4:  MOVF   43,W
04A5:  MOVWF  04
04A6:  BCF    03.7
04A7:  BTFSC  44.0
04A8:  BSF    03.7
04A9:  MOVF   77,W
04AA:  MOVWF  00
....................  
....................          if(s[cnt]>0x39) 
04AB:  MOVF   41,W
04AC:  ADDWF  39,W
04AD:  MOVWF  04
04AE:  BCF    03.7
04AF:  BTFSC  3A.0
04B0:  BSF    03.7
04B1:  MOVF   00,W
04B2:  SUBLW  39
04B3:  BTFSC  03.0
04B4:  GOTO   4BE
....................             s[cnt]+=0x7; 
04B5:  MOVF   41,W
04B6:  ADDWF  39,W
04B7:  MOVWF  04
04B8:  BCF    03.7
04B9:  BTFSC  3A.0
04BA:  BSF    03.7
04BB:  MOVLW  07
04BC:  ADDWF  00,W
04BD:  MOVWF  00
....................  
....................          cnt++; 
04BE:  INCF   41,F
....................          num=temp; 
04BF:  MOVF   3E,W
04C0:  MOVWF  37
04C1:  MOVF   3D,W
04C2:  MOVWF  36
04C3:  MOVF   3C,W
04C4:  MOVWF  35
04C5:  MOVF   3B,W
04C6:  MOVWF  34
04C7:  GOTO   440
....................      } 
....................  
....................      if(sign==1) { 
04C8:  DECFSZ 40,W
04C9:  GOTO   4D3
....................          s[cnt]=0x2D;      // Negative sign 
04CA:  MOVF   41,W
04CB:  ADDWF  39,W
04CC:  MOVWF  04
04CD:  BCF    03.7
04CE:  BTFSC  3A.0
04CF:  BSF    03.7
04D0:  MOVLW  2D
04D1:  MOVWF  00
....................          cnt++; 
04D2:  INCF   41,F
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
04D3:  CLRF   3F
04D4:  BCF    03.0
04D5:  RRF    41,W
04D6:  SUBWF  3F,W
04D7:  BTFSC  03.0
04D8:  GOTO   509
....................  
....................          c=s[i]; 
04D9:  MOVF   3F,W
04DA:  ADDWF  39,W
04DB:  MOVWF  04
04DC:  BCF    03.7
04DD:  BTFSC  3A.0
04DE:  BSF    03.7
04DF:  MOVF   00,W
04E0:  MOVWF  42
....................          s[i]=s[cnt-i-1];        // Reverse the number 
04E1:  MOVF   3F,W
04E2:  ADDWF  39,W
04E3:  MOVWF  78
04E4:  MOVF   3A,W
04E5:  MOVWF  7A
04E6:  BTFSC  03.0
04E7:  INCF   7A,F
04E8:  MOVF   78,W
04E9:  MOVWF  43
04EA:  MOVF   7A,W
04EB:  MOVWF  44
04EC:  MOVF   3F,W
04ED:  SUBWF  41,W
04EE:  ADDLW  FF
04EF:  ADDWF  39,W
04F0:  MOVWF  04
04F1:  BCF    03.7
04F2:  BTFSC  3A.0
04F3:  BSF    03.7
04F4:  MOVF   00,W
04F5:  MOVWF  45
04F6:  MOVF   43,W
04F7:  MOVWF  04
04F8:  BCF    03.7
04F9:  BTFSC  44.0
04FA:  BSF    03.7
04FB:  MOVF   45,W
04FC:  MOVWF  00
....................          s[cnt-i-1]=c; 
04FD:  MOVF   3F,W
04FE:  SUBWF  41,W
04FF:  ADDLW  FF
0500:  ADDWF  39,W
0501:  MOVWF  04
0502:  BCF    03.7
0503:  BTFSC  3A.0
0504:  BSF    03.7
0505:  MOVF   42,W
0506:  MOVWF  00
0507:  INCF   3F,F
0508:  GOTO   4D4
....................      } 
....................      s[cnt]='\0';     // End the string 
0509:  MOVF   41,W
050A:  ADDWF  39,W
050B:  MOVWF  04
050C:  BCF    03.7
050D:  BTFSC  3A.0
050E:  BSF    03.7
050F:  CLRF   00
....................      return s; 
0510:  MOVF   39,W
0511:  MOVWF  78
0512:  MOVF   3A,W
0513:  MOVWF  79
0514:  BCF    03.6
0515:  RETURN
.................... } 
....................  
.................... #if defined(__PCD__) 
....................  
.................... char * itoa(signed int48 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int48 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... char * itoa(signed int64 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int64 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................       
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1;         
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................              
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #endif 
....................  
.................... float strtof(char *s, char *endptr) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s, char *endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float48)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float48)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s, char *endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float64)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float64)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtoulGO; 
....................  
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................    { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... int8 mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #if !defined(__PCD__) 
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2);  
.................... #else  
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2);  
.................... #endif 
....................  
....................  
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    unsigned int8 t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=1; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = 0; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
.................... #INCLUDE <STDIO.H> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDIO 
.................... #define _STDIO 
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #ifndef getc 
.................... #define getc getch 
.................... #define getchar getch 
.................... #define puts(s) {printf(s); putchar(13); putchar(10);} 
.................... #define putc putchar 
.................... #endif 
.................... /* maps error number to an error message. Writes a sequence of characters to 
.................... stderr stream thus: if s is not null then string pointed to by s follwed by 
.................... a colon (:) and a space and the appropriate error message returned by strerror 
.................... function with argument errno 
....................  
.................... Returns: no value 
.................... */ 
....................  
.................... #ifdef _ERRNO 
.................... void perror(char *s) 
.................... { 
....................   if(s) 
....................   fprintf(STDERR,"%s: ",s); 
....................   fprintf(STDERR,"%s\r\n",strerror(errno)); 
.................... } 
.................... #endif 
.................... #endif 
....................  
.................... #INCLUDE <MATH.H> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2011 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                    //// 
.................... //// History:                                                           //// 
.................... ////  * 9/20/2001 :  Improvments are made to sin/cos code.              //// 
.................... ////                 The code now is small, much faster,                //// 
.................... ////                 and more accurate.                                 //// 
.................... ////  * 2/21/2007 :  Compiler handles & operator differently and does   //// 
.................... ////                 not return generic (int8 *) so type cast is done   //// 
.................... ////  * 6/19/2010 :  Divisions by constants converted to multiplication //// 
.................... ////                 by its inverse to improve computation speed        //// 
.................... ////  * 1/21/2011 :  Constants used for double precision math updated   //// 
.................... ////                 Updated routines include 64 bit versions of cos,   //// 
.................... ////                 asin,atan,exp,log and dependant functions          //// 
.................... ////  * 1/31/2011 :  Optimized current 32-bit float routines for cos    //// 
.................... ////                 and log function                                   //// 
.................... ////  * 6/13/2011 :  Fixed PCD overload CEIL_FLOOR functions for values //// 
.................... ////                 greater then 10000000 and less then -10000000      //// 
.................... ////                                                                    //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef MATH_H 
.................... #define MATH_H 
....................  
.................... #ifdef PI 
.................... #undef  PI 
.................... #endif 
.................... #define PI     3.1415926535897932 
....................  
....................  
.................... #define SQRT2  1.4142135623730950 
....................  
.................... //float const ps[4] = {5.9304945, 21.125224, 8.9403076, 0.29730279}; 
.................... //float const qs[4] = {1.0000000, 15.035723, 17.764134, 2.4934718}; 
....................  
.................... ///////////////////////////// Round Functions ////////////////////////////// 
....................  
.................... float32 CEIL_FLOOR(float32 x, unsigned int8 n) 
.................... { 
....................    float32 y, res; 
....................    unsigned int16 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................       res = (float32)(unsigned int16)y; 
....................  
....................  else if (y < 10000000.0) 
....................    {  
....................       l = (unsigned int16)(y*0.000030517578125); 
....................       y = 32768.0*(y*0.000030517578125 - (float32)l); 
....................       res = 32768.0*(float32)l; 
....................       res += (float32)(unsigned int16)y; 
....................    } 
....................  
....................  else 
....................   res = y; 
....................  
....................  y = y - (float32)(unsigned int16)y; 
....................  
....................  if (s) 
....................   res = -res; 
....................  
....................  if (y != 0) 
....................  { 
....................   if (s == 1 && n == 0) 
....................    res -= 1.0; 
....................  
....................   if (s == 0 && n == 1) 
....................    res += 1.0; 
....................  } 
....................  if (x == 0) 
....................     res = 0; 
....................  
....................  return (res); 
.................... } 
....................  
.................... // Overloaded Functions to take care for new Data types in PCD 
.................... // Overloaded function CEIL_FLOOR() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 CEIL_FLOOR(float48 x, unsigned int8 n) 
.................... { 
....................    float48 y, res; 
....................    unsigned int32 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................       res = (float48)(unsigned int16)y; 
....................  
....................    else if (y < 549755813888.0) 
....................    { 
....................       l = (unsigned int32)(y*0.000030517578125); 
....................       y = 32768.0*(y*0.000030517578125 - (float48)l); 
....................       res = 32768.0*(float48)l; 
....................       res += (float48)(unsigned int16)y; 
....................    } 
....................    else 
....................    {   
....................       res = y; 
....................       y = 0.0; 
....................    } 
....................     
....................    if(y != 0) 
....................       y = y - (float48)(unsigned int16)y; 
....................  
....................    if (s) 
....................       res = -res; 
....................  
....................    if (y != 0) 
....................    { 
....................       if (s == 1 && n == 0) 
....................          res -= 1.0; 
....................  
....................       if (s == 0 && n == 1) 
....................          res += 1.0; 
....................    } 
....................    if (x == 0) 
....................       res = 0; 
....................  
....................    return (res); 
.................... } 
....................  
....................  
.................... // Overloaded function CEIL_FLOOR() for data type - Float64 
.................... float64 CEIL_FLOOR(float64 x, unsigned int8 n) 
.................... { 
....................    float64 y, res; 
....................    int64 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................       res = (float64)(unsigned int16)y; 
....................    else if (y < 4503599627370496.0) 
....................    { 
....................       l = (int64)(y*0.000030517578125); 
....................       y = 32768.0*(y*0.000030517578125 - (float64)l); 
....................       res = 32768.0*(float64)l; 
....................       res += (float64)(unsigned int16)y; 
....................    } 
....................    else 
....................    { 
....................       res = y; 
....................       y = 0.0; 
....................    } 
....................     
....................    if(y != 0) 
....................       y = y - (float64)(unsigned int16)y; 
....................  
....................    if (s) 
....................       res = -res; 
....................  
....................    if (y != 0) 
....................    { 
....................       if (s == 1 && n == 0) 
....................          res -= 1.0; 
....................  
....................       if (s == 0 && n == 1) 
....................          res += 1.0; 
....................    } 
....................     
....................    if (x == 0) 
....................       res = 0; 
....................  
....................    return (res); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float floor(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : rounds down the number x. 
.................... // Date : N/A 
.................... // 
.................... float32 floor(float32 x) 
.................... { 
....................    return CEIL_FLOOR(x,0); 
.................... } 
.................... // Following 2 functions are overloaded functions of floor() for PCD 
.................... // Overloaded function floor() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 floor(float48 x) 
.................... { 
....................    return CEIL_FLOOR(x, 0); 
.................... } 
....................  
.................... // Overloaded function floor() for data type - Float64 
.................... float64 floor(float64 x) 
.................... { 
....................    return CEIL_FLOOR(x, 0); 
.................... } 
.................... #endif 
....................  
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float ceil(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : rounds up the number x. 
.................... // Date : N/A 
.................... // 
.................... float32 ceil(float32 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
.................... // Following 2 functions are overloaded functions of ceil() for PCD 
.................... // Overloaded function ceil() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 ceil(float48 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
....................  
.................... // Overloaded function ceil() for data type - Float64 
.................... float64 ceil(float64 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
.................... #endif 
....................  
....................  //////////////////////////////////////////////////////////////////////////// 
.................... //   float fabs(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the absolute value of floating point number x 
.................... // Returns : returns the absolute value of x 
.................... // Date : N/A 
.................... // 
.................... #define fabs abs 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float fmod(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the floating point remainder of x/y 
.................... // Returns : returns the value of x= i*y, for some integer i such that, if y 
.................... // is non zero, the result has the same isgn of x na dmagnitude less than the 
.................... // magnitude of y. If y is zero then a domain error occurs. 
.................... // Date : N/A 
.................... // 
....................  
.................... float fmod(float32 x,float32 y) 
.................... { 
....................    float32 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... //Overloaded function for fmod() for PCD 
.................... // Overloaded function fmod() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 fmod(float48 x,float48 y) 
.................... { 
....................    float48 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... // Overloaded function fmod() for data type - Float64 
.................... float64 fmod(float64 x,float64 y) 
.................... { 
....................    float64 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... #endif 
.................... //////////////////// Exponential and logarithmic functions //////////////////// 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float exp(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (e^x) 
.................... // Date : N/A 
.................... // 
.................... #define LN2 0.6931471805599453 
.................... #define LN2_INV 1.4426950408889634073 
....................  
.................... float const pe[6] = {0.000207455774, 0.00127100575, 0.00965065093, 
....................                      0.0554965651,  0.240227138,  0.693147172}; 
....................  
....................  
.................... float32 exp(float32 x) 
.................... { 
....................    float32 y, res, r; 
....................    #if defined(__PCD__) 
....................    int8 data1; 
....................    #endif 
....................    signed int8 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 88.722838) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    n = (signed int16)(x*LN2_INV); 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
.................... #if !defined(__PCD__) 
....................    *((unsigned int8 *)(&res)) = n + 0x7F; 
.................... #endif 
....................  
.................... #if defined(__PCD__)  // Takes care of IEEE format for PCD 
....................    data1 = n+0x7F; 
....................    if(bit_test(data1,0)) 
....................    bit_set(*(((unsigned int8 *)(&res)+2)),7); 
....................    rotate_right(&data1,1); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&res)+3)) = data1; 
.................... #endif 
....................  
....................    y = y*LN2_INV - (float32)n; 
....................  
....................    r = pe[0]*y + pe[1]; 
....................    r = r*y + pe[2]; 
....................    r = r*y + pe[3]; 
....................    r = r*y + pe[4]; 
....................    r = r*y + pe[5]; 
....................  
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
....................  
....................  
.................... //Overloaded function for exp() for PCD 
.................... // Overloaded function exp() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 exp(float48 x) 
.................... { 
....................    float48 y, res, r; 
....................    int8 data1; 
....................    signed int8 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 88.722838) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    n = (signed int16)(x*LN2_INV); 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
....................  
....................    data1 = n+0x7F; 
....................    if(bit_test(data1,0)) 
....................    bit_set(*(((unsigned int8 *)(&res)+4)),7); 
....................    rotate_right(&data1,1); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&res)+5)) = data1; 
....................  
....................    y = y*LN2_INV - (float48)n; 
....................  
....................    r = pe[0]*y + pe[1]; 
....................    r = r*y + pe[2]; 
....................    r = r*y + pe[3]; 
....................    r = r*y + pe[4]; 
....................    r = r*y + pe[5]; 
....................  
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function exp() for data type - Float64 
.................... float64 const pe_64[12] ={9.30741400474913e-011,-4.28655416283316e-011, 
....................                           8.71486547014137e-009,9.84458531538385e-008, 
....................                           1.32588296983536e-006,1.52489283823016e-005, 
....................                           0.000154037598423921,0.00133335487036216, 
....................                           0.00961812936407326,0.0555041086222122, 
....................                           0.240226506962827,0.693147180559823}; 
....................  
.................... float64 exp(float64 x) 
.................... { 
....................    float64 y, res, r; 
....................    unsigned int16 data1, data2; 
....................    unsigned int16 *p; 
....................    signed int16 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 709.7827128) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x*LN2_INV; 
....................    n = (signed int16)y; 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
....................  
.................... #if !defined(__PCD__) 
....................    *((unsigned int16 *)(&res)) = n + 0x7F; 
.................... #endif 
....................    p= (((unsigned int16 *)(&res))+3); 
....................    data1 = *p; 
....................    data2 = *p;    
....................    data1 = n + 0x3FF; 
....................    data1 = data1 <<4; 
....................    if(bit_test(data2,15)) 
....................    bit_set(data1,15); 
....................    data2 = data2 & 0x000F; 
....................    data1 ^= data2; 
....................  
....................    *(((unsigned int16 *)(&res)+3)) = data1; 
....................  
....................  
....................    y = y*LN2_INV - (float64)n; 
....................  
....................    r = pe_64[0]*y + pe_64[1]; 
....................    r = r*y + pe_64[2]; 
....................    r = r*y + pe_64[3]; 
....................    r = r*y + pe_64[4]; 
....................    r = r*y + pe_64[5]; 
....................    r = r*y + pe_64[6]; 
....................    r = r*y + pe_64[7]; 
....................    r = r*y + pe_64[8]; 
....................    r = r*y + pe_64[9]; 
....................    r = r*y + pe_64[10]; 
....................    r = r*y + pe_64[11]; 
....................     
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
.................... #ENDIF 
....................  
....................  
.................... /************************************************************/ 
....................  
.................... float32 const pl[4] = {-1.080310025160955, 1.999999947089217}; 
.................... float32 const ql[4] = {0.091284365719509, -0.873491916557671}; 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float log(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the the natural log of x 
.................... // Date : N/A 
.................... // 
.................... float32 log(float32 x) 
.................... { 
....................    float32 y, res, r, y2; 
....................    #if defined(__PCD__) 
....................    unsigned int8  data1,data2; 
....................    #endif 
....................    signed int8 n; 
....................    #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
.................... #if !defined(__PCD__) 
....................     *((unsigned int8 *)(&y)) = 0x7E;  
.................... #endif 
....................  
.................... #if defined(__PCD__) // Takes care of IEEE format 
....................    data2 = *(((unsigned int8 *)(&y))+3); 
....................    *(((unsigned int8 *)(&y))+3) = 0x3F; 
....................    data1 = *(((unsigned int8 *)(&y))+2); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&y))+2) = data1; 
....................    if(bit_test(data2,7)) 
....................      bit_set(*(((unsigned int8 *)(&y))+3),7); 
.................... #endif 
....................  
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl[0]*y2 + pl[1]; 
....................  
....................       r = ql[0]*y2 + ql[1]; 
....................       r = r*y2 + 1.0; 
....................  
....................       res = y*res/r; 
.................... #if !defined(__PCD__) 
....................       n = *((unsigned int8 *)(&x)) - 0x7E; 
.................... #endif 
.................... #if defined(__PCD__)  
....................     data1 = *(((unsigned int8 *)(&x)+3)); 
....................     rotate_left(&data1,1); 
....................     data2 = *(((unsigned int8 *)(&x)+2)); 
....................     if(bit_test (data2,7)) 
....................       bit_set(data1,0); 
....................     n = data1 - 0x7E; 
.................... #endif 
....................  
....................       if (n<0)  
....................          r = -(float32)-n; 
....................       else 
....................          r = (float32)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................       res = 0.0; 
....................  
....................    return(res); 
.................... } 
....................  
.................... //Overloaded function for log() for PCD 
.................... // Overloaded function log() for data type - Float48 
.................... #if defined(__PCD__) 
.................... // Overloaded function log() for data type - float64 
.................... float64 const pl_64[4] = {-0.145694052150681, 1.365485300000370, 
....................                           -3.120535668274329, 2.000000000000000}; 
....................  
.................... float64 const ql_64[4] = {0.006047500465908, -0.208298281937234, 
....................                           1.113943039156721, -1.893601167470470}; 
....................  
.................... float48 log(float48 x) 
.................... { 
....................    float48 y, res, r, y2; 
....................    unsigned int8  data1,data2; 
....................    signed int8 n; 
.................... #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
.................... #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
....................  
.................... #if !defined(__PCD__) 
....................       *((unsigned int8 *)(&y)) = 0x7E;  
.................... #endif 
....................       data2 = *(((unsigned int8 *)(&y))+5); 
....................       *(((unsigned int8 *)(&y))+5) = 0x3F; 
....................       data1 = *(((unsigned int8 *)(&y))+4); 
....................       bit_clear(data1,7); 
....................       *(((unsigned int8 *)(&y))+4) = data1; 
....................  
....................       if(bit_test(data2,7)) 
....................       bit_set(*(((unsigned int8 *)(&y))+4),7); 
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl_64[0]*y2 + pl_64[1]; 
....................       res = res*y2 + pl_64[2]; 
....................       res = res*y2 + pl_64[3]; 
....................  
....................       r = ql_64[0]*y2 + ql_64[1]; 
....................       r = r*y2 + ql_64[2]; 
....................       r = r*y2 + ql_64[3]; 
....................       r = r*y2 + 1.0;  
....................       res = y*res/r; 
....................  
....................       data1 = *(((unsigned int8 *)(&x)+5)); 
....................       rotate_left(&data1,1); 
....................       data2 = *(((unsigned int8 *)(&x)+4)); 
....................       if(bit_test (data2,7)) 
....................       bit_set(data1,0); 
....................        
....................       n = data1 - 0x7E; 
....................  
....................       if (n<0) 
....................       r = -(float48)-n; 
....................       else 
....................       r = (float48)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................    res = 0.0; 
....................  
....................    return(res); 
.................... } 
....................  
.................... float64 log(float64 x) 
.................... { 
....................    float64 y, res, r, y2; 
....................    unsigned int16  data1,data2; 
....................    unsigned int16 *p; 
....................    signed int16 n; 
....................    #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
....................    #if !defined(__PCD__) 
....................        *((unsigned int8 *)(&y)) = 0x7E;  
....................    #endif 
....................       p= (((unsigned int16 *)(&y))+3); 
....................       data1 = *p; 
....................       data2 = *p; 
....................       data1 = 0x3FE; 
....................       data1 = data1 <<4; 
....................       if(bit_test (data2,15)) 
....................          bit_set(data1,15); 
....................       data2 = data2 & 0x000F; 
....................       data1 ^=data2; 
....................  
....................       *p = data1; 
....................  
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl_64[0]*y2 + pl_64[1]; 
....................       res = res*y2 + pl_64[2]; 
....................       res = res*y2 + pl_64[3]; 
....................  
....................       r = ql_64[0]*y2 + ql_64[1]; 
....................       r = r*y2 + ql_64[2]; 
....................       r = r*y2 + ql_64[3]; 
....................       r = r*y2 + 1.0; 
....................  
....................       res = y*res/r; 
....................   
....................       p= (((unsigned int16 *)(&x))+3); 
....................       data1 = *p; 
....................       bit_clear(data1,15); 
....................       data1 = data1 >>4;     
....................       n = data1 - 0x3FE; 
....................  
....................  
....................       if (n<0) 
....................          r = -(float64)-n; 
....................       else 
....................          r = (float64)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................       res = 0.0; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
....................  
.................... #define LN10 2.3025850929940456 
.................... #define LN10_INV 0.4342944819032518276 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float log10(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the the log base 10 of x 
.................... // Date : N/A 
.................... // 
.................... float32 log10(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = log(x); 
....................    r = r*LN10_INV; 
....................    return(r); 
.................... } 
....................  
.................... //Overloaded functions for log10() for PCD 
.................... // Overloaded function log10() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 log10(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = log(x); 
....................    r = r*LN10_INV; 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function log10() for data type - Float64 
.................... float64 log10(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = log(x); 
....................    r = r*LN10_INV; 
....................    return(r); 
.................... } 
.................... #endif 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float modf(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description :breaks the argument value int integral and fractional parts, 
.................... // ach of which have the same sign as the argument.  It stores the integral part 
.................... // as a float in the object pointed to by the iptr 
.................... // Returns : returns the signed fractional part of value. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 modf(float32 value,float32 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... //Overloaded functions for modf() for PCD 
.................... // Overloaded function modf() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 modf(float48 value,float48 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... // Overloaded function modf() for data type - Float64 
.................... float64 modf(float64 value,float64 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float pwr(float x,float y) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (x^y) 
.................... // Date : N/A 
.................... // Note : 0 is returned when the function will generate an imaginary number 
.................... // 
.................... float32 pwr(float32 x,float32 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... //Overloaded functions for pwr() for PCD 
.................... // Overloaded function pwr() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 pwr(float48 x,float48 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... // Overloaded function pwr() for data type - Float64 
.................... float64 pwr(float64 x,float64 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////// Power functions //////////////////// 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float pow(float x,float y) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (x^y) 
.................... // Date : N/A 
.................... // Note : 0 is returned when the function will generate an imaginary number 
.................... // 
.................... float32 pow(float32 x,float32 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... //Overloaded functions for pow() for PCD 
.................... // Overloaded function for pow() data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 pow(float48 x,float48 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
....................  
.................... // Overloaded function pow() for data type - Float64 
.................... float64 pow(float64 x,float64 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sqrt(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the square root of x 
.................... // Date : N/A 
.................... // 
.................... float32 sqrt(float32 x) 
.................... { 
....................    float32 y, res; 
....................    #if defined(__PCD__) 
....................    unsigned int16 data1,data2; 
....................    #endif 
....................    unsigned int8 *p; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................     
....................    #if !defined(__PCD__) 
....................     p=&y; 
....................    (*p)=(unsigned int8)((((unsigned int16)(*p)) + 127) >> 1); 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     p = (((unsigned int8 *)(&y))+3); 
....................     data1 = *(((unsigned int8 *)(&y))+3); 
....................     data2 = *(((unsigned int8 *)(&y))+2); 
....................     rotate_left(&data1,1);     
....................     if(bit_test(data2,7))     
....................        bit_set(data1,0);     
....................     data1 = ((data1+127) >>1); 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+3) = data1; 
....................     *(((unsigned int8 *)(&y))+2) = data2; 
....................      
....................   #endif 
....................  
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................  
....................       #if !defined(__PCD__) 
....................      (*p)--; 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     data1 = *(((unsigned int8 *)(&y))+3); 
....................     data2 = *(((unsigned int8 *)(&y))+2); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................        bit_set(data1,0);     
....................     data1--; 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+3) = data1; 
....................     *(((unsigned int8 *)(&y))+2) = data2; 
....................      
....................   #endif 
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
.................... //Overloaded functions for sqrt() for PCD 
.................... // Overloaded function sqrt() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sqrt(float48 x) 
.................... { 
....................    float48 y, res; 
....................    unsigned int16 data1,data2; 
....................    unsigned int8 *p; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................     
....................    #if !defined(__PCD__) 
....................     p=&y; 
....................    (*p)=(unsigned int8)((((unsigned int16)(*p)) + 127) >> 1); 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     p = (((unsigned int8 *)(&y))+5); 
....................     data1 = *(((unsigned int8 *)(&y))+5); 
....................     data2 = *(((unsigned int8 *)(&y))+4); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................        bit_set(data1,0);     
....................     data1 = ((data1+127) >>1); 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+5) = data1; 
....................     *(((unsigned int8 *)(&y))+4) = data2; 
....................      
....................   #endif 
....................  
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................  
....................       #if !defined(__PCD__) 
....................      (*p)--; 
....................    #endif 
....................     
....................     data1 = *(((unsigned int8 *)(&y))+5); 
....................     data2 = *(((unsigned int8 *)(&y))+4); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................        bit_set(data1,0);     
....................     data1--; 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+5) = data1; 
....................     *(((unsigned int8 *)(&y))+4) = data2; 
....................      
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function sqrt() for data type - Float64 
.................... float64 sqrt(float64 x) 
.................... { 
....................    float64 y, res; 
....................    unsigned int16 *p; 
....................    unsigned int16 temp1,temp2; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................    p= (((unsigned int16 *)(&y))+3); 
....................    temp1 = *p; 
....................    temp2 = *p; 
....................    bit_clear(temp1,15); 
....................    temp1 = (temp1>>4)+1023; 
....................    temp1 = temp1 >> 1; 
....................    temp1 = (temp1<<4) & 0xFFF0; 
....................    if(bit_test(temp2,15)) 
....................       bit_set(temp1,15); 
....................    temp2 = temp2 & 0x000F; 
....................    temp1 ^= temp2; 
....................     
....................    (*p) = temp1; 
....................     
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................      temp1 = *p; 
....................      temp2 = *p; 
....................      bit_clear(temp1,15); 
....................      temp1 = (temp1>>4); 
....................      temp1--; 
....................      temp1 = (temp1<<4) & 0xFFF0; 
....................      if(bit_test(temp2,15)) 
....................         bit_set(temp1,15); 
....................      temp2 = temp2 & 0x000F; 
....................      temp1 ^= temp2; 
....................      (*p) = temp1; 
....................  
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... ////////////////////////////// Trig Functions ////////////////////////////// 
.................... #ifdef PI_DIV_BY_TWO_INV 
.................... #undef PI_DIV_BY_TWO_INV 
.................... #endif 
.................... #define PI_DIV_BY_TWO_INV 0.63661977236758134 
.................... #ifdef PI_DIV_BY_TWO 
.................... #undef PI_DIV_BY_TWO 
.................... #endif 
.................... #define PI_DIV_BY_TWO   1.5707963267948966 
.................... #ifdef TWOBYPI 
.................... #undef TWOBYPI 
.................... #endif 
.................... #define TWOBYPI          0.6366197723675813 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float cos(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the cosine value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 cos(float32 x) 
.................... { 
....................    float32 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float32 frac; 
....................    float32 p[5] = {                    //by the series definition for cosine 
....................       -0.49999999456337096,            // sum ( ( (-1)^n * x^2n )/(2n)! ) 
....................        0.04166663896921267, 
....................       -0.00138883894522527, 
....................        0.00002476138231734, 
....................       -0.00000026070414770 
....................       //-0.00000000001147, 
....................       // 0.00000000000005 
....................    }; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant 
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 1.0; 
....................    t = t * t; 
....................    for (i = 0; i <= 4; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
....................  
.................... //Overloaded functions for cos() for PCD 
.................... // Overloaded function cos() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 cos(float48 x) 
.................... { 
....................    float48 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float48 frac; 
....................    float48 p[6] = {                    //by the series definition for cosine 
....................       -0.5,                            // sum ( ( (-1)^n * x^2n )/(2n)! ) 
....................        0.04166666666667, 
....................       -0.00138888888889, 
....................        0.00002480158730, 
....................       -0.00000027557319, 
....................        0.00000000208767, 
....................       //-0.00000000001147, 
....................       // 0.00000000000005 
....................    }; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant 
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 0.999999999781; 
....................    t = t * t; 
....................    for (i = 0; i <= 5; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
.................... // Overloaded function cos() for data type - Float64 
.................... float64 cos(float64 x) 
.................... { 
....................    float64 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float64 frac; 
....................    float64 p_64[9] = {               //by the series definition for cosine 
....................      -0.49999999999998740,           // sum ( ( (-1)^n * x^2n )/(2n)! )              
....................       0.04166666666656518, 
....................      -0.00138888888851691, 
....................       0.00002480158658490, 
....................      -0.00000027557239796, 
....................       0.00000000208715031, 
....................      -0.00000000001126577, 
....................       0.00000000000000427, 
....................       0.00000000000000372}; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant 
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 1.0; 
....................    t = t * t; 
....................    for (i = 0; i <= 8; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p_64[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sin(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the sine value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 sin(float32 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
....................  
.................... //Overloaded functions for sin() for PCD 
.................... // Overloaded function sin() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sin(float48 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
....................  
.................... // Overloaded function sin() for data type - Float48 
.................... float64 sin(float64 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float tan(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the tangent value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 tan(float32 x) 
.................... { 
....................    float32 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
.................... //Overloaded functions for tan() for PCD 
.................... // Overloaded function tan() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 tan(float48 x) 
.................... { 
....................    float48 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
....................  
.................... // Overloaded function tan() for data type - Float48 
.................... float64 tan(float64 x) 
.................... { 
....................    float64 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
.................... #endif 
....................  
.................... float32 const pas[3] = {0.49559947, -4.6145309, 5.6036290}; 
.................... float32 const qas[3] = {1.0000000,  -5.5484666, 5.6036290}; 
....................  
.................... float32 ASIN_COS(float32 x, unsigned int8 n) 
.................... { 
....................    float32 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)*0.5); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas[0]*y2 + pas[1]; 
....................    res = res*y2 + pas[2]; 
....................  
....................    r = qas[0]*y2 + qas[1]; 
....................    r = r*y2 + qas[2]; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
....................  
....................  
.................... //Overloaded functions for ASIN_COS() for PCD 
.................... // Overloaded function ASIN_COS() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 ASIN_COS(float48 x, unsigned int8 n) 
.................... { 
....................    float48 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)*0.5); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas[0]*y2 + pas[1]; 
....................    res = res*y2 + pas[2]; 
....................  
....................    r = qas[0]*y2 + qas[1]; 
....................    r = r*y2 + qas[2]; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function ASIN_COS() for data type - Float64 
.................... double pas_64[5]={1.000000000000000,-2.069938587724477,1.421444580548907, 
....................                  -0.360690137621842,0.024929451660228}; 
....................  
.................... double qas_64[5]={-2.236605254391134,1.719212122946451,-0.524122954476133, 
....................                    0.052808872045749,-0.000662536036570}; 
....................                     
.................... float64 ASIN_COS(float64 x, unsigned int8 n) 
.................... { 
....................    float64 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)*0.5); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas_64[4]*y2 + pas_64[3]; 
....................    res = res*y2 + pas_64[2]; 
....................    res = res*y2 + pas_64[1]; 
....................    res = res*y2 + pas_64[0]; 
....................  
....................    r = qas_64[4]*y2 + qas_64[3]; 
....................    r = r*y2 + qas_64[2]; 
....................    r = r*y2 + qas_64[1]; 
....................    r = r*y2 + qas_64[0]; 
....................    r = r*y2 + 1.0; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float asin(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arcsine value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 asin(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
.................... //Overloaded functions for asin() for PCD 
.................... // Overloaded function asin() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 asin(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function asin() for data type - Float64 
.................... float64 asin(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float acos(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arccosine value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 acos(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
.................... //Overloaded functions for acos() for PCD 
.................... // Overloaded function acos() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 acos(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function acos() for data type - Float64 
.................... float64 acos(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
.................... #endif 
....................  
.................... float32 const pat[4] = {0.17630401, 5.6710795, 22.376096, 19.818457}; 
.................... float32 const qat[4] = {1.0000000,  11.368190, 28.982246, 19.818457}; 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float atan(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arctangent value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 atan(float32 x) 
.................... { 
....................    float32 y, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................  
....................    res = pat[0]*y*y + pat[1]; 
....................    res = res*y*y + pat[2]; 
....................    res = res*y*y + pat[3]; 
....................  
....................    r = qat[0]*y*y + qat[1]; 
....................    r = r*y*y + qat[2]; 
....................    r = r*y*y + qat[3]; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
.................... //Overloaded functions for atan() for PCD 
.................... // Overloaded function atan() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 atan(float48 x) 
.................... { 
....................    float48 y, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................  
....................    res = pat[0]*y*y + pat[1]; 
....................    res = res*y*y + pat[2]; 
....................    res = res*y*y + pat[3]; 
....................  
....................    r = qat[0]*y*y + qat[1]; 
....................    r = r*y*y + qat[2]; 
....................    r = r*y*y + qat[3]; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
....................  
.................... float64 pat_64[6]={0.999999999999999,2.249923645595566,1.771541617806449, 
....................                    0.579678874003185,0.072162702162882,0.002281100141660}; 
....................  
.................... float64 qat_64[6]={2.583256978928510,2.432627277466967,1.016760379885393, 
....................                    0.182482977188688,0.011155377971690,0.000100013019160}; 
.................... // Overloaded function atan() for data type - Float64 
.................... float64 atan(float64 x) 
.................... { 
....................    float64 y,y2, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................    y2 = y*y; 
....................    res = pat_64[5]*y2 + pat_64[4]; 
....................    res = res*y2 + pat_64[3]; 
....................    res = res*y2 + pat_64[2]; 
....................    res = res*y2 + pat_64[1]; 
....................    res = res*y2 + pat_64[0]; 
....................  
....................    r = qat_64[5]*y2 + qat_64[4]; 
....................    r = r*y2 + qat_64[3]; 
....................    r = r*y2 + qat_64[2]; 
....................    r = r*y2 + qat_64[1]; 
....................    r = r*y2 + qat_64[0]; 
....................    r = r*y2 + 1.0; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... ///////////////////////////////////////////////////////////////////////////// 
.................... //   float atan2(float y, float x) 
.................... ///////////////////////////////////////////////////////////////////////////// 
.................... // Description :computes the principal value of arc tangent of y/x, using the 
.................... // signs of both the arguments to determine the quadrant of the return value 
.................... // Returns : returns the arc tangent of y/x. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 atan2(float32 y,float32 x) 
.................... { 
....................    float32 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
....................  
.................... //Overloaded functions for atan2() for PCD 
.................... // Overloaded function atan2() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 atan2(float48 y,float48 x) 
.................... { 
....................    float48 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
....................  
.................... // Overloaded function atan2() for data type - Float64 
.................... float64 atan2(float64 y,float64 x) 
.................... { 
....................    float64 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////// Hyperbolic functions //////////////////// 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float cosh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic cosine value of x 
.................... // Returns : returns the hyperbolic cosine value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 cosh(float32 x) 
.................... { 
....................    return ((exp(x)+exp(-x))*0.5); 
.................... } 
.................... //Overloaded functions for cosh() for PCD 
.................... // Overloaded function cosh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 cosh(float48 x) 
.................... { 
....................    return ((exp(x)+exp(-x))*0.5); 
.................... } 
....................  
.................... // Overloaded function cosh() for data type - Float64 
.................... float64 cosh(float64 x) 
.................... { 
....................    return ((exp(x)+exp(-x))*0.5); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sinh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic sine value of x 
.................... // Returns : returns the hyperbolic sine value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 sinh(float32 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))*0.5); 
.................... } 
.................... //Overloaded functions for sinh() for PCD 
.................... // Overloaded function sinh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sinh(float48 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))*0.5); 
.................... } 
....................  
.................... // Overloaded function sinh() for data type - Float48 
.................... float64 sinh(float64 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))*0.5); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float tanh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic tangent value of x 
.................... // Returns : returns the hyperbolic tangent value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 tanh(float32 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
.................... //Overloaded functions for tanh() for PCD 
.................... // Overloaded function tanh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 tanh(float48 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
....................  
.................... // Overloaded function tanh() for data type - Float64 
.................... float64 tanh(float64 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float frexp(float x, signed int *exp) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : breaks a floating point number into a normalized fraction and an integral 
.................... // power of 2. It stores the integer in the signed int object pointed to by exp. 
.................... // Returns : returns the value x, such that x is a double with magnitude in the interval 
.................... // [1/2,1) or zero, and value equals x times 2 raised to the power *exp.If value is zero, 
.................... // both parts of the result are zero. 
.................... // Date : N/A 
.................... // 
....................  
.................... #define LOG2 .30102999566398119521 
.................... #define LOG2_INV 3.32192809488736234787 
.................... float32 frexp(float32 x, signed int8 *exp) 
.................... { 
....................    float32 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)*LOG2_INV)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
....................  
.................... //Overloaded functions for frexp() for PCD 
.................... // Overloaded function frexp() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 frexp(float48 x, signed int8 *exp) 
.................... { 
....................    float48 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)*LOG2_INV)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
....................  
.................... // Overloaded function frexp() for data type - Float64 
.................... float64 frexp(float64 x, signed int8 *exp) 
.................... { 
....................    float64 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)*LOG2_INV)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
.................... #endif 
....................  
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... //   float ldexp(float x, signed int *exp) 
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... // Description : multiplies a floating point number by an integral power of 2. 
.................... // Returns : returns the value of x times 2 raised to the power exp. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 ldexp(float32 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... //Overloaded functions for ldexp() for PCD 
.................... // Overloaded function ldexp() for data type - Float48 
....................  
.................... #if defined(__PCD__) 
.................... float48 ldexp(float48 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... // Overloaded function ldexp() for data type - Float64 
.................... float64 ldexp(float64 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... #endif 
....................  
.................... #endif 
....................  
.................... #FUSES NOWDT, PUT, HS 
.................... #USE DELAY(CLOCK=20M) 
*
0152:  MOVLW  36
0153:  MOVWF  04
0154:  BSF    03.7
0155:  MOVF   00,W
0156:  BTFSC  03.2
0157:  GOTO   165
0158:  MOVLW  06
0159:  MOVWF  78
015A:  CLRF   77
015B:  DECFSZ 77,F
015C:  GOTO   15B
015D:  DECFSZ 78,F
015E:  GOTO   15A
015F:  MOVLW  7B
0160:  MOVWF  77
0161:  DECFSZ 77,F
0162:  GOTO   161
0163:  DECFSZ 00,F
0164:  GOTO   158
0165:  RETURN
.................... #USE RS232(BAUD=9600,XMIT=PIN_C6,RCV=PIN_C7) 
.................... #DEFINE BT1_PIN PIN_B1 
.................... #DEFINE BT2_PIN PIN_B2 
.................... #DEFINE BT3_PIN PIN_B3 
.................... #DEFINE LCD_ENABLE_PIN  PIN_E0                                    
.................... #DEFINE LCD_RS_PIN      PIN_E1                                 
.................... #DEFINE LCD_RW_PIN      PIN_E2   
.................... #DEFINE LCD_DATA4       PIN_C0                                
.................... #DEFINE LCD_DATA5       PIN_C1                                  
.................... #DEFINE LCD_DATA6       PIN_C2                                    
.................... #DEFINE LCD_DATA7       PIN_C3   
.................... #INCLUDE <LCD.C> 
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... ////                             LCD.C                                     //// 
.................... ////                 Driver for common LCD modules                         //// 
.................... ////                                                                       //// 
.................... ////  lcd_init()   Must be called before any other function.               //// 
.................... ////                                                                       //// 
.................... ////  lcd_putc(c)  Will display c on the next position of the LCD.         //// 
.................... ////                 \a  Set cursor position to upper left                 //// 
.................... ////                 \f  Clear display, set cursor to upper left           //// 
.................... ////                 \n  Go to start of second line                        //// 
.................... ////                 \b  Move back one position                            //// 
.................... ////              If LCD_EXTENDED_NEWLINE is defined, the \n character     //// 
.................... ////              will erase all remanining characters on the current      //// 
.................... ////              line, and move the cursor to the beginning of the next   //// 
.................... ////              line.                                                    //// 
.................... ////              If LCD_EXTENDED_NEWLINE is defined, the \r character     //// 
.................... ////              will move the cursor to the start of the current         //// 
.................... ////              line.                                                    //// 
.................... ////                                                                       //// 
.................... ////  lcd_gotoxy(x,y) Set write position on LCD (upper left is 1,1)        //// 
.................... ////                                                                       //// 
.................... ////  lcd_getc(x,y)   Returns character at position x,y on LCD             //// 
.................... ////                                                                       //// 
.................... ////  lcd_cursor_on(int1 on)   Turn the cursor on (on=TRUE) or off         //// 
.................... ////              (on=FALSE).                                              //// 
.................... ////                                                                       //// 
.................... ////  lcd_set_cgram_char(w, *p)   Write a custom character to the CGRAM.   //// 
.................... ////                                                                       //// 
.................... ////                                                                       //// 
.................... ////  CONFIGURATION                                                        //// 
.................... ////  The LCD can be configured in one of two ways: a.) port access or     //// 
.................... ////  b.) pin access.  Port access requires the entire 7 bit interface     //// 
.................... ////  connected to one GPIO port, and the data bits (D4:D7 of the LCD)     //// 
.................... ////  connected to sequential pins on the GPIO.  Pin access                //// 
.................... ////  has no requirements, all 7 bits of the control interface can         //// 
.................... ////  can be connected to any GPIO using several ports.                    //// 
.................... ////                                                                       //// 
.................... ////  To use port access, #define LCD_DATA_PORT to the SFR location of     //// 
.................... ////  of the GPIO port that holds the interface, -AND- edit LCD_PIN_MAP    //// 
.................... ////  of this file to configure the pin order.  If you are using a         //// 
.................... ////  baseline PIC (PCB), then LCD_OUTPUT_MAP and LCD_INPUT_MAP also must  //// 
.................... ////  be defined.                                                          //// 
.................... ////                                                                       //// 
.................... ////  Example of port access:                                              //// 
.................... ////     #define LCD_DATA_PORT getenv("SFR:PORTD")                         //// 
.................... ////                                                                       //// 
.................... ////  To use pin access, the following pins must be defined:               //// 
.................... ////     LCD_ENABLE_PIN                                                    //// 
.................... ////     LCD_RS_PIN                                                        //// 
.................... ////     LCD_RW_PIN                                                        //// 
.................... ////     LCD_DATA4                                                         //// 
.................... ////     LCD_DATA5                                                         //// 
.................... ////     LCD_DATA6                                                         //// 
.................... ////     LCD_DATA7                                                         //// 
.................... ////                                                                       //// 
.................... ////  Example of pin access:                                               //// 
.................... ////     #define LCD_ENABLE_PIN  PIN_E0                                    //// 
.................... ////     #define LCD_RS_PIN      PIN_E1                                    //// 
.................... ////     #define LCD_RW_PIN      PIN_E2                                    //// 
.................... ////     #define LCD_DATA4       PIN_D4                                    //// 
.................... ////     #define LCD_DATA5       PIN_D5                                    //// 
.................... ////     #define LCD_DATA6       PIN_D6                                    //// 
.................... ////     #define LCD_DATA7       PIN_D7                                    //// 
.................... ////                                                                       //// 
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2010 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef __LCD_C__ 
.................... #define __LCD_C__ 
....................  
.................... // define the pinout. 
.................... // only required if port access is being used. 
.................... typedef struct   
.................... {                            // This structure is overlayed 
....................    int1 enable;           // on to an I/O port to gain 
....................    int1 rs;               // access to the LCD pins. 
....................    int1 rw;               // The bits are allocated from 
....................    int1 unused;           // low order up.  ENABLE will 
....................    unsigned int     data : 4;         // be LSB pin of that port. 
....................   #if defined(__PCD__)       // The port used will be LCD_DATA_PORT. 
....................    unsigned int    reserved: 8; 
....................   #endif 
.................... } LCD_PIN_MAP; 
....................  
.................... // this is to improve compatability with previous LCD drivers that accepted 
.................... // a define labeled 'use_portb_lcd' that configured the LCD onto port B. 
.................... #if ((defined(use_portb_lcd)) && (use_portb_lcd==TRUE)) 
....................  #define LCD_DATA_PORT getenv("SFR:PORTB") 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
....................    // these definitions only need to be modified for baseline PICs. 
....................    // all other PICs use LCD_PIN_MAP or individual LCD_xxx pin definitions. 
.................... /*                                    EN, RS,   RW,   UNUSED,  DATA  */ 
....................  const LCD_PIN_MAP LCD_OUTPUT_MAP =  {0,  0,    0,    0,       0}; 
....................  const LCD_PIN_MAP LCD_INPUT_MAP =   {0,  0,    0,    0,       0xF}; 
.................... #endif 
....................  
.................... ////////////////////// END CONFIGURATION /////////////////////////////////// 
....................  
.................... #ifndef LCD_ENABLE_PIN 
....................    #define lcd_output_enable(x) lcdlat.enable=x 
....................    #define lcd_enable_tris()   lcdtris.enable=0 
.................... #else 
....................    #define lcd_output_enable(x) output_bit(LCD_ENABLE_PIN, x) 
....................    #define lcd_enable_tris()  output_drive(LCD_ENABLE_PIN) 
.................... #endif 
....................  
.................... #ifndef LCD_RS_PIN 
....................    #define lcd_output_rs(x) lcdlat.rs=x 
....................    #define lcd_rs_tris()   lcdtris.rs=0 
.................... #else 
....................    #define lcd_output_rs(x) output_bit(LCD_RS_PIN, x) 
....................    #define lcd_rs_tris()  output_drive(LCD_RS_PIN) 
.................... #endif 
....................  
.................... #ifndef LCD_RW_PIN 
....................    #define lcd_output_rw(x) lcdlat.rw=x 
....................    #define lcd_rw_tris()   lcdtris.rw=0 
.................... #else 
....................    #define lcd_output_rw(x) output_bit(LCD_RW_PIN, x) 
....................    #define lcd_rw_tris()  output_drive(LCD_RW_PIN) 
.................... #endif 
....................  
.................... // original version of this library incorrectly labeled LCD_DATA0 as LCD_DATA4, 
.................... // LCD_DATA1 as LCD_DATA5, and so on.  this block of code makes the driver 
.................... // compatible with any code written for the original library 
.................... #if (defined(LCD_DATA0) && defined(LCD_DATA1) && defined(LCD_DATA2) && defined(LCD_DATA3) && !defined(LCD_DATA4) && !defined(LCD_DATA5) && !defined(LCD_DATA6) && !defined(LCD_DATA7)) 
....................    #define  LCD_DATA4    LCD_DATA0 
....................    #define  LCD_DATA5    LCD_DATA1 
....................    #define  LCD_DATA6    LCD_DATA2 
....................    #define  LCD_DATA7    LCD_DATA3 
.................... #endif 
....................  
.................... #ifndef LCD_DATA4 
.................... #ifndef LCD_DATA_PORT 
....................    #if defined(__PCB__) 
....................       #define LCD_DATA_PORT      0x06     //portb 
....................       #define set_tris_lcd(x)   set_tris_b(x) 
....................    #else 
....................      #if defined(PIN_D0) 
....................       #define LCD_DATA_PORT      getenv("SFR:PORTD")     //portd 
....................      #else 
....................       #define LCD_DATA_PORT      getenv("SFR:PORTB")     //portb 
....................      #endif 
....................    #endif    
.................... #endif 
....................  
.................... #if defined(__PCB__) 
....................    LCD_PIN_MAP lcd, lcdlat; 
....................    #byte lcd = LCD_DATA_PORT 
....................    #byte lcdlat = LCD_DATA_PORT 
.................... #elif defined(__PCM__) 
....................    LCD_PIN_MAP lcd, lcdlat, lcdtris; 
....................    #byte lcd = LCD_DATA_PORT 
....................    #byte lcdlat = LCD_DATA_PORT 
....................    #byte lcdtris = LCD_DATA_PORT+0x80 
.................... #elif defined(__PCH__) 
....................    LCD_PIN_MAP lcd, lcdlat, lcdtris; 
....................    #byte lcd = LCD_DATA_PORT 
....................    #byte lcdlat = LCD_DATA_PORT+9 
....................    #byte lcdtris = LCD_DATA_PORT+0x12 
.................... #elif defined(__PCD__) 
....................    LCD_PIN_MAP lcd, lcdlat, lcdtris; 
....................    #word lcd = LCD_DATA_PORT 
....................    #word lcdlat = LCD_DATA_PORT+2 
....................    #word lcdtris = LCD_DATA_PORT-0x02 
.................... #endif 
.................... #endif   //LCD_DATA4 not defined 
....................  
.................... #ifndef LCD_TYPE 
....................    #define LCD_TYPE 2           // 0=5x7, 1=5x10, 2=2 lines 
.................... #endif 
....................  
.................... #ifndef LCD_LINE_TWO 
....................    #define LCD_LINE_TWO 0x40    // LCD RAM address for the second line 
.................... #endif 
....................  
.................... #ifndef LCD_LINE_LENGTH 
....................    #define LCD_LINE_LENGTH 20 
.................... #endif 
....................  
.................... unsigned int8 lcd_read_nibble(void); 
....................  
.................... unsigned int8 lcd_read_byte(void) 
.................... { 
....................    unsigned int8 low,high; 
....................  
....................  #if defined(__PCB__) 
....................    set_tris_lcd(LCD_INPUT_MAP); 
....................  #else 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    output_float(LCD_DATA4); 
*
01F9:  BSF    07.0
....................    output_float(LCD_DATA5); 
01FA:  BSF    07.1
....................    output_float(LCD_DATA6); 
01FB:  BSF    07.2
....................    output_float(LCD_DATA7); 
01FC:  BSF    07.3
....................   #else 
....................    lcdtris.data = 0xF; 
....................   #endif 
....................  #endif 
....................          
....................    lcd_output_rw(1); 
01FD:  BCF    03.5
01FE:  BSF    09.2
01FF:  BSF    03.5
0200:  BCF    09.2
....................    delay_cycles(1); 
0201:  NOP
....................    lcd_output_enable(1); 
0202:  BCF    03.5
0203:  BSF    09.0
0204:  BSF    03.5
0205:  BCF    09.0
....................    delay_cycles(1); 
0206:  NOP
....................    high = lcd_read_nibble(); 
0207:  BCF    03.5
0208:  CALL   1AE
0209:  MOVF   78,W
020A:  BSF    03.6
020B:  MOVWF  3D
....................        
....................    lcd_output_enable(0); 
020C:  BCF    03.6
020D:  BCF    09.0
020E:  BSF    03.5
020F:  BCF    09.0
....................    delay_cycles(1); 
0210:  NOP
....................    lcd_output_enable(1); 
0211:  BCF    03.5
0212:  BSF    09.0
0213:  BSF    03.5
0214:  BCF    09.0
....................    delay_us(1); 
0215:  GOTO   216
0216:  GOTO   217
0217:  NOP
....................    low = lcd_read_nibble(); 
0218:  BCF    03.5
0219:  CALL   1AE
021A:  MOVF   78,W
021B:  BSF    03.6
021C:  MOVWF  3C
....................        
....................    lcd_output_enable(0); 
021D:  BCF    03.6
021E:  BCF    09.0
021F:  BSF    03.5
0220:  BCF    09.0
....................  
....................  #if defined(__PCB__) 
....................    set_tris_lcd(LCD_OUTPUT_MAP); 
....................  #else 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    output_drive(LCD_DATA4); 
0221:  BCF    03.5
0222:  BCF    31.0
0223:  MOVF   31,W
0224:  BSF    03.5
0225:  MOVWF  07
....................    output_drive(LCD_DATA5); 
0226:  BCF    03.5
0227:  BCF    31.1
0228:  MOVF   31,W
0229:  BSF    03.5
022A:  MOVWF  07
....................    output_drive(LCD_DATA6); 
022B:  BCF    03.5
022C:  BCF    31.2
022D:  MOVF   31,W
022E:  BSF    03.5
022F:  MOVWF  07
....................    output_drive(LCD_DATA7); 
0230:  BCF    03.5
0231:  BCF    31.3
0232:  MOVF   31,W
0233:  BSF    03.5
0234:  MOVWF  07
....................   #else 
....................    lcdtris.data = 0x0; 
....................   #endif 
....................  #endif 
....................  
....................    return( (high<<4) | low); 
0235:  BCF    03.5
0236:  BSF    03.6
0237:  SWAPF  3D,W
0238:  MOVWF  77
0239:  MOVLW  F0
023A:  ANDWF  77,F
023B:  MOVF   77,W
023C:  IORWF  3C,W
023D:  MOVWF  78
.................... } 
....................  
.................... unsigned int8 lcd_read_nibble(void) 
.................... { 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
*
01AE:  BSF    03.6
01AF:  CLRF   3E
....................    unsigned int8 n = 0x00; 
....................  
....................    /* Read the data port */ 
....................    n |= input(LCD_DATA4); 
01B0:  BCF    03.6
01B1:  BSF    31.0
01B2:  MOVF   31,W
01B3:  BSF    03.5
01B4:  MOVWF  07
01B5:  MOVLW  00
01B6:  BCF    03.5
01B7:  BTFSC  07.0
01B8:  MOVLW  01
01B9:  BSF    03.6
01BA:  IORWF  3E,F
....................    n |= input(LCD_DATA5) << 1; 
01BB:  BCF    03.6
01BC:  BSF    31.1
01BD:  MOVF   31,W
01BE:  BSF    03.5
01BF:  MOVWF  07
01C0:  MOVLW  00
01C1:  BCF    03.5
01C2:  BTFSC  07.1
01C3:  MOVLW  01
01C4:  MOVWF  77
01C5:  BCF    03.0
01C6:  RLF    77,F
01C7:  MOVF   77,W
01C8:  BSF    03.6
01C9:  IORWF  3E,F
....................    n |= input(LCD_DATA6) << 2; 
01CA:  BCF    03.6
01CB:  BSF    31.2
01CC:  MOVF   31,W
01CD:  BSF    03.5
01CE:  MOVWF  07
01CF:  MOVLW  00
01D0:  BCF    03.5
01D1:  BTFSC  07.2
01D2:  MOVLW  01
01D3:  MOVWF  77
01D4:  RLF    77,F
01D5:  RLF    77,F
01D6:  MOVLW  FC
01D7:  ANDWF  77,F
01D8:  MOVF   77,W
01D9:  BSF    03.6
01DA:  IORWF  3E,F
....................    n |= input(LCD_DATA7) << 3; 
01DB:  BCF    03.6
01DC:  BSF    31.3
01DD:  MOVF   31,W
01DE:  BSF    03.5
01DF:  MOVWF  07
01E0:  MOVLW  00
01E1:  BCF    03.5
01E2:  BTFSC  07.3
01E3:  MOVLW  01
01E4:  MOVWF  77
01E5:  RLF    77,F
01E6:  RLF    77,F
01E7:  RLF    77,F
01E8:  MOVLW  F8
01E9:  ANDWF  77,F
01EA:  MOVF   77,W
01EB:  BSF    03.6
01EC:  IORWF  3E,F
....................     
....................    return(n); 
01ED:  MOVF   3E,W
01EE:  MOVWF  78
....................   #else 
01EF:  BCF    03.6
01F0:  RETURN
....................    return(lcd.data); 
....................   #endif 
.................... } 
....................  
.................... void lcd_send_nibble(unsigned int8 n) 
.................... { 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    /* Write to the data port */ 
....................    output_bit(LCD_DATA4, bit_test(n, 0)); 
*
0166:  BSF    03.6
0167:  BTFSC  3D.0
0168:  GOTO   16D
0169:  BCF    03.6
016A:  BCF    07.0
016B:  GOTO   16F
016C:  BSF    03.6
016D:  BCF    03.6
016E:  BSF    07.0
016F:  BCF    31.0
0170:  MOVF   31,W
0171:  BSF    03.5
0172:  MOVWF  07
....................    output_bit(LCD_DATA5, bit_test(n, 1)); 
0173:  BCF    03.5
0174:  BSF    03.6
0175:  BTFSC  3D.1
0176:  GOTO   17B
0177:  BCF    03.6
0178:  BCF    07.1
0179:  GOTO   17D
017A:  BSF    03.6
017B:  BCF    03.6
017C:  BSF    07.1
017D:  BCF    31.1
017E:  MOVF   31,W
017F:  BSF    03.5
0180:  MOVWF  07
....................    output_bit(LCD_DATA6, bit_test(n, 2)); 
0181:  BCF    03.5
0182:  BSF    03.6
0183:  BTFSC  3D.2
0184:  GOTO   189
0185:  BCF    03.6
0186:  BCF    07.2
0187:  GOTO   18B
0188:  BSF    03.6
0189:  BCF    03.6
018A:  BSF    07.2
018B:  BCF    31.2
018C:  MOVF   31,W
018D:  BSF    03.5
018E:  MOVWF  07
....................    output_bit(LCD_DATA7, bit_test(n, 3)); 
018F:  BCF    03.5
0190:  BSF    03.6
0191:  BTFSC  3D.3
0192:  GOTO   197
0193:  BCF    03.6
0194:  BCF    07.3
0195:  GOTO   199
0196:  BSF    03.6
0197:  BCF    03.6
0198:  BSF    07.3
0199:  BCF    31.3
019A:  MOVF   31,W
019B:  BSF    03.5
019C:  MOVWF  07
....................   #else       
....................    lcdlat.data = n; 
....................   #endif 
....................        
....................    delay_cycles(1); 
019D:  NOP
....................    lcd_output_enable(1); 
019E:  BCF    03.5
019F:  BSF    09.0
01A0:  BSF    03.5
01A1:  BCF    09.0
....................    delay_us(2); 
01A2:  MOVLW  02
01A3:  MOVWF  77
01A4:  DECFSZ 77,F
01A5:  GOTO   1A4
01A6:  GOTO   1A7
01A7:  NOP
....................    lcd_output_enable(0); 
01A8:  BCF    03.5
01A9:  BCF    09.0
01AA:  BSF    03.5
01AB:  BCF    09.0
01AC:  BCF    03.5
01AD:  RETURN
.................... } 
....................  
.................... void lcd_send_byte(unsigned int8 address, unsigned int8 n) 
.................... { 
....................   #if defined(__PCB__) 
....................    set_tris_lcd(LCD_OUTPUT_MAP); 
....................   #else 
....................    lcd_enable_tris(); 
*
01F1:  BSF    03.5
01F2:  BCF    09.0
....................    lcd_rs_tris(); 
01F3:  BCF    09.1
....................    lcd_rw_tris(); 
01F4:  BCF    09.2
....................   #endif 
....................  
....................    lcd_output_rs(0); 
01F5:  BCF    03.5
01F6:  BCF    09.1
01F7:  BSF    03.5
01F8:  BCF    09.1
....................    while ( bit_test(lcd_read_byte(),7) ) ; 
*
023E:  MOVF   78,W
023F:  MOVWF  3C
0240:  BTFSS  3C.7
0241:  GOTO   245
0242:  BSF    03.5
0243:  BCF    03.6
0244:  GOTO   1F9
....................    lcd_output_rs(address); 
0245:  MOVF   3A,F
0246:  BTFSS  03.2
0247:  GOTO   24C
0248:  BCF    03.6
0249:  BCF    09.1
024A:  GOTO   24E
024B:  BSF    03.6
024C:  BCF    03.6
024D:  BSF    09.1
024E:  BSF    03.5
024F:  BCF    09.1
....................    delay_cycles(1); 
0250:  NOP
....................    lcd_output_rw(0); 
0251:  BCF    03.5
0252:  BCF    09.2
0253:  BSF    03.5
0254:  BCF    09.2
....................    delay_cycles(1); 
0255:  NOP
....................    lcd_output_enable(0); 
0256:  BCF    03.5
0257:  BCF    09.0
0258:  BSF    03.5
0259:  BCF    09.0
....................    lcd_send_nibble(n >> 4); 
025A:  BCF    03.5
025B:  BSF    03.6
025C:  SWAPF  3B,W
025D:  MOVWF  3C
025E:  MOVLW  0F
025F:  ANDWF  3C,F
0260:  MOVF   3C,W
0261:  MOVWF  3D
0262:  BCF    03.6
0263:  CALL   166
....................    lcd_send_nibble(n & 0xf); 
0264:  BSF    03.6
0265:  MOVF   3B,W
0266:  ANDLW  0F
0267:  MOVWF  3C
0268:  MOVWF  3D
0269:  BCF    03.6
026A:  CALL   166
026B:  RETURN
.................... } 
....................  
.................... #if defined(LCD_EXTENDED_NEWLINE) 
.................... unsigned int8 g_LcdX, g_LcdY; 
.................... #endif 
....................  
.................... void lcd_init(void)  
.................... { 
....................    unsigned int8 i; 
....................    unsigned int8 LCD_INIT_STRING[4] = {0x20 | (LCD_TYPE << 2), 0xc, 1, 6}; 
026C:  MOVLW  28
026D:  BSF    03.5
026E:  MOVWF  58
026F:  MOVLW  0C
0270:  MOVWF  59
0271:  MOVLW  01
0272:  MOVWF  5A
0273:  MOVLW  06
0274:  MOVWF  5B
....................                              // These bytes need to be sent to the LCD 
....................                              // to start it up. 
....................     
....................  
....................    lcd_output_enable(0); 
0275:  BCF    03.5
0276:  BCF    09.0
0277:  BSF    03.5
0278:  BCF    09.0
....................    lcd_output_rs(0); 
0279:  BCF    03.5
027A:  BCF    09.1
027B:  BSF    03.5
027C:  BCF    09.1
....................    lcd_output_rw(0); 
027D:  BCF    03.5
027E:  BCF    09.2
027F:  BSF    03.5
0280:  BCF    09.2
....................  
....................  #if defined(__PCB__) 
....................    set_tris_lcd(LCD_OUTPUT_MAP); 
....................  #else 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    output_drive(LCD_DATA4); 
0281:  BCF    03.5
0282:  BCF    31.0
0283:  MOVF   31,W
0284:  BSF    03.5
0285:  MOVWF  07
....................    output_drive(LCD_DATA5); 
0286:  BCF    03.5
0287:  BCF    31.1
0288:  MOVF   31,W
0289:  BSF    03.5
028A:  MOVWF  07
....................    output_drive(LCD_DATA6); 
028B:  BCF    03.5
028C:  BCF    31.2
028D:  MOVF   31,W
028E:  BSF    03.5
028F:  MOVWF  07
....................    output_drive(LCD_DATA7); 
0290:  BCF    03.5
0291:  BCF    31.3
0292:  MOVF   31,W
0293:  BSF    03.5
0294:  MOVWF  07
....................   #else 
....................    lcdtris.data = 0x0; 
....................   #endif 
....................    lcd_enable_tris(); 
0295:  BCF    09.0
....................    lcd_rs_tris(); 
0296:  BCF    09.1
....................    lcd_rw_tris(); 
0297:  BCF    09.2
....................  #endif 
....................      
....................    delay_ms(15); 
0298:  MOVLW  0F
0299:  BCF    03.5
029A:  BSF    03.6
029B:  MOVWF  36
029C:  BCF    03.6
029D:  CALL   152
....................    for(i=1;i<=3;++i) 
029E:  MOVLW  01
029F:  BSF    03.5
02A0:  MOVWF  57
02A1:  MOVF   57,W
02A2:  SUBLW  03
02A3:  BTFSS  03.0
02A4:  GOTO   2B3
....................    { 
....................        lcd_send_nibble(3); 
02A5:  MOVLW  03
02A6:  BCF    03.5
02A7:  BSF    03.6
02A8:  MOVWF  3D
02A9:  BCF    03.6
02AA:  CALL   166
....................        delay_ms(5); 
02AB:  MOVLW  05
02AC:  BSF    03.6
02AD:  MOVWF  36
02AE:  BCF    03.6
02AF:  CALL   152
02B0:  BSF    03.5
02B1:  INCF   57,F
02B2:  GOTO   2A1
....................    } 
....................     
....................    lcd_send_nibble(2); 
02B3:  MOVLW  02
02B4:  BCF    03.5
02B5:  BSF    03.6
02B6:  MOVWF  3D
02B7:  BCF    03.6
02B8:  CALL   166
....................    delay_ms(5); 
02B9:  MOVLW  05
02BA:  BSF    03.6
02BB:  MOVWF  36
02BC:  BCF    03.6
02BD:  CALL   152
....................    for(i=0;i<=3;++i) 
02BE:  BSF    03.5
02BF:  CLRF   57
02C0:  MOVF   57,W
02C1:  SUBLW  03
02C2:  BTFSS  03.0
02C3:  GOTO   2D8
....................       lcd_send_byte(0,LCD_INIT_STRING[i]); 
02C4:  MOVLW  D8
02C5:  ADDWF  57,W
02C6:  MOVWF  04
02C7:  BCF    03.7
02C8:  MOVF   00,W
02C9:  MOVWF  5C
02CA:  BCF    03.5
02CB:  BSF    03.6
02CC:  CLRF   3A
02CD:  BSF    03.5
02CE:  BCF    03.6
02CF:  MOVF   5C,W
02D0:  BCF    03.5
02D1:  BSF    03.6
02D2:  MOVWF  3B
02D3:  BCF    03.6
02D4:  CALL   1F1
....................  
....................   #if defined(LCD_EXTENDED_NEWLINE) 
02D5:  BSF    03.5
02D6:  INCF   57,F
02D7:  GOTO   2C0
02D8:  BCF    03.5
02D9:  BCF    0A.3
02DA:  BSF    0A.4
02DB:  GOTO   40A (RETURN)
....................    g_LcdX = 0; 
....................    g_LcdY = 0; 
....................   #endif 
.................... } 
....................  
.................... void lcd_gotoxy(unsigned int8 x, unsigned int8 y) 
.................... { 
....................    unsigned int8 address; 
....................     
....................    if(y!=1) 
02DC:  BSF    03.6
02DD:  DECFSZ 37,W
02DE:  GOTO   2E0
02DF:  GOTO   2E3
....................       address=LCD_LINE_TWO; 
02E0:  MOVLW  40
02E1:  MOVWF  38
02E2:  GOTO   2E4
....................    else 
....................       address=0; 
02E3:  CLRF   38
....................       
....................    address+=x-1; 
02E4:  MOVLW  01
02E5:  SUBWF  36,W
02E6:  ADDWF  38,F
....................    lcd_send_byte(0,0x80|address); 
02E7:  MOVF   38,W
02E8:  IORLW  80
02E9:  MOVWF  39
02EA:  CLRF   3A
02EB:  MOVF   39,W
02EC:  MOVWF  3B
02ED:  BCF    03.6
02EE:  CALL   1F1
....................  
....................   #if defined(LCD_EXTENDED_NEWLINE) 
02EF:  RETURN
....................    g_LcdX = x - 1; 
....................    g_LcdY = y - 1; 
....................   #endif 
.................... } 
....................  
.................... void lcd_putc(char c) 
.................... { 
....................    switch (c) 
02F0:  BSF    03.6
02F1:  MOVF   35,W
02F2:  XORLW  07
02F3:  BCF    03.6
02F4:  BTFSC  03.2
02F5:  GOTO   300
02F6:  XORLW  0B
02F7:  BTFSC  03.2
02F8:  GOTO   307
02F9:  XORLW  06
02FA:  BTFSC  03.2
02FB:  GOTO   313
02FC:  XORLW  02
02FD:  BTFSC  03.2
02FE:  GOTO   31B
02FF:  GOTO   322
....................    { 
....................       case '\a'   :  lcd_gotoxy(1,1);     break; 
0300:  MOVLW  01
0301:  BSF    03.6
0302:  MOVWF  36
0303:  MOVWF  37
0304:  BCF    03.6
0305:  CALL   2DC
0306:  GOTO   329
....................  
....................       case '\f'   :  lcd_send_byte(0,1); 
0307:  BSF    03.6
0308:  CLRF   3A
0309:  MOVLW  01
030A:  MOVWF  3B
030B:  BCF    03.6
030C:  CALL   1F1
....................                      delay_ms(2); 
030D:  MOVLW  02
030E:  BSF    03.6
030F:  MOVWF  36
0310:  BCF    03.6
0311:  CALL   152
....................                     #if defined(LCD_EXTENDED_NEWLINE) 
....................                      g_LcdX = 0; 
....................                      g_LcdY = 0; 
....................                     #endif 
....................                      break; 
0312:  GOTO   329
....................  
....................      #if defined(LCD_EXTENDED_NEWLINE) 
....................       case '\r'   :  lcd_gotoxy(1, g_LcdY+1);   break; 
....................       case '\n'   : 
....................          while (g_LcdX++ < LCD_LINE_LENGTH) 
....................          { 
....................             lcd_send_byte(1, ' '); 
....................          } 
....................          lcd_gotoxy(1, g_LcdY+2); 
....................          break; 
....................      #else 
....................       case '\n'   : lcd_gotoxy(1,2);        break; 
0313:  MOVLW  01
0314:  BSF    03.6
0315:  MOVWF  36
0316:  MOVLW  02
0317:  MOVWF  37
0318:  BCF    03.6
0319:  CALL   2DC
031A:  GOTO   329
....................      #endif 
....................       
....................       case '\b'   : lcd_send_byte(0,0x10);  break; 
031B:  BSF    03.6
031C:  CLRF   3A
031D:  MOVLW  10
031E:  MOVWF  3B
031F:  BCF    03.6
0320:  CALL   1F1
0321:  GOTO   329
....................       
....................      #if defined(LCD_EXTENDED_NEWLINE) 
....................       default     :  
....................          if (g_LcdX < LCD_LINE_LENGTH) 
....................          { 
....................             lcd_send_byte(1, c); 
....................             g_LcdX++; 
....................          } 
....................          break; 
....................      #else 
....................       default     : lcd_send_byte(1,c);     break; 
0322:  MOVLW  01
0323:  BSF    03.6
0324:  MOVWF  3A
0325:  MOVF   35,W
0326:  MOVWF  3B
0327:  BCF    03.6
0328:  CALL   1F1
....................      #endif 
....................    } 
0329:  RETURN
.................... } 
....................   
.................... char lcd_getc(unsigned int8 x, unsigned int8 y) 
.................... { 
....................    char value; 
....................  
....................    lcd_gotoxy(x,y); 
....................    while ( bit_test(lcd_read_byte(),7) ); // wait until busy flag is low 
....................    lcd_output_rs(1); 
....................    value = lcd_read_byte(); 
....................    lcd_output_rs(0); 
....................     
....................    return(value); 
.................... } 
....................  
.................... // write a custom character to the ram 
.................... // which is 0-7 and specifies which character array we are modifying. 
.................... // ptr points to an array of 8 bytes, where each byte is the next row of 
.................... //    pixels.  only bits 0-4 are used.  the last row is the cursor row, and 
.................... //    usually you will want to leave this byte 0x00. 
.................... void lcd_set_cgram_char(unsigned int8 which, unsigned int8 *ptr) 
.................... { 
....................    unsigned int i; 
....................  
....................    which <<= 3; 
....................    which &= 0x38; 
....................  
....................    lcd_send_byte(0, 0x40 | which);  //set cgram address 
....................  
....................    for(i=0; i<8; i++) 
....................    { 
....................       lcd_send_byte(1, *ptr++); 
....................    } 
....................    
....................    #if defined(LCD_EXTENDED_NEWLINE) 
....................     lcd_gotoxy(g_LcdX+1, g_LcdY+1);  //set ddram address 
....................    #endif 
.................... } 
....................  
.................... void lcd_cursor_on(int1 on) 
.................... { 
....................    if (on) 
....................    { 
....................       lcd_send_byte(0,0x0F);           //turn LCD cursor ON 
....................    } 
....................    else 
....................    { 
....................       lcd_send_byte(0,0x0C);           //turn LCD cursor OFF 
....................    } 
.................... } 
....................  
.................... #endif 
....................  
.................... #BIT TMR1IF = 0x0C.0 //bit thu 0 (TMR1IF) cua PIR1 
....................  
.................... #INCLUDE <khaibaobien.c> // VARIABLE. 
.................... UNSIGNED INT16 KQADC,AN0, AN1; 
.................... UNSIGNED INT8 KET_QUA_ANALOG[]={0,0,0,0}; 
*
1377:  CLRF   38
1378:  CLRF   39
1379:  CLRF   3A
137A:  CLRF   3B
.................... UNSIGNED INT8 CONFIG_FUN=0; 
.................... UNSIGNED INT8 VT=0, KYTU=0;// KYTU[30],  
.................... UNSIGNED INT8 ID_DEVICE_NHAN,TT_DEVICE_NHAN; 
.................... UNSIGNED INT8 ID_GATEWAY[6] = {6,4,7,5,3,4}; 
137B:  MOVLW  06
137C:  MOVWF  41
137D:  MOVLW  04
137E:  MOVWF  42
137F:  MOVLW  07
1380:  MOVWF  43
1381:  MOVLW  05
1382:  MOVWF  44
1383:  MOVLW  03
1384:  MOVWF  45
1385:  MOVLW  04
1386:  MOVWF  46
.................... UNSIGNED INT8 ID_NODE[4] = {4,6,4,8}; 
1387:  MOVWF  47
1388:  MOVLW  06
1389:  MOVWF  48
138A:  MOVLW  04
138B:  MOVWF  49
138C:  MOVLW  08
138D:  MOVWF  4A
.................... UNSIGNED INT8 LEN_PACKAGES = 0; 
.................... UNSIGNED INT8 LENHDIEUKHIEN =0, DODAI_DATA_NHAN =0; 
.................... UNSIGNED INT8 SOLUONGTHIETBI_CONFIG=0, SOLUONGCAMBIEN_CONFIG = 3; 
.................... SIGNED INT8 SOSANH_IDNODE=0, SOSANH_IDGW=0; 
....................  
.................... INT1 TTNHAN = 0, TT_CONFIG=0, TT_CONTROL=0,TT_CONFIG_DONE=0, TT_FUN=0, TT_STT=0 , TT_CONFIG_OKE_UART = 0; 
....................  
.................... CHAR *ID_NODE_CHAR[]= "0589"; 
138E:  MOVLW  30
138F:  MOVWF  55
1390:  MOVLW  35
1391:  MOVWF  56
1392:  MOVLW  38
1393:  MOVWF  57
1394:  MOVLW  39
1395:  MOVWF  58
1396:  CLRF   59
1397:  CLRF   54
1398:  MOVLW  55
1399:  MOVWF  53
.................... CHAR *ID_GATEWAY_CHAR[]= "127102"; 
139A:  MOVLW  31
139B:  MOVWF  5C
139C:  MOVLW  32
139D:  MOVWF  5D
139E:  MOVLW  37
139F:  MOVWF  5E
13A0:  MOVLW  31
13A1:  MOVWF  5F
13A2:  MOVLW  30
13A3:  MOVWF  60
13A4:  MOVLW  32
13A5:  MOVWF  61
13A6:  CLRF   62
13A7:  CLRF   5B
13A8:  MOVLW  5C
13A9:  MOVWF  5A
.................... CHAR *ID_NODE_NHAN[]= "0000"; 
13AA:  MOVLW  30
13AB:  MOVWF  65
13AC:  MOVWF  66
13AD:  MOVWF  67
13AE:  MOVWF  68
13AF:  CLRF   69
13B0:  CLRF   64
13B1:  MOVLW  65
13B2:  MOVWF  63
.................... CHAR *ID_GW_NHAN[]= "000000"; 
13B3:  MOVLW  30
13B4:  MOVWF  6C
13B5:  MOVWF  6D
13B6:  MOVWF  6E
13B7:  MOVWF  6F
13B8:  MOVWF  70
13B9:  MOVWF  71
13BA:  CLRF   72
13BB:  CLRF   6B
13BC:  MOVLW  6C
13BD:  MOVWF  6A
.................... CHAR KYTUCHAR[30]="HIHI"; 
13BE:  MOVLW  48
13BF:  BSF    03.5
13C0:  MOVWF  20
13C1:  MOVLW  49
13C2:  MOVWF  21
13C3:  MOVLW  48
13C4:  MOVWF  22
13C5:  MOVLW  49
13C6:  MOVWF  23
13C7:  CLRF   24
.................... CHAR KYTUCHAR2[15]="HIHI"; 
13C8:  MOVLW  48
13C9:  MOVWF  3E
13CA:  MOVLW  49
13CB:  MOVWF  3F
13CC:  MOVLW  48
13CD:  MOVWF  40
13CE:  MOVLW  49
13CF:  MOVWF  41
13D0:  CLRF   42
.................... //CHAR *DATA_NHANDUOC[]={"IDGW","IDNODE","COMMAN","DATA"}; 
.................... CHAR *TEMP_CHAR[]="0000";   
13D1:  MOVLW  30
13D2:  MOVWF  4D
13D3:  MOVWF  4E
13D4:  MOVWF  4F
13D5:  MOVWF  50
13D6:  CLRF   51
13D7:  CLRF   74
13D8:  MOVLW  CD
13D9:  MOVWF  73
.................... CHAR *TEMP_CHAR2[]="2700";  
13DA:  MOVLW  32
13DB:  MOVWF  52
13DC:  MOVLW  37
13DD:  MOVWF  53
13DE:  MOVLW  30
13DF:  MOVWF  54
13E0:  MOVWF  55
13E1:  CLRF   56
13E2:  CLRF   76
13E3:  MOVLW  D2
13E4:  MOVWF  75
.................... //CHAR *TEMP_CHAR3[]="000000";  
....................  
....................  
....................  
.................... //#INCLUDE <CONFIG_NODE.C> // CU HINH NODE. 
.................... #INCLUDE <config_1.C> // CU HINH NODE. 
....................  
.................... //--------------------------------------------------------------------// 
.................... VOID CHON_ID() 
.................... { 
....................    // TT_CONFIG_DONE; 
....................    TT_CONFIG_DONE = 0; 
*
05C9:  BCF    52.3
....................    TT_STT = 1; 
05CA:  BSF    52.5
....................    UNSIGNED INT8 NUM = 0; 
05CB:  BSF    03.5
05CC:  CLRF   57
....................    TEMP_CHAR = "0"; 
05CD:  CLRF   58
05CE:  CLRF   59
05CF:  MOVLW  73
05D0:  MOVWF  04
05D1:  BCF    03.7
05D2:  MOVF   58,W
05D3:  ADDWF  04,F
05D4:  MOVF   59,W
05D5:  BCF    03.5
05D6:  CALL   058
05D7:  MOVWF  00
05D8:  IORLW  00
05D9:  BTFSC  03.2
05DA:  GOTO   5E0
05DB:  BSF    03.5
05DC:  INCF   59,F
05DD:  INCF   58,F
05DE:  GOTO   5CF
05DF:  BCF    03.5
....................    LCD_GOTOXY (1, 2) ; 
05E0:  MOVLW  01
05E1:  BSF    03.6
05E2:  MOVWF  36
05E3:  MOVLW  02
05E4:  MOVWF  37
05E5:  BCF    03.6
05E6:  CALL   2DC
....................    DELAY_MS (10); 
05E7:  MOVLW  0A
05E8:  BSF    03.6
05E9:  MOVWF  36
05EA:  BCF    03.6
05EB:  CALL   152
....................    PRINTF (LCD_PUTC, "NODE: "); 
05EC:  MOVLW  6F
05ED:  BSF    03.6
05EE:  MOVWF  0D
05EF:  MOVLW  00
05F0:  MOVWF  0F
05F1:  BCF    03.6
05F2:  CALL   32A
....................    PRINTF (LCD_PUTC, "0000          "); 
05F3:  MOVLW  73
05F4:  BSF    03.6
05F5:  MOVWF  0D
05F6:  MOVLW  00
05F7:  MOVWF  0F
05F8:  BCF    03.6
05F9:  CALL   32A
....................    LCD_GOTOXY (1, 1) ; 
05FA:  MOVLW  01
05FB:  BSF    03.6
05FC:  MOVWF  36
05FD:  MOVWF  37
05FE:  BCF    03.6
05FF:  CALL   2DC
....................    PRINTF (LCD_PUTC, "      _              ");//6 SPACE PHIA TRUOC "_" 
0600:  MOVLW  7B
0601:  BSF    03.6
0602:  MOVWF  0D
0603:  MOVLW  00
0604:  MOVWF  0F
0605:  BCF    03.6
0606:  CALL   32A
....................    //ID_GW = "1234";     
....................  
....................    WHILE (TT_STT) 
0607:  BTFSS  52.5
0608:  GOTO   693
....................    { 
....................       IF (!INPUT (BT2_PIN)) //NEU NUT BAM DUOC BAM 
0609:  BSF    03.5
060A:  BSF    06.2
060B:  BCF    03.5
060C:  BTFSC  06.2
060D:  GOTO   630
....................       { 
....................           
....................          NUM++; 
060E:  BSF    03.5
060F:  INCF   57,F
....................          NUM = NUM % 4; 
0610:  MOVLW  03
0611:  ANDWF  57,F
....................          LCD_GOTOXY (3 + NUM, 1); 
0612:  ADDWF  57,W
0613:  MOVWF  58
0614:  BCF    03.5
0615:  BSF    03.6
0616:  MOVWF  36
0617:  MOVLW  01
0618:  MOVWF  37
0619:  BCF    03.6
061A:  CALL   2DC
....................          PRINTF (LCD_PUTC, "    _    ");//4SPACE 
061B:  MOVLW  86
061C:  BSF    03.6
061D:  MOVWF  0D
061E:  MOVLW  00
061F:  MOVWF  0F
0620:  BCF    03.6
0621:  CALL   32A
....................          DELAY_MS (300);  
0622:  MOVLW  02
0623:  BSF    03.5
0624:  MOVWF  58
0625:  MOVLW  96
0626:  BCF    03.5
0627:  BSF    03.6
0628:  MOVWF  36
0629:  BCF    03.6
062A:  CALL   152
062B:  BSF    03.5
062C:  DECFSZ 58,F
062D:  GOTO   625
....................       } 
062E:  GOTO   691
062F:  BCF    03.5
....................  
....................       ELSE IF (!INPUT (BT3_PIN)) 
0630:  BSF    03.5
0631:  BSF    06.3
0632:  BCF    03.5
0633:  BTFSC  06.3
0634:  GOTO   692
....................       { 
....................          ID_NODE[NUM]++; 
0635:  MOVLW  47
0636:  BSF    03.5
0637:  ADDWF  57,W
0638:  MOVWF  04
0639:  BCF    03.7
063A:  INCF   00,F
....................          ID_NODE[NUM] = ID_NODE[NUM] % 10; 
063B:  MOVLW  47
063C:  ADDWF  57,W
063D:  MOVWF  78
063E:  CLRF   7A
063F:  BTFSC  03.0
0640:  INCF   7A,F
0641:  MOVF   78,W
0642:  MOVWF  58
0643:  MOVF   7A,W
0644:  MOVWF  59
0645:  MOVLW  47
0646:  ADDWF  57,W
0647:  MOVWF  04
0648:  BCF    03.7
0649:  MOVF   00,W
064A:  MOVWF  5B
064B:  MOVLW  0A
064C:  MOVWF  5C
064D:  BCF    03.5
064E:  CALL   535
064F:  MOVF   77,W
0650:  BSF    03.5
0651:  MOVWF  5A
0652:  MOVF   58,W
0653:  MOVWF  04
0654:  BCF    03.7
0655:  BTFSC  59.0
0656:  BSF    03.7
0657:  MOVF   5A,W
0658:  MOVWF  00
....................          ITOA (ID_NODE[NUM], 10, TEMP_CHAR); 
0659:  MOVLW  47
065A:  ADDWF  57,W
065B:  MOVWF  04
065C:  BCF    03.7
065D:  MOVF   00,W
065E:  MOVWF  58
065F:  BCF    03.5
0660:  BSF    03.6
0661:  CLRF   37
0662:  CLRF   36
0663:  CLRF   35
0664:  BSF    03.5
0665:  BCF    03.6
0666:  MOVF   58,W
0667:  BCF    03.5
0668:  BSF    03.6
0669:  MOVWF  34
066A:  MOVLW  0A
066B:  MOVWF  38
066C:  CLRF   3A
066D:  MOVLW  73
066E:  MOVWF  39
066F:  BCF    03.6
0670:  CALL   3F6
....................          LCD_GOTOXY (7 + NUM, 2); 
0671:  MOVLW  07
0672:  BSF    03.5
0673:  ADDWF  57,W
0674:  MOVWF  58
0675:  BCF    03.5
0676:  BSF    03.6
0677:  MOVWF  36
0678:  MOVLW  02
0679:  MOVWF  37
067A:  BCF    03.6
067B:  CALL   2DC
....................          DELAY_MS (10); 
067C:  MOVLW  0A
067D:  BSF    03.6
067E:  MOVWF  36
067F:  BCF    03.6
0680:  CALL   152
....................          PRINTF (LCD_PUTC, TEMP_CHAR); 
0681:  MOVLW  73
0682:  MOVWF  04
0683:  BCF    03.7
0684:  CALL   516
....................          DELAY_MS (300); 
0685:  MOVLW  02
0686:  BSF    03.5
0687:  MOVWF  58
0688:  MOVLW  96
0689:  BCF    03.5
068A:  BSF    03.6
068B:  MOVWF  36
068C:  BCF    03.6
068D:  CALL   152
068E:  BSF    03.5
068F:  DECFSZ 58,F
0690:  GOTO   688
0691:  BCF    03.5
....................       } 
0692:  GOTO   607
....................    } 
.................... } 
....................  
.................... VOID NHAPID_GW() 
*
0694:  BSF    03.5
0695:  CLRF   57
.................... { 
....................    UNSIGNED INT8 NUM = 0; 
....................    TEMP_CHAR = "0"; 
0696:  CLRF   58
0697:  CLRF   59
0698:  MOVLW  73
0699:  MOVWF  04
069A:  BCF    03.7
069B:  MOVF   58,W
069C:  ADDWF  04,F
069D:  MOVF   59,W
069E:  BCF    03.5
069F:  CALL   058
06A0:  MOVWF  00
06A1:  IORLW  00
06A2:  BTFSC  03.2
06A3:  GOTO   6A9
06A4:  BSF    03.5
06A5:  INCF   59,F
06A6:  INCF   58,F
06A7:  GOTO   698
06A8:  BCF    03.5
....................    TT_CONFIG_DONE = 0; 
06A9:  BCF    52.3
....................    TT_STT = 1; 
06AA:  BSF    52.5
....................    LCD_GOTOXY (1, 2) ; 
06AB:  MOVLW  01
06AC:  BSF    03.6
06AD:  MOVWF  36
06AE:  MOVLW  02
06AF:  MOVWF  37
06B0:  BCF    03.6
06B1:  CALL   2DC
....................    DELAY_MS (10); 
06B2:  MOVLW  0A
06B3:  BSF    03.6
06B4:  MOVWF  36
06B5:  BCF    03.6
06B6:  CALL   152
....................    PRINTF (LCD_PUTC, "ID_GW:"); 
06B7:  MOVLW  8B
06B8:  BSF    03.6
06B9:  MOVWF  0D
06BA:  MOVLW  00
06BB:  MOVWF  0F
06BC:  BCF    03.6
06BD:  CALL   32A
....................    PRINTF (LCD_PUTC, "000000        "); 
06BE:  MOVLW  8F
06BF:  BSF    03.6
06C0:  MOVWF  0D
06C1:  MOVLW  00
06C2:  MOVWF  0F
06C3:  BCF    03.6
06C4:  CALL   32A
....................    LCD_GOTOXY (1, 1) ; 
06C5:  MOVLW  01
06C6:  BSF    03.6
06C7:  MOVWF  36
06C8:  MOVWF  37
06C9:  BCF    03.6
06CA:  CALL   2DC
....................    PRINTF (LCD_PUTC, "      _                ");//6 SPACE PHIA TRUOC "_" 
06CB:  MOVLW  97
06CC:  BSF    03.6
06CD:  MOVWF  0D
06CE:  MOVLW  00
06CF:  MOVWF  0F
06D0:  BCF    03.6
06D1:  CALL   32A
....................    //ID_GW = "1234";     
....................  
....................    WHILE (TT_STT) 
06D2:  BTFSS  52.5
06D3:  GOTO   766
....................    { 
....................       IF (!INPUT (BT2_PIN)) //NEU NUT BAM DUOC BAM 
06D4:  BSF    03.5
06D5:  BSF    06.2
06D6:  BCF    03.5
06D7:  BTFSC  06.2
06D8:  GOTO   703
....................       { 
....................           
....................          NUM++; 
06D9:  BSF    03.5
06DA:  INCF   57,F
....................          NUM = NUM % 6; 
06DB:  MOVF   57,W
06DC:  MOVWF  5B
06DD:  MOVLW  06
06DE:  MOVWF  5C
06DF:  BCF    03.5
06E0:  CALL   535
06E1:  MOVF   77,W
06E2:  BSF    03.5
06E3:  MOVWF  57
....................          LCD_GOTOXY (3 + NUM, 1); 
06E4:  MOVLW  03
06E5:  ADDWF  57,W
06E6:  MOVWF  58
06E7:  BCF    03.5
06E8:  BSF    03.6
06E9:  MOVWF  36
06EA:  MOVLW  01
06EB:  MOVWF  37
06EC:  BCF    03.6
06ED:  CALL   2DC
....................          PRINTF (LCD_PUTC, "    _        ");//4SPACE 
06EE:  MOVLW  A3
06EF:  BSF    03.6
06F0:  MOVWF  0D
06F1:  MOVLW  00
06F2:  MOVWF  0F
06F3:  BCF    03.6
06F4:  CALL   32A
....................          DELAY_MS (300);  
06F5:  MOVLW  02
06F6:  BSF    03.5
06F7:  MOVWF  58
06F8:  MOVLW  96
06F9:  BCF    03.5
06FA:  BSF    03.6
06FB:  MOVWF  36
06FC:  BCF    03.6
06FD:  CALL   152
06FE:  BSF    03.5
06FF:  DECFSZ 58,F
0700:  GOTO   6F8
....................       } 
0701:  GOTO   764
0702:  BCF    03.5
....................  
....................       ELSE IF (!INPUT (BT3_PIN)) 
0703:  BSF    03.5
0704:  BSF    06.3
0705:  BCF    03.5
0706:  BTFSC  06.3
0707:  GOTO   765
....................       { 
....................          ID_GATEWAY[NUM]++; 
0708:  MOVLW  41
0709:  BSF    03.5
070A:  ADDWF  57,W
070B:  MOVWF  04
070C:  BCF    03.7
070D:  INCF   00,F
....................          ID_GATEWAY[NUM] = ID_GATEWAY[NUM] % 10; 
070E:  MOVLW  41
070F:  ADDWF  57,W
0710:  MOVWF  78
0711:  CLRF   7A
0712:  BTFSC  03.0
0713:  INCF   7A,F
0714:  MOVF   78,W
0715:  MOVWF  58
0716:  MOVF   7A,W
0717:  MOVWF  59
0718:  MOVLW  41
0719:  ADDWF  57,W
071A:  MOVWF  04
071B:  BCF    03.7
071C:  MOVF   00,W
071D:  MOVWF  5B
071E:  MOVLW  0A
071F:  MOVWF  5C
0720:  BCF    03.5
0721:  CALL   535
0722:  MOVF   77,W
0723:  BSF    03.5
0724:  MOVWF  5A
0725:  MOVF   58,W
0726:  MOVWF  04
0727:  BCF    03.7
0728:  BTFSC  59.0
0729:  BSF    03.7
072A:  MOVF   5A,W
072B:  MOVWF  00
....................          ITOA (ID_GATEWAY[NUM], 10, TEMP_CHAR); 
072C:  MOVLW  41
072D:  ADDWF  57,W
072E:  MOVWF  04
072F:  BCF    03.7
0730:  MOVF   00,W
0731:  MOVWF  58
0732:  BCF    03.5
0733:  BSF    03.6
0734:  CLRF   37
0735:  CLRF   36
0736:  CLRF   35
0737:  BSF    03.5
0738:  BCF    03.6
0739:  MOVF   58,W
073A:  BCF    03.5
073B:  BSF    03.6
073C:  MOVWF  34
073D:  MOVLW  0A
073E:  MOVWF  38
073F:  CLRF   3A
0740:  MOVLW  73
0741:  MOVWF  39
0742:  BCF    03.6
0743:  CALL   3F6
....................          LCD_GOTOXY (7 + NUM, 2); 
0744:  MOVLW  07
0745:  BSF    03.5
0746:  ADDWF  57,W
0747:  MOVWF  58
0748:  BCF    03.5
0749:  BSF    03.6
074A:  MOVWF  36
074B:  MOVLW  02
074C:  MOVWF  37
074D:  BCF    03.6
074E:  CALL   2DC
....................          DELAY_MS (10); 
074F:  MOVLW  0A
0750:  BSF    03.6
0751:  MOVWF  36
0752:  BCF    03.6
0753:  CALL   152
....................          PRINTF (LCD_PUTC, TEMP_CHAR); 
0754:  MOVLW  73
0755:  MOVWF  04
0756:  BCF    03.7
0757:  CALL   516
....................          DELAY_MS (300); 
0758:  MOVLW  02
0759:  BSF    03.5
075A:  MOVWF  58
075B:  MOVLW  96
075C:  BCF    03.5
075D:  BSF    03.6
075E:  MOVWF  36
075F:  BCF    03.6
0760:  CALL   152
0761:  BSF    03.5
0762:  DECFSZ 58,F
0763:  GOTO   75B
0764:  BCF    03.5
....................       } 
0765:  GOTO   6D2
....................    } 
.................... } 
....................  
.................... VOID BUTT_OKE() 
.................... { 
....................    TT_CONFIG_DONE = 0; 
*
0118:  BCF    03.6
0119:  BCF    52.3
....................    TT_FUN = 0;//BREAK WHILE BUTT_FUN 
011A:  BCF    52.4
....................    TT_STT = 0;// BREAK WHILE CHONID/NHAPID_GW 
011B:  BCF    52.5
.................... } 
....................  
.................... VOID SELLECT_FUN() 
.................... { 
....................    TT_CONFIG_DONE = 0; 
*
05C1:  BCF    52.3
....................  
....................    SWITCH (CONFIG_FUN) 
05C2:  MOVF   3C,W
05C3:  BTFSC  03.2
05C4:  GOTO   5C9
05C5:  XORLW  01
05C6:  BTFSC  03.2
05C7:  GOTO   694
05C8:  GOTO   766
....................    { 
....................       CASE 0: 
....................       CHON_ID (); 
....................       BREAK; 
*
0693:  GOTO   766
....................  
....................       CASE 1:     
....................       NHAPID_GW (); 
....................       BREAK; 
....................    } 
.................... } 
....................  
.................... VOID BUTT_FUN() 
.................... { 
....................    TT_FUN = 1; 
*
054C:  BSF    52.4
....................    LCD_GOTOXY (1, 1) ; 
054D:  MOVLW  01
054E:  BSF    03.6
054F:  MOVWF  36
0550:  MOVWF  37
0551:  BCF    03.6
0552:  CALL   2DC
....................    DELAY_MS (10); 
0553:  MOVLW  0A
0554:  BSF    03.6
0555:  MOVWF  36
0556:  BCF    03.6
0557:  CALL   152
....................    PRINTF (LCD_PUTC, "CONFIG:        "); 
0558:  MOVLW  AA
0559:  BSF    03.6
055A:  MOVWF  0D
055B:  MOVLW  00
055C:  MOVWF  0F
055D:  BCF    03.6
055E:  CALL   32A
....................  
....................    // HIEN THI LCD 
....................    LCD_GOTOXY (1, 2) ; 
055F:  MOVLW  01
0560:  BSF    03.6
0561:  MOVWF  36
0562:  MOVLW  02
0563:  MOVWF  37
0564:  BCF    03.6
0565:  CALL   2DC
....................    DELAY_MS (10); 
0566:  MOVLW  0A
0567:  BSF    03.6
0568:  MOVWF  36
0569:  BCF    03.6
056A:  CALL   152
....................    PRINTF (LCD_PUTC, "CASE:          ") ; 
056B:  MOVLW  B2
056C:  BSF    03.6
056D:  MOVWF  0D
056E:  MOVLW  00
056F:  MOVWF  0F
0570:  BCF    03.6
0571:  CALL   32A
....................  
....................    WHILE (TT_FUN) 
0572:  BTFSS  52.4
0573:  GOTO   5BF
....................    { 
....................       IF (INPUT (BT2_PIN) == 0) //NEU NUT BAM DUOC BAM 
0574:  BSF    03.5
0575:  BSF    06.2
0576:  BCF    03.5
0577:  BTFSC  06.2
0578:  GOTO   5BE
....................       { 
....................          CONFIG_FUN ++; 
0579:  INCF   3C,F
....................          CONFIG_FUN = CONFIG_FUN % 2; 
057A:  MOVLW  01
057B:  ANDWF  3C,F
....................          DELAY_MS (300); 
057C:  MOVLW  02
057D:  BSF    03.5
057E:  MOVWF  57
057F:  MOVLW  96
0580:  BCF    03.5
0581:  BSF    03.6
0582:  MOVWF  36
0583:  BCF    03.6
0584:  CALL   152
0585:  BSF    03.5
0586:  DECFSZ 57,F
0587:  GOTO   57F
....................          //HIEN THI 
....................          LCD_GOTOXY (6, 2) ; 
0588:  MOVLW  06
0589:  BCF    03.5
058A:  BSF    03.6
058B:  MOVWF  36
058C:  MOVLW  02
058D:  MOVWF  37
058E:  BCF    03.6
058F:  CALL   2DC
....................          ITOA (CONFIG_FUN, 10, TEMP_CHAR); 
0590:  BSF    03.6
0591:  CLRF   37
0592:  CLRF   36
0593:  CLRF   35
0594:  BCF    03.6
0595:  MOVF   3C,W
0596:  BSF    03.6
0597:  MOVWF  34
0598:  MOVLW  0A
0599:  MOVWF  38
059A:  CLRF   3A
059B:  MOVLW  73
059C:  MOVWF  39
059D:  BCF    03.6
059E:  CALL   3F6
....................          DELAY_MS (10); 
059F:  MOVLW  0A
05A0:  BSF    03.6
05A1:  MOVWF  36
05A2:  BCF    03.6
05A3:  CALL   152
....................          PRINTF (LCD_PUTC, TEMP_CHAR); 
05A4:  MOVLW  73
05A5:  MOVWF  04
05A6:  BCF    03.7
05A7:  CALL   516
....................  
....................          SWITCH (CONFIG_FUN) 
05A8:  MOVF   3C,W
05A9:  BTFSC  03.2
05AA:  GOTO   5AF
05AB:  XORLW  01
05AC:  BTFSC  03.2
05AD:  GOTO   5B7
05AE:  GOTO   5BE
....................          { 
....................             CASE 0: 
....................             PRINTF (LCD_PUTC, " - ID-NODE      "); 
05AF:  MOVLW  BA
05B0:  BSF    03.6
05B1:  MOVWF  0D
05B2:  MOVLW  00
05B3:  MOVWF  0F
05B4:  BCF    03.6
05B5:  CALL   32A
....................             BREAK; 
05B6:  GOTO   5BE
....................  
....................             CASE 1: 
....................             PRINTF (LCD_PUTC, " - ID-GW       "); 
05B7:  MOVLW  C3
05B8:  BSF    03.6
05B9:  MOVWF  0D
05BA:  MOVLW  00
05BB:  MOVWF  0F
05BC:  BCF    03.6
05BD:  CALL   32A
....................             BREAK;             
....................          } 
....................       } 
05BE:  GOTO   572
....................    } 
....................  
....................    ////// 
....................    IF (!TT_CONFIG_DONE) 
05BF:  BTFSC  52.3
05C0:  GOTO   766
....................    { 
....................       SELLECT_FUN (); 
....................    } 
*
0766:  BCF    0A.3
0767:  BSF    0A.4
0768:  GOTO   417 (RETURN)
.................... } 
.................... VOID XULY_IDNODE_NHAP(){ 
....................    //*TEMP_CHAR3 = "\0"; 
....................    *ID_NODE_CHAR = "\0"; 
*
0899:  CLRF   7A
089A:  MOVLW  53
089B:  BCF    03.5
089C:  BSF    03.6
089D:  MOVWF  33
089E:  MOVF   7A,W
089F:  MOVWF  34
08A0:  MOVF   33,W
08A1:  MOVWF  04
08A2:  BCF    03.7
08A3:  BTFSC  34.0
08A4:  BSF    03.7
08A5:  CLRF   00
....................    FOR (int j = 0; j < 4; j++) 
08A6:  CLRF   32
08A7:  MOVF   32,W
08A8:  SUBLW  03
08A9:  BTFSS  03.0
08AA:  GOTO   0D4
....................    { 
....................       ITOA (ID_NODE[j], 10, TEMP_CHAR); 
08AB:  MOVLW  47
08AC:  ADDWF  32,W
08AD:  MOVWF  04
08AE:  BCF    03.7
08AF:  MOVF   00,W
08B0:  MOVWF  33
08B1:  CLRF   37
08B2:  CLRF   36
08B3:  CLRF   35
08B4:  MOVF   33,W
08B5:  MOVWF  34
08B6:  MOVLW  0A
08B7:  MOVWF  38
08B8:  CLRF   3A
08B9:  MOVLW  73
08BA:  MOVWF  39
08BB:  BCF    0A.3
08BC:  BCF    03.6
08BD:  CALL   3F6
08BE:  BSF    0A.3
....................       DELAY_MS (1); 
08BF:  MOVLW  01
08C0:  BSF    03.6
08C1:  MOVWF  36
08C2:  BCF    0A.3
08C3:  BCF    03.6
08C4:  CALL   152
08C5:  BSF    0A.3
....................       STRCAT (ID_NODE_CHAR, TEMP_CHAR); 
08C6:  BSF    03.6
08C7:  CLRF   34
08C8:  MOVLW  53
08C9:  MOVWF  33
08CA:  CLRF   36
08CB:  MOVLW  73
08CC:  MOVWF  35
08CD:  BCF    0A.3
08CE:  BCF    03.6
08CF:  CALL   769
08D0:  BSF    0A.3
08D1:  BSF    03.6
08D2:  INCF   32,F
08D3:  GOTO   0A7
....................    }   
....................    //ID_NODE_CHAR = TEMP_CHAR3;    
....................    //STRCPY(ID_NODE_CHAR,TEMP_CHAR3); 
....................    //strcpy 
.................... } 
.................... VOID XULY_IDGW_NHAP(){ 
....................  
....................    *ID_GATEWAY_CHAR = "\0"; 
*
0859:  CLRF   7A
085A:  MOVLW  5A
085B:  BCF    03.5
085C:  BSF    03.6
085D:  MOVWF  33
085E:  MOVF   7A,W
085F:  MOVWF  34
0860:  MOVF   33,W
0861:  MOVWF  04
0862:  BCF    03.7
0863:  BTFSC  34.0
0864:  BSF    03.7
0865:  CLRF   00
....................    FOR (int j = 0; j < 6; j++) 
0866:  CLRF   32
0867:  MOVF   32,W
0868:  SUBLW  05
0869:  BTFSS  03.0
086A:  GOTO   094
....................    { 
....................       ITOA (ID_GATEWAY[j], 10, TEMP_CHAR); 
086B:  MOVLW  41
086C:  ADDWF  32,W
086D:  MOVWF  04
086E:  BCF    03.7
086F:  MOVF   00,W
0870:  MOVWF  33
0871:  CLRF   37
0872:  CLRF   36
0873:  CLRF   35
0874:  MOVF   33,W
0875:  MOVWF  34
0876:  MOVLW  0A
0877:  MOVWF  38
0878:  CLRF   3A
0879:  MOVLW  73
087A:  MOVWF  39
087B:  BCF    0A.3
087C:  BCF    03.6
087D:  CALL   3F6
087E:  BSF    0A.3
....................       DELAY_MS (1); 
087F:  MOVLW  01
0880:  BSF    03.6
0881:  MOVWF  36
0882:  BCF    0A.3
0883:  BCF    03.6
0884:  CALL   152
0885:  BSF    0A.3
....................       STRCAT (ID_GATEWAY_CHAR, TEMP_CHAR); 
0886:  BSF    03.6
0887:  CLRF   34
0888:  MOVLW  5A
0889:  MOVWF  33
088A:  CLRF   36
088B:  MOVLW  73
088C:  MOVWF  35
088D:  BCF    0A.3
088E:  BCF    03.6
088F:  CALL   769
0890:  BSF    0A.3
0891:  BSF    03.6
0892:  INCF   32,F
0893:  GOTO   067
....................    }   
.................... } 
....................  
....................  
.................... VOID CONFIG_DONE() 
.................... { 
....................    TT_FUN = 0; 
*
0800:  BCF    52.4
....................    TT_STT = 0; 
0801:  BCF    52.5
....................    CHAR *PACKAGE_CONFIG[]={"*", "LENGHT","C_F", "ID_GW1234" ,"ID_NODE","#"}; 
0802:  MOVLW  2A
0803:  BSF    03.6
0804:  MOVWF  10
0805:  CLRF   11
0806:  MOVLW  4C
0807:  MOVWF  12
0808:  MOVLW  45
0809:  MOVWF  13
080A:  MOVLW  4E
080B:  MOVWF  14
080C:  MOVLW  47
080D:  MOVWF  15
080E:  MOVLW  48
080F:  MOVWF  16
0810:  MOVLW  54
0811:  MOVWF  17
0812:  CLRF   18
0813:  MOVLW  43
0814:  MOVWF  19
0815:  MOVLW  5F
0816:  MOVWF  1A
0817:  MOVLW  46
0818:  MOVWF  1B
0819:  CLRF   1C
081A:  MOVLW  49
081B:  MOVWF  1D
081C:  MOVLW  44
081D:  MOVWF  1E
081E:  MOVLW  5F
081F:  MOVWF  1F
0820:  MOVLW  47
0821:  MOVWF  20
0822:  MOVLW  57
0823:  MOVWF  21
0824:  MOVLW  31
0825:  MOVWF  22
0826:  MOVLW  32
0827:  MOVWF  23
0828:  MOVLW  33
0829:  MOVWF  24
082A:  MOVLW  34
082B:  MOVWF  25
082C:  CLRF   26
082D:  MOVLW  49
082E:  MOVWF  27
082F:  MOVLW  44
0830:  MOVWF  28
0831:  MOVLW  5F
0832:  MOVWF  29
0833:  MOVLW  4E
0834:  MOVWF  2A
0835:  MOVLW  4F
0836:  MOVWF  2B
0837:  MOVLW  44
0838:  MOVWF  2C
0839:  MOVLW  45
083A:  MOVWF  2D
083B:  CLRF   2E
083C:  MOVLW  23
083D:  MOVWF  2F
083E:  CLRF   30
083F:  MOVLW  01
0840:  BSF    03.5
0841:  BCF    03.6
0842:  MOVWF  58
0843:  MOVLW  10
0844:  MOVWF  57
0845:  MOVLW  01
0846:  MOVWF  5A
0847:  MOVLW  12
0848:  MOVWF  59
0849:  MOVLW  01
084A:  MOVWF  5C
084B:  MOVLW  19
084C:  MOVWF  5B
084D:  MOVLW  01
084E:  MOVWF  5E
084F:  MOVLW  1D
0850:  MOVWF  5D
0851:  MOVLW  01
0852:  MOVWF  60
0853:  MOVLW  27
0854:  MOVWF  5F
0855:  MOVLW  01
0856:  MOVWF  62
0857:  MOVLW  2F
0858:  MOVWF  61
....................    XULY_IDGW_NHAP(); 
....................    PACKAGE_CONFIG[3] = ID_GATEWAY_CHAR; 
*
0894:  BSF    03.5
0895:  BCF    03.6
0896:  CLRF   5E
0897:  MOVLW  5A
0898:  MOVWF  5D
....................     
....................     
....................    XULY_IDNODE_NHAP(); 
....................    PACKAGE_CONFIG[4] = ID_NODE_CHAR;     
*
08D4:  BSF    03.5
08D5:  BCF    03.6
08D6:  CLRF   60
08D7:  MOVLW  53
08D8:  MOVWF  5F
....................         
....................    LEN_PACKAGES = 0; 
08D9:  BCF    03.5
08DA:  CLRF   4B
....................    PACKAGE_CONFIG[1] = "12"; //DO DAI CUA LENGHT CO DO DAI = 2 
08DB:  MOVLW  31
08DC:  BSF    03.5
08DD:  MOVWF  59
08DE:  MOVLW  32
08DF:  MOVWF  5A
....................    FOR (int J = 0; J < 6; J++) 
08E0:  CLRF   63
08E1:  MOVF   63,W
08E2:  SUBLW  05
08E3:  BTFSS  03.0
08E4:  GOTO   103
....................    { 
....................       LEN_PACKAGES += strlen(PACKAGE_CONFIG[J]); 
08E5:  BCF    03.0
08E6:  RLF    63,W
08E7:  ADDLW  D7
08E8:  MOVWF  04
08E9:  BCF    03.7
08EA:  INCF   04,F
08EB:  MOVF   00,W
08EC:  MOVWF  65
08ED:  DECF   04,F
08EE:  MOVF   00,W
08EF:  MOVWF  64
08F0:  MOVF   65,W
08F1:  BCF    03.5
08F2:  BSF    03.6
08F3:  MOVWF  35
08F4:  BSF    03.5
08F5:  BCF    03.6
08F6:  MOVF   64,W
08F7:  BCF    03.5
08F8:  BSF    03.6
08F9:  MOVWF  34
08FA:  BCF    0A.3
08FB:  BCF    03.6
08FC:  CALL   7A7
08FD:  BSF    0A.3
08FE:  MOVF   78,W
08FF:  ADDWF  4B,F
0900:  BSF    03.5
0901:  INCF   63,F
0902:  GOTO   0E1
....................    }    
....................    LEN_PACKAGES = LEN_PACKAGES+5; //5 @ 
0903:  MOVLW  05
0904:  BCF    03.5
0905:  ADDWF  4B,F
....................    ITOA (LEN_PACKAGES, 10, TEMP_CHAR); 
0906:  BSF    03.6
0907:  CLRF   37
0908:  CLRF   36
0909:  CLRF   35
090A:  BCF    03.6
090B:  MOVF   4B,W
090C:  BSF    03.6
090D:  MOVWF  34
090E:  MOVLW  0A
090F:  MOVWF  38
0910:  CLRF   3A
0911:  MOVLW  73
0912:  MOVWF  39
0913:  BCF    0A.3
0914:  BCF    03.6
0915:  CALL   3F6
0916:  BSF    0A.3
....................    PACKAGE_CONFIG[1] = TEMP_CHAR; 
0917:  BSF    03.5
0918:  CLRF   5A
0919:  MOVLW  73
091A:  MOVWF  59
....................     
....................    FOR ( J = 0; J < 6; J++) 
091B:  CLRF   63
091C:  MOVF   63,W
091D:  SUBLW  05
091E:  BTFSS  03.0
091F:  GOTO   13A
....................    { 
....................       PRINTF (PACKAGE_CONFIG[J]); 
0920:  BCF    03.0
0921:  RLF    63,W
0922:  ADDLW  D7
0923:  MOVWF  04
0924:  BCF    03.7
0925:  INCF   04,F
0926:  MOVF   00,W
0927:  MOVWF  65
0928:  DECF   04,F
0929:  MOVF   00,W
092A:  MOVWF  64
092B:  MOVWF  04
092C:  BCF    03.7
092D:  BTFSC  65.0
092E:  BSF    03.7
092F:  BCF    0A.3
0930:  BCF    03.5
0931:  CALL   7C7
0932:  BSF    0A.3
....................       PRINTF ("@"); 
0933:  MOVLW  40
0934:  BTFSS  0C.4
0935:  GOTO   134
0936:  MOVWF  19
0937:  BSF    03.5
0938:  INCF   63,F
0939:  GOTO   11C
....................    } 
....................  
....................  
....................    LCD_GOTOXY (1, 1) ; 
093A:  MOVLW  01
093B:  BCF    03.5
093C:  BSF    03.6
093D:  MOVWF  36
093E:  MOVWF  37
093F:  BCF    0A.3
0940:  BCF    03.6
0941:  CALL   2DC
0942:  BSF    0A.3
....................    DELAY_MS (10); 
0943:  MOVLW  0A
0944:  BSF    03.6
0945:  MOVWF  36
0946:  BCF    0A.3
0947:  BCF    03.6
0948:  CALL   152
0949:  BSF    0A.3
....................    PRINTF (LCD_PUTC, "WAITING ....        ") ; 
094A:  MOVLW  CB
094B:  BSF    03.6
094C:  MOVWF  0D
094D:  MOVLW  00
094E:  MOVWF  0F
094F:  BCF    0A.3
0950:  BCF    03.6
0951:  CALL   32A
0952:  BSF    0A.3
....................    LCD_GOTOXY (1, 2) ; 
0953:  MOVLW  01
0954:  BSF    03.6
0955:  MOVWF  36
0956:  MOVLW  02
0957:  MOVWF  37
0958:  BCF    0A.3
0959:  BCF    03.6
095A:  CALL   2DC
095B:  BSF    0A.3
....................    DELAY_MS (10); 
095C:  MOVLW  0A
095D:  BSF    03.6
095E:  MOVWF  36
095F:  BCF    0A.3
0960:  BCF    03.6
0961:  CALL   152
0962:  BSF    0A.3
....................    PRINTF (LCD_PUTC, "WAITING ....        ") ;    
0963:  MOVLW  D6
0964:  BSF    03.6
0965:  MOVWF  0D
0966:  MOVLW  00
0967:  MOVWF  0F
0968:  BCF    0A.3
0969:  BCF    03.6
096A:  CALL   32A
096B:  BSF    0A.3
....................    TT_CONFIG_DONE = 0; 
096C:  BCF    52.3
096D:  BCF    0A.3
096E:  BSF    0A.4
096F:  GOTO   41E (RETURN)
.................... } 
....................  
....................  
....................  VOID XACNHANCONFIG() 
....................  {    
....................    KYTU=0; 
*
0CF2:  CLRF   3E
....................    OUTPUT_D (0XFF);        
0CF3:  BSF    03.5
0CF4:  CLRF   08
0CF5:  MOVLW  FF
0CF6:  BCF    03.5
0CF7:  MOVWF  08
....................    LCD_GOTOXY (1, 1) ; 
0CF8:  MOVLW  01
0CF9:  BSF    03.6
0CFA:  MOVWF  36
0CFB:  MOVWF  37
0CFC:  BCF    0A.3
0CFD:  BCF    03.6
0CFE:  CALL   2DC
0CFF:  BSF    0A.3
....................    DELAY_MS (10); 
0D00:  MOVLW  0A
0D01:  BSF    03.6
0D02:  MOVWF  36
0D03:  BCF    0A.3
0D04:  BCF    03.6
0D05:  CALL   152
0D06:  BSF    0A.3
....................    TEMP_CHAR = "_"; 
0D07:  BSF    03.5
0D08:  CLRF   5F
0D09:  CLRF   60
0D0A:  MOVLW  73
0D0B:  MOVWF  04
0D0C:  BCF    03.7
0D0D:  MOVF   5F,W
0D0E:  ADDWF  04,F
0D0F:  MOVF   60,W
0D10:  BCF    0A.3
0D11:  BCF    03.5
0D12:  CALL   05E
0D13:  BSF    0A.3
0D14:  MOVWF  00
0D15:  IORLW  00
0D16:  BTFSC  03.2
0D17:  GOTO   51D
0D18:  BSF    03.5
0D19:  INCF   60,F
0D1A:  INCF   5F,F
0D1B:  GOTO   50A
0D1C:  BCF    03.5
....................    CHAR * TOKEN; 
....................    TOKEN = STRTOK (KYTUCHAR2, TEMP_CHAR);    
0D1D:  BSF    03.5
0D1E:  CLRF   60
0D1F:  MOVLW  BE
0D20:  MOVWF  5F
0D21:  CLRF   62
0D22:  MOVLW  73
0D23:  MOVWF  61
0D24:  BCF    03.5
0D25:  CALL   170
0D26:  MOVF   79,W
0D27:  BSF    03.5
0D28:  MOVWF  5E
0D29:  MOVF   78,W
0D2A:  MOVWF  5D
....................     WHILE (TOKEN != NULL) 
0D2B:  MOVF   5D,F
0D2C:  BTFSS  03.2
0D2D:  GOTO   531
0D2E:  MOVF   5E,F
0D2F:  BTFSC  03.2
0D30:  GOTO   57A
....................     {                 
....................        SWITCH(KYTU) 
0D31:  BCF    03.5
0D32:  MOVF   3E,W
0D33:  BTFSC  03.2
0D34:  GOTO   53C
0D35:  XORLW  01
0D36:  BTFSC  03.2
0D37:  GOTO   556
0D38:  XORLW  03
0D39:  BTFSC  03.2
0D3A:  GOTO   560
0D3B:  GOTO   569
....................        { 
....................          CASE 0: 
....................          DELAY_MS (1); 
0D3C:  MOVLW  01
0D3D:  BSF    03.6
0D3E:  MOVWF  36
0D3F:  BCF    0A.3
0D40:  BCF    03.6
0D41:  CALL   152
0D42:  BSF    0A.3
....................          PRINTF (LCD_PUTC,TOKEN); 
0D43:  BSF    03.5
0D44:  MOVF   5D,W
0D45:  MOVWF  04
0D46:  BCF    03.7
0D47:  BTFSC  5E.0
0D48:  BSF    03.7
0D49:  BCF    0A.3
0D4A:  BCF    03.5
0D4B:  CALL   516
0D4C:  BSF    0A.3
....................          PRINTF (LCD_PUTC,"            "); 
0D4D:  MOVLW  E1
0D4E:  BSF    03.6
0D4F:  MOVWF  0D
0D50:  MOVLW  00
0D51:  MOVWF  0F
0D52:  BCF    0A.3
0D53:  BCF    03.6
0D54:  CALL   32A
0D55:  BSF    0A.3
....................          CASE 1:  
....................          SOLUONGTHIETBI_CONFIG = ATOI(TOKEN); 
0D56:  BSF    03.5
0D57:  MOVF   5E,W
0D58:  MOVWF  60
0D59:  MOVF   5D,W
0D5A:  MOVWF  5F
0D5B:  BCF    03.5
0D5C:  CALL   261
0D5D:  MOVF   78,W
0D5E:  MOVWF  4E
....................          BREAK;                      
0D5F:  GOTO   569
....................          CASE 2: 
....................          SOLUONGCAMBIEN_CONFIG = ATOI(TOKEN); 
0D60:  BSF    03.5
0D61:  MOVF   5E,W
0D62:  MOVWF  60
0D63:  MOVF   5D,W
0D64:  MOVWF  5F
0D65:  BCF    03.5
0D66:  CALL   261
0D67:  MOVF   78,W
0D68:  MOVWF  4F
....................          BREAK;               
....................        }  
....................       TOKEN = STRTOK(NULL, TEMP_CHAR); 
0D69:  BSF    03.5
0D6A:  CLRF   60
0D6B:  CLRF   5F
0D6C:  CLRF   62
0D6D:  MOVLW  73
0D6E:  MOVWF  61
0D6F:  BCF    03.5
0D70:  CALL   170
0D71:  MOVF   79,W
0D72:  BSF    03.5
0D73:  MOVWF  5E
0D74:  MOVF   78,W
0D75:  MOVWF  5D
....................       KYTU++;         
0D76:  BCF    03.5
0D77:  INCF   3E,F
0D78:  BSF    03.5
0D79:  GOTO   52B
....................     }           
....................    DELAY_MS(500); 
0D7A:  MOVLW  02
0D7B:  MOVWF  5F
0D7C:  MOVLW  FA
0D7D:  BCF    03.5
0D7E:  BSF    03.6
0D7F:  MOVWF  36
0D80:  BCF    0A.3
0D81:  BCF    03.6
0D82:  CALL   152
0D83:  BSF    0A.3
0D84:  BSF    03.5
0D85:  DECFSZ 5F,F
0D86:  GOTO   57C
....................    DELAY_MS (1);  
0D87:  MOVLW  01
0D88:  BCF    03.5
0D89:  BSF    03.6
0D8A:  MOVWF  36
0D8B:  BCF    0A.3
0D8C:  BCF    03.6
0D8D:  CALL   152
0D8E:  BSF    0A.3
....................    OUTPUT_D (0XFF);      
0D8F:  BSF    03.5
0D90:  CLRF   08
0D91:  MOVLW  FF
0D92:  BCF    03.5
0D93:  MOVWF  08
....................    LCD_GOTOXY (1, 2) ; 
0D94:  MOVLW  01
0D95:  BSF    03.6
0D96:  MOVWF  36
0D97:  MOVLW  02
0D98:  MOVWF  37
0D99:  BCF    0A.3
0D9A:  BCF    03.6
0D9B:  CALL   2DC
0D9C:  BSF    0A.3
....................    DELAY_MS (10); 
0D9D:  MOVLW  0A
0D9E:  BSF    03.6
0D9F:  MOVWF  36
0DA0:  BCF    0A.3
0DA1:  BCF    03.6
0DA2:  CALL   152
0DA3:  BSF    0A.3
....................    PRINTF (LCD_PUTC,"TB: ");    
0DA4:  MOVLW  E8
0DA5:  BSF    03.6
0DA6:  MOVWF  0D
0DA7:  MOVLW  00
0DA8:  MOVWF  0F
0DA9:  BCF    0A.3
0DAA:  BCF    03.6
0DAB:  CALL   32A
0DAC:  BSF    0A.3
....................    ITOA (SOLUONGTHIETBI_CONFIG, 10, TEMP_CHAR);    
0DAD:  BSF    03.6
0DAE:  CLRF   37
0DAF:  CLRF   36
0DB0:  CLRF   35
0DB1:  BCF    03.6
0DB2:  MOVF   4E,W
0DB3:  BSF    03.6
0DB4:  MOVWF  34
0DB5:  MOVLW  0A
0DB6:  MOVWF  38
0DB7:  CLRF   3A
0DB8:  MOVLW  73
0DB9:  MOVWF  39
0DBA:  BCF    0A.3
0DBB:  BCF    03.6
0DBC:  CALL   3F6
0DBD:  BSF    0A.3
....................    PRINTF (LCD_PUTC,TEMP_CHAR);    
0DBE:  MOVLW  73
0DBF:  MOVWF  04
0DC0:  BCF    03.7
0DC1:  BCF    0A.3
0DC2:  CALL   516
0DC3:  BSF    0A.3
....................    PRINTF (LCD_PUTC,"    CB:");    
0DC4:  MOVLW  EB
0DC5:  BSF    03.6
0DC6:  MOVWF  0D
0DC7:  MOVLW  00
0DC8:  MOVWF  0F
0DC9:  BCF    0A.3
0DCA:  BCF    03.6
0DCB:  CALL   32A
0DCC:  BSF    0A.3
....................    ITOA (SOLUONGCAMBIEN_CONFIG, 10, TEMP_CHAR);    
0DCD:  BSF    03.6
0DCE:  CLRF   37
0DCF:  CLRF   36
0DD0:  CLRF   35
0DD1:  BCF    03.6
0DD2:  MOVF   4F,W
0DD3:  BSF    03.6
0DD4:  MOVWF  34
0DD5:  MOVLW  0A
0DD6:  MOVWF  38
0DD7:  CLRF   3A
0DD8:  MOVLW  73
0DD9:  MOVWF  39
0DDA:  BCF    0A.3
0DDB:  BCF    03.6
0DDC:  CALL   3F6
0DDD:  BSF    0A.3
....................    PRINTF (LCD_PUTC,TEMP_CHAR);       
0DDE:  MOVLW  73
0DDF:  MOVWF  04
0DE0:  BCF    03.7
0DE1:  BCF    0A.3
0DE2:  CALL   516
0DE3:  BSF    0A.3
....................    OUTPUT_D (0X00); 
0DE4:  BSF    03.5
0DE5:  CLRF   08
0DE6:  BCF    03.5
0DE7:  CLRF   08
....................    DELAY_MS(500); 
0DE8:  MOVLW  02
0DE9:  BSF    03.5
0DEA:  MOVWF  5F
0DEB:  MOVLW  FA
0DEC:  BCF    03.5
0DED:  BSF    03.6
0DEE:  MOVWF  36
0DEF:  BCF    0A.3
0DF0:  BCF    03.6
0DF1:  CALL   152
0DF2:  BSF    0A.3
0DF3:  BSF    03.5
0DF4:  DECFSZ 5F,F
0DF5:  GOTO   5EB
....................    OUTPUT_D (0XFF);     
0DF6:  CLRF   08
0DF7:  MOVLW  FF
0DF8:  BCF    03.5
0DF9:  MOVWF  08
....................    DELAY_MS(500); 
0DFA:  MOVLW  02
0DFB:  BSF    03.5
0DFC:  MOVWF  5F
0DFD:  MOVLW  FA
0DFE:  BCF    03.5
0DFF:  BSF    03.6
0E00:  MOVWF  36
0E01:  BCF    0A.3
0E02:  BCF    03.6
0E03:  CALL   152
0E04:  BSF    0A.3
0E05:  BSF    03.5
0E06:  DECFSZ 5F,F
0E07:  GOTO   5FD
....................    OUTPUT_D (0X00); 
0E08:  CLRF   08
0E09:  BCF    03.5
0E0A:  CLRF   08
....................    TT_CONFIG_OKE_UART = 1; 
0E0B:  BSF    52.6
....................     
....................  }  
.................... //--------------------------------------------------------------------// 
....................  
....................  
....................  
....................  
....................  
.................... VOID QUET_PHIM() 
*
00EF:  BSF    03.6
00F0:  CLRF   69
.................... { 
....................    INT BDT = 0; 
....................  
....................    WHILE (!INPUT (BT1_PIN)) //NEU NUT BAM DUOC BAM 
00F1:  BSF    03.5
00F2:  BCF    03.6
00F3:  BSF    06.1
00F4:  BCF    03.5
00F5:  BTFSC  06.1
00F6:  GOTO   10A
....................    { 
....................       IF (TMR1IF) 
00F7:  BTFSS  0C.0
00F8:  GOTO   107
....................       { 
....................          OUTPUT_TOGGLE (PIN_D2); 
00F9:  BSF    03.5
00FA:  BCF    08.2
00FB:  MOVLW  04
00FC:  BCF    03.5
00FD:  XORWF  08,F
....................          TMR1IF = 0; SET_TIMER1 (3036); BDT++; 
00FE:  BCF    0C.0
00FF:  CLRF   0E
0100:  MOVLW  0B
0101:  MOVWF  0F
0102:  MOVLW  DC
0103:  MOVWF  0E
0104:  BSF    03.6
0105:  INCF   69,F
0106:  BCF    03.6
....................       } 
0107:  BSF    03.6
0108:  GOTO   0F1
0109:  BCF    03.6
....................    } 
....................  
....................    IF (BDT > 20) 
010A:  BSF    03.6
010B:  MOVF   69,W
010C:  SUBLW  14
010D:  BTFSC  03.0
010E:  GOTO   118
....................    { 
....................       //CONFIG NODE 
....................       TT_CONFIG = ~TT_CONFIG; // VAO TRANG THAI CONFIG 
010F:  MOVLW  02
0110:  BCF    03.6
0111:  XORWF  52,F
....................       TT_CONTROL = ~TT_CONTROL; 
0112:  MOVLW  04
0113:  XORWF  52,F
....................       //CONFIG_DONE (); 
....................       TT_CONFIG_DONE = 1; 
0114:  BSF    52.3
....................       TT_FUN = 0; 
0115:  BCF    52.4
....................    } 
0116:  GOTO   11C
0117:  BSF    03.6
....................  
....................    ELSE 
....................    { 
....................       BUTT_OKE (); //OKE 
....................    } 
.................... } 
....................  
.................... #INT_EXT 
....................  
....................  VOID NGAT_NGOAI () 
....................  { 
....................     QUET_PHIM (); 
....................  } 
....................  
*
011C:  BCF    0B.1
011D:  BCF    0A.3
011E:  BCF    0A.4
011F:  GOTO   031
....................  #INT_RDA 
....................  VOID NGAT () 
....................  { 
....................     KYTUCHAR[VT] = GETCH (); 
0120:  MOVLW  A0
0121:  ADDWF  3D,W
0122:  MOVWF  04
0123:  BCF    03.7
0124:  BTFSS  0C.5
0125:  GOTO   124
0126:  MOVF   1A,W
0127:  MOVWF  00
....................  
....................     IF (KYTUCHAR[VT] == '.') 
0128:  MOVLW  A0
0129:  ADDWF  3D,W
012A:  MOVWF  04
012B:  BCF    03.7
012C:  MOVF   00,W
012D:  SUBLW  2E
012E:  BTFSS  03.2
012F:  GOTO   138
....................     { 
....................        KYTUCHAR[VT] = '\0'; 
0130:  MOVLW  A0
0131:  ADDWF  3D,W
0132:  MOVWF  04
0133:  BCF    03.7
0134:  CLRF   00
....................        VT = 0; 
0135:  CLRF   3D
....................        TTNHAN = 1; 
0136:  BSF    52.0
....................     } 
0137:  GOTO   139
....................     ELSE 
....................     VT++; 
0138:  INCF   3D,F
0139:  BCF    0C.5
013A:  BCF    0A.3
013B:  BCF    0A.4
013C:  GOTO   031
....................  } 
....................   INT ADC_READ (INT KENH) 
....................  { 
....................     UNSIGNED INT8 ANALOG_PORT[] = {1,2,4,8,16,32,64};  
*
1010:  MOVLW  01
1011:  MOVWF  5B
1012:  MOVLW  02
1013:  MOVWF  5C
1014:  MOVLW  04
1015:  MOVWF  5D
1016:  MOVLW  08
1017:  MOVWF  5E
1018:  MOVLW  10
1019:  MOVWF  5F
101A:  MOVLW  20
101B:  MOVWF  60
101C:  MOVLW  40
101D:  MOVWF  61
....................     SETUP_ADC_PORTS (ANALOG_PORT[KENH]); 
101E:  MOVLW  DB
101F:  ADDWF  5A,W
1020:  MOVWF  04
1021:  BCF    03.7
1022:  MOVF   00,W
1023:  MOVWF  63
1024:  MOVWF  64
1025:  CLRF   65
1026:  CLRF   66
1027:  CLRF   67
1028:  MOVLW  89
1029:  MOVWF  04
102A:  BSF    03.7
102B:  MOVLW  C0
102C:  ANDWF  00,F
102D:  MOVF   66,W
102E:  IORWF  00,F
102F:  MOVLW  9F
1030:  MOVWF  04
1031:  BCF    03.7
1032:  MOVLW  CF
1033:  ANDWF  00,F
1034:  MOVF   65,W
1035:  IORWF  00,F
1036:  MOVLW  88
1037:  MOVWF  04
1038:  BSF    03.7
1039:  MOVF   64,W
103A:  MOVWF  00
....................     DELAY_MS(3); 
103B:  MOVLW  03
103C:  BCF    03.5
103D:  BSF    03.6
103E:  MOVWF  36
103F:  BCF    0A.4
1040:  BCF    03.6
1041:  CALL   152
1042:  BSF    0A.4
....................     SET_ADC_CHANNEL (KENH); 
1043:  BSF    03.5
1044:  RLF    5A,W
1045:  MOVWF  77
1046:  RLF    77,F
1047:  MOVLW  FC
1048:  ANDWF  77,F
1049:  BCF    03.5
104A:  MOVF   1F,W
104B:  ANDLW  C3
104C:  IORWF  77,W
104D:  MOVWF  1F
....................     DELAY_MS(3); 
104E:  MOVLW  03
104F:  BSF    03.6
1050:  MOVWF  36
1051:  BCF    0A.4
1052:  BCF    03.6
1053:  CALL   152
1054:  BSF    0A.4
....................     KQADC = 0; 
1055:  CLRF   33
1056:  CLRF   32
....................     FOR (INT I = 0; I < 100; I++) 
1057:  BSF    03.5
1058:  CLRF   62
1059:  MOVF   62,W
105A:  SUBLW  63
105B:  BTFSS  03.0
105C:  GOTO   073
....................     { 
....................        KQADC = KQADC + READ_ADC () ; 
105D:  BCF    03.5
105E:  BSF    1F.1
105F:  BTFSC  1F.1
1060:  GOTO   05F
1061:  BSF    03.5
1062:  MOVF   1E,W
1063:  BCF    03.5
1064:  ADDWF  32,F
1065:  MOVF   1E,W
1066:  BTFSC  03.0
1067:  INCFSZ 1E,W
1068:  ADDWF  33,F
....................        DELAY_MS (1); 
1069:  MOVLW  01
106A:  BSF    03.6
106B:  MOVWF  36
106C:  BCF    0A.4
106D:  BCF    03.6
106E:  CALL   152
106F:  BSF    0A.4
1070:  BSF    03.5
1071:  INCF   62,F
1072:  GOTO   059
....................     } 
....................  
....................     KQADC = KQADC / (100 * 2.046); 
1073:  BCF    03.5
1074:  MOVF   33,W
1075:  BSF    03.5
1076:  MOVWF  64
1077:  BCF    03.5
1078:  MOVF   32,W
1079:  BSF    03.5
107A:  MOVWF  63
*
1097:  MOVF   7A,W
1098:  MOVWF  66
1099:  MOVF   79,W
109A:  MOVWF  65
109B:  MOVF   78,W
109C:  MOVWF  64
109D:  MOVF   77,W
109E:  MOVWF  63
109F:  MOVLW  9A
10A0:  MOVWF  6A
10A1:  MOVLW  99
10A2:  MOVWF  69
10A3:  MOVLW  4C
10A4:  MOVWF  68
10A5:  MOVLW  86
10A6:  MOVWF  67
*
11C8:  MOVF   7A,W
11C9:  BSF    03.5
11CA:  BCF    03.6
11CB:  MOVWF  66
11CC:  MOVF   79,W
11CD:  MOVWF  65
11CE:  MOVF   78,W
11CF:  MOVWF  64
11D0:  MOVF   77,W
11D1:  MOVWF  63
*
11F0:  MOVF   79,W
11F1:  BCF    03.5
11F2:  MOVWF  33
11F3:  MOVF   78,W
11F4:  MOVWF  32
....................     RETURN KQADC; 
11F5:  MOVF   32,W
11F6:  MOVWF  78
....................  } 
....................  
....................  
....................  VOID READ_ANALOG ( ) 
....................  { 
....................    FOR(INT K = 0; K<SOLUONGCAMBIEN_CONFIG; K++){ 
*
1000:  BSF    03.5
1001:  CLRF   57
1002:  BCF    03.5
1003:  MOVF   4F,W
1004:  BSF    03.5
1005:  SUBWF  57,W
1006:  BTFSC  03.0
1007:  GOTO   201
....................       KET_QUA_ANALOG[K] = ADC_READ (K);   
1008:  MOVLW  38
1009:  ADDWF  57,W
100A:  MOVWF  58
100B:  CLRF   59
100C:  BTFSC  03.0
100D:  INCF   59,F
100E:  MOVF   57,W
100F:  MOVWF  5A
*
11F7:  BSF    03.5
11F8:  MOVF   58,W
11F9:  MOVWF  04
11FA:  BCF    03.7
11FB:  BTFSC  59.0
11FC:  BSF    03.7
11FD:  MOVF   78,W
11FE:  MOVWF  00
11FF:  INCF   57,F
1200:  GOTO   002
....................    } 
1201:  BCF    03.5
1202:  BCF    0A.3
1203:  BSF    0A.4
1204:  GOTO   431 (RETURN)
....................  } 
....................  
....................  VOID SEND_ANALOG_UART() 
....................  { 
....................    OUTPUT_TOGGLE(PIN_D6); 
1205:  BSF    03.5
1206:  BCF    08.6
1207:  MOVLW  40
1208:  BCF    03.5
1209:  XORWF  08,F
....................    //CHAR *PACKAGE_SS[]={"*", "26","SS", "IDGW12" ,"NODE","ZZ","AA","VV","CC","SS"}; 
....................    CHAR *PACKAGE_SS[]={"IDGW12" ,"NODE","ZZ","AA","VV","CC","SS"};    
120A:  MOVLW  49
120B:  BSF    03.6
120C:  MOVWF  10
120D:  MOVLW  44
120E:  MOVWF  11
120F:  MOVLW  47
1210:  MOVWF  12
1211:  MOVLW  57
1212:  MOVWF  13
1213:  MOVLW  31
1214:  MOVWF  14
1215:  MOVLW  32
1216:  MOVWF  15
1217:  CLRF   16
1218:  MOVLW  4E
1219:  MOVWF  17
121A:  MOVLW  4F
121B:  MOVWF  18
121C:  MOVLW  44
121D:  MOVWF  19
121E:  MOVLW  45
121F:  MOVWF  1A
1220:  CLRF   1B
1221:  MOVLW  5A
1222:  MOVWF  1C
1223:  MOVWF  1D
1224:  CLRF   1E
1225:  MOVLW  41
1226:  MOVWF  1F
1227:  MOVWF  20
1228:  CLRF   21
1229:  MOVLW  56
122A:  MOVWF  22
122B:  MOVWF  23
122C:  CLRF   24
122D:  MOVLW  43
122E:  MOVWF  25
122F:  MOVWF  26
1230:  CLRF   27
1231:  MOVLW  53
1232:  MOVWF  28
1233:  MOVWF  29
1234:  CLRF   2A
1235:  MOVLW  01
1236:  BSF    03.5
1237:  BCF    03.6
1238:  MOVWF  58
1239:  MOVLW  10
123A:  MOVWF  57
123B:  MOVLW  01
123C:  MOVWF  5A
123D:  MOVLW  17
123E:  MOVWF  59
123F:  MOVLW  01
1240:  MOVWF  5C
1241:  MOVLW  1C
1242:  MOVWF  5B
1243:  MOVLW  01
1244:  MOVWF  5E
1245:  MOVLW  1F
1246:  MOVWF  5D
1247:  MOVLW  01
1248:  MOVWF  60
1249:  MOVLW  22
124A:  MOVWF  5F
124B:  MOVLW  01
124C:  MOVWF  62
124D:  MOVLW  25
124E:  MOVWF  61
124F:  MOVLW  01
1250:  MOVWF  64
1251:  MOVLW  28
1252:  MOVWF  63
....................    PACKAGE_SS[0] = ID_GATEWAY_CHAR; 
1253:  CLRF   58
1254:  MOVLW  5A
1255:  MOVWF  57
....................    PACKAGE_SS[1] = ID_NODE_CHAR; 
1256:  CLRF   5A
1257:  MOVLW  53
1258:  MOVWF  59
....................    UNSIGNED INT8 DO_DAI =20; 
1259:  MOVLW  14
125A:  MOVWF  65
....................     
....................    FOR(INT I = 0; I<SOLUONGCAMBIEN_CONFIG; I++) 
125B:  CLRF   66
125C:  BCF    03.5
125D:  MOVF   4F,W
125E:  BSF    03.5
125F:  SUBWF  66,W
1260:  BTFSC  03.0
1261:  GOTO   299
....................    { 
....................       ITOA(KET_QUA_ANALOG[I],10,PACKAGE_SS[2+I]); 
1262:  MOVLW  38
1263:  ADDWF  66,W
1264:  MOVWF  04
1265:  BCF    03.7
1266:  MOVF   00,W
1267:  MOVWF  67
1268:  MOVLW  02
1269:  ADDWF  66,W
126A:  MOVWF  77
126B:  BCF    03.0
126C:  RLF    77,F
126D:  MOVF   77,W
126E:  ADDLW  D7
126F:  MOVWF  04
1270:  BCF    03.7
1271:  INCF   04,F
1272:  MOVF   00,W
1273:  MOVWF  69
1274:  DECF   04,F
1275:  MOVF   00,W
1276:  MOVWF  68
1277:  BCF    03.5
1278:  BSF    03.6
1279:  CLRF   37
127A:  CLRF   36
127B:  CLRF   35
127C:  BSF    03.5
127D:  BCF    03.6
127E:  MOVF   67,W
127F:  BCF    03.5
1280:  BSF    03.6
1281:  MOVWF  34
1282:  MOVLW  0A
1283:  MOVWF  38
1284:  BSF    03.5
1285:  BCF    03.6
1286:  MOVF   69,W
1287:  BCF    03.5
1288:  BSF    03.6
1289:  MOVWF  3A
128A:  BSF    03.5
128B:  BCF    03.6
128C:  MOVF   68,W
128D:  BCF    03.5
128E:  BSF    03.6
128F:  MOVWF  39
1290:  BCF    0A.4
1291:  BCF    03.6
1292:  CALL   3F6
1293:  BSF    0A.4
....................       DO_DAI = DO_DAI + 3; 
1294:  MOVLW  03
1295:  BSF    03.5
1296:  ADDWF  65,F
1297:  INCF   66,F
1298:  GOTO   25C
....................    }       
....................    ITOA(DO_DAI,10,TEMP_CHAR2); 
1299:  BCF    03.5
129A:  BSF    03.6
129B:  CLRF   37
129C:  CLRF   36
129D:  CLRF   35
129E:  BSF    03.5
129F:  BCF    03.6
12A0:  MOVF   65,W
12A1:  BCF    03.5
12A2:  BSF    03.6
12A3:  MOVWF  34
12A4:  MOVLW  0A
12A5:  MOVWF  38
12A6:  CLRF   3A
12A7:  MOVLW  75
12A8:  MOVWF  39
12A9:  BCF    0A.4
12AA:  BCF    03.6
12AB:  CALL   3F6
12AC:  BSF    0A.4
....................    PRINTF ("*@");    
12AD:  MOVLW  2A
12AE:  BTFSS  0C.4
12AF:  GOTO   2AE
12B0:  MOVWF  19
12B1:  MOVLW  40
12B2:  BTFSS  0C.4
12B3:  GOTO   2B2
12B4:  MOVWF  19
....................    PRINTF (TEMP_CHAR2); 
12B5:  MOVLW  75
12B6:  MOVWF  04
12B7:  BCF    03.7
12B8:  BCF    0A.4
12B9:  CALL   7C7
12BA:  BSF    0A.4
....................    PRINTF ("@SS@");    
12BB:  MOVLW  3D
12BC:  BSF    03.6
12BD:  MOVWF  0D
12BE:  MOVLW  01
12BF:  MOVWF  0F
....................    FOR ( I = 0; I < 2 + SOLUONGCAMBIEN_CONFIG; I++) 
*
130F:  BSF    03.5
1310:  BCF    03.6
1311:  CLRF   66
1312:  MOVLW  02
1313:  BCF    03.5
1314:  ADDWF  4F,W
1315:  BSF    03.5
1316:  SUBWF  66,W
1317:  BTFSC  03.0
1318:  GOTO   333
....................    { 
....................       PRINTF (PACKAGE_SS[I]); 
1319:  BCF    03.0
131A:  RLF    66,W
131B:  ADDLW  D7
131C:  MOVWF  04
131D:  BCF    03.7
131E:  INCF   04,F
131F:  MOVF   00,W
1320:  MOVWF  68
1321:  DECF   04,F
1322:  MOVF   00,W
1323:  MOVWF  67
1324:  MOVWF  04
1325:  BCF    03.7
1326:  BTFSC  68.0
1327:  BSF    03.7
1328:  BCF    0A.4
1329:  BCF    03.5
132A:  CALL   7C7
132B:  BSF    0A.4
....................       PRINTF ("@"); 
132C:  MOVLW  40
132D:  BTFSS  0C.4
132E:  GOTO   32D
132F:  MOVWF  19
1330:  BSF    03.5
1331:  INCF   66,F
1332:  GOTO   312
....................    } 
....................    PRINTF ("#"); 
1333:  MOVLW  23
1334:  BCF    03.5
1335:  BTFSS  0C.4
1336:  GOTO   335
1337:  MOVWF  19
....................    OUTPUT_TOGGLE(PIN_D6); 
1338:  BSF    03.5
1339:  BCF    08.6
133A:  MOVLW  40
133B:  BCF    03.5
133C:  XORWF  08,F
133D:  BCF    0A.3
133E:  BSF    0A.4
133F:  GOTO   445 (RETURN)
....................     
....................  } 
....................  VOID DIEUKHIENTHIETBI() 
....................  { 
....................     /* LAY TOKEN DAU TIEN */     
....................     KYTU = 0; 
*
0E0D:  CLRF   3E
....................     TEMP_CHAR = "_"; 
0E0E:  BSF    03.5
0E0F:  CLRF   5F
0E10:  CLRF   60
0E11:  MOVLW  73
0E12:  MOVWF  04
0E13:  BCF    03.7
0E14:  MOVF   5F,W
0E15:  ADDWF  04,F
0E16:  MOVF   60,W
0E17:  BCF    0A.3
0E18:  BCF    03.5
0E19:  CALL   05E
0E1A:  BSF    0A.3
0E1B:  MOVWF  00
0E1C:  IORLW  00
0E1D:  BTFSC  03.2
0E1E:  GOTO   624
0E1F:  BSF    03.5
0E20:  INCF   60,F
0E21:  INCF   5F,F
0E22:  GOTO   611
0E23:  BCF    03.5
....................     LCD_GOTOXY (1, 1) ; 
0E24:  MOVLW  01
0E25:  BSF    03.6
0E26:  MOVWF  36
0E27:  MOVWF  37
0E28:  BCF    0A.3
0E29:  BCF    03.6
0E2A:  CALL   2DC
0E2B:  BSF    0A.3
....................     DELAY_MS (10);        
0E2C:  MOVLW  0A
0E2D:  BSF    03.6
0E2E:  MOVWF  36
0E2F:  BCF    0A.3
0E30:  BCF    03.6
0E31:  CALL   152
0E32:  BSF    0A.3
....................     PRINTF (LCD_PUTC, KYTUCHAR2);    
0E33:  MOVLW  BE
0E34:  MOVWF  04
0E35:  BCF    03.7
0E36:  BCF    0A.3
0E37:  CALL   516
0E38:  BSF    0A.3
....................     PRINTF (LCD_PUTC, "                 "); 
0E39:  MOVLW  40
0E3A:  BSF    03.6
0E3B:  MOVWF  0D
0E3C:  MOVLW  01
0E3D:  MOVWF  0F
0E3E:  BCF    0A.3
0E3F:  BCF    03.6
0E40:  CALL   32A
0E41:  BSF    0A.3
....................     LCD_GOTOXY (1, 2) ; 
0E42:  MOVLW  01
0E43:  BSF    03.6
0E44:  MOVWF  36
0E45:  MOVLW  02
0E46:  MOVWF  37
0E47:  BCF    0A.3
0E48:  BCF    03.6
0E49:  CALL   2DC
0E4A:  BSF    0A.3
....................     DELAY_MS (10);           
0E4B:  MOVLW  0A
0E4C:  BSF    03.6
0E4D:  MOVWF  36
0E4E:  BCF    0A.3
0E4F:  BCF    03.6
0E50:  CALL   152
0E51:  BSF    0A.3
....................     PRINTF (LCD_PUTC, "                 ");     
0E52:  MOVLW  49
0E53:  BSF    03.6
0E54:  MOVWF  0D
0E55:  MOVLW  01
0E56:  MOVWF  0F
0E57:  BCF    0A.3
0E58:  BCF    03.6
0E59:  CALL   32A
0E5A:  BSF    0A.3
....................     CHAR * TOKEN; 
....................     TOKEN = STRTOK (KYTUCHAR2, TEMP_CHAR);    
0E5B:  BSF    03.5
0E5C:  CLRF   60
0E5D:  MOVLW  BE
0E5E:  MOVWF  5F
0E5F:  CLRF   62
0E60:  MOVLW  73
0E61:  MOVWF  61
0E62:  BCF    03.5
0E63:  CALL   170
0E64:  MOVF   79,W
0E65:  BSF    03.5
0E66:  MOVWF  5E
0E67:  MOVF   78,W
0E68:  MOVWF  5D
....................      
....................     /* DUYET QUA CAC TOKEN CON LAI */                 
....................     WHILE (TOKEN != NULL) 
0E69:  MOVF   5D,F
0E6A:  BTFSS  03.2
0E6B:  GOTO   66F
0E6C:  MOVF   5E,F
0E6D:  BTFSC  03.2
0E6E:  GOTO   6CD
....................     {                 
....................        SWITCH(KYTU) 
0E6F:  BCF    03.5
0E70:  MOVF   3E,W
0E71:  BTFSC  03.2
0E72:  GOTO   67A
0E73:  XORLW  01
0E74:  BTFSC  03.2
0E75:  GOTO   684
0E76:  XORLW  03
0E77:  BTFSC  03.2
0E78:  GOTO   68E
0E79:  GOTO   6A2
....................        { 
....................          CASE 0: 
....................          ID_DEVICE_NHAN =  ATOI(TOKEN) +64 ;        
0E7A:  BSF    03.5
0E7B:  MOVF   5E,W
0E7C:  MOVWF  60
0E7D:  MOVF   5D,W
0E7E:  MOVWF  5F
0E7F:  BCF    03.5
0E80:  CALL   261
0E81:  MOVLW  40
0E82:  ADDWF  78,W
0E83:  MOVWF  3F
....................          CASE 1:  
....................          TT_DEVICE_NHAN =  ATOI(TOKEN);        
0E84:  BSF    03.5
0E85:  MOVF   5E,W
0E86:  MOVWF  60
0E87:  MOVF   5D,W
0E88:  MOVWF  5F
0E89:  BCF    03.5
0E8A:  CALL   261
0E8B:  MOVF   78,W
0E8C:  MOVWF  40
....................          BREAK;                      
0E8D:  GOTO   6A2
....................          CASE 2: 
....................          STRCAT (ID_NODE_NHAN, TOKEN); 
0E8E:  BSF    03.6
0E8F:  CLRF   34
0E90:  MOVLW  63
0E91:  MOVWF  33
0E92:  BSF    03.5
0E93:  BCF    03.6
0E94:  MOVF   5E,W
0E95:  BCF    03.5
0E96:  BSF    03.6
0E97:  MOVWF  36
0E98:  BSF    03.5
0E99:  BCF    03.6
0E9A:  MOVF   5D,W
0E9B:  BCF    03.5
0E9C:  BSF    03.6
0E9D:  MOVWF  35
0E9E:  BCF    0A.3
0E9F:  BCF    03.6
0EA0:  CALL   769
0EA1:  BSF    0A.3
....................          BREAK;               
....................        }  
....................        LCD_GOTOXY (7, 2) ; 
0EA2:  MOVLW  07
0EA3:  BSF    03.6
0EA4:  MOVWF  36
0EA5:  MOVLW  02
0EA6:  MOVWF  37
0EA7:  BCF    0A.3
0EA8:  BCF    03.6
0EA9:  CALL   2DC
0EAA:  BSF    0A.3
....................        DELAY_MS (10);        
0EAB:  MOVLW  0A
0EAC:  BSF    03.6
0EAD:  MOVWF  36
0EAE:  BCF    0A.3
0EAF:  BCF    03.6
0EB0:  CALL   152
0EB1:  BSF    0A.3
....................        PRINTF (LCD_PUTC, TOKEN); 
0EB2:  BSF    03.5
0EB3:  MOVF   5D,W
0EB4:  MOVWF  04
0EB5:  BCF    03.7
0EB6:  BTFSC  5E.0
0EB7:  BSF    03.7
0EB8:  BCF    0A.3
0EB9:  BCF    03.5
0EBA:  CALL   516
0EBB:  BSF    0A.3
....................       TOKEN = STRTOK(NULL, TEMP_CHAR); 
0EBC:  BSF    03.5
0EBD:  CLRF   60
0EBE:  CLRF   5F
0EBF:  CLRF   62
0EC0:  MOVLW  73
0EC1:  MOVWF  61
0EC2:  BCF    03.5
0EC3:  CALL   170
0EC4:  MOVF   79,W
0EC5:  BSF    03.5
0EC6:  MOVWF  5E
0EC7:  MOVF   78,W
0EC8:  MOVWF  5D
....................       KYTU++;         
0EC9:  BCF    03.5
0ECA:  INCF   3E,F
0ECB:  BSF    03.5
0ECC:  GOTO   669
....................     }  
....................     OUTPUT_BIT (ID_DEVICE_NHAN, TT_DEVICE_NHAN); 
0ECD:  BCF    03.5
0ECE:  MOVF   40,F
0ECF:  BTFSS  03.2
0ED0:  GOTO   6D3
0ED1:  MOVLW  00
0ED2:  GOTO   6D4
0ED3:  MOVLW  01
0ED4:  MOVWF  77
0ED5:  MOVF   3F,W
0ED6:  BSF    03.5
0ED7:  MOVWF  5F
0ED8:  MOVF   77,W
0ED9:  MOVWF  60
0EDA:  CLRF   62
0EDB:  CLRF   61
0EDC:  BCF    03.5
0EDD:  CALL   3A9
0EDE:  MOVF   3F,W
0EDF:  BSF    03.5
0EE0:  MOVWF  5F
0EE1:  CLRF   60
0EE2:  CLRF   62
0EE3:  MOVLW  80
0EE4:  MOVWF  61
0EE5:  BCF    03.5
0EE6:  CALL   3A9
....................  } 
....................  
....................  VOID XU_LY_UART() 
*
0BCB:  MOVLW  2A
0BCC:  BSF    03.5
0BCD:  MOVWF  57
....................  { 
....................      //ID_NODE_NHAN = KYTU[1] - 48; 
....................     //ID_DEVICE_NHAN = KYTU[2] - 48 + 64; 
....................     //TT_DEVICE_NHAN = KYTU[3] - 48; // - 48 ASCII -- > S?. + 64 -- > PORT_D (D0 = 64)                
....................  
....................     /*TINH DO DAI*/ 
....................     CHAR CH = '*'; 
....................     CHAR *RET; 
....................     *ID_NODE_NHAN = '\0'; 
0BCE:  CLRF   7A
0BCF:  MOVLW  63
0BD0:  MOVWF  04
0BD1:  BCF    03.7
0BD2:  BTFSC  7A.0
0BD3:  BSF    03.7
0BD4:  CLRF   00
....................     *ID_GW_NHAN = '\0'; 
0BD5:  CLRF   7A
0BD6:  MOVLW  6A
0BD7:  MOVWF  04
0BD8:  BCF    03.7
0BD9:  BTFSC  7A.0
0BDA:  BSF    03.7
0BDB:  CLRF   00
....................     KYTUCHAR2 = ""; 
0BDC:  CLRF   5D
0BDD:  CLRF   5E
0BDE:  MOVLW  BE
0BDF:  MOVWF  04
0BE0:  BCF    03.7
0BE1:  MOVF   5D,W
0BE2:  ADDWF  04,F
0BE3:  MOVF   5E,W
0BE4:  BCF    0A.3
0BE5:  BCF    03.5
0BE6:  CALL   06A
0BE7:  BSF    0A.3
0BE8:  MOVWF  00
0BE9:  IORLW  00
0BEA:  BTFSC  03.2
0BEB:  GOTO   3F1
0BEC:  BSF    03.5
0BED:  INCF   5E,F
0BEE:  INCF   5D,F
0BEF:  GOTO   3DE
0BF0:  BCF    03.5
....................     UNSIGNED INT8 LEN_RET;     
....................     RET = STRCHR(KYTUCHAR,CH); 
0BF1:  BSF    03.5
0BF2:  CLRF   5E
0BF3:  MOVLW  A0
0BF4:  MOVWF  5D
0BF5:  MOVF   57,W
0BF6:  MOVWF  5F
*
0C18:  MOVF   79,W
0C19:  MOVWF  59
0C1A:  MOVF   78,W
0C1B:  MOVWF  58
....................     LEN_RET = STRLEN(RET);  
0C1C:  MOVF   59,W
0C1D:  BCF    03.5
0C1E:  BSF    03.6
0C1F:  MOVWF  35
0C20:  BSF    03.5
0C21:  BCF    03.6
0C22:  MOVF   58,W
0C23:  BCF    03.5
0C24:  BSF    03.6
0C25:  MOVWF  34
0C26:  BCF    0A.3
0C27:  BCF    03.6
0C28:  CALL   7A7
0C29:  BSF    0A.3
0C2A:  MOVF   78,W
0C2B:  BSF    03.5
0C2C:  MOVWF  5A
....................     /* LAY TOKEN DAU TIEN */     
....................     KYTU = 0; 
0C2D:  BCF    03.5
0C2E:  CLRF   3E
....................     TEMP_CHAR = "#"; 
0C2F:  BSF    03.5
0C30:  CLRF   5D
0C31:  CLRF   5E
0C32:  MOVLW  73
0C33:  MOVWF  04
0C34:  BCF    03.7
0C35:  MOVF   5D,W
0C36:  ADDWF  04,F
0C37:  MOVF   5E,W
0C38:  BCF    0A.3
0C39:  BCF    03.5
0C3A:  CALL   064
0C3B:  BSF    0A.3
0C3C:  MOVWF  00
0C3D:  IORLW  00
0C3E:  BTFSC  03.2
0C3F:  GOTO   445
0C40:  BSF    03.5
0C41:  INCF   5E,F
0C42:  INCF   5D,F
0C43:  GOTO   432
0C44:  BCF    03.5
....................     CHAR * TOKEN; 
....................     TOKEN = STRTOK (KYTUCHAR, TEMP_CHAR);                 
0C45:  BSF    03.5
0C46:  CLRF   60
0C47:  MOVLW  A0
0C48:  MOVWF  5F
0C49:  CLRF   62
0C4A:  MOVLW  73
0C4B:  MOVWF  61
0C4C:  BCF    03.5
0C4D:  CALL   170
0C4E:  MOVF   79,W
0C4F:  BSF    03.5
0C50:  MOVWF  5C
0C51:  MOVF   78,W
0C52:  MOVWF  5B
....................     /* DUYET QUA CAC TOKEN CON LAI */                 
....................     WHILE (TOKEN != NULL) 
0C53:  MOVF   5B,F
0C54:  BTFSS  03.2
0C55:  GOTO   459
0C56:  MOVF   5C,F
0C57:  BTFSC  03.2
0C58:  GOTO   4C4
....................     {                 
....................        SWITCH(KYTU) 
0C59:  BCF    03.5
0C5A:  MOVF   3E,W
0C5B:  ADDLW  FA
0C5C:  BTFSC  03.0
0C5D:  GOTO   4B3
0C5E:  ADDLW  06
0C5F:  GOTO   6F2
....................        { 
....................          CASE 0: 
....................          BREAK; 
0C60:  GOTO   4B3
....................          CASE 1:  
....................          STRCAT (ID_GW_NHAN, TOKEN); 
0C61:  BSF    03.6
0C62:  CLRF   34
0C63:  MOVLW  6A
0C64:  MOVWF  33
0C65:  BSF    03.5
0C66:  BCF    03.6
0C67:  MOVF   5C,W
0C68:  BCF    03.5
0C69:  BSF    03.6
0C6A:  MOVWF  36
0C6B:  BSF    03.5
0C6C:  BCF    03.6
0C6D:  MOVF   5B,W
0C6E:  BCF    03.5
0C6F:  BSF    03.6
0C70:  MOVWF  35
0C71:  BCF    0A.3
0C72:  BCF    03.6
0C73:  CALL   769
0C74:  BSF    0A.3
....................          BREAK;                      
0C75:  GOTO   4B3
....................          CASE 2: 
....................          STRCAT (ID_NODE_NHAN, TOKEN); 
0C76:  BSF    03.6
0C77:  CLRF   34
0C78:  MOVLW  63
0C79:  MOVWF  33
0C7A:  BSF    03.5
0C7B:  BCF    03.6
0C7C:  MOVF   5C,W
0C7D:  BCF    03.5
0C7E:  BSF    03.6
0C7F:  MOVWF  36
0C80:  BSF    03.5
0C81:  BCF    03.6
0C82:  MOVF   5B,W
0C83:  BCF    03.5
0C84:  BSF    03.6
0C85:  MOVWF  35
0C86:  BCF    0A.3
0C87:  BCF    03.6
0C88:  CALL   769
0C89:  BSF    0A.3
....................          BREAK;       
0C8A:  GOTO   4B3
....................          CASE 3: 
....................          LENHDIEUKHIEN =  ATOI(TOKEN);                  
0C8B:  BSF    03.5
0C8C:  MOVF   5C,W
0C8D:  MOVWF  60
0C8E:  MOVF   5B,W
0C8F:  MOVWF  5F
0C90:  BCF    03.5
0C91:  CALL   261
0C92:  MOVF   78,W
0C93:  MOVWF  4C
....................          BREAK;     
0C94:  GOTO   4B3
....................          CASE 4: 
....................          DODAI_DATA_NHAN =  ATOI(TOKEN);                  
0C95:  BSF    03.5
0C96:  MOVF   5C,W
0C97:  MOVWF  60
0C98:  MOVF   5B,W
0C99:  MOVWF  5F
0C9A:  BCF    03.5
0C9B:  CALL   261
0C9C:  MOVF   78,W
0C9D:  MOVWF  4D
....................          BREAK;   
0C9E:  GOTO   4B3
....................          CASE 5:   
....................          STRCAT (KYTUCHAR2, TOKEN); 
0C9F:  BSF    03.6
0CA0:  CLRF   34
0CA1:  MOVLW  BE
0CA2:  MOVWF  33
0CA3:  BSF    03.5
0CA4:  BCF    03.6
0CA5:  MOVF   5C,W
0CA6:  BCF    03.5
0CA7:  BSF    03.6
0CA8:  MOVWF  36
0CA9:  BSF    03.5
0CAA:  BCF    03.6
0CAB:  MOVF   5B,W
0CAC:  BCF    03.5
0CAD:  BSF    03.6
0CAE:  MOVWF  35
0CAF:  BCF    0A.3
0CB0:  BCF    03.6
0CB1:  CALL   769
0CB2:  BSF    0A.3
....................          BREAK;          
....................        }          
....................       TOKEN = STRTOK(NULL, TEMP_CHAR); 
0CB3:  BSF    03.5
0CB4:  CLRF   60
0CB5:  CLRF   5F
0CB6:  CLRF   62
0CB7:  MOVLW  73
0CB8:  MOVWF  61
0CB9:  BCF    03.5
0CBA:  CALL   170
0CBB:  MOVF   79,W
0CBC:  BSF    03.5
0CBD:  MOVWF  5C
0CBE:  MOVF   78,W
0CBF:  MOVWF  5B
....................       KYTU++;         
0CC0:  BCF    03.5
0CC1:  INCF   3E,F
0CC2:  BSF    03.5
0CC3:  GOTO   453
....................     }               
....................       /* SO SANH ID returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................       SOSANH_IDGW = STRCMP(ID_GW_NHAN,ID_GATEWAY_CHAR);       
0CC4:  CLRF   5E
0CC5:  MOVLW  6A
0CC6:  MOVWF  5D
0CC7:  CLRF   60
0CC8:  MOVLW  5A
0CC9:  MOVWF  5F
0CCA:  BCF    03.5
0CCB:  CALL   363
0CCC:  MOVF   78,W
0CCD:  MOVWF  51
....................       SOSANH_IDNODE = STRCMP(ID_NODE_NHAN,ID_NODE_CHAR);     
0CCE:  BSF    03.5
0CCF:  CLRF   5E
0CD0:  MOVLW  63
0CD1:  MOVWF  5D
0CD2:  CLRF   60
0CD3:  MOVLW  53
0CD4:  MOVWF  5F
0CD5:  BCF    03.5
0CD6:  CALL   363
0CD7:  MOVF   78,W
0CD8:  MOVWF  50
....................     IF ( SOSANH_IDGW == 0 && SOSANH_IDNODE == 0 && LEN_RET == DODAI_DATA_NHAN) 
0CD9:  MOVF   51,F
0CDA:  BTFSS  03.2
0CDB:  GOTO   6E8
0CDC:  MOVF   50,F
0CDD:  BTFSS  03.2
0CDE:  GOTO   6E8
0CDF:  MOVF   4D,W
0CE0:  BSF    03.5
0CE1:  SUBWF  5A,W
0CE2:  BTFSC  03.2
0CE3:  GOTO   4E6
0CE4:  BCF    03.5
0CE5:  GOTO   6E8
....................     {                       
....................       SWITCH(LENHDIEUKHIEN) 
0CE6:  BCF    03.5
0CE7:  MOVF   4C,W
0CE8:  BTFSC  03.2
0CE9:  GOTO   4F1
0CEA:  XORLW  01
0CEB:  BTFSC  03.2
0CEC:  GOTO   4F2
0CED:  XORLW  03
0CEE:  BTFSC  03.2
0CEF:  GOTO   60D
0CF0:  GOTO   6E7
....................        { 
....................          CASE 0: 
....................          BREAK; 
0CF1:  GOTO   6E7
....................          CASE 1: 
....................          XACNHANCONFIG(); 
....................          BREAK;                      
*
0E0C:  GOTO   6E7
....................          CASE 2: 
....................          DIEUKHIENTHIETBI(); 
....................          BREAK;               
....................        }  
....................     } 
*
0EE7:  GOTO   6EF
....................     ELSE{ 
....................       DELAY_MS (10); 
0EE8:  MOVLW  0A
0EE9:  BSF    03.6
0EEA:  MOVWF  36
0EEB:  BCF    0A.3
0EEC:  BCF    03.6
0EED:  CALL   152
0EEE:  BSF    0A.3
....................       /*DATA RCV SAI ID NODE, ID GW HOAC LA SAI DO DAI*/ 
....................     } 
0EEF:  BCF    0A.3
0EF0:  BSF    0A.4
0EF1:  GOTO   42C (RETURN)
....................      
....................  } 
....................  
....................  
....................  VOID CHUONG_TRINH_CON () 
....................  { 
....................     FOR (INT I = 0; I <= 30; I++) 
*
07E5:  BSF    03.5
07E6:  CLRF   57
07E7:  MOVF   57,W
07E8:  SUBLW  1E
07E9:  BTFSS  03.0
07EA:  GOTO   7F7
....................     { 
....................        OUTPUT_TOGGLE (PIN_D1); 
07EB:  BCF    08.1
07EC:  MOVLW  02
07ED:  BCF    03.5
07EE:  XORWF  08,F
....................        DELAY_MS (100); 
07EF:  MOVLW  64
07F0:  BSF    03.6
07F1:  MOVWF  36
07F2:  BCF    03.6
07F3:  CALL   152
07F4:  BSF    03.5
07F5:  INCF   57,F
07F6:  GOTO   7E7
....................     } 
....................     OUTPUT_TOGGLE(PIN_D0); 
07F7:  BCF    08.0
07F8:  MOVLW  01
07F9:  BCF    03.5
07FA:  XORWF  08,F
07FB:  BCF    0A.3
07FC:  BSF    0A.4
07FD:  GOTO   425 (RETURN)
....................  } 
....................  
....................  VOID MAIN  () 
*
1340:  MOVF   03,W
1341:  ANDLW  1F
1342:  MOVWF  03
1343:  BSF    03.5
1344:  BSF    03.6
1345:  BSF    07.3
1346:  MOVLW  08
1347:  BCF    03.6
1348:  MOVWF  19
1349:  MOVLW  02
134A:  MOVWF  1A
134B:  MOVLW  A6
134C:  MOVWF  18
134D:  MOVLW  90
134E:  BCF    03.5
134F:  MOVWF  18
1350:  MOVLW  FF
1351:  MOVWF  31
1352:  CLRF   3C
1353:  CLRF   3D
1354:  CLRF   3E
1355:  CLRF   4B
1356:  CLRF   4C
1357:  CLRF   4D
1358:  CLRF   4E
1359:  MOVLW  03
135A:  MOVWF  4F
135B:  CLRF   50
135C:  CLRF   51
135D:  BCF    52.0
135E:  BCF    52.1
135F:  BCF    52.2
1360:  BCF    52.3
1361:  BCF    52.4
1362:  BCF    52.5
1363:  BCF    52.6
1364:  BSF    03.5
1365:  BSF    03.6
1366:  MOVF   09,W
1367:  ANDLW  C0
1368:  MOVWF  09
1369:  BCF    03.6
136A:  BCF    1F.4
136B:  BCF    1F.5
136C:  MOVLW  00
136D:  BSF    03.6
136E:  MOVWF  08
136F:  BCF    03.5
1370:  CLRF   07
1371:  CLRF   08
1372:  CLRF   09
1373:  BCF    03.7
....................  { 
....................     SET_TRIS_D (0X00); 
*
13E5:  MOVLW  00
13E6:  MOVWF  08
....................     SET_TRIS_B (0XFF); 
13E7:  MOVLW  FF
13E8:  MOVWF  06
....................     SET_TRIS_E (0); 
13E9:  BCF    09.0
13EA:  BCF    09.1
13EB:  BCF    09.2
13EC:  BCF    09.3
....................     SET_TRIS_C (0X80); 
13ED:  MOVLW  80
13EE:  MOVWF  07
13EF:  BCF    03.5
13F0:  MOVWF  31
....................     SETUP_ADC (ADC_CLOCK_DIV_8);        
13F1:  BSF    1F.6
13F2:  BCF    1F.7
13F3:  BSF    03.5
13F4:  BSF    1F.7
13F5:  BCF    03.5
13F6:  BSF    1F.0
....................     ENABLE_INTERRUPTS (INT_TIMER0); 
13F7:  BSF    0B.5
....................     ENABLE_INTERRUPTS (INT_EXT); //CHO PHEP NGAT NGOAI 
13F8:  BSF    0B.4
....................     ENABLE_INTERRUPTS (INT_EXT_H2L); //NGAT XAY RA KHI CO XUNG TU CAO XUONG THAP 
13F9:  BSF    0B.4
13FA:  BSF    03.5
13FB:  BCF    01.6
....................     ENABLE_INTERRUPTS (INT_RDA); 
13FC:  BSF    0C.5
....................     ENABLE_INTERRUPTS (GLOBAL); 
13FD:  MOVLW  C0
13FE:  BCF    03.5
13FF:  IORWF  0B,F
....................      
....................     SETUP_TIMER_1 (T1_INTERNAL|T1_DIV_BY_8); 
1400:  MOVLW  35
1401:  MOVWF  10
....................     //SET_TIMER1 (0); 
....................     SET_TIMER1 (3036); 
1402:  CLRF   0E
1403:  MOVLW  0B
1404:  MOVWF  0F
1405:  MOVLW  DC
1406:  MOVWF  0E
....................     TMR1IF = 0; 
1407:  BCF    0C.0
....................     LCD_INIT (); // KHOI TAO LCD 
1408:  BCF    0A.4
1409:  GOTO   26C
140A:  BSF    0A.4
....................  
....................     TT_CONFIG = 0; 
140B:  BCF    52.1
....................     TT_CONFIG_DONE = 0; 
140C:  BCF    52.3
....................     TT_CONTROL = 1; 
140D:  BSF    52.2
....................     OUTPUT_D (0X00); 
140E:  BSF    03.5
140F:  CLRF   08
1410:  BCF    03.5
1411:  CLRF   08
....................     TTNHAN = 0; 
1412:  BCF    52.0
....................      
....................     
....................     WHILE (TRUE) 
....................     { 
....................        IF (TT_CONFIG)             {BUTT_FUN (); } // GOI HAM CHON LENH (SWITCH CASE) 
1413:  BTFSS  52.1
1414:  GOTO   419
1415:  BCF    0A.4
1416:  GOTO   54C
1417:  BSF    0A.4
1418:  GOTO   446
....................        ELSE IF (TT_CONFIG_DONE)   { CONFIG_DONE ();}        
1419:  BTFSS  52.3
141A:  GOTO   421
141B:  BCF    0A.4
141C:  BSF    0A.3
141D:  GOTO   000
141E:  BSF    0A.4
141F:  BCF    0A.3
1420:  GOTO   446
....................        ELSE 
....................        { 
....................           WHILE (!TT_CONFIG) 
1421:  BTFSC  52.1
1422:  GOTO   446
....................           { 
....................              CHUONG_TRINH_CON ();                       
1423:  BCF    0A.4
1424:  GOTO   7E5
1425:  BSF    0A.4
....................              IF (TTNHAN == 1) 
1426:  BTFSS  52.0
1427:  GOTO   42E
....................              { 
....................                 TTNHAN = 0; 
1428:  BCF    52.0
....................                 XU_LY_UART(); 
1429:  BCF    0A.4
142A:  BSF    0A.3
142B:  GOTO   3CB
142C:  BSF    0A.4
142D:  BCF    0A.3
....................              }  
....................               
....................              IF (TT_CONFIG_OKE_UART == 1){ 
142E:  BTFSS  52.6
142F:  GOTO   445
....................                READ_ANALOG(); 
1430:  GOTO   000
....................                IF (KET_QUA_ANALOG[0]>28) 
1431:  MOVF   38,W
1432:  SUBLW  1C
1433:  BTFSC  03.0
1434:  GOTO   445
....................                { 
....................                DELAY_MS(500); 
1435:  MOVLW  02
1436:  BSF    03.5
1437:  MOVWF  57
1438:  MOVLW  FA
1439:  BCF    03.5
143A:  BSF    03.6
143B:  MOVWF  36
143C:  BCF    0A.4
143D:  BCF    03.6
143E:  CALL   152
143F:  BSF    0A.4
1440:  BSF    03.5
1441:  DECFSZ 57,F
1442:  GOTO   438
....................                SEND_ANALOG_UART(); 
1443:  BCF    03.5
1444:  GOTO   205
....................                } 
....................              } 
1445:  GOTO   421
....................  
....................           } 
....................        } 
1446:  GOTO   413
....................     } 
....................  } 
....................  
1447:  SLEEP

Configuration Fuses:
   Word  1: 2FE2   HS NOWDT PUT MCLR NOPROTECT NOCPD BROWNOUT IESO FCMEN NOLVP NODEBUG
   Word  2: 3FFF   BORV40 NOWRT
