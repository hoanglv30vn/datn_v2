CCS PCM C Compiler, Version 5.015, 5967               30-Oct-21 23:01

               Filename:   E:\DATN_V2\NODE\pic\pic16f887\hellopic.lst

               ROM used:   4058 words (50%)
                           Largest free fragment is 2048
               RAM used:   135 (37%) at main() level
                           244 (66%) worst case
               Stack used: 7 locations (6 in main + 1 for interrupts)
               Stack size: 8

*
0000:  MOVLW  0E
0001:  MOVWF  0A
0002:  GOTO   6FA
0003:  NOP
0004:  MOVWF  7F
0005:  SWAPF  03,W
0006:  CLRF   03
0007:  MOVWF  21
0008:  MOVF   0A,W
0009:  MOVWF  20
000A:  CLRF   0A
000B:  MOVF   04,W
000C:  MOVWF  22
000D:  MOVF   77,W
000E:  MOVWF  23
000F:  MOVF   78,W
0010:  MOVWF  24
0011:  MOVF   79,W
0012:  MOVWF  25
0013:  MOVF   7A,W
0014:  MOVWF  26
0015:  BSF    03.6
0016:  MOVF   0D,W
0017:  BCF    03.6
0018:  MOVWF  27
0019:  BSF    03.6
001A:  MOVF   0F,W
001B:  BCF    03.6
001C:  MOVWF  28
001D:  BSF    03.6
001E:  MOVF   0C,W
001F:  BCF    03.6
0020:  MOVWF  29
0021:  BSF    03.6
0022:  MOVF   0E,W
0023:  BCF    03.6
0024:  MOVWF  2A
0025:  BCF    03.7
0026:  BCF    03.5
0027:  BTFSS  0B.4
0028:  GOTO   02B
0029:  BTFSC  0B.1
002A:  GOTO   052
002B:  MOVLW  8C
002C:  MOVWF  04
002D:  BTFSS  00.5
002E:  GOTO   031
002F:  BTFSC  0C.5
0030:  GOTO   055
0031:  MOVF   22,W
0032:  MOVWF  04
0033:  MOVF   23,W
0034:  MOVWF  77
0035:  MOVF   24,W
0036:  MOVWF  78
0037:  MOVF   25,W
0038:  MOVWF  79
0039:  MOVF   26,W
003A:  MOVWF  7A
003B:  MOVF   27,W
003C:  BSF    03.6
003D:  MOVWF  0D
003E:  BCF    03.6
003F:  MOVF   28,W
0040:  BSF    03.6
0041:  MOVWF  0F
0042:  BCF    03.6
0043:  MOVF   29,W
0044:  BSF    03.6
0045:  MOVWF  0C
0046:  BCF    03.6
0047:  MOVF   2A,W
0048:  BSF    03.6
0049:  MOVWF  0E
004A:  BCF    03.6
004B:  MOVF   20,W
004C:  MOVWF  0A
004D:  SWAPF  21,W
004E:  MOVWF  03
004F:  SWAPF  7F,F
0050:  SWAPF  7F,W
0051:  RETFIE
0052:  BCF    0A.3
0053:  BCF    0A.4
0054:  GOTO   0EF
0055:  BCF    0A.3
0056:  BCF    0A.4
0057:  GOTO   120
....................  
.................... #INCLUDE <thuvien.c> 
.................... #INCLUDE <16F887.H> 
.................... //////////// Standard Header file for the PIC16F887 device //////////////// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2013 Custom Computer Services          //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... #device PIC16F887 
0058:  BCF    0A.0
0059:  BCF    0A.1
005A:  BCF    0A.2
005B:  ADDWF  02,F
005C:  RETLW  30
005D:  RETLW  00
005E:  BCF    0A.0
005F:  BCF    0A.1
0060:  BCF    0A.2
0061:  ADDWF  02,F
0062:  RETLW  5F
0063:  RETLW  00
0064:  BCF    0A.0
0065:  BCF    0A.1
0066:  BCF    0A.2
0067:  ADDWF  02,F
0068:  RETLW  00
0069:  BCF    0A.0
006A:  BCF    0A.1
006B:  BCF    0A.2
006C:  ADDWF  02,F
006D:  RETLW  23
006E:  RETLW  00
006F:  DATA CE,27
0070:  DATA C4,22
0071:  DATA 3A,10
0072:  DATA 00,00
0073:  DATA 30,18
0074:  DATA 30,18
0075:  DATA 20,10
0076:  DATA 20,10
0077:  DATA 20,10
0078:  DATA 20,10
0079:  DATA 20,10
007A:  DATA 00,01
007B:  DATA 20,10
007C:  DATA 20,10
007D:  DATA 20,10
007E:  DATA 5F,10
007F:  DATA 20,10
0080:  DATA 20,10
0081:  DATA 20,10
0082:  DATA 20,10
0083:  DATA 20,10
0084:  DATA 20,10
0085:  DATA 20,00
0086:  DATA 20,10
0087:  DATA 20,10
0088:  DATA 5F,10
0089:  DATA 20,10
008A:  DATA 20,00
008B:  DATA 49,22
008C:  DATA DF,23
008D:  DATA 57,1D
008E:  DATA 00,01
008F:  DATA 30,18
0090:  DATA 30,18
0091:  DATA 30,18
0092:  DATA 20,10
0093:  DATA 20,10
0094:  DATA 20,10
0095:  DATA 20,10
0096:  DATA 00,01
0097:  DATA 20,10
0098:  DATA 20,10
0099:  DATA 20,10
009A:  DATA 5F,10
009B:  DATA 20,10
009C:  DATA 20,10
009D:  DATA 20,10
009E:  DATA 20,10
009F:  DATA 20,10
00A0:  DATA 20,10
00A1:  DATA 20,10
00A2:  DATA 20,00
00A3:  DATA 20,10
00A4:  DATA 20,10
00A5:  DATA 5F,10
00A6:  DATA 20,10
00A7:  DATA 20,10
00A8:  DATA 20,10
00A9:  DATA 20,00
00AA:  DATA C3,27
00AB:  DATA 4E,23
00AC:  DATA C9,23
00AD:  DATA 3A,10
00AE:  DATA 20,10
00AF:  DATA 20,10
00B0:  DATA 20,10
00B1:  DATA 20,00
00B2:  DATA C3,20
00B3:  DATA D3,22
00B4:  DATA 3A,10
00B5:  DATA 20,10
00B6:  DATA 20,10
00B7:  DATA 20,10
00B8:  DATA 20,10
00B9:  DATA 20,00
00BA:  DATA A0,16
00BB:  DATA A0,24
00BC:  DATA C4,16
00BD:  DATA CE,27
00BE:  DATA C4,22
00BF:  DATA 20,10
00C0:  DATA 20,10
00C1:  DATA 20,10
00C2:  DATA 00,01
00C3:  DATA A0,16
00C4:  DATA A0,24
00C5:  DATA C4,16
00C6:  DATA C7,2B
00C7:  DATA 20,10
00C8:  DATA 20,10
00C9:  DATA 20,10
00CA:  DATA 20,00
00CB:  DATA D7,20
00CC:  DATA 49,2A
00CD:  DATA 49,27
00CE:  DATA 47,10
00CF:  DATA 2E,17
00D0:  DATA 2E,17
00D1:  DATA 20,10
00D2:  DATA 20,10
00D3:  DATA 20,10
00D4:  DATA 20,10
00D5:  DATA 00,01
00D6:  DATA D7,20
00D7:  DATA 49,2A
00D8:  DATA 49,27
00D9:  DATA 47,10
00DA:  DATA 2E,17
00DB:  DATA 2E,17
00DC:  DATA 20,10
00DD:  DATA 20,10
00DE:  DATA 20,10
00DF:  DATA 20,10
00E0:  DATA 00,00
00E1:  DATA 20,10
00E2:  DATA 20,10
00E3:  DATA 20,10
00E4:  DATA 20,10
00E5:  DATA 20,10
00E6:  DATA 20,10
00E7:  DATA 00,01
00E8:  DATA 54,21
00E9:  DATA 3A,10
00EA:  DATA 00,01
00EB:  DATA 20,10
00EC:  DATA 20,10
00ED:  DATA 43,21
00EE:  DATA 3A,00
*
013D:  DATA 20,10
013E:  DATA 20,10
013F:  DATA 20,10
0140:  DATA 20,10
0141:  DATA 20,10
0142:  DATA 20,10
0143:  DATA 20,10
0144:  DATA 20,10
0145:  DATA 20,00
0146:  DATA 20,10
0147:  DATA 20,10
0148:  DATA 20,10
0149:  DATA 20,10
014A:  DATA 20,10
014B:  DATA 20,10
014C:  DATA 20,10
014D:  DATA 20,10
014E:  DATA 20,00
*
0327:  MOVF   0B,W
0328:  BSF    03.6
0329:  MOVWF  32
032A:  BCF    03.6
032B:  BCF    0B.7
032C:  BSF    03.5
032D:  BSF    03.6
032E:  BSF    0C.7
032F:  BSF    0C.0
0330:  NOP
0331:  NOP
0332:  BCF    03.5
0333:  BTFSS  32.7
0334:  GOTO   338
0335:  BCF    03.6
0336:  BSF    0B.7
0337:  BSF    03.6
0338:  MOVF   0C,W
0339:  ANDLW  7F
033A:  BTFSC  03.2
033B:  GOTO   375
033C:  MOVWF  32
033D:  MOVF   0D,W
033E:  MOVWF  33
033F:  MOVF   0F,W
0340:  MOVWF  34
0341:  MOVF   32,W
0342:  MOVWF  35
0343:  BCF    03.6
0344:  CALL   2ED
0345:  BSF    03.6
0346:  MOVF   33,W
0347:  MOVWF  0D
0348:  MOVF   34,W
0349:  MOVWF  0F
034A:  BCF    03.6
034B:  MOVF   0B,W
034C:  BSF    03.6
034D:  MOVWF  35
034E:  BCF    03.6
034F:  BCF    0B.7
0350:  BSF    03.5
0351:  BSF    03.6
0352:  BSF    0C.7
0353:  BSF    0C.0
0354:  NOP
0355:  NOP
0356:  BCF    03.5
0357:  BTFSS  35.7
0358:  GOTO   35C
0359:  BCF    03.6
035A:  BSF    0B.7
035B:  BSF    03.6
035C:  RLF    0C,W
035D:  RLF    0E,W
035E:  ANDLW  7F
035F:  BTFSC  03.2
0360:  GOTO   375
0361:  MOVWF  32
0362:  MOVF   0D,W
0363:  MOVWF  33
0364:  MOVF   0F,W
0365:  MOVWF  34
0366:  MOVF   32,W
0367:  MOVWF  35
0368:  BCF    03.6
0369:  CALL   2ED
036A:  BSF    03.6
036B:  MOVF   33,W
036C:  MOVWF  0D
036D:  MOVF   34,W
036E:  MOVWF  0F
036F:  INCF   0D,F
0370:  BTFSC  03.2
0371:  INCF   0F,F
0372:  BCF    03.6
0373:  GOTO   327
0374:  BSF    03.6
0375:  BCF    03.6
0376:  RETURN
0377:  BTFSC  03.1
0378:  GOTO   37C
0379:  MOVLW  53
037A:  MOVWF  04
037B:  BSF    03.7
037C:  BSF    03.6
037D:  MOVF   4E,W
037E:  XORWF  52,W
037F:  ANDLW  80
0380:  MOVWF  58
0381:  BTFSS  4E.7
0382:  GOTO   38E
0383:  COMF   4B,F
0384:  COMF   4C,F
0385:  COMF   4D,F
0386:  COMF   4E,F
0387:  INCF   4B,F
0388:  BTFSC  03.2
0389:  INCF   4C,F
038A:  BTFSC  03.2
038B:  INCF   4D,F
038C:  BTFSC  03.2
038D:  INCF   4E,F
038E:  BTFSS  52.7
038F:  GOTO   39B
0390:  COMF   4F,F
0391:  COMF   50,F
0392:  COMF   51,F
0393:  COMF   52,F
0394:  INCF   4F,F
0395:  BTFSC  03.2
0396:  INCF   50,F
0397:  BTFSC  03.2
0398:  INCF   51,F
0399:  BTFSC  03.2
039A:  INCF   52,F
039B:  CLRF   77
039C:  CLRF   78
039D:  CLRF   79
039E:  CLRF   7A
039F:  CLRF   53
03A0:  CLRF   54
03A1:  CLRF   55
03A2:  CLRF   56
03A3:  MOVF   52,W
03A4:  IORWF  51,W
03A5:  IORWF  50,W
03A6:  IORWF  4F,W
03A7:  BTFSC  03.2
03A8:  GOTO   3D9
03A9:  MOVLW  20
03AA:  MOVWF  57
03AB:  BCF    03.0
03AC:  RLF    4B,F
03AD:  RLF    4C,F
03AE:  RLF    4D,F
03AF:  RLF    4E,F
03B0:  RLF    53,F
03B1:  RLF    54,F
03B2:  RLF    55,F
03B3:  RLF    56,F
03B4:  MOVF   52,W
03B5:  SUBWF  56,W
03B6:  BTFSS  03.2
03B7:  GOTO   3C2
03B8:  MOVF   51,W
03B9:  SUBWF  55,W
03BA:  BTFSS  03.2
03BB:  GOTO   3C2
03BC:  MOVF   50,W
03BD:  SUBWF  54,W
03BE:  BTFSS  03.2
03BF:  GOTO   3C2
03C0:  MOVF   4F,W
03C1:  SUBWF  53,W
03C2:  BTFSS  03.0
03C3:  GOTO   3D3
03C4:  MOVF   4F,W
03C5:  SUBWF  53,F
03C6:  MOVF   50,W
03C7:  BTFSS  03.0
03C8:  INCFSZ 50,W
03C9:  SUBWF  54,F
03CA:  MOVF   51,W
03CB:  BTFSS  03.0
03CC:  INCFSZ 51,W
03CD:  SUBWF  55,F
03CE:  MOVF   52,W
03CF:  BTFSS  03.0
03D0:  INCFSZ 52,W
03D1:  SUBWF  56,F
03D2:  BSF    03.0
03D3:  RLF    77,F
03D4:  RLF    78,F
03D5:  RLF    79,F
03D6:  RLF    7A,F
03D7:  DECFSZ 57,F
03D8:  GOTO   3AB
03D9:  BTFSS  58.7
03DA:  GOTO   3E6
03DB:  COMF   77,F
03DC:  COMF   78,F
03DD:  COMF   79,F
03DE:  COMF   7A,F
03DF:  INCF   77,F
03E0:  BTFSC  03.2
03E1:  INCF   78,F
03E2:  BTFSC  03.2
03E3:  INCF   79,F
03E4:  BTFSC  03.2
03E5:  INCF   7A,F
03E6:  MOVF   53,W
03E7:  MOVWF  00
03E8:  INCF   04,F
03E9:  MOVF   54,W
03EA:  MOVWF  00
03EB:  INCF   04,F
03EC:  MOVF   55,W
03ED:  MOVWF  00
03EE:  INCF   04,F
03EF:  MOVF   56,W
03F0:  MOVWF  00
03F1:  BCF    03.6
03F2:  RETURN
*
040C:  MOVLW  20
040D:  MOVWF  4F
040E:  CLRF   4B
040F:  CLRF   4C
0410:  CLRF   4D
0411:  CLRF   4E
0412:  MOVF   46,W
0413:  MOVWF  7A
0414:  MOVF   45,W
0415:  MOVWF  79
0416:  MOVF   44,W
0417:  MOVWF  78
0418:  MOVF   43,W
0419:  MOVWF  77
041A:  BCF    03.0
041B:  BTFSS  77.0
041C:  GOTO   42B
041D:  MOVF   47,W
041E:  ADDWF  4B,F
041F:  MOVF   48,W
0420:  BTFSC  03.0
0421:  INCFSZ 48,W
0422:  ADDWF  4C,F
0423:  MOVF   49,W
0424:  BTFSC  03.0
0425:  INCFSZ 49,W
0426:  ADDWF  4D,F
0427:  MOVF   4A,W
0428:  BTFSC  03.0
0429:  INCFSZ 4A,W
042A:  ADDWF  4E,F
042B:  RRF    4E,F
042C:  RRF    4D,F
042D:  RRF    4C,F
042E:  RRF    4B,F
042F:  RRF    7A,F
0430:  RRF    79,F
0431:  RRF    78,F
0432:  RRF    77,F
0433:  DECFSZ 4F,F
0434:  GOTO   41A
*
0513:  MOVF   00,F
0514:  BTFSC  03.2
0515:  GOTO   531
0516:  BSF    03.5
0517:  CLRF   56
0518:  MOVF   04,W
0519:  MOVWF  55
051A:  BCF    56.0
051B:  BTFSC  03.7
051C:  BSF    56.0
051D:  MOVF   00,W
051E:  BCF    03.5
051F:  BSF    03.6
0520:  MOVWF  35
0521:  BCF    03.6
0522:  CALL   2ED
0523:  BSF    03.5
0524:  MOVF   55,W
0525:  MOVWF  04
0526:  BCF    03.7
0527:  BTFSC  56.0
0528:  BSF    03.7
0529:  INCF   04,F
052A:  BTFSS  03.2
052B:  GOTO   52F
052C:  BCF    03.5
052D:  INCF   05,F
052E:  BSF    03.5
052F:  BCF    03.5
0530:  GOTO   513
0531:  RETURN
0532:  BSF    03.5
0533:  MOVF   52,W
0534:  CLRF   78
0535:  SUBWF  51,W
0536:  BTFSC  03.0
0537:  GOTO   53B
0538:  MOVF   51,W
0539:  MOVWF  77
053A:  GOTO   547
053B:  CLRF   77
053C:  MOVLW  08
053D:  MOVWF  53
053E:  RLF    51,F
053F:  RLF    77,F
0540:  MOVF   52,W
0541:  SUBWF  77,W
0542:  BTFSC  03.0
0543:  MOVWF  77
0544:  RLF    78,F
0545:  DECFSZ 53,F
0546:  GOTO   53E
0547:  BCF    03.5
0548:  RETURN
*
07DA:  BSF    03.5
07DB:  MOVF   55,W
07DC:  ANDLW  07
07DD:  MOVWF  77
07DE:  RRF    55,W
07DF:  MOVWF  78
07E0:  RRF    78,F
07E1:  RRF    78,F
07E2:  MOVLW  1F
07E3:  ANDWF  78,F
07E4:  MOVF   78,W
07E5:  ADDWF  57,W
07E6:  MOVWF  04
07E7:  BCF    03.7
07E8:  BTFSC  58.0
07E9:  BSF    03.7
07EA:  CLRF   78
07EB:  INCF   78,F
07EC:  INCF   77,F
07ED:  GOTO   7EF
07EE:  RLF    78,F
07EF:  DECFSZ 77,F
07F0:  GOTO   7EE
07F1:  MOVF   56,F
07F2:  BTFSC  03.2
07F3:  GOTO   7F7
07F4:  MOVF   78,W
07F5:  IORWF  00,F
07F6:  GOTO   7FA
07F7:  COMF   78,F
07F8:  MOVF   78,W
07F9:  ANDWF  00,F
07FA:  BCF    03.5
07FB:  RETURN
*
0930:  MOVF   00,F
0931:  BTFSC  03.2
0932:  GOTO   14F
0933:  BCF    03.5
0934:  BSF    03.6
0935:  CLRF   35
0936:  MOVF   04,W
0937:  MOVWF  34
0938:  BCF    35.0
0939:  BTFSC  03.7
093A:  BSF    35.0
093B:  MOVF   00,W
093C:  BCF    03.6
093D:  BTFSS  0C.4
093E:  GOTO   13D
093F:  MOVWF  19
0940:  BSF    03.6
0941:  MOVF   34,W
0942:  MOVWF  04
0943:  BCF    03.7
0944:  BTFSC  35.0
0945:  BSF    03.7
0946:  INCF   04,F
0947:  BTFSS  03.2
0948:  GOTO   14C
0949:  BCF    03.6
094A:  INCF   05,F
094B:  BSF    03.6
094C:  BSF    03.5
094D:  BCF    03.6
094E:  GOTO   130
*
0AED:  CLRF   77
0AEE:  CLRF   78
0AEF:  MOVF   5C,W
0AF0:  BCF    03.0
0AF1:  BTFSC  5D.0
0AF2:  ADDWF  77,F
0AF3:  RRF    77,F
0AF4:  RRF    78,F
0AF5:  BTFSC  5D.1
0AF6:  ADDWF  77,F
0AF7:  RRF    77,F
0AF8:  RRF    78,F
0AF9:  BTFSC  5D.2
0AFA:  ADDWF  77,F
0AFB:  RRF    77,F
0AFC:  RRF    78,F
0AFD:  BTFSC  5D.3
0AFE:  ADDWF  77,F
0AFF:  RRF    77,F
0B00:  RRF    78,F
0B01:  BTFSC  5D.4
0B02:  ADDWF  77,F
0B03:  RRF    77,F
0B04:  RRF    78,F
0B05:  BTFSC  5D.5
0B06:  ADDWF  77,F
0B07:  RRF    77,F
0B08:  RRF    78,F
0B09:  BTFSC  5D.6
0B0A:  ADDWF  77,F
0B0B:  RRF    77,F
0B0C:  RRF    78,F
0B0D:  BTFSC  5D.7
0B0E:  ADDWF  77,F
0B0F:  RRF    77,F
0B10:  RRF    78,F
*
0EF0:  BCF    0A.0
0EF1:  BSF    0A.1
0EF2:  BSF    0A.2
0EF3:  ADDWF  02,F
0EF4:  GOTO   45B
0EF5:  GOTO   45C
0EF6:  GOTO   471
0EF7:  GOTO   486
0EF8:  GOTO   490
0EF9:  GOTO   49A
....................  
.................... #list 
....................  
.................... #DEVICE ADC=10 
.................... #INCLUDE <STRING.H> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
*
0766:  BSF    03.6
0767:  MOVF   34,W
0768:  MOVWF  38
0769:  MOVF   33,W
076A:  MOVWF  37
076B:  MOVF   38,W
076C:  MOVWF  7A
076D:  MOVF   37,W
076E:  MOVWF  04
076F:  BCF    03.7
0770:  BTFSC  7A.0
0771:  BSF    03.7
0772:  MOVF   00,F
0773:  BTFSC  03.2
0774:  GOTO   779
0775:  INCF   37,F
0776:  BTFSC  03.2
0777:  INCF   38,F
0778:  GOTO   76B
....................    while(*s2 != '\0') 
0779:  MOVF   36,W
077A:  MOVWF  7A
077B:  MOVF   35,W
077C:  MOVWF  04
077D:  BCF    03.7
077E:  BTFSC  7A.0
077F:  BSF    03.7
0780:  MOVF   00,F
0781:  BTFSC  03.2
0782:  GOTO   798
....................    { 
....................       *s = *s2; 
0783:  MOVF   35,W
0784:  MOVWF  04
0785:  BCF    03.7
0786:  BTFSC  36.0
0787:  BSF    03.7
0788:  MOVF   00,W
0789:  MOVWF  3B
078A:  MOVF   37,W
078B:  MOVWF  04
078C:  BCF    03.7
078D:  BTFSC  38.0
078E:  BSF    03.7
078F:  MOVF   3B,W
0790:  MOVWF  00
....................       ++s; 
0791:  INCF   37,F
0792:  BTFSC  03.2
0793:  INCF   38,F
....................       ++s2; 
0794:  INCF   35,F
0795:  BTFSC  03.2
0796:  INCF   36,F
0797:  GOTO   779
....................    } 
....................  
....................    *s = '\0'; 
0798:  MOVF   37,W
0799:  MOVWF  04
079A:  BCF    03.7
079B:  BTFSC  38.0
079C:  BSF    03.7
079D:  CLRF   00
....................    return(s1); 
079E:  MOVF   33,W
079F:  MOVWF  78
07A0:  MOVF   34,W
07A1:  MOVWF  79
07A2:  BCF    03.6
07A3:  RETURN
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
*
0B80:  BSF    03.5
0B81:  MOVF   54,W
0B82:  MOVWF  7A
0B83:  MOVF   53,W
0B84:  MOVWF  04
0B85:  BCF    03.7
0B86:  BTFSC  7A.0
0B87:  BSF    03.7
0B88:  MOVF   00,W
0B89:  MOVWF  57
0B8A:  MOVF   56,W
0B8B:  MOVWF  7A
0B8C:  MOVF   55,W
0B8D:  MOVWF  04
0B8E:  BCF    03.7
0B8F:  BTFSC  7A.0
0B90:  BSF    03.7
0B91:  MOVF   00,W
0B92:  SUBWF  57,W
0B93:  BTFSS  03.2
0B94:  GOTO   3AC
....................       if (*s1 == '\0') 
0B95:  MOVF   54,W
0B96:  MOVWF  7A
0B97:  MOVF   53,W
0B98:  MOVWF  04
0B99:  BCF    03.7
0B9A:  BTFSC  7A.0
0B9B:  BSF    03.7
0B9C:  MOVF   00,F
0B9D:  BTFSS  03.2
0B9E:  GOTO   3A2
....................          return(0); 
0B9F:  MOVLW  00
0BA0:  MOVWF  78
0BA1:  GOTO   3C4
0BA2:  MOVF   54,W
0BA3:  MOVWF  7A
0BA4:  MOVF   53,W
0BA5:  INCF   53,F
0BA6:  BTFSC  03.2
0BA7:  INCF   54,F
0BA8:  INCF   55,F
0BA9:  BTFSC  03.2
0BAA:  INCF   56,F
0BAB:  GOTO   381
....................    return((*s1 < *s2) ? -1: 1); 
0BAC:  MOVF   54,W
0BAD:  MOVWF  7A
0BAE:  MOVF   53,W
0BAF:  MOVWF  04
0BB0:  BCF    03.7
0BB1:  BTFSC  54.0
0BB2:  BSF    03.7
0BB3:  MOVF   00,W
0BB4:  MOVWF  57
0BB5:  MOVF   56,W
0BB6:  MOVWF  7A
0BB7:  MOVF   55,W
0BB8:  MOVWF  04
0BB9:  BCF    03.7
0BBA:  BTFSC  56.0
0BBB:  BSF    03.7
0BBC:  MOVF   00,W
0BBD:  SUBWF  57,W
0BBE:  BTFSC  03.0
0BBF:  GOTO   3C2
0BC0:  MOVLW  FF
0BC1:  GOTO   3C3
0BC2:  MOVLW  01
0BC3:  MOVWF  78
0BC4:  BCF    03.5
0BC5:  RETURN
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
*
0BF2:  MOVF   54,W
0BF3:  MOVWF  7A
0BF4:  MOVF   53,W
0BF5:  MOVWF  04
0BF6:  BCF    03.7
0BF7:  BTFSC  7A.0
0BF8:  BSF    03.7
0BF9:  MOVF   55,W
0BFA:  SUBWF  00,W
0BFB:  BTFSC  03.2
0BFC:  GOTO   40F
....................       if (*s == '\0') 
0BFD:  MOVF   54,W
0BFE:  MOVWF  7A
0BFF:  MOVF   53,W
0C00:  MOVWF  04
0C01:  BCF    03.7
0C02:  BTFSC  7A.0
0C03:  BSF    03.7
0C04:  MOVF   00,F
0C05:  BTFSS  03.2
0C06:  GOTO   40B
....................          return(0); 
0C07:  MOVLW  00
0C08:  MOVWF  78
0C09:  MOVWF  79
0C0A:  GOTO   413
0C0B:  INCF   53,F
0C0C:  BTFSC  03.2
0C0D:  INCF   54,F
0C0E:  GOTO   3F2
....................    return(s); 
0C0F:  MOVF   53,W
0C10:  MOVWF  78
0C11:  MOVF   54,W
0C12:  MOVWF  79
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
*
0A19:  MOVF   5E,W
0A1A:  MOVWF  62
0A1B:  MOVF   5D,W
0A1C:  MOVWF  61
0A1D:  MOVF   62,W
0A1E:  MOVWF  7A
0A1F:  MOVF   61,W
0A20:  MOVWF  04
0A21:  BCF    03.7
0A22:  BTFSC  7A.0
0A23:  BSF    03.7
0A24:  MOVF   00,F
0A25:  BTFSC  03.2
0A26:  GOTO   256
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
0A27:  MOVF   60,W
0A28:  MOVWF  64
0A29:  MOVF   5F,W
0A2A:  MOVWF  63
0A2B:  MOVF   64,W
0A2C:  MOVWF  7A
0A2D:  MOVF   63,W
0A2E:  MOVWF  04
0A2F:  BCF    03.7
0A30:  BTFSC  7A.0
0A31:  BSF    03.7
0A32:  MOVF   00,F
0A33:  BTFSC  03.2
0A34:  GOTO   252
....................          if (*sc1 == *sc2) 
0A35:  MOVF   62,W
0A36:  MOVWF  7A
0A37:  MOVF   61,W
0A38:  MOVWF  04
0A39:  BCF    03.7
0A3A:  BTFSC  7A.0
0A3B:  BSF    03.7
0A3C:  MOVF   00,W
0A3D:  MOVWF  65
0A3E:  MOVF   64,W
0A3F:  MOVWF  7A
0A40:  MOVF   63,W
0A41:  MOVWF  04
0A42:  BCF    03.7
0A43:  BTFSC  7A.0
0A44:  BSF    03.7
0A45:  MOVF   00,W
0A46:  SUBWF  65,W
0A47:  BTFSS  03.2
0A48:  GOTO   24E
....................             return(sc1); 
0A49:  MOVF   61,W
0A4A:  MOVWF  78
0A4B:  MOVF   62,W
0A4C:  MOVWF  79
0A4D:  GOTO   259
0A4E:  INCF   63,F
0A4F:  BTFSC  03.2
0A50:  INCF   64,F
0A51:  GOTO   22B
0A52:  INCF   61,F
0A53:  BTFSC  03.2
0A54:  INCF   62,F
0A55:  GOTO   21D
....................    return(0); 
0A56:  MOVLW  00
0A57:  MOVWF  78
0A58:  MOVWF  79
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
*
09A6:  MOVF   5E,W
09A7:  MOVWF  62
09A8:  MOVF   5D,W
09A9:  MOVWF  61
09AA:  MOVF   62,W
09AB:  MOVWF  7A
09AC:  MOVF   61,W
09AD:  MOVWF  04
09AE:  BCF    03.7
09AF:  BTFSC  7A.0
09B0:  BSF    03.7
09B1:  MOVF   00,F
09B2:  BTFSC  03.2
09B3:  GOTO   1EB
....................       for (sc2 = s2; ; sc2++) 
09B4:  MOVF   60,W
09B5:  MOVWF  64
09B6:  MOVF   5F,W
09B7:  MOVWF  63
....................     if (*sc2 == '\0') 
09B8:  MOVF   64,W
09B9:  MOVWF  7A
09BA:  MOVF   63,W
09BB:  MOVWF  04
09BC:  BCF    03.7
09BD:  BTFSC  7A.0
09BE:  BSF    03.7
09BF:  MOVF   00,F
09C0:  BTFSS  03.2
09C1:  GOTO   1CF
....................        return(sc1 - s1); 
09C2:  MOVF   5D,W
09C3:  SUBWF  61,W
09C4:  MOVWF  77
09C5:  MOVF   62,W
09C6:  MOVWF  7A
09C7:  MOVF   5E,W
09C8:  BTFSS  03.0
09C9:  INCFSZ 5E,W
09CA:  SUBWF  7A,F
09CB:  MOVF   77,W
09CC:  MOVWF  78
09CD:  GOTO   1F6
09CE:  GOTO   1E3
....................          else if (*sc1 == *sc2) 
09CF:  MOVF   62,W
09D0:  MOVWF  7A
09D1:  MOVF   61,W
09D2:  MOVWF  04
09D3:  BCF    03.7
09D4:  BTFSC  7A.0
09D5:  BSF    03.7
09D6:  MOVF   00,W
09D7:  MOVWF  65
09D8:  MOVF   64,W
09D9:  MOVWF  7A
09DA:  MOVF   63,W
09DB:  MOVWF  04
09DC:  BCF    03.7
09DD:  BTFSC  7A.0
09DE:  BSF    03.7
09DF:  MOVF   00,W
09E0:  SUBWF  65,W
09E1:  BTFSC  03.2
....................             break; 
09E2:  GOTO   1E7
09E3:  INCF   63,F
09E4:  BTFSC  03.2
09E5:  INCF   64,F
09E6:  GOTO   1B8
09E7:  INCF   61,F
09E8:  BTFSC  03.2
09E9:  INCF   62,F
09EA:  GOTO   1AA
....................    return(sc1 - s1); 
09EB:  MOVF   5D,W
09EC:  SUBWF  61,W
09ED:  MOVWF  77
09EE:  MOVF   62,W
09EF:  MOVWF  7A
09F0:  MOVF   5E,W
09F1:  BTFSS  03.0
09F2:  INCFSZ 5E,W
09F3:  SUBWF  7A,F
09F4:  MOVF   77,W
09F5:  MOVWF  78
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
*
0F2C:  BCF    03.6
0F2D:  CLRF   2B
0F2E:  CLRF   2C
....................  
....................    beg = (s1)? s1: save; 
*
098D:  BSF    03.5
098E:  MOVF   55,W
098F:  IORWF  56,W
0990:  BTFSC  03.2
0991:  GOTO   196
0992:  MOVF   56,W
0993:  MOVWF  7A
0994:  MOVF   55,W
0995:  GOTO   19B
0996:  BCF    03.5
0997:  MOVF   2C,W
0998:  MOVWF  7A
0999:  MOVF   2B,W
099A:  BSF    03.5
099B:  MOVWF  59
099C:  MOVF   7A,W
099D:  MOVWF  5A
....................    beg += strspn(beg, s2); 
099E:  MOVF   5A,W
099F:  MOVWF  5E
09A0:  MOVF   59,W
09A1:  MOVWF  5D
09A2:  MOVF   58,W
09A3:  MOVWF  60
09A4:  MOVF   57,W
09A5:  MOVWF  5F
*
09F6:  MOVF   78,W
09F7:  ADDWF  59,F
09F8:  BTFSC  03.0
09F9:  INCF   5A,F
....................    if (*beg == '\0') 
09FA:  MOVF   5A,W
09FB:  MOVWF  7A
09FC:  MOVF   59,W
09FD:  MOVWF  04
09FE:  BCF    03.7
09FF:  BTFSC  7A.0
0A00:  BSF    03.7
0A01:  MOVF   00,F
0A02:  BTFSS  03.2
0A03:  GOTO   211
....................    { 
....................       *save = ' '; 
0A04:  BCF    03.5
0A05:  MOVF   2B,W
0A06:  MOVWF  04
0A07:  BCF    03.7
0A08:  BTFSC  2C.0
0A09:  BSF    03.7
0A0A:  MOVLW  20
0A0B:  MOVWF  00
....................       return(0); 
0A0C:  MOVLW  00
0A0D:  MOVWF  78
0A0E:  MOVWF  79
0A0F:  GOTO   27D
0A10:  BSF    03.5
....................    } 
....................    end = strpbrk(beg, s2); 
0A11:  MOVF   5A,W
0A12:  MOVWF  5E
0A13:  MOVF   59,W
0A14:  MOVWF  5D
0A15:  MOVF   58,W
0A16:  MOVWF  60
0A17:  MOVF   57,W
0A18:  MOVWF  5F
*
0A59:  MOVF   79,W
0A5A:  MOVWF  5C
0A5B:  MOVF   78,W
0A5C:  MOVWF  5B
....................    if (*end != '\0') 
0A5D:  MOVF   5C,W
0A5E:  MOVWF  7A
0A5F:  MOVF   5B,W
0A60:  MOVWF  04
0A61:  BCF    03.7
0A62:  BTFSC  7A.0
0A63:  BSF    03.7
0A64:  MOVF   00,F
0A65:  BTFSC  03.2
0A66:  GOTO   270
....................    { 
....................       *end = '\0'; 
0A67:  MOVF   5B,W
0A68:  MOVWF  04
0A69:  BCF    03.7
0A6A:  BTFSC  5C.0
0A6B:  BSF    03.7
0A6C:  CLRF   00
....................       end++; 
0A6D:  INCF   5B,F
0A6E:  BTFSC  03.2
0A6F:  INCF   5C,F
....................    } 
....................    save = end; 
0A70:  MOVF   5C,W
0A71:  BCF    03.5
0A72:  MOVWF  2C
0A73:  BSF    03.5
0A74:  MOVF   5B,W
0A75:  BCF    03.5
0A76:  MOVWF  2B
....................    return(beg); 
0A77:  BSF    03.5
0A78:  MOVF   59,W
0A79:  MOVWF  78
0A7A:  MOVF   5A,W
0A7B:  MOVWF  79
0A7C:  BCF    03.5
0A7D:  RETURN
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
*
07A4:  BSF    03.6
07A5:  MOVF   35,W
07A6:  MOVWF  37
07A7:  MOVF   34,W
07A8:  MOVWF  36
07A9:  MOVF   37,W
07AA:  MOVWF  7A
07AB:  MOVF   36,W
07AC:  MOVWF  04
07AD:  BCF    03.7
07AE:  BTFSC  7A.0
07AF:  BSF    03.7
07B0:  MOVF   00,F
07B1:  BTFSC  03.2
07B2:  GOTO   7B7
07B3:  INCF   36,F
07B4:  BTFSC  03.2
07B5:  INCF   37,F
07B6:  GOTO   7A9
....................    return(sc - s); 
07B7:  MOVF   34,W
07B8:  SUBWF  36,W
07B9:  MOVWF  77
07BA:  MOVF   37,W
07BB:  MOVWF  7A
07BC:  MOVF   35,W
07BD:  BTFSS  03.0
07BE:  INCFSZ 35,W
07BF:  SUBWF  7A,F
07C0:  MOVF   77,W
07C1:  MOVWF  78
07C2:  BCF    03.6
07C3:  RETURN
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #INCLUDE <STDLIB.H> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... /* Standart template: float strtof(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... float strtof(char *s,char *endptr); 
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s,char *endptr); 
.................... float64 strtod(char *s,char *endptr); 
.................... #else 
.................... //provided for compatibility 
.................... #define strtof48(s, e) strtof(s, e) 
.................... #define strtod(s, e) strtof(s, e) 
.................... #endif 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof(s)   strtof(s, 0) 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof48(s) strtof48(s, 0) 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof64(s) strtod(s, 0) 
.................... #endif 
....................  
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float atoe(char * s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s); 
.................... #endif 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... unsigned int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................  
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
*
0A7E:  BSF    03.5
0A7F:  CLRF   5A
....................    sign = 0; 
0A80:  CLRF   58
....................    base = 10; 
0A81:  MOVLW  0A
0A82:  MOVWF  59
....................    result = 0; 
0A83:  CLRF   57
....................  
....................    if (!s) 
0A84:  MOVF   55,W
0A85:  IORWF  56,W
0A86:  BTFSS  03.2
0A87:  GOTO   28B
....................       return 0; 
0A88:  MOVLW  00
0A89:  MOVWF  78
0A8A:  GOTO   37E
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
0A8B:  MOVF   5A,W
0A8C:  INCF   5A,F
0A8D:  ADDWF  55,W
0A8E:  MOVWF  04
0A8F:  BCF    03.7
0A90:  BTFSC  56.0
0A91:  BSF    03.7
0A92:  MOVF   00,W
0A93:  MOVWF  5B
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
0A94:  MOVF   5B,W
0A95:  SUBLW  2D
0A96:  BTFSS  03.2
0A97:  GOTO   2A4
....................    { 
....................       sign = 1;         // Set the sign to negative 
0A98:  MOVLW  01
0A99:  MOVWF  58
....................       c = s[index++]; 
0A9A:  MOVF   5A,W
0A9B:  INCF   5A,F
0A9C:  ADDWF  55,W
0A9D:  MOVWF  04
0A9E:  BCF    03.7
0A9F:  BTFSC  56.0
0AA0:  BSF    03.7
0AA1:  MOVF   00,W
0AA2:  MOVWF  5B
....................    } 
0AA3:  GOTO   2B1
....................    else if (c == '+') 
0AA4:  MOVF   5B,W
0AA5:  SUBLW  2B
0AA6:  BTFSS  03.2
0AA7:  GOTO   2B1
....................    { 
....................       c = s[index++]; 
0AA8:  MOVF   5A,W
0AA9:  INCF   5A,F
0AAA:  ADDWF  55,W
0AAB:  MOVWF  04
0AAC:  BCF    03.7
0AAD:  BTFSC  56.0
0AAE:  BSF    03.7
0AAF:  MOVF   00,W
0AB0:  MOVWF  5B
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
0AB1:  MOVF   5B,W
0AB2:  SUBLW  2F
0AB3:  BTFSC  03.0
0AB4:  GOTO   374
0AB5:  MOVF   5B,W
0AB6:  SUBLW  39
0AB7:  BTFSS  03.0
0AB8:  GOTO   374
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
0AB9:  MOVF   5B,W
0ABA:  SUBLW  30
0ABB:  BTFSS  03.2
0ABC:  GOTO   2DD
0ABD:  MOVF   5A,W
0ABE:  ADDWF  55,W
0ABF:  MOVWF  04
0AC0:  BCF    03.7
0AC1:  BTFSC  56.0
0AC2:  BSF    03.7
0AC3:  MOVF   00,W
0AC4:  SUBLW  78
0AC5:  BTFSC  03.2
0AC6:  GOTO   2D1
0AC7:  MOVF   5A,W
0AC8:  ADDWF  55,W
0AC9:  MOVWF  04
0ACA:  BCF    03.7
0ACB:  BTFSC  56.0
0ACC:  BSF    03.7
0ACD:  MOVF   00,W
0ACE:  SUBLW  58
0ACF:  BTFSS  03.2
0AD0:  GOTO   2DD
....................       { 
....................          base = 16; 
0AD1:  MOVLW  10
0AD2:  MOVWF  59
....................          index++; 
0AD3:  INCF   5A,F
....................          c = s[index++]; 
0AD4:  MOVF   5A,W
0AD5:  INCF   5A,F
0AD6:  ADDWF  55,W
0AD7:  MOVWF  04
0AD8:  BCF    03.7
0AD9:  BTFSC  56.0
0ADA:  BSF    03.7
0ADB:  MOVF   00,W
0ADC:  MOVWF  5B
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
0ADD:  MOVF   59,W
0ADE:  SUBLW  0A
0ADF:  BTFSS  03.2
0AE0:  GOTO   322
....................       { 
....................          while (c >= '0' && c <= '9') 
0AE1:  MOVF   5B,W
0AE2:  SUBLW  2F
0AE3:  BTFSC  03.0
0AE4:  GOTO   321
0AE5:  MOVF   5B,W
0AE6:  SUBLW  39
0AE7:  BTFSS  03.0
0AE8:  GOTO   321
....................          { 
....................             result = 10*result + (c - '0'); 
0AE9:  MOVLW  0A
0AEA:  MOVWF  5C
0AEB:  MOVF   57,W
0AEC:  MOVWF  5D
*
0B11:  MOVF   78,W
0B12:  MOVWF  5C
0B13:  MOVLW  30
0B14:  SUBWF  5B,W
0B15:  ADDWF  5C,W
0B16:  MOVWF  57
....................             c = s[index++]; 
0B17:  MOVF   5A,W
0B18:  INCF   5A,F
0B19:  ADDWF  55,W
0B1A:  MOVWF  04
0B1B:  BCF    03.7
0B1C:  BTFSC  56.0
0B1D:  BSF    03.7
0B1E:  MOVF   00,W
0B1F:  MOVWF  5B
0B20:  GOTO   2E1
....................          } 
....................       } 
0B21:  GOTO   374
....................       else if (base == 16)    // The number is a hexa number 
0B22:  MOVF   59,W
0B23:  SUBLW  10
0B24:  BTFSS  03.2
0B25:  GOTO   374
....................       { 
....................          c = toupper(c); 
0B26:  MOVF   5B,W
0B27:  SUBLW  60
0B28:  BTFSC  03.0
0B29:  GOTO   331
0B2A:  MOVF   5B,W
0B2B:  SUBLW  7A
0B2C:  BTFSS  03.0
0B2D:  GOTO   331
0B2E:  MOVF   5B,W
0B2F:  ANDLW  DF
0B30:  GOTO   332
0B31:  MOVF   5B,W
0B32:  MOVWF  5B
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
0B33:  MOVF   5B,W
0B34:  SUBLW  2F
0B35:  BTFSC  03.0
0B36:  GOTO   33B
0B37:  MOVF   5B,W
0B38:  SUBLW  39
0B39:  BTFSC  03.0
0B3A:  GOTO   343
0B3B:  MOVF   5B,W
0B3C:  SUBLW  40
0B3D:  BTFSC  03.0
0B3E:  GOTO   374
0B3F:  MOVF   5B,W
0B40:  SUBLW  46
0B41:  BTFSS  03.0
0B42:  GOTO   374
....................          { 
....................             if (c >= '0' && c <= '9') 
0B43:  MOVF   5B,W
0B44:  SUBLW  2F
0B45:  BTFSC  03.0
0B46:  GOTO   354
0B47:  MOVF   5B,W
0B48:  SUBLW  39
0B49:  BTFSS  03.0
0B4A:  GOTO   354
....................                result = (result << 4) + (c - '0'); 
0B4B:  SWAPF  57,W
0B4C:  MOVWF  5C
0B4D:  MOVLW  F0
0B4E:  ANDWF  5C,F
0B4F:  MOVLW  30
0B50:  SUBWF  5B,W
0B51:  ADDWF  5C,W
0B52:  MOVWF  57
0B53:  GOTO   35D
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
0B54:  SWAPF  57,W
0B55:  MOVWF  5C
0B56:  MOVLW  F0
0B57:  ANDWF  5C,F
0B58:  MOVLW  41
0B59:  SUBWF  5B,W
0B5A:  ADDLW  0A
0B5B:  ADDWF  5C,W
0B5C:  MOVWF  57
....................  
....................             c = s[index++]; 
0B5D:  MOVF   5A,W
0B5E:  INCF   5A,F
0B5F:  ADDWF  55,W
0B60:  MOVWF  04
0B61:  BCF    03.7
0B62:  BTFSC  56.0
0B63:  BSF    03.7
0B64:  MOVF   00,W
0B65:  MOVWF  5B
....................             c = toupper(c); 
0B66:  MOVF   5B,W
0B67:  SUBLW  60
0B68:  BTFSC  03.0
0B69:  GOTO   371
0B6A:  MOVF   5B,W
0B6B:  SUBLW  7A
0B6C:  BTFSS  03.0
0B6D:  GOTO   371
0B6E:  MOVF   5B,W
0B6F:  ANDLW  DF
0B70:  GOTO   372
0B71:  MOVF   5B,W
0B72:  MOVWF  5B
0B73:  GOTO   333
....................          } 
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
0B74:  DECFSZ 58,W
0B75:  GOTO   37C
0B76:  MOVF   59,W
0B77:  SUBLW  0A
0B78:  BTFSS  03.2
0B79:  GOTO   37C
....................        result = -result; 
0B7A:  COMF   57,F
0B7B:  INCF   57,F
....................  
....................    return(result); 
0B7C:  MOVF   57,W
0B7D:  MOVWF  78
0B7E:  BCF    03.5
0B7F:  RETURN
.................... } 
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
*
03F3:  BSF    03.6
03F4:  CLRF   3E
03F5:  CLRF   3D
03F6:  CLRF   3C
03F7:  MOVLW  01
03F8:  MOVWF  3B
03F9:  CLRF   40
03FA:  CLRF   41
.................... { 
....................      unsigned int32 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
03FB:  BTFSS  37.7
03FC:  GOTO   43D
....................          sign=1;        // Check for negative number 
03FD:  MOVLW  01
03FE:  MOVWF  40
....................          num*=-1; 
03FF:  MOVF   37,W
0400:  MOVWF  46
0401:  MOVF   36,W
0402:  MOVWF  45
0403:  MOVF   35,W
0404:  MOVWF  44
0405:  MOVF   34,W
0406:  MOVWF  43
0407:  MOVLW  FF
0408:  MOVWF  4A
0409:  MOVWF  49
040A:  MOVWF  48
040B:  MOVWF  47
*
0435:  MOVF   7A,W
0436:  MOVWF  37
0437:  MOVF   79,W
0438:  MOVWF  36
0439:  MOVF   78,W
043A:  MOVWF  35
043B:  MOVF   77,W
043C:  MOVWF  34
....................      } 
....................  
....................      while(temp>0) { 
043D:  MOVF   3B,F
043E:  BTFSS  03.2
043F:  GOTO   449
0440:  MOVF   3C,F
0441:  BTFSS  03.2
0442:  GOTO   449
0443:  MOVF   3D,F
0444:  BTFSS  03.2
0445:  GOTO   449
0446:  MOVF   3E,F
0447:  BTFSC  03.2
0448:  GOTO   4C5
....................          temp=(num/base); 
0449:  BCF    03.1
044A:  MOVF   37,W
044B:  MOVWF  4E
044C:  MOVF   36,W
044D:  MOVWF  4D
044E:  MOVF   35,W
044F:  MOVWF  4C
0450:  MOVF   34,W
0451:  MOVWF  4B
0452:  CLRF   52
0453:  CLRF   51
0454:  CLRF   50
0455:  MOVF   38,W
0456:  MOVWF  4F
0457:  BCF    03.6
0458:  CALL   377
0459:  MOVF   7A,W
045A:  BSF    03.6
045B:  MOVWF  3E
045C:  MOVF   79,W
045D:  MOVWF  3D
045E:  MOVF   78,W
045F:  MOVWF  3C
0460:  MOVF   77,W
0461:  MOVWF  3B
....................          s[cnt]=(num%base)+'0';    // Conversion 
0462:  MOVF   41,W
0463:  ADDWF  39,W
0464:  MOVWF  78
0465:  MOVF   3A,W
0466:  MOVWF  7A
0467:  BTFSC  03.0
0468:  INCF   7A,F
0469:  MOVF   78,W
046A:  MOVWF  43
046B:  MOVF   7A,W
046C:  MOVWF  44
046D:  CLRF   46
046E:  MOVF   04,W
046F:  MOVWF  45
0470:  BCF    46.0
0471:  BTFSC  03.7
0472:  BSF    46.0
0473:  BSF    03.1
0474:  MOVLW  47
0475:  MOVWF  04
0476:  BSF    03.7
0477:  MOVF   37,W
0478:  MOVWF  4E
0479:  MOVF   36,W
047A:  MOVWF  4D
047B:  MOVF   35,W
047C:  MOVWF  4C
047D:  MOVF   34,W
047E:  MOVWF  4B
047F:  CLRF   52
0480:  CLRF   51
0481:  CLRF   50
0482:  MOVF   38,W
0483:  MOVWF  4F
0484:  BCF    03.6
0485:  CALL   377
0486:  BSF    03.6
0487:  MOVF   45,W
0488:  MOVWF  04
0489:  BCF    03.7
048A:  BTFSC  46.0
048B:  BSF    03.7
048C:  MOVLW  30
048D:  ADDWF  47,W
048E:  MOVWF  77
048F:  MOVF   48,W
0490:  MOVWF  78
0491:  MOVLW  00
0492:  BTFSC  03.0
0493:  MOVLW  01
0494:  ADDWF  78,F
0495:  MOVF   49,W
0496:  MOVWF  79
0497:  MOVLW  00
0498:  BTFSC  03.0
0499:  MOVLW  01
049A:  ADDWF  79,F
049B:  MOVF   4A,W
049C:  MOVWF  7A
049D:  MOVLW  00
049E:  BTFSC  03.0
049F:  MOVLW  01
04A0:  ADDWF  7A,F
04A1:  MOVF   43,W
04A2:  MOVWF  04
04A3:  BCF    03.7
04A4:  BTFSC  44.0
04A5:  BSF    03.7
04A6:  MOVF   77,W
04A7:  MOVWF  00
....................  
....................          if(s[cnt]>0x39) 
04A8:  MOVF   41,W
04A9:  ADDWF  39,W
04AA:  MOVWF  04
04AB:  BCF    03.7
04AC:  BTFSC  3A.0
04AD:  BSF    03.7
04AE:  MOVF   00,W
04AF:  SUBLW  39
04B0:  BTFSC  03.0
04B1:  GOTO   4BB
....................             s[cnt]+=0x7; 
04B2:  MOVF   41,W
04B3:  ADDWF  39,W
04B4:  MOVWF  04
04B5:  BCF    03.7
04B6:  BTFSC  3A.0
04B7:  BSF    03.7
04B8:  MOVLW  07
04B9:  ADDWF  00,W
04BA:  MOVWF  00
....................  
....................          cnt++; 
04BB:  INCF   41,F
....................          num=temp; 
04BC:  MOVF   3E,W
04BD:  MOVWF  37
04BE:  MOVF   3D,W
04BF:  MOVWF  36
04C0:  MOVF   3C,W
04C1:  MOVWF  35
04C2:  MOVF   3B,W
04C3:  MOVWF  34
04C4:  GOTO   43D
....................      } 
....................  
....................      if(sign==1) { 
04C5:  DECFSZ 40,W
04C6:  GOTO   4D0
....................          s[cnt]=0x2D;      // Negative sign 
04C7:  MOVF   41,W
04C8:  ADDWF  39,W
04C9:  MOVWF  04
04CA:  BCF    03.7
04CB:  BTFSC  3A.0
04CC:  BSF    03.7
04CD:  MOVLW  2D
04CE:  MOVWF  00
....................          cnt++; 
04CF:  INCF   41,F
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
04D0:  CLRF   3F
04D1:  BCF    03.0
04D2:  RRF    41,W
04D3:  SUBWF  3F,W
04D4:  BTFSC  03.0
04D5:  GOTO   506
....................  
....................          c=s[i]; 
04D6:  MOVF   3F,W
04D7:  ADDWF  39,W
04D8:  MOVWF  04
04D9:  BCF    03.7
04DA:  BTFSC  3A.0
04DB:  BSF    03.7
04DC:  MOVF   00,W
04DD:  MOVWF  42
....................          s[i]=s[cnt-i-1];        // Reverse the number 
04DE:  MOVF   3F,W
04DF:  ADDWF  39,W
04E0:  MOVWF  78
04E1:  MOVF   3A,W
04E2:  MOVWF  7A
04E3:  BTFSC  03.0
04E4:  INCF   7A,F
04E5:  MOVF   78,W
04E6:  MOVWF  43
04E7:  MOVF   7A,W
04E8:  MOVWF  44
04E9:  MOVF   3F,W
04EA:  SUBWF  41,W
04EB:  ADDLW  FF
04EC:  ADDWF  39,W
04ED:  MOVWF  04
04EE:  BCF    03.7
04EF:  BTFSC  3A.0
04F0:  BSF    03.7
04F1:  MOVF   00,W
04F2:  MOVWF  45
04F3:  MOVF   43,W
04F4:  MOVWF  04
04F5:  BCF    03.7
04F6:  BTFSC  44.0
04F7:  BSF    03.7
04F8:  MOVF   45,W
04F9:  MOVWF  00
....................          s[cnt-i-1]=c; 
04FA:  MOVF   3F,W
04FB:  SUBWF  41,W
04FC:  ADDLW  FF
04FD:  ADDWF  39,W
04FE:  MOVWF  04
04FF:  BCF    03.7
0500:  BTFSC  3A.0
0501:  BSF    03.7
0502:  MOVF   42,W
0503:  MOVWF  00
0504:  INCF   3F,F
0505:  GOTO   4D1
....................      } 
....................      s[cnt]='\0';     // End the string 
0506:  MOVF   41,W
0507:  ADDWF  39,W
0508:  MOVWF  04
0509:  BCF    03.7
050A:  BTFSC  3A.0
050B:  BSF    03.7
050C:  CLRF   00
....................      return s; 
050D:  MOVF   39,W
050E:  MOVWF  78
050F:  MOVF   3A,W
0510:  MOVWF  79
0511:  BCF    03.6
0512:  RETURN
.................... } 
....................  
.................... #if defined(__PCD__) 
....................  
.................... char * itoa(signed int48 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int48 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... char * itoa(signed int64 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int64 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................       
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1;         
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................              
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #endif 
....................  
.................... float strtof(char *s, char *endptr) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s, char *endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float48)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float48)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s, char *endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float64)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float64)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtoulGO; 
....................  
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................    { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... int8 mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #if !defined(__PCD__) 
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2);  
.................... #else  
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2);  
.................... #endif 
....................  
....................  
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    unsigned int8 t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=1; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = 0; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
.................... #INCLUDE <STDIO.H> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDIO 
.................... #define _STDIO 
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #ifndef getc 
.................... #define getc getch 
.................... #define getchar getch 
.................... #define puts(s) {printf(s); putchar(13); putchar(10);} 
.................... #define putc putchar 
.................... #endif 
.................... /* maps error number to an error message. Writes a sequence of characters to 
.................... stderr stream thus: if s is not null then string pointed to by s follwed by 
.................... a colon (:) and a space and the appropriate error message returned by strerror 
.................... function with argument errno 
....................  
.................... Returns: no value 
.................... */ 
....................  
.................... #ifdef _ERRNO 
.................... void perror(char *s) 
.................... { 
....................   if(s) 
....................   fprintf(STDERR,"%s: ",s); 
....................   fprintf(STDERR,"%s\r\n",strerror(errno)); 
.................... } 
.................... #endif 
.................... #endif 
....................  
.................... #FUSES NOWDT, PUT, HS 
.................... #USE DELAY(CLOCK=20M) 
*
014F:  MOVLW  36
0150:  MOVWF  04
0151:  BSF    03.7
0152:  MOVF   00,W
0153:  BTFSC  03.2
0154:  GOTO   162
0155:  MOVLW  06
0156:  MOVWF  78
0157:  CLRF   77
0158:  DECFSZ 77,F
0159:  GOTO   158
015A:  DECFSZ 78,F
015B:  GOTO   157
015C:  MOVLW  7B
015D:  MOVWF  77
015E:  DECFSZ 77,F
015F:  GOTO   15E
0160:  DECFSZ 00,F
0161:  GOTO   155
0162:  RETURN
.................... #USE RS232(BAUD=9600,XMIT=PIN_C6,RCV=PIN_C7) 
.................... #DEFINE BT1_PIN PIN_B1 
.................... #DEFINE BT2_PIN PIN_B2 
.................... #DEFINE BT3_PIN PIN_B3 
.................... #DEFINE LCD_ENABLE_PIN  PIN_E0                                    
.................... #DEFINE LCD_RS_PIN      PIN_E1                                 
.................... #DEFINE LCD_RW_PIN      PIN_E2   
.................... #DEFINE LCD_DATA4       PIN_C0                                
.................... #DEFINE LCD_DATA5       PIN_C1                                  
.................... #DEFINE LCD_DATA6       PIN_C2                                    
.................... #DEFINE LCD_DATA7       PIN_C3   
.................... #INCLUDE <LCD.C> 
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... ////                             LCD.C                                     //// 
.................... ////                 Driver for common LCD modules                         //// 
.................... ////                                                                       //// 
.................... ////  lcd_init()   Must be called before any other function.               //// 
.................... ////                                                                       //// 
.................... ////  lcd_putc(c)  Will display c on the next position of the LCD.         //// 
.................... ////                 \a  Set cursor position to upper left                 //// 
.................... ////                 \f  Clear display, set cursor to upper left           //// 
.................... ////                 \n  Go to start of second line                        //// 
.................... ////                 \b  Move back one position                            //// 
.................... ////              If LCD_EXTENDED_NEWLINE is defined, the \n character     //// 
.................... ////              will erase all remanining characters on the current      //// 
.................... ////              line, and move the cursor to the beginning of the next   //// 
.................... ////              line.                                                    //// 
.................... ////              If LCD_EXTENDED_NEWLINE is defined, the \r character     //// 
.................... ////              will move the cursor to the start of the current         //// 
.................... ////              line.                                                    //// 
.................... ////                                                                       //// 
.................... ////  lcd_gotoxy(x,y) Set write position on LCD (upper left is 1,1)        //// 
.................... ////                                                                       //// 
.................... ////  lcd_getc(x,y)   Returns character at position x,y on LCD             //// 
.................... ////                                                                       //// 
.................... ////  lcd_cursor_on(int1 on)   Turn the cursor on (on=TRUE) or off         //// 
.................... ////              (on=FALSE).                                              //// 
.................... ////                                                                       //// 
.................... ////  lcd_set_cgram_char(w, *p)   Write a custom character to the CGRAM.   //// 
.................... ////                                                                       //// 
.................... ////                                                                       //// 
.................... ////  CONFIGURATION                                                        //// 
.................... ////  The LCD can be configured in one of two ways: a.) port access or     //// 
.................... ////  b.) pin access.  Port access requires the entire 7 bit interface     //// 
.................... ////  connected to one GPIO port, and the data bits (D4:D7 of the LCD)     //// 
.................... ////  connected to sequential pins on the GPIO.  Pin access                //// 
.................... ////  has no requirements, all 7 bits of the control interface can         //// 
.................... ////  can be connected to any GPIO using several ports.                    //// 
.................... ////                                                                       //// 
.................... ////  To use port access, #define LCD_DATA_PORT to the SFR location of     //// 
.................... ////  of the GPIO port that holds the interface, -AND- edit LCD_PIN_MAP    //// 
.................... ////  of this file to configure the pin order.  If you are using a         //// 
.................... ////  baseline PIC (PCB), then LCD_OUTPUT_MAP and LCD_INPUT_MAP also must  //// 
.................... ////  be defined.                                                          //// 
.................... ////                                                                       //// 
.................... ////  Example of port access:                                              //// 
.................... ////     #define LCD_DATA_PORT getenv("SFR:PORTD")                         //// 
.................... ////                                                                       //// 
.................... ////  To use pin access, the following pins must be defined:               //// 
.................... ////     LCD_ENABLE_PIN                                                    //// 
.................... ////     LCD_RS_PIN                                                        //// 
.................... ////     LCD_RW_PIN                                                        //// 
.................... ////     LCD_DATA4                                                         //// 
.................... ////     LCD_DATA5                                                         //// 
.................... ////     LCD_DATA6                                                         //// 
.................... ////     LCD_DATA7                                                         //// 
.................... ////                                                                       //// 
.................... ////  Example of pin access:                                               //// 
.................... ////     #define LCD_ENABLE_PIN  PIN_E0                                    //// 
.................... ////     #define LCD_RS_PIN      PIN_E1                                    //// 
.................... ////     #define LCD_RW_PIN      PIN_E2                                    //// 
.................... ////     #define LCD_DATA4       PIN_D4                                    //// 
.................... ////     #define LCD_DATA5       PIN_D5                                    //// 
.................... ////     #define LCD_DATA6       PIN_D6                                    //// 
.................... ////     #define LCD_DATA7       PIN_D7                                    //// 
.................... ////                                                                       //// 
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2010 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef __LCD_C__ 
.................... #define __LCD_C__ 
....................  
.................... // define the pinout. 
.................... // only required if port access is being used. 
.................... typedef struct   
.................... {                            // This structure is overlayed 
....................    int1 enable;           // on to an I/O port to gain 
....................    int1 rs;               // access to the LCD pins. 
....................    int1 rw;               // The bits are allocated from 
....................    int1 unused;           // low order up.  ENABLE will 
....................    unsigned int     data : 4;         // be LSB pin of that port. 
....................   #if defined(__PCD__)       // The port used will be LCD_DATA_PORT. 
....................    unsigned int    reserved: 8; 
....................   #endif 
.................... } LCD_PIN_MAP; 
....................  
.................... // this is to improve compatability with previous LCD drivers that accepted 
.................... // a define labeled 'use_portb_lcd' that configured the LCD onto port B. 
.................... #if ((defined(use_portb_lcd)) && (use_portb_lcd==TRUE)) 
....................  #define LCD_DATA_PORT getenv("SFR:PORTB") 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
....................    // these definitions only need to be modified for baseline PICs. 
....................    // all other PICs use LCD_PIN_MAP or individual LCD_xxx pin definitions. 
.................... /*                                    EN, RS,   RW,   UNUSED,  DATA  */ 
....................  const LCD_PIN_MAP LCD_OUTPUT_MAP =  {0,  0,    0,    0,       0}; 
....................  const LCD_PIN_MAP LCD_INPUT_MAP =   {0,  0,    0,    0,       0xF}; 
.................... #endif 
....................  
.................... ////////////////////// END CONFIGURATION /////////////////////////////////// 
....................  
.................... #ifndef LCD_ENABLE_PIN 
....................    #define lcd_output_enable(x) lcdlat.enable=x 
....................    #define lcd_enable_tris()   lcdtris.enable=0 
.................... #else 
....................    #define lcd_output_enable(x) output_bit(LCD_ENABLE_PIN, x) 
....................    #define lcd_enable_tris()  output_drive(LCD_ENABLE_PIN) 
.................... #endif 
....................  
.................... #ifndef LCD_RS_PIN 
....................    #define lcd_output_rs(x) lcdlat.rs=x 
....................    #define lcd_rs_tris()   lcdtris.rs=0 
.................... #else 
....................    #define lcd_output_rs(x) output_bit(LCD_RS_PIN, x) 
....................    #define lcd_rs_tris()  output_drive(LCD_RS_PIN) 
.................... #endif 
....................  
.................... #ifndef LCD_RW_PIN 
....................    #define lcd_output_rw(x) lcdlat.rw=x 
....................    #define lcd_rw_tris()   lcdtris.rw=0 
.................... #else 
....................    #define lcd_output_rw(x) output_bit(LCD_RW_PIN, x) 
....................    #define lcd_rw_tris()  output_drive(LCD_RW_PIN) 
.................... #endif 
....................  
.................... // original version of this library incorrectly labeled LCD_DATA0 as LCD_DATA4, 
.................... // LCD_DATA1 as LCD_DATA5, and so on.  this block of code makes the driver 
.................... // compatible with any code written for the original library 
.................... #if (defined(LCD_DATA0) && defined(LCD_DATA1) && defined(LCD_DATA2) && defined(LCD_DATA3) && !defined(LCD_DATA4) && !defined(LCD_DATA5) && !defined(LCD_DATA6) && !defined(LCD_DATA7)) 
....................    #define  LCD_DATA4    LCD_DATA0 
....................    #define  LCD_DATA5    LCD_DATA1 
....................    #define  LCD_DATA6    LCD_DATA2 
....................    #define  LCD_DATA7    LCD_DATA3 
.................... #endif 
....................  
.................... #ifndef LCD_DATA4 
.................... #ifndef LCD_DATA_PORT 
....................    #if defined(__PCB__) 
....................       #define LCD_DATA_PORT      0x06     //portb 
....................       #define set_tris_lcd(x)   set_tris_b(x) 
....................    #else 
....................      #if defined(PIN_D0) 
....................       #define LCD_DATA_PORT      getenv("SFR:PORTD")     //portd 
....................      #else 
....................       #define LCD_DATA_PORT      getenv("SFR:PORTB")     //portb 
....................      #endif 
....................    #endif    
.................... #endif 
....................  
.................... #if defined(__PCB__) 
....................    LCD_PIN_MAP lcd, lcdlat; 
....................    #byte lcd = LCD_DATA_PORT 
....................    #byte lcdlat = LCD_DATA_PORT 
.................... #elif defined(__PCM__) 
....................    LCD_PIN_MAP lcd, lcdlat, lcdtris; 
....................    #byte lcd = LCD_DATA_PORT 
....................    #byte lcdlat = LCD_DATA_PORT 
....................    #byte lcdtris = LCD_DATA_PORT+0x80 
.................... #elif defined(__PCH__) 
....................    LCD_PIN_MAP lcd, lcdlat, lcdtris; 
....................    #byte lcd = LCD_DATA_PORT 
....................    #byte lcdlat = LCD_DATA_PORT+9 
....................    #byte lcdtris = LCD_DATA_PORT+0x12 
.................... #elif defined(__PCD__) 
....................    LCD_PIN_MAP lcd, lcdlat, lcdtris; 
....................    #word lcd = LCD_DATA_PORT 
....................    #word lcdlat = LCD_DATA_PORT+2 
....................    #word lcdtris = LCD_DATA_PORT-0x02 
.................... #endif 
.................... #endif   //LCD_DATA4 not defined 
....................  
.................... #ifndef LCD_TYPE 
....................    #define LCD_TYPE 2           // 0=5x7, 1=5x10, 2=2 lines 
.................... #endif 
....................  
.................... #ifndef LCD_LINE_TWO 
....................    #define LCD_LINE_TWO 0x40    // LCD RAM address for the second line 
.................... #endif 
....................  
.................... #ifndef LCD_LINE_LENGTH 
....................    #define LCD_LINE_LENGTH 20 
.................... #endif 
....................  
.................... unsigned int8 lcd_read_nibble(void); 
....................  
.................... unsigned int8 lcd_read_byte(void) 
.................... { 
....................    unsigned int8 low,high; 
....................  
....................  #if defined(__PCB__) 
....................    set_tris_lcd(LCD_INPUT_MAP); 
....................  #else 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    output_float(LCD_DATA4); 
*
01F6:  BSF    07.0
....................    output_float(LCD_DATA5); 
01F7:  BSF    07.1
....................    output_float(LCD_DATA6); 
01F8:  BSF    07.2
....................    output_float(LCD_DATA7); 
01F9:  BSF    07.3
....................   #else 
....................    lcdtris.data = 0xF; 
....................   #endif 
....................  #endif 
....................          
....................    lcd_output_rw(1); 
01FA:  BCF    03.5
01FB:  BSF    09.2
01FC:  BSF    03.5
01FD:  BCF    09.2
....................    delay_cycles(1); 
01FE:  NOP
....................    lcd_output_enable(1); 
01FF:  BCF    03.5
0200:  BSF    09.0
0201:  BSF    03.5
0202:  BCF    09.0
....................    delay_cycles(1); 
0203:  NOP
....................    high = lcd_read_nibble(); 
0204:  BCF    03.5
0205:  CALL   1AB
0206:  MOVF   78,W
0207:  BSF    03.6
0208:  MOVWF  3D
....................        
....................    lcd_output_enable(0); 
0209:  BCF    03.6
020A:  BCF    09.0
020B:  BSF    03.5
020C:  BCF    09.0
....................    delay_cycles(1); 
020D:  NOP
....................    lcd_output_enable(1); 
020E:  BCF    03.5
020F:  BSF    09.0
0210:  BSF    03.5
0211:  BCF    09.0
....................    delay_us(1); 
0212:  GOTO   213
0213:  GOTO   214
0214:  NOP
....................    low = lcd_read_nibble(); 
0215:  BCF    03.5
0216:  CALL   1AB
0217:  MOVF   78,W
0218:  BSF    03.6
0219:  MOVWF  3C
....................        
....................    lcd_output_enable(0); 
021A:  BCF    03.6
021B:  BCF    09.0
021C:  BSF    03.5
021D:  BCF    09.0
....................  
....................  #if defined(__PCB__) 
....................    set_tris_lcd(LCD_OUTPUT_MAP); 
....................  #else 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    output_drive(LCD_DATA4); 
021E:  BCF    03.5
021F:  BCF    31.0
0220:  MOVF   31,W
0221:  BSF    03.5
0222:  MOVWF  07
....................    output_drive(LCD_DATA5); 
0223:  BCF    03.5
0224:  BCF    31.1
0225:  MOVF   31,W
0226:  BSF    03.5
0227:  MOVWF  07
....................    output_drive(LCD_DATA6); 
0228:  BCF    03.5
0229:  BCF    31.2
022A:  MOVF   31,W
022B:  BSF    03.5
022C:  MOVWF  07
....................    output_drive(LCD_DATA7); 
022D:  BCF    03.5
022E:  BCF    31.3
022F:  MOVF   31,W
0230:  BSF    03.5
0231:  MOVWF  07
....................   #else 
....................    lcdtris.data = 0x0; 
....................   #endif 
....................  #endif 
....................  
....................    return( (high<<4) | low); 
0232:  BCF    03.5
0233:  BSF    03.6
0234:  SWAPF  3D,W
0235:  MOVWF  77
0236:  MOVLW  F0
0237:  ANDWF  77,F
0238:  MOVF   77,W
0239:  IORWF  3C,W
023A:  MOVWF  78
.................... } 
....................  
.................... unsigned int8 lcd_read_nibble(void) 
.................... { 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
*
01AB:  BSF    03.6
01AC:  CLRF   3E
....................    unsigned int8 n = 0x00; 
....................  
....................    /* Read the data port */ 
....................    n |= input(LCD_DATA4); 
01AD:  BCF    03.6
01AE:  BSF    31.0
01AF:  MOVF   31,W
01B0:  BSF    03.5
01B1:  MOVWF  07
01B2:  MOVLW  00
01B3:  BCF    03.5
01B4:  BTFSC  07.0
01B5:  MOVLW  01
01B6:  BSF    03.6
01B7:  IORWF  3E,F
....................    n |= input(LCD_DATA5) << 1; 
01B8:  BCF    03.6
01B9:  BSF    31.1
01BA:  MOVF   31,W
01BB:  BSF    03.5
01BC:  MOVWF  07
01BD:  MOVLW  00
01BE:  BCF    03.5
01BF:  BTFSC  07.1
01C0:  MOVLW  01
01C1:  MOVWF  77
01C2:  BCF    03.0
01C3:  RLF    77,F
01C4:  MOVF   77,W
01C5:  BSF    03.6
01C6:  IORWF  3E,F
....................    n |= input(LCD_DATA6) << 2; 
01C7:  BCF    03.6
01C8:  BSF    31.2
01C9:  MOVF   31,W
01CA:  BSF    03.5
01CB:  MOVWF  07
01CC:  MOVLW  00
01CD:  BCF    03.5
01CE:  BTFSC  07.2
01CF:  MOVLW  01
01D0:  MOVWF  77
01D1:  RLF    77,F
01D2:  RLF    77,F
01D3:  MOVLW  FC
01D4:  ANDWF  77,F
01D5:  MOVF   77,W
01D6:  BSF    03.6
01D7:  IORWF  3E,F
....................    n |= input(LCD_DATA7) << 3; 
01D8:  BCF    03.6
01D9:  BSF    31.3
01DA:  MOVF   31,W
01DB:  BSF    03.5
01DC:  MOVWF  07
01DD:  MOVLW  00
01DE:  BCF    03.5
01DF:  BTFSC  07.3
01E0:  MOVLW  01
01E1:  MOVWF  77
01E2:  RLF    77,F
01E3:  RLF    77,F
01E4:  RLF    77,F
01E5:  MOVLW  F8
01E6:  ANDWF  77,F
01E7:  MOVF   77,W
01E8:  BSF    03.6
01E9:  IORWF  3E,F
....................     
....................    return(n); 
01EA:  MOVF   3E,W
01EB:  MOVWF  78
....................   #else 
01EC:  BCF    03.6
01ED:  RETURN
....................    return(lcd.data); 
....................   #endif 
.................... } 
....................  
.................... void lcd_send_nibble(unsigned int8 n) 
.................... { 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    /* Write to the data port */ 
....................    output_bit(LCD_DATA4, bit_test(n, 0)); 
*
0163:  BSF    03.6
0164:  BTFSC  3D.0
0165:  GOTO   16A
0166:  BCF    03.6
0167:  BCF    07.0
0168:  GOTO   16C
0169:  BSF    03.6
016A:  BCF    03.6
016B:  BSF    07.0
016C:  BCF    31.0
016D:  MOVF   31,W
016E:  BSF    03.5
016F:  MOVWF  07
....................    output_bit(LCD_DATA5, bit_test(n, 1)); 
0170:  BCF    03.5
0171:  BSF    03.6
0172:  BTFSC  3D.1
0173:  GOTO   178
0174:  BCF    03.6
0175:  BCF    07.1
0176:  GOTO   17A
0177:  BSF    03.6
0178:  BCF    03.6
0179:  BSF    07.1
017A:  BCF    31.1
017B:  MOVF   31,W
017C:  BSF    03.5
017D:  MOVWF  07
....................    output_bit(LCD_DATA6, bit_test(n, 2)); 
017E:  BCF    03.5
017F:  BSF    03.6
0180:  BTFSC  3D.2
0181:  GOTO   186
0182:  BCF    03.6
0183:  BCF    07.2
0184:  GOTO   188
0185:  BSF    03.6
0186:  BCF    03.6
0187:  BSF    07.2
0188:  BCF    31.2
0189:  MOVF   31,W
018A:  BSF    03.5
018B:  MOVWF  07
....................    output_bit(LCD_DATA7, bit_test(n, 3)); 
018C:  BCF    03.5
018D:  BSF    03.6
018E:  BTFSC  3D.3
018F:  GOTO   194
0190:  BCF    03.6
0191:  BCF    07.3
0192:  GOTO   196
0193:  BSF    03.6
0194:  BCF    03.6
0195:  BSF    07.3
0196:  BCF    31.3
0197:  MOVF   31,W
0198:  BSF    03.5
0199:  MOVWF  07
....................   #else       
....................    lcdlat.data = n; 
....................   #endif 
....................        
....................    delay_cycles(1); 
019A:  NOP
....................    lcd_output_enable(1); 
019B:  BCF    03.5
019C:  BSF    09.0
019D:  BSF    03.5
019E:  BCF    09.0
....................    delay_us(2); 
019F:  MOVLW  02
01A0:  MOVWF  77
01A1:  DECFSZ 77,F
01A2:  GOTO   1A1
01A3:  GOTO   1A4
01A4:  NOP
....................    lcd_output_enable(0); 
01A5:  BCF    03.5
01A6:  BCF    09.0
01A7:  BSF    03.5
01A8:  BCF    09.0
01A9:  BCF    03.5
01AA:  RETURN
.................... } 
....................  
.................... void lcd_send_byte(unsigned int8 address, unsigned int8 n) 
.................... { 
....................   #if defined(__PCB__) 
....................    set_tris_lcd(LCD_OUTPUT_MAP); 
....................   #else 
....................    lcd_enable_tris(); 
*
01EE:  BSF    03.5
01EF:  BCF    09.0
....................    lcd_rs_tris(); 
01F0:  BCF    09.1
....................    lcd_rw_tris(); 
01F1:  BCF    09.2
....................   #endif 
....................  
....................    lcd_output_rs(0); 
01F2:  BCF    03.5
01F3:  BCF    09.1
01F4:  BSF    03.5
01F5:  BCF    09.1
....................    while ( bit_test(lcd_read_byte(),7) ) ; 
*
023B:  MOVF   78,W
023C:  MOVWF  3C
023D:  BTFSS  3C.7
023E:  GOTO   242
023F:  BSF    03.5
0240:  BCF    03.6
0241:  GOTO   1F6
....................    lcd_output_rs(address); 
0242:  MOVF   3A,F
0243:  BTFSS  03.2
0244:  GOTO   249
0245:  BCF    03.6
0246:  BCF    09.1
0247:  GOTO   24B
0248:  BSF    03.6
0249:  BCF    03.6
024A:  BSF    09.1
024B:  BSF    03.5
024C:  BCF    09.1
....................    delay_cycles(1); 
024D:  NOP
....................    lcd_output_rw(0); 
024E:  BCF    03.5
024F:  BCF    09.2
0250:  BSF    03.5
0251:  BCF    09.2
....................    delay_cycles(1); 
0252:  NOP
....................    lcd_output_enable(0); 
0253:  BCF    03.5
0254:  BCF    09.0
0255:  BSF    03.5
0256:  BCF    09.0
....................    lcd_send_nibble(n >> 4); 
0257:  BCF    03.5
0258:  BSF    03.6
0259:  SWAPF  3B,W
025A:  MOVWF  3C
025B:  MOVLW  0F
025C:  ANDWF  3C,F
025D:  MOVF   3C,W
025E:  MOVWF  3D
025F:  BCF    03.6
0260:  CALL   163
....................    lcd_send_nibble(n & 0xf); 
0261:  BSF    03.6
0262:  MOVF   3B,W
0263:  ANDLW  0F
0264:  MOVWF  3C
0265:  MOVWF  3D
0266:  BCF    03.6
0267:  CALL   163
0268:  RETURN
.................... } 
....................  
.................... #if defined(LCD_EXTENDED_NEWLINE) 
.................... unsigned int8 g_LcdX, g_LcdY; 
.................... #endif 
....................  
.................... void lcd_init(void)  
.................... { 
....................    unsigned int8 i; 
....................    unsigned int8 LCD_INIT_STRING[4] = {0x20 | (LCD_TYPE << 2), 0xc, 1, 6}; 
0269:  MOVLW  28
026A:  BSF    03.5
026B:  MOVWF  4E
026C:  MOVLW  0C
026D:  MOVWF  4F
026E:  MOVLW  01
026F:  MOVWF  50
0270:  MOVLW  06
0271:  MOVWF  51
....................                              // These bytes need to be sent to the LCD 
....................                              // to start it up. 
....................     
....................  
....................    lcd_output_enable(0); 
0272:  BCF    03.5
0273:  BCF    09.0
0274:  BSF    03.5
0275:  BCF    09.0
....................    lcd_output_rs(0); 
0276:  BCF    03.5
0277:  BCF    09.1
0278:  BSF    03.5
0279:  BCF    09.1
....................    lcd_output_rw(0); 
027A:  BCF    03.5
027B:  BCF    09.2
027C:  BSF    03.5
027D:  BCF    09.2
....................  
....................  #if defined(__PCB__) 
....................    set_tris_lcd(LCD_OUTPUT_MAP); 
....................  #else 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    output_drive(LCD_DATA4); 
027E:  BCF    03.5
027F:  BCF    31.0
0280:  MOVF   31,W
0281:  BSF    03.5
0282:  MOVWF  07
....................    output_drive(LCD_DATA5); 
0283:  BCF    03.5
0284:  BCF    31.1
0285:  MOVF   31,W
0286:  BSF    03.5
0287:  MOVWF  07
....................    output_drive(LCD_DATA6); 
0288:  BCF    03.5
0289:  BCF    31.2
028A:  MOVF   31,W
028B:  BSF    03.5
028C:  MOVWF  07
....................    output_drive(LCD_DATA7); 
028D:  BCF    03.5
028E:  BCF    31.3
028F:  MOVF   31,W
0290:  BSF    03.5
0291:  MOVWF  07
....................   #else 
....................    lcdtris.data = 0x0; 
....................   #endif 
....................    lcd_enable_tris(); 
0292:  BCF    09.0
....................    lcd_rs_tris(); 
0293:  BCF    09.1
....................    lcd_rw_tris(); 
0294:  BCF    09.2
....................  #endif 
....................      
....................    delay_ms(15); 
0295:  MOVLW  0F
0296:  BCF    03.5
0297:  BSF    03.6
0298:  MOVWF  36
0299:  BCF    03.6
029A:  CALL   14F
....................    for(i=1;i<=3;++i) 
029B:  MOVLW  01
029C:  BSF    03.5
029D:  MOVWF  4D
029E:  MOVF   4D,W
029F:  SUBLW  03
02A0:  BTFSS  03.0
02A1:  GOTO   2B0
....................    { 
....................        lcd_send_nibble(3); 
02A2:  MOVLW  03
02A3:  BCF    03.5
02A4:  BSF    03.6
02A5:  MOVWF  3D
02A6:  BCF    03.6
02A7:  CALL   163
....................        delay_ms(5); 
02A8:  MOVLW  05
02A9:  BSF    03.6
02AA:  MOVWF  36
02AB:  BCF    03.6
02AC:  CALL   14F
02AD:  BSF    03.5
02AE:  INCF   4D,F
02AF:  GOTO   29E
....................    } 
....................     
....................    lcd_send_nibble(2); 
02B0:  MOVLW  02
02B1:  BCF    03.5
02B2:  BSF    03.6
02B3:  MOVWF  3D
02B4:  BCF    03.6
02B5:  CALL   163
....................    delay_ms(5); 
02B6:  MOVLW  05
02B7:  BSF    03.6
02B8:  MOVWF  36
02B9:  BCF    03.6
02BA:  CALL   14F
....................    for(i=0;i<=3;++i) 
02BB:  BSF    03.5
02BC:  CLRF   4D
02BD:  MOVF   4D,W
02BE:  SUBLW  03
02BF:  BTFSS  03.0
02C0:  GOTO   2D5
....................       lcd_send_byte(0,LCD_INIT_STRING[i]); 
02C1:  MOVLW  CE
02C2:  ADDWF  4D,W
02C3:  MOVWF  04
02C4:  BCF    03.7
02C5:  MOVF   00,W
02C6:  MOVWF  52
02C7:  BCF    03.5
02C8:  BSF    03.6
02C9:  CLRF   3A
02CA:  BSF    03.5
02CB:  BCF    03.6
02CC:  MOVF   52,W
02CD:  BCF    03.5
02CE:  BSF    03.6
02CF:  MOVWF  3B
02D0:  BCF    03.6
02D1:  CALL   1EE
....................  
....................   #if defined(LCD_EXTENDED_NEWLINE) 
02D2:  BSF    03.5
02D3:  INCF   4D,F
02D4:  GOTO   2BD
02D5:  BCF    03.5
02D6:  BSF    0A.3
02D7:  BCF    0A.4
02D8:  GOTO   7BF (RETURN)
....................    g_LcdX = 0; 
....................    g_LcdY = 0; 
....................   #endif 
.................... } 
....................  
.................... void lcd_gotoxy(unsigned int8 x, unsigned int8 y) 
.................... { 
....................    unsigned int8 address; 
....................     
....................    if(y!=1) 
02D9:  BSF    03.6
02DA:  DECFSZ 37,W
02DB:  GOTO   2DD
02DC:  GOTO   2E0
....................       address=LCD_LINE_TWO; 
02DD:  MOVLW  40
02DE:  MOVWF  38
02DF:  GOTO   2E1
....................    else 
....................       address=0; 
02E0:  CLRF   38
....................       
....................    address+=x-1; 
02E1:  MOVLW  01
02E2:  SUBWF  36,W
02E3:  ADDWF  38,F
....................    lcd_send_byte(0,0x80|address); 
02E4:  MOVF   38,W
02E5:  IORLW  80
02E6:  MOVWF  39
02E7:  CLRF   3A
02E8:  MOVF   39,W
02E9:  MOVWF  3B
02EA:  BCF    03.6
02EB:  CALL   1EE
....................  
....................   #if defined(LCD_EXTENDED_NEWLINE) 
02EC:  RETURN
....................    g_LcdX = x - 1; 
....................    g_LcdY = y - 1; 
....................   #endif 
.................... } 
....................  
.................... void lcd_putc(char c) 
.................... { 
....................    switch (c) 
02ED:  BSF    03.6
02EE:  MOVF   35,W
02EF:  XORLW  07
02F0:  BCF    03.6
02F1:  BTFSC  03.2
02F2:  GOTO   2FD
02F3:  XORLW  0B
02F4:  BTFSC  03.2
02F5:  GOTO   304
02F6:  XORLW  06
02F7:  BTFSC  03.2
02F8:  GOTO   310
02F9:  XORLW  02
02FA:  BTFSC  03.2
02FB:  GOTO   318
02FC:  GOTO   31F
....................    { 
....................       case '\a'   :  lcd_gotoxy(1,1);     break; 
02FD:  MOVLW  01
02FE:  BSF    03.6
02FF:  MOVWF  36
0300:  MOVWF  37
0301:  BCF    03.6
0302:  CALL   2D9
0303:  GOTO   326
....................  
....................       case '\f'   :  lcd_send_byte(0,1); 
0304:  BSF    03.6
0305:  CLRF   3A
0306:  MOVLW  01
0307:  MOVWF  3B
0308:  BCF    03.6
0309:  CALL   1EE
....................                      delay_ms(2); 
030A:  MOVLW  02
030B:  BSF    03.6
030C:  MOVWF  36
030D:  BCF    03.6
030E:  CALL   14F
....................                     #if defined(LCD_EXTENDED_NEWLINE) 
....................                      g_LcdX = 0; 
....................                      g_LcdY = 0; 
....................                     #endif 
....................                      break; 
030F:  GOTO   326
....................  
....................      #if defined(LCD_EXTENDED_NEWLINE) 
....................       case '\r'   :  lcd_gotoxy(1, g_LcdY+1);   break; 
....................       case '\n'   : 
....................          while (g_LcdX++ < LCD_LINE_LENGTH) 
....................          { 
....................             lcd_send_byte(1, ' '); 
....................          } 
....................          lcd_gotoxy(1, g_LcdY+2); 
....................          break; 
....................      #else 
....................       case '\n'   : lcd_gotoxy(1,2);        break; 
0310:  MOVLW  01
0311:  BSF    03.6
0312:  MOVWF  36
0313:  MOVLW  02
0314:  MOVWF  37
0315:  BCF    03.6
0316:  CALL   2D9
0317:  GOTO   326
....................      #endif 
....................       
....................       case '\b'   : lcd_send_byte(0,0x10);  break; 
0318:  BSF    03.6
0319:  CLRF   3A
031A:  MOVLW  10
031B:  MOVWF  3B
031C:  BCF    03.6
031D:  CALL   1EE
031E:  GOTO   326
....................       
....................      #if defined(LCD_EXTENDED_NEWLINE) 
....................       default     :  
....................          if (g_LcdX < LCD_LINE_LENGTH) 
....................          { 
....................             lcd_send_byte(1, c); 
....................             g_LcdX++; 
....................          } 
....................          break; 
....................      #else 
....................       default     : lcd_send_byte(1,c);     break; 
031F:  MOVLW  01
0320:  BSF    03.6
0321:  MOVWF  3A
0322:  MOVF   35,W
0323:  MOVWF  3B
0324:  BCF    03.6
0325:  CALL   1EE
....................      #endif 
....................    } 
0326:  RETURN
.................... } 
....................   
.................... char lcd_getc(unsigned int8 x, unsigned int8 y) 
.................... { 
....................    char value; 
....................  
....................    lcd_gotoxy(x,y); 
....................    while ( bit_test(lcd_read_byte(),7) ); // wait until busy flag is low 
....................    lcd_output_rs(1); 
....................    value = lcd_read_byte(); 
....................    lcd_output_rs(0); 
....................     
....................    return(value); 
.................... } 
....................  
.................... // write a custom character to the ram 
.................... // which is 0-7 and specifies which character array we are modifying. 
.................... // ptr points to an array of 8 bytes, where each byte is the next row of 
.................... //    pixels.  only bits 0-4 are used.  the last row is the cursor row, and 
.................... //    usually you will want to leave this byte 0x00. 
.................... void lcd_set_cgram_char(unsigned int8 which, unsigned int8 *ptr) 
.................... { 
....................    unsigned int i; 
....................  
....................    which <<= 3; 
....................    which &= 0x38; 
....................  
....................    lcd_send_byte(0, 0x40 | which);  //set cgram address 
....................  
....................    for(i=0; i<8; i++) 
....................    { 
....................       lcd_send_byte(1, *ptr++); 
....................    } 
....................    
....................    #if defined(LCD_EXTENDED_NEWLINE) 
....................     lcd_gotoxy(g_LcdX+1, g_LcdY+1);  //set ddram address 
....................    #endif 
.................... } 
....................  
.................... void lcd_cursor_on(int1 on) 
.................... { 
....................    if (on) 
....................    { 
....................       lcd_send_byte(0,0x0F);           //turn LCD cursor ON 
....................    } 
....................    else 
....................    { 
....................       lcd_send_byte(0,0x0C);           //turn LCD cursor OFF 
....................    } 
.................... } 
....................  
.................... #endif 
....................  
.................... #BIT TMR1IF = 0x0C.0 //bit thu 0 (TMR1IF) cua PIR1 
....................  
.................... #INCLUDE <khaibaobien.c> // VARIABLE. 
.................... UNSIGNED INT16 KQADC,AN0, AN1; 
.................... UNSIGNED INT8 CONFIG_FUN=0; 
.................... UNSIGNED INT8 VT=0, KYTU=0;// KYTU[30],  
.................... UNSIGNED INT8 ID_DEVICE_NHAN,TT_DEVICE_NHAN; 
.................... UNSIGNED INT8 ID_GATEWAY[6] = {0,6,3,2,3,3}; 
*
0F2F:  CLRF   3D
0F30:  MOVLW  06
0F31:  MOVWF  3E
0F32:  MOVLW  03
0F33:  MOVWF  3F
0F34:  MOVLW  02
0F35:  MOVWF  40
0F36:  MOVLW  03
0F37:  MOVWF  41
0F38:  MOVWF  42
.................... UNSIGNED INT8 ID_NODE[4] = {7,4,5,8}; 
0F39:  MOVLW  07
0F3A:  MOVWF  43
0F3B:  MOVLW  04
0F3C:  MOVWF  44
0F3D:  MOVLW  05
0F3E:  MOVWF  45
0F3F:  MOVLW  08
0F40:  MOVWF  46
.................... UNSIGNED INT8 LEN_PACKAGES = 0; 
.................... UNSIGNED INT8 LENHDIEUKHIEN =0, DODAI_DATA_NHAN =0; 
.................... UNSIGNED INT8 SOLUONGTHIETBI_CONFIG=0, SOLUONGCAMBIEN_CONFIG = 0; 
.................... SIGNED INT8 SOSANH_IDNODE=0, SOSANH_IDGW=0; 
....................  
.................... INT1 TTNHAN = 0, TT_CONFIG=0, TT_CONTROL=0,TT_CONFIG_DONE=0, TT_FUN=0, TT_STT=0; 
....................  
.................... CHAR *ID_NODE_CHAR[]= "0589"; 
0F41:  MOVLW  30
0F42:  MOVWF  51
0F43:  MOVLW  35
0F44:  MOVWF  52
0F45:  MOVLW  38
0F46:  MOVWF  53
0F47:  MOVLW  39
0F48:  MOVWF  54
0F49:  CLRF   55
0F4A:  CLRF   50
0F4B:  MOVLW  51
0F4C:  MOVWF  4F
.................... CHAR *ID_GATEWAY_CHAR[]= "127102"; 
0F4D:  MOVLW  31
0F4E:  MOVWF  58
0F4F:  MOVLW  32
0F50:  MOVWF  59
0F51:  MOVLW  37
0F52:  MOVWF  5A
0F53:  MOVLW  31
0F54:  MOVWF  5B
0F55:  MOVLW  30
0F56:  MOVWF  5C
0F57:  MOVLW  32
0F58:  MOVWF  5D
0F59:  CLRF   5E
0F5A:  CLRF   57
0F5B:  MOVLW  58
0F5C:  MOVWF  56
.................... CHAR *ID_NODE_NHAN[]= "0000"; 
0F5D:  MOVLW  30
0F5E:  MOVWF  61
0F5F:  MOVWF  62
0F60:  MOVWF  63
0F61:  MOVWF  64
0F62:  CLRF   65
0F63:  CLRF   60
0F64:  MOVLW  61
0F65:  MOVWF  5F
.................... CHAR *ID_GW_NHAN[]= "000000"; 
0F66:  MOVLW  30
0F67:  MOVWF  68
0F68:  MOVWF  69
0F69:  MOVWF  6A
0F6A:  MOVWF  6B
0F6B:  MOVWF  6C
0F6C:  MOVWF  6D
0F6D:  CLRF   6E
0F6E:  CLRF   67
0F6F:  MOVLW  68
0F70:  MOVWF  66
.................... CHAR KYTUCHAR[30]="HIHI"; 
0F71:  MOVLW  48
0F72:  BSF    03.5
0F73:  MOVWF  20
0F74:  MOVLW  49
0F75:  MOVWF  21
0F76:  MOVLW  48
0F77:  MOVWF  22
0F78:  MOVLW  49
0F79:  MOVWF  23
0F7A:  CLRF   24
.................... CHAR KYTUCHAR2[15]="HIHI"; 
0F7B:  MOVLW  48
0F7C:  MOVWF  3E
0F7D:  MOVLW  49
0F7E:  MOVWF  3F
0F7F:  MOVLW  48
0F80:  MOVWF  40
0F81:  MOVLW  49
0F82:  MOVWF  41
0F83:  CLRF   42
.................... //CHAR *DATA_NHANDUOC[]={"IDGW","IDNODE","COMMAN","DATA"}; 
.................... CHAR *TEMP_CHAR[]="00";   
0F84:  MOVLW  30
0F85:  MOVWF  71
0F86:  MOVWF  72
0F87:  CLRF   73
0F88:  CLRF   70
0F89:  MOVLW  71
0F8A:  BCF    03.5
0F8B:  MOVWF  6F
.................... //CHAR *TEMP_CHAR3[]="000000";  
....................  
....................  
....................  
.................... //#INCLUDE <CONFIG_NODE.C> // CU HINH NODE. 
.................... #INCLUDE <config_1.C> // CU HINH NODE. 
....................  
.................... //--------------------------------------------------------------------// 
.................... VOID CHON_ID() 
.................... { 
....................    // TT_CONFIG_DONE; 
....................    TT_CONFIG_DONE = 0; 
*
05C6:  BCF    4E.3
....................    TT_STT = 1; 
05C7:  BSF    4E.5
....................    UNSIGNED INT8 NUM = 0; 
05C8:  BSF    03.5
05C9:  CLRF   4D
....................    TEMP_CHAR = "0"; 
05CA:  CLRF   4E
05CB:  CLRF   4F
05CC:  MOVLW  6F
05CD:  MOVWF  04
05CE:  BCF    03.7
05CF:  MOVF   4E,W
05D0:  ADDWF  04,F
05D1:  MOVF   4F,W
05D2:  BCF    03.5
05D3:  CALL   058
05D4:  MOVWF  00
05D5:  IORLW  00
05D6:  BTFSC  03.2
05D7:  GOTO   5DD
05D8:  BSF    03.5
05D9:  INCF   4F,F
05DA:  INCF   4E,F
05DB:  GOTO   5CC
05DC:  BCF    03.5
....................    LCD_GOTOXY (1, 2) ; 
05DD:  MOVLW  01
05DE:  BSF    03.6
05DF:  MOVWF  36
05E0:  MOVLW  02
05E1:  MOVWF  37
05E2:  BCF    03.6
05E3:  CALL   2D9
....................    DELAY_MS (10); 
05E4:  MOVLW  0A
05E5:  BSF    03.6
05E6:  MOVWF  36
05E7:  BCF    03.6
05E8:  CALL   14F
....................    PRINTF (LCD_PUTC, "NODE: "); 
05E9:  MOVLW  6F
05EA:  BSF    03.6
05EB:  MOVWF  0D
05EC:  MOVLW  00
05ED:  MOVWF  0F
05EE:  BCF    03.6
05EF:  CALL   327
....................    PRINTF (LCD_PUTC, "0000          "); 
05F0:  MOVLW  73
05F1:  BSF    03.6
05F2:  MOVWF  0D
05F3:  MOVLW  00
05F4:  MOVWF  0F
05F5:  BCF    03.6
05F6:  CALL   327
....................    LCD_GOTOXY (1, 1) ; 
05F7:  MOVLW  01
05F8:  BSF    03.6
05F9:  MOVWF  36
05FA:  MOVWF  37
05FB:  BCF    03.6
05FC:  CALL   2D9
....................    PRINTF (LCD_PUTC, "      _              ");//6 SPACE PHIA TRUOC "_" 
05FD:  MOVLW  7B
05FE:  BSF    03.6
05FF:  MOVWF  0D
0600:  MOVLW  00
0601:  MOVWF  0F
0602:  BCF    03.6
0603:  CALL   327
....................    //ID_GW = "1234";     
....................  
....................    WHILE (TT_STT) 
0604:  BTFSS  4E.5
0605:  GOTO   690
....................    { 
....................       IF (!INPUT (BT2_PIN)) //NEU NUT BAM DUOC BAM 
0606:  BSF    03.5
0607:  BSF    06.2
0608:  BCF    03.5
0609:  BTFSC  06.2
060A:  GOTO   62D
....................       { 
....................           
....................          NUM++; 
060B:  BSF    03.5
060C:  INCF   4D,F
....................          NUM = NUM % 4; 
060D:  MOVLW  03
060E:  ANDWF  4D,F
....................          LCD_GOTOXY (3 + NUM, 1); 
060F:  ADDWF  4D,W
0610:  MOVWF  4E
0611:  BCF    03.5
0612:  BSF    03.6
0613:  MOVWF  36
0614:  MOVLW  01
0615:  MOVWF  37
0616:  BCF    03.6
0617:  CALL   2D9
....................          PRINTF (LCD_PUTC, "    _    ");//4SPACE 
0618:  MOVLW  86
0619:  BSF    03.6
061A:  MOVWF  0D
061B:  MOVLW  00
061C:  MOVWF  0F
061D:  BCF    03.6
061E:  CALL   327
....................          DELAY_MS (300);  
061F:  MOVLW  02
0620:  BSF    03.5
0621:  MOVWF  4E
0622:  MOVLW  96
0623:  BCF    03.5
0624:  BSF    03.6
0625:  MOVWF  36
0626:  BCF    03.6
0627:  CALL   14F
0628:  BSF    03.5
0629:  DECFSZ 4E,F
062A:  GOTO   622
....................       } 
062B:  GOTO   68E
062C:  BCF    03.5
....................  
....................       ELSE IF (!INPUT (BT3_PIN)) 
062D:  BSF    03.5
062E:  BSF    06.3
062F:  BCF    03.5
0630:  BTFSC  06.3
0631:  GOTO   68F
....................       { 
....................          ID_NODE[NUM]++; 
0632:  MOVLW  43
0633:  BSF    03.5
0634:  ADDWF  4D,W
0635:  MOVWF  04
0636:  BCF    03.7
0637:  INCF   00,F
....................          ID_NODE[NUM] = ID_NODE[NUM] % 10; 
0638:  MOVLW  43
0639:  ADDWF  4D,W
063A:  MOVWF  78
063B:  CLRF   7A
063C:  BTFSC  03.0
063D:  INCF   7A,F
063E:  MOVF   78,W
063F:  MOVWF  4E
0640:  MOVF   7A,W
0641:  MOVWF  4F
0642:  MOVLW  43
0643:  ADDWF  4D,W
0644:  MOVWF  04
0645:  BCF    03.7
0646:  MOVF   00,W
0647:  MOVWF  51
0648:  MOVLW  0A
0649:  MOVWF  52
064A:  BCF    03.5
064B:  CALL   532
064C:  MOVF   77,W
064D:  BSF    03.5
064E:  MOVWF  50
064F:  MOVF   4E,W
0650:  MOVWF  04
0651:  BCF    03.7
0652:  BTFSC  4F.0
0653:  BSF    03.7
0654:  MOVF   50,W
0655:  MOVWF  00
....................          ITOA (ID_NODE[NUM], 10, TEMP_CHAR); 
0656:  MOVLW  43
0657:  ADDWF  4D,W
0658:  MOVWF  04
0659:  BCF    03.7
065A:  MOVF   00,W
065B:  MOVWF  4E
065C:  BCF    03.5
065D:  BSF    03.6
065E:  CLRF   37
065F:  CLRF   36
0660:  CLRF   35
0661:  BSF    03.5
0662:  BCF    03.6
0663:  MOVF   4E,W
0664:  BCF    03.5
0665:  BSF    03.6
0666:  MOVWF  34
0667:  MOVLW  0A
0668:  MOVWF  38
0669:  CLRF   3A
066A:  MOVLW  6F
066B:  MOVWF  39
066C:  BCF    03.6
066D:  CALL   3F3
....................          LCD_GOTOXY (7 + NUM, 2); 
066E:  MOVLW  07
066F:  BSF    03.5
0670:  ADDWF  4D,W
0671:  MOVWF  4E
0672:  BCF    03.5
0673:  BSF    03.6
0674:  MOVWF  36
0675:  MOVLW  02
0676:  MOVWF  37
0677:  BCF    03.6
0678:  CALL   2D9
....................          DELAY_MS (10); 
0679:  MOVLW  0A
067A:  BSF    03.6
067B:  MOVWF  36
067C:  BCF    03.6
067D:  CALL   14F
....................          PRINTF (LCD_PUTC, TEMP_CHAR); 
067E:  MOVLW  6F
067F:  MOVWF  04
0680:  BCF    03.7
0681:  CALL   513
....................          DELAY_MS (300); 
0682:  MOVLW  02
0683:  BSF    03.5
0684:  MOVWF  4E
0685:  MOVLW  96
0686:  BCF    03.5
0687:  BSF    03.6
0688:  MOVWF  36
0689:  BCF    03.6
068A:  CALL   14F
068B:  BSF    03.5
068C:  DECFSZ 4E,F
068D:  GOTO   685
068E:  BCF    03.5
....................       } 
068F:  GOTO   604
....................    } 
.................... } 
....................  
.................... VOID NHAPID_GW() 
*
0691:  BSF    03.5
0692:  CLRF   4D
.................... { 
....................    UNSIGNED INT8 NUM = 0; 
....................    TEMP_CHAR = "0"; 
0693:  CLRF   4E
0694:  CLRF   4F
0695:  MOVLW  6F
0696:  MOVWF  04
0697:  BCF    03.7
0698:  MOVF   4E,W
0699:  ADDWF  04,F
069A:  MOVF   4F,W
069B:  BCF    03.5
069C:  CALL   058
069D:  MOVWF  00
069E:  IORLW  00
069F:  BTFSC  03.2
06A0:  GOTO   6A6
06A1:  BSF    03.5
06A2:  INCF   4F,F
06A3:  INCF   4E,F
06A4:  GOTO   695
06A5:  BCF    03.5
....................    TT_CONFIG_DONE = 0; 
06A6:  BCF    4E.3
....................    TT_STT = 1; 
06A7:  BSF    4E.5
....................    LCD_GOTOXY (1, 2) ; 
06A8:  MOVLW  01
06A9:  BSF    03.6
06AA:  MOVWF  36
06AB:  MOVLW  02
06AC:  MOVWF  37
06AD:  BCF    03.6
06AE:  CALL   2D9
....................    DELAY_MS (10); 
06AF:  MOVLW  0A
06B0:  BSF    03.6
06B1:  MOVWF  36
06B2:  BCF    03.6
06B3:  CALL   14F
....................    PRINTF (LCD_PUTC, "ID_GW:"); 
06B4:  MOVLW  8B
06B5:  BSF    03.6
06B6:  MOVWF  0D
06B7:  MOVLW  00
06B8:  MOVWF  0F
06B9:  BCF    03.6
06BA:  CALL   327
....................    PRINTF (LCD_PUTC, "000000        "); 
06BB:  MOVLW  8F
06BC:  BSF    03.6
06BD:  MOVWF  0D
06BE:  MOVLW  00
06BF:  MOVWF  0F
06C0:  BCF    03.6
06C1:  CALL   327
....................    LCD_GOTOXY (1, 1) ; 
06C2:  MOVLW  01
06C3:  BSF    03.6
06C4:  MOVWF  36
06C5:  MOVWF  37
06C6:  BCF    03.6
06C7:  CALL   2D9
....................    PRINTF (LCD_PUTC, "      _                ");//6 SPACE PHIA TRUOC "_" 
06C8:  MOVLW  97
06C9:  BSF    03.6
06CA:  MOVWF  0D
06CB:  MOVLW  00
06CC:  MOVWF  0F
06CD:  BCF    03.6
06CE:  CALL   327
....................    //ID_GW = "1234";     
....................  
....................    WHILE (TT_STT) 
06CF:  BTFSS  4E.5
06D0:  GOTO   763
....................    { 
....................       IF (!INPUT (BT2_PIN)) //NEU NUT BAM DUOC BAM 
06D1:  BSF    03.5
06D2:  BSF    06.2
06D3:  BCF    03.5
06D4:  BTFSC  06.2
06D5:  GOTO   700
....................       { 
....................           
....................          NUM++; 
06D6:  BSF    03.5
06D7:  INCF   4D,F
....................          NUM = NUM % 6; 
06D8:  MOVF   4D,W
06D9:  MOVWF  51
06DA:  MOVLW  06
06DB:  MOVWF  52
06DC:  BCF    03.5
06DD:  CALL   532
06DE:  MOVF   77,W
06DF:  BSF    03.5
06E0:  MOVWF  4D
....................          LCD_GOTOXY (3 + NUM, 1); 
06E1:  MOVLW  03
06E2:  ADDWF  4D,W
06E3:  MOVWF  4E
06E4:  BCF    03.5
06E5:  BSF    03.6
06E6:  MOVWF  36
06E7:  MOVLW  01
06E8:  MOVWF  37
06E9:  BCF    03.6
06EA:  CALL   2D9
....................          PRINTF (LCD_PUTC, "    _        ");//4SPACE 
06EB:  MOVLW  A3
06EC:  BSF    03.6
06ED:  MOVWF  0D
06EE:  MOVLW  00
06EF:  MOVWF  0F
06F0:  BCF    03.6
06F1:  CALL   327
....................          DELAY_MS (300);  
06F2:  MOVLW  02
06F3:  BSF    03.5
06F4:  MOVWF  4E
06F5:  MOVLW  96
06F6:  BCF    03.5
06F7:  BSF    03.6
06F8:  MOVWF  36
06F9:  BCF    03.6
06FA:  CALL   14F
06FB:  BSF    03.5
06FC:  DECFSZ 4E,F
06FD:  GOTO   6F5
....................       } 
06FE:  GOTO   761
06FF:  BCF    03.5
....................  
....................       ELSE IF (!INPUT (BT3_PIN)) 
0700:  BSF    03.5
0701:  BSF    06.3
0702:  BCF    03.5
0703:  BTFSC  06.3
0704:  GOTO   762
....................       { 
....................          ID_GATEWAY[NUM]++; 
0705:  MOVLW  3D
0706:  BSF    03.5
0707:  ADDWF  4D,W
0708:  MOVWF  04
0709:  BCF    03.7
070A:  INCF   00,F
....................          ID_GATEWAY[NUM] = ID_GATEWAY[NUM] % 10; 
070B:  MOVLW  3D
070C:  ADDWF  4D,W
070D:  MOVWF  78
070E:  CLRF   7A
070F:  BTFSC  03.0
0710:  INCF   7A,F
0711:  MOVF   78,W
0712:  MOVWF  4E
0713:  MOVF   7A,W
0714:  MOVWF  4F
0715:  MOVLW  3D
0716:  ADDWF  4D,W
0717:  MOVWF  04
0718:  BCF    03.7
0719:  MOVF   00,W
071A:  MOVWF  51
071B:  MOVLW  0A
071C:  MOVWF  52
071D:  BCF    03.5
071E:  CALL   532
071F:  MOVF   77,W
0720:  BSF    03.5
0721:  MOVWF  50
0722:  MOVF   4E,W
0723:  MOVWF  04
0724:  BCF    03.7
0725:  BTFSC  4F.0
0726:  BSF    03.7
0727:  MOVF   50,W
0728:  MOVWF  00
....................          ITOA (ID_GATEWAY[NUM], 10, TEMP_CHAR); 
0729:  MOVLW  3D
072A:  ADDWF  4D,W
072B:  MOVWF  04
072C:  BCF    03.7
072D:  MOVF   00,W
072E:  MOVWF  4E
072F:  BCF    03.5
0730:  BSF    03.6
0731:  CLRF   37
0732:  CLRF   36
0733:  CLRF   35
0734:  BSF    03.5
0735:  BCF    03.6
0736:  MOVF   4E,W
0737:  BCF    03.5
0738:  BSF    03.6
0739:  MOVWF  34
073A:  MOVLW  0A
073B:  MOVWF  38
073C:  CLRF   3A
073D:  MOVLW  6F
073E:  MOVWF  39
073F:  BCF    03.6
0740:  CALL   3F3
....................          LCD_GOTOXY (7 + NUM, 2); 
0741:  MOVLW  07
0742:  BSF    03.5
0743:  ADDWF  4D,W
0744:  MOVWF  4E
0745:  BCF    03.5
0746:  BSF    03.6
0747:  MOVWF  36
0748:  MOVLW  02
0749:  MOVWF  37
074A:  BCF    03.6
074B:  CALL   2D9
....................          DELAY_MS (10); 
074C:  MOVLW  0A
074D:  BSF    03.6
074E:  MOVWF  36
074F:  BCF    03.6
0750:  CALL   14F
....................          PRINTF (LCD_PUTC, TEMP_CHAR); 
0751:  MOVLW  6F
0752:  MOVWF  04
0753:  BCF    03.7
0754:  CALL   513
....................          DELAY_MS (300); 
0755:  MOVLW  02
0756:  BSF    03.5
0757:  MOVWF  4E
0758:  MOVLW  96
0759:  BCF    03.5
075A:  BSF    03.6
075B:  MOVWF  36
075C:  BCF    03.6
075D:  CALL   14F
075E:  BSF    03.5
075F:  DECFSZ 4E,F
0760:  GOTO   758
0761:  BCF    03.5
....................       } 
0762:  GOTO   6CF
....................    } 
.................... } 
....................  
.................... VOID BUTT_OKE() 
.................... { 
....................    TT_CONFIG_DONE = 0; 
*
0118:  BCF    03.6
0119:  BCF    4E.3
....................    TT_FUN = 0;//BREAK WHILE BUTT_FUN 
011A:  BCF    4E.4
....................    TT_STT = 0;// BREAK WHILE CHONID/NHAPID_GW 
011B:  BCF    4E.5
.................... } 
....................  
.................... VOID SELLECT_FUN() 
.................... { 
....................    TT_CONFIG_DONE = 0; 
*
05BE:  BCF    4E.3
....................  
....................    SWITCH (CONFIG_FUN) 
05BF:  MOVF   38,W
05C0:  BTFSC  03.2
05C1:  GOTO   5C6
05C2:  XORLW  01
05C3:  BTFSC  03.2
05C4:  GOTO   691
05C5:  GOTO   763
....................    { 
....................       CASE 0: 
....................       CHON_ID (); 
....................       BREAK; 
*
0690:  GOTO   763
....................  
....................       CASE 1:     
....................       NHAPID_GW (); 
....................       BREAK; 
....................    } 
.................... } 
....................  
.................... VOID BUTT_FUN() 
.................... { 
....................    TT_FUN = 1; 
*
0549:  BSF    4E.4
....................    LCD_GOTOXY (1, 1) ; 
054A:  MOVLW  01
054B:  BSF    03.6
054C:  MOVWF  36
054D:  MOVWF  37
054E:  BCF    03.6
054F:  CALL   2D9
....................    DELAY_MS (10); 
0550:  MOVLW  0A
0551:  BSF    03.6
0552:  MOVWF  36
0553:  BCF    03.6
0554:  CALL   14F
....................    PRINTF (LCD_PUTC, "CONFIG:        "); 
0555:  MOVLW  AA
0556:  BSF    03.6
0557:  MOVWF  0D
0558:  MOVLW  00
0559:  MOVWF  0F
055A:  BCF    03.6
055B:  CALL   327
....................  
....................    // HIEN THI LCD 
....................    LCD_GOTOXY (1, 2) ; 
055C:  MOVLW  01
055D:  BSF    03.6
055E:  MOVWF  36
055F:  MOVLW  02
0560:  MOVWF  37
0561:  BCF    03.6
0562:  CALL   2D9
....................    DELAY_MS (10); 
0563:  MOVLW  0A
0564:  BSF    03.6
0565:  MOVWF  36
0566:  BCF    03.6
0567:  CALL   14F
....................    PRINTF (LCD_PUTC, "CASE:          ") ; 
0568:  MOVLW  B2
0569:  BSF    03.6
056A:  MOVWF  0D
056B:  MOVLW  00
056C:  MOVWF  0F
056D:  BCF    03.6
056E:  CALL   327
....................  
....................    WHILE (TT_FUN) 
056F:  BTFSS  4E.4
0570:  GOTO   5BC
....................    { 
....................       IF (INPUT (BT2_PIN) == 0) //NEU NUT BAM DUOC BAM 
0571:  BSF    03.5
0572:  BSF    06.2
0573:  BCF    03.5
0574:  BTFSC  06.2
0575:  GOTO   5BB
....................       { 
....................          CONFIG_FUN ++; 
0576:  INCF   38,F
....................          CONFIG_FUN = CONFIG_FUN % 2; 
0577:  MOVLW  01
0578:  ANDWF  38,F
....................          DELAY_MS (300); 
0579:  MOVLW  02
057A:  BSF    03.5
057B:  MOVWF  4D
057C:  MOVLW  96
057D:  BCF    03.5
057E:  BSF    03.6
057F:  MOVWF  36
0580:  BCF    03.6
0581:  CALL   14F
0582:  BSF    03.5
0583:  DECFSZ 4D,F
0584:  GOTO   57C
....................          //HIEN THI 
....................          LCD_GOTOXY (6, 2) ; 
0585:  MOVLW  06
0586:  BCF    03.5
0587:  BSF    03.6
0588:  MOVWF  36
0589:  MOVLW  02
058A:  MOVWF  37
058B:  BCF    03.6
058C:  CALL   2D9
....................          ITOA (CONFIG_FUN, 10, TEMP_CHAR); 
058D:  BSF    03.6
058E:  CLRF   37
058F:  CLRF   36
0590:  CLRF   35
0591:  BCF    03.6
0592:  MOVF   38,W
0593:  BSF    03.6
0594:  MOVWF  34
0595:  MOVLW  0A
0596:  MOVWF  38
0597:  CLRF   3A
0598:  MOVLW  6F
0599:  MOVWF  39
059A:  BCF    03.6
059B:  CALL   3F3
....................          DELAY_MS (10); 
059C:  MOVLW  0A
059D:  BSF    03.6
059E:  MOVWF  36
059F:  BCF    03.6
05A0:  CALL   14F
....................          PRINTF (LCD_PUTC, TEMP_CHAR); 
05A1:  MOVLW  6F
05A2:  MOVWF  04
05A3:  BCF    03.7
05A4:  CALL   513
....................  
....................          SWITCH (CONFIG_FUN) 
05A5:  MOVF   38,W
05A6:  BTFSC  03.2
05A7:  GOTO   5AC
05A8:  XORLW  01
05A9:  BTFSC  03.2
05AA:  GOTO   5B4
05AB:  GOTO   5BB
....................          { 
....................             CASE 0: 
....................             PRINTF (LCD_PUTC, " - ID-NODE      "); 
05AC:  MOVLW  BA
05AD:  BSF    03.6
05AE:  MOVWF  0D
05AF:  MOVLW  00
05B0:  MOVWF  0F
05B1:  BCF    03.6
05B2:  CALL   327
....................             BREAK; 
05B3:  GOTO   5BB
....................  
....................             CASE 1: 
....................             PRINTF (LCD_PUTC, " - ID-GW       "); 
05B4:  MOVLW  C3
05B5:  BSF    03.6
05B6:  MOVWF  0D
05B7:  MOVLW  00
05B8:  MOVWF  0F
05B9:  BCF    03.6
05BA:  CALL   327
....................             BREAK;             
....................          } 
....................       } 
05BB:  GOTO   56F
....................    } 
....................  
....................    ////// 
....................    IF (!TT_CONFIG_DONE) 
05BC:  BTFSC  4E.3
05BD:  GOTO   763
....................    { 
....................       SELLECT_FUN (); 
....................    } 
*
0763:  BSF    0A.3
0764:  BCF    0A.4
0765:  GOTO   7CC (RETURN)
.................... } 
.................... VOID XULY_IDNODE_NHAP(){ 
....................    //*TEMP_CHAR3 = "\0"; 
....................    *ID_NODE_CHAR = "\0"; 
*
0899:  CLRF   7A
089A:  MOVLW  4F
089B:  BCF    03.5
089C:  BSF    03.6
089D:  MOVWF  33
089E:  MOVF   7A,W
089F:  MOVWF  34
08A0:  MOVF   33,W
08A1:  MOVWF  04
08A2:  BCF    03.7
08A3:  BTFSC  34.0
08A4:  BSF    03.7
08A5:  CLRF   00
....................    FOR (int j = 0; j < 4; j++) 
08A6:  CLRF   32
08A7:  MOVF   32,W
08A8:  SUBLW  03
08A9:  BTFSS  03.0
08AA:  GOTO   0D4
....................    { 
....................       ITOA (ID_NODE[j], 10, TEMP_CHAR); 
08AB:  MOVLW  43
08AC:  ADDWF  32,W
08AD:  MOVWF  04
08AE:  BCF    03.7
08AF:  MOVF   00,W
08B0:  MOVWF  33
08B1:  CLRF   37
08B2:  CLRF   36
08B3:  CLRF   35
08B4:  MOVF   33,W
08B5:  MOVWF  34
08B6:  MOVLW  0A
08B7:  MOVWF  38
08B8:  CLRF   3A
08B9:  MOVLW  6F
08BA:  MOVWF  39
08BB:  BCF    0A.3
08BC:  BCF    03.6
08BD:  CALL   3F3
08BE:  BSF    0A.3
....................       DELAY_MS (1); 
08BF:  MOVLW  01
08C0:  BSF    03.6
08C1:  MOVWF  36
08C2:  BCF    0A.3
08C3:  BCF    03.6
08C4:  CALL   14F
08C5:  BSF    0A.3
....................       STRCAT (ID_NODE_CHAR, TEMP_CHAR); 
08C6:  BSF    03.6
08C7:  CLRF   34
08C8:  MOVLW  4F
08C9:  MOVWF  33
08CA:  CLRF   36
08CB:  MOVLW  6F
08CC:  MOVWF  35
08CD:  BCF    0A.3
08CE:  BCF    03.6
08CF:  CALL   766
08D0:  BSF    0A.3
08D1:  BSF    03.6
08D2:  INCF   32,F
08D3:  GOTO   0A7
....................    }   
....................    //ID_NODE_CHAR = TEMP_CHAR3;    
....................    //STRCPY(ID_NODE_CHAR,TEMP_CHAR3); 
....................    //strcpy 
.................... } 
.................... VOID XULY_IDGW_NHAP(){ 
....................  
....................    *ID_GATEWAY_CHAR = "\0"; 
*
0859:  CLRF   7A
085A:  MOVLW  56
085B:  BCF    03.5
085C:  BSF    03.6
085D:  MOVWF  33
085E:  MOVF   7A,W
085F:  MOVWF  34
0860:  MOVF   33,W
0861:  MOVWF  04
0862:  BCF    03.7
0863:  BTFSC  34.0
0864:  BSF    03.7
0865:  CLRF   00
....................    FOR (int j = 0; j < 6; j++) 
0866:  CLRF   32
0867:  MOVF   32,W
0868:  SUBLW  05
0869:  BTFSS  03.0
086A:  GOTO   094
....................    { 
....................       ITOA (ID_GATEWAY[j], 10, TEMP_CHAR); 
086B:  MOVLW  3D
086C:  ADDWF  32,W
086D:  MOVWF  04
086E:  BCF    03.7
086F:  MOVF   00,W
0870:  MOVWF  33
0871:  CLRF   37
0872:  CLRF   36
0873:  CLRF   35
0874:  MOVF   33,W
0875:  MOVWF  34
0876:  MOVLW  0A
0877:  MOVWF  38
0878:  CLRF   3A
0879:  MOVLW  6F
087A:  MOVWF  39
087B:  BCF    0A.3
087C:  BCF    03.6
087D:  CALL   3F3
087E:  BSF    0A.3
....................       DELAY_MS (1); 
087F:  MOVLW  01
0880:  BSF    03.6
0881:  MOVWF  36
0882:  BCF    0A.3
0883:  BCF    03.6
0884:  CALL   14F
0885:  BSF    0A.3
....................       STRCAT (ID_GATEWAY_CHAR, TEMP_CHAR); 
0886:  BSF    03.6
0887:  CLRF   34
0888:  MOVLW  56
0889:  MOVWF  33
088A:  CLRF   36
088B:  MOVLW  6F
088C:  MOVWF  35
088D:  BCF    0A.3
088E:  BCF    03.6
088F:  CALL   766
0890:  BSF    0A.3
0891:  BSF    03.6
0892:  INCF   32,F
0893:  GOTO   067
....................    }   
.................... } 
....................  
....................  
.................... VOID CONFIG_DONE() 
.................... { 
....................    TT_FUN = 0; 
*
0800:  BCF    4E.4
....................    TT_STT = 0; 
0801:  BCF    4E.5
....................    CHAR *PACKAGE_CONFIG[]={"*", "LENGHT","C_F", "ID_GW1234" ,"ID_NODE","#"}; 
0802:  MOVLW  2A
0803:  BSF    03.6
0804:  MOVWF  10
0805:  CLRF   11
0806:  MOVLW  4C
0807:  MOVWF  12
0808:  MOVLW  45
0809:  MOVWF  13
080A:  MOVLW  4E
080B:  MOVWF  14
080C:  MOVLW  47
080D:  MOVWF  15
080E:  MOVLW  48
080F:  MOVWF  16
0810:  MOVLW  54
0811:  MOVWF  17
0812:  CLRF   18
0813:  MOVLW  43
0814:  MOVWF  19
0815:  MOVLW  5F
0816:  MOVWF  1A
0817:  MOVLW  46
0818:  MOVWF  1B
0819:  CLRF   1C
081A:  MOVLW  49
081B:  MOVWF  1D
081C:  MOVLW  44
081D:  MOVWF  1E
081E:  MOVLW  5F
081F:  MOVWF  1F
0820:  MOVLW  47
0821:  MOVWF  20
0822:  MOVLW  57
0823:  MOVWF  21
0824:  MOVLW  31
0825:  MOVWF  22
0826:  MOVLW  32
0827:  MOVWF  23
0828:  MOVLW  33
0829:  MOVWF  24
082A:  MOVLW  34
082B:  MOVWF  25
082C:  CLRF   26
082D:  MOVLW  49
082E:  MOVWF  27
082F:  MOVLW  44
0830:  MOVWF  28
0831:  MOVLW  5F
0832:  MOVWF  29
0833:  MOVLW  4E
0834:  MOVWF  2A
0835:  MOVLW  4F
0836:  MOVWF  2B
0837:  MOVLW  44
0838:  MOVWF  2C
0839:  MOVLW  45
083A:  MOVWF  2D
083B:  CLRF   2E
083C:  MOVLW  23
083D:  MOVWF  2F
083E:  CLRF   30
083F:  MOVLW  01
0840:  BSF    03.5
0841:  BCF    03.6
0842:  MOVWF  4E
0843:  MOVLW  10
0844:  MOVWF  4D
0845:  MOVLW  01
0846:  MOVWF  50
0847:  MOVLW  12
0848:  MOVWF  4F
0849:  MOVLW  01
084A:  MOVWF  52
084B:  MOVLW  19
084C:  MOVWF  51
084D:  MOVLW  01
084E:  MOVWF  54
084F:  MOVLW  1D
0850:  MOVWF  53
0851:  MOVLW  01
0852:  MOVWF  56
0853:  MOVLW  27
0854:  MOVWF  55
0855:  MOVLW  01
0856:  MOVWF  58
0857:  MOVLW  2F
0858:  MOVWF  57
....................    XULY_IDGW_NHAP(); 
....................    PACKAGE_CONFIG[3] = ID_GATEWAY_CHAR; 
*
0894:  BSF    03.5
0895:  BCF    03.6
0896:  CLRF   54
0897:  MOVLW  56
0898:  MOVWF  53
....................     
....................    XULY_IDNODE_NHAP(); 
....................    PACKAGE_CONFIG[4] = ID_NODE_CHAR;          
*
08D4:  BSF    03.5
08D5:  BCF    03.6
08D6:  CLRF   56
08D7:  MOVLW  4F
08D8:  MOVWF  55
....................    LEN_PACKAGES = 0; 
08D9:  BCF    03.5
08DA:  CLRF   47
....................    PACKAGE_CONFIG[1] = "12"; //DO DAI CUA LENGHT CO DO DAI = 2 
08DB:  MOVLW  31
08DC:  BSF    03.5
08DD:  MOVWF  4F
08DE:  MOVLW  32
08DF:  MOVWF  50
....................    FOR (int J = 0; J < 6; J++) 
08E0:  CLRF   59
08E1:  MOVF   59,W
08E2:  SUBLW  05
08E3:  BTFSS  03.0
08E4:  GOTO   103
....................    { 
....................       LEN_PACKAGES += strlen(PACKAGE_CONFIG[J]); 
08E5:  BCF    03.0
08E6:  RLF    59,W
08E7:  ADDLW  CD
08E8:  MOVWF  04
08E9:  BCF    03.7
08EA:  INCF   04,F
08EB:  MOVF   00,W
08EC:  MOVWF  5B
08ED:  DECF   04,F
08EE:  MOVF   00,W
08EF:  MOVWF  5A
08F0:  MOVF   5B,W
08F1:  BCF    03.5
08F2:  BSF    03.6
08F3:  MOVWF  35
08F4:  BSF    03.5
08F5:  BCF    03.6
08F6:  MOVF   5A,W
08F7:  BCF    03.5
08F8:  BSF    03.6
08F9:  MOVWF  34
08FA:  BCF    0A.3
08FB:  BCF    03.6
08FC:  CALL   7A4
08FD:  BSF    0A.3
08FE:  MOVF   78,W
08FF:  ADDWF  47,F
0900:  BSF    03.5
0901:  INCF   59,F
0902:  GOTO   0E1
....................    }    
....................    LEN_PACKAGES = LEN_PACKAGES+5; //5 @ 
0903:  MOVLW  05
0904:  BCF    03.5
0905:  ADDWF  47,F
....................    ITOA (LEN_PACKAGES, 10, TEMP_CHAR); 
0906:  BSF    03.6
0907:  CLRF   37
0908:  CLRF   36
0909:  CLRF   35
090A:  BCF    03.6
090B:  MOVF   47,W
090C:  BSF    03.6
090D:  MOVWF  34
090E:  MOVLW  0A
090F:  MOVWF  38
0910:  CLRF   3A
0911:  MOVLW  6F
0912:  MOVWF  39
0913:  BCF    0A.3
0914:  BCF    03.6
0915:  CALL   3F3
0916:  BSF    0A.3
....................    PACKAGE_CONFIG[1] = TEMP_CHAR; 
0917:  BSF    03.5
0918:  CLRF   50
0919:  MOVLW  6F
091A:  MOVWF  4F
....................     
....................    FOR ( J = 0; J < 6; J++) 
091B:  CLRF   59
091C:  MOVF   59,W
091D:  SUBLW  05
091E:  BTFSS  03.0
091F:  GOTO   157
....................    { 
....................       PRINTF (PACKAGE_CONFIG[J]); 
0920:  BCF    03.0
0921:  RLF    59,W
0922:  ADDLW  CD
0923:  MOVWF  04
0924:  BCF    03.7
0925:  INCF   04,F
0926:  MOVF   00,W
0927:  MOVWF  5B
0928:  DECF   04,F
0929:  MOVF   00,W
092A:  MOVWF  5A
092B:  MOVF   5A,W
092C:  MOVWF  04
092D:  BCF    03.7
092E:  BTFSC  5B.0
092F:  BSF    03.7
....................       PRINTF ("@"); 
*
094F:  MOVLW  40
0950:  BCF    03.5
0951:  BTFSS  0C.4
0952:  GOTO   151
0953:  MOVWF  19
0954:  BSF    03.5
0955:  INCF   59,F
0956:  GOTO   11C
....................    } 
....................  
....................  
....................    LCD_GOTOXY (1, 1) ; 
0957:  MOVLW  01
0958:  BCF    03.5
0959:  BSF    03.6
095A:  MOVWF  36
095B:  MOVWF  37
095C:  BCF    0A.3
095D:  BCF    03.6
095E:  CALL   2D9
095F:  BSF    0A.3
....................    DELAY_MS (10); 
0960:  MOVLW  0A
0961:  BSF    03.6
0962:  MOVWF  36
0963:  BCF    0A.3
0964:  BCF    03.6
0965:  CALL   14F
0966:  BSF    0A.3
....................    PRINTF (LCD_PUTC, "WAITING ....        ") ; 
0967:  MOVLW  CB
0968:  BSF    03.6
0969:  MOVWF  0D
096A:  MOVLW  00
096B:  MOVWF  0F
096C:  BCF    0A.3
096D:  BCF    03.6
096E:  CALL   327
096F:  BSF    0A.3
....................    LCD_GOTOXY (1, 2) ; 
0970:  MOVLW  01
0971:  BSF    03.6
0972:  MOVWF  36
0973:  MOVLW  02
0974:  MOVWF  37
0975:  BCF    0A.3
0976:  BCF    03.6
0977:  CALL   2D9
0978:  BSF    0A.3
....................    DELAY_MS (10); 
0979:  MOVLW  0A
097A:  BSF    03.6
097B:  MOVWF  36
097C:  BCF    0A.3
097D:  BCF    03.6
097E:  CALL   14F
097F:  BSF    0A.3
....................    PRINTF (LCD_PUTC, "WAITING ....        ") ;    
0980:  MOVLW  D6
0981:  BSF    03.6
0982:  MOVWF  0D
0983:  MOVLW  00
0984:  MOVWF  0F
0985:  BCF    0A.3
0986:  BCF    03.6
0987:  CALL   327
0988:  BSF    0A.3
....................    TT_CONFIG_DONE = 0; 
0989:  BCF    4E.3
098A:  BSF    0A.3
098B:  BCF    0A.4
098C:  GOTO   7D1 (RETURN)
.................... } 
....................  
....................  
....................  VOID XACNHANCONFIG() 
....................  {    
....................    KYTU=0; 
*
0CED:  CLRF   3A
....................    OUTPUT_D (0XFF);        
0CEE:  BSF    03.5
0CEF:  CLRF   08
0CF0:  MOVLW  FF
0CF1:  BCF    03.5
0CF2:  MOVWF  08
....................    LCD_GOTOXY (1, 1) ; 
0CF3:  MOVLW  01
0CF4:  BSF    03.6
0CF5:  MOVWF  36
0CF6:  MOVWF  37
0CF7:  BCF    0A.3
0CF8:  BCF    03.6
0CF9:  CALL   2D9
0CFA:  BSF    0A.3
....................    DELAY_MS (10); 
0CFB:  MOVLW  0A
0CFC:  BSF    03.6
0CFD:  MOVWF  36
0CFE:  BCF    0A.3
0CFF:  BCF    03.6
0D00:  CALL   14F
0D01:  BSF    0A.3
....................    TEMP_CHAR = "_"; 
0D02:  BSF    03.5
0D03:  CLRF   55
0D04:  CLRF   56
0D05:  MOVLW  6F
0D06:  MOVWF  04
0D07:  BCF    03.7
0D08:  MOVF   55,W
0D09:  ADDWF  04,F
0D0A:  MOVF   56,W
0D0B:  BCF    0A.3
0D0C:  BCF    03.5
0D0D:  CALL   05E
0D0E:  BSF    0A.3
0D0F:  MOVWF  00
0D10:  IORLW  00
0D11:  BTFSC  03.2
0D12:  GOTO   518
0D13:  BSF    03.5
0D14:  INCF   56,F
0D15:  INCF   55,F
0D16:  GOTO   505
0D17:  BCF    03.5
....................    CHAR * TOKEN; 
....................    TOKEN = STRTOK (KYTUCHAR2, TEMP_CHAR);    
0D18:  BSF    03.5
0D19:  CLRF   56
0D1A:  MOVLW  BE
0D1B:  MOVWF  55
0D1C:  CLRF   58
0D1D:  MOVLW  6F
0D1E:  MOVWF  57
0D1F:  BCF    03.5
0D20:  CALL   18D
0D21:  MOVF   79,W
0D22:  BSF    03.5
0D23:  MOVWF  54
0D24:  MOVF   78,W
0D25:  MOVWF  53
....................     WHILE (TOKEN != NULL) 
0D26:  MOVF   53,F
0D27:  BTFSS  03.2
0D28:  GOTO   52C
0D29:  MOVF   54,F
0D2A:  BTFSC  03.2
0D2B:  GOTO   575
....................     {                 
....................        SWITCH(KYTU) 
0D2C:  BCF    03.5
0D2D:  MOVF   3A,W
0D2E:  BTFSC  03.2
0D2F:  GOTO   537
0D30:  XORLW  01
0D31:  BTFSC  03.2
0D32:  GOTO   551
0D33:  XORLW  03
0D34:  BTFSC  03.2
0D35:  GOTO   55B
0D36:  GOTO   564
....................        { 
....................          CASE 0: 
....................          DELAY_MS (1); 
0D37:  MOVLW  01
0D38:  BSF    03.6
0D39:  MOVWF  36
0D3A:  BCF    0A.3
0D3B:  BCF    03.6
0D3C:  CALL   14F
0D3D:  BSF    0A.3
....................          PRINTF (LCD_PUTC,TOKEN); 
0D3E:  BSF    03.5
0D3F:  MOVF   53,W
0D40:  MOVWF  04
0D41:  BCF    03.7
0D42:  BTFSC  54.0
0D43:  BSF    03.7
0D44:  BCF    0A.3
0D45:  BCF    03.5
0D46:  CALL   513
0D47:  BSF    0A.3
....................          PRINTF (LCD_PUTC,"            "); 
0D48:  MOVLW  E1
0D49:  BSF    03.6
0D4A:  MOVWF  0D
0D4B:  MOVLW  00
0D4C:  MOVWF  0F
0D4D:  BCF    0A.3
0D4E:  BCF    03.6
0D4F:  CALL   327
0D50:  BSF    0A.3
....................          CASE 1:  
....................          SOLUONGTHIETBI_CONFIG = ATOI(TOKEN); 
0D51:  BSF    03.5
0D52:  MOVF   54,W
0D53:  MOVWF  56
0D54:  MOVF   53,W
0D55:  MOVWF  55
0D56:  BCF    03.5
0D57:  CALL   27E
0D58:  MOVF   78,W
0D59:  MOVWF  4A
....................          BREAK;                      
0D5A:  GOTO   564
....................          CASE 2: 
....................          SOLUONGCAMBIEN_CONFIG = ATOI(TOKEN); 
0D5B:  BSF    03.5
0D5C:  MOVF   54,W
0D5D:  MOVWF  56
0D5E:  MOVF   53,W
0D5F:  MOVWF  55
0D60:  BCF    03.5
0D61:  CALL   27E
0D62:  MOVF   78,W
0D63:  MOVWF  4B
....................          BREAK;               
....................        }  
....................       TOKEN = STRTOK(NULL, TEMP_CHAR); 
0D64:  BSF    03.5
0D65:  CLRF   56
0D66:  CLRF   55
0D67:  CLRF   58
0D68:  MOVLW  6F
0D69:  MOVWF  57
0D6A:  BCF    03.5
0D6B:  CALL   18D
0D6C:  MOVF   79,W
0D6D:  BSF    03.5
0D6E:  MOVWF  54
0D6F:  MOVF   78,W
0D70:  MOVWF  53
....................       KYTU++;         
0D71:  BCF    03.5
0D72:  INCF   3A,F
0D73:  BSF    03.5
0D74:  GOTO   526
....................     }           
....................    DELAY_MS(500); 
0D75:  MOVLW  02
0D76:  MOVWF  55
0D77:  MOVLW  FA
0D78:  BCF    03.5
0D79:  BSF    03.6
0D7A:  MOVWF  36
0D7B:  BCF    0A.3
0D7C:  BCF    03.6
0D7D:  CALL   14F
0D7E:  BSF    0A.3
0D7F:  BSF    03.5
0D80:  DECFSZ 55,F
0D81:  GOTO   577
....................    DELAY_MS (1);  
0D82:  MOVLW  01
0D83:  BCF    03.5
0D84:  BSF    03.6
0D85:  MOVWF  36
0D86:  BCF    0A.3
0D87:  BCF    03.6
0D88:  CALL   14F
0D89:  BSF    0A.3
....................    OUTPUT_D (0XFF);      
0D8A:  BSF    03.5
0D8B:  CLRF   08
0D8C:  MOVLW  FF
0D8D:  BCF    03.5
0D8E:  MOVWF  08
....................    LCD_GOTOXY (1, 2) ; 
0D8F:  MOVLW  01
0D90:  BSF    03.6
0D91:  MOVWF  36
0D92:  MOVLW  02
0D93:  MOVWF  37
0D94:  BCF    0A.3
0D95:  BCF    03.6
0D96:  CALL   2D9
0D97:  BSF    0A.3
....................    DELAY_MS (10); 
0D98:  MOVLW  0A
0D99:  BSF    03.6
0D9A:  MOVWF  36
0D9B:  BCF    0A.3
0D9C:  BCF    03.6
0D9D:  CALL   14F
0D9E:  BSF    0A.3
....................    PRINTF (LCD_PUTC,"TB: ");    
0D9F:  MOVLW  E8
0DA0:  BSF    03.6
0DA1:  MOVWF  0D
0DA2:  MOVLW  00
0DA3:  MOVWF  0F
0DA4:  BCF    0A.3
0DA5:  BCF    03.6
0DA6:  CALL   327
0DA7:  BSF    0A.3
....................    ITOA (SOLUONGTHIETBI_CONFIG, 10, TEMP_CHAR);    
0DA8:  BSF    03.6
0DA9:  CLRF   37
0DAA:  CLRF   36
0DAB:  CLRF   35
0DAC:  BCF    03.6
0DAD:  MOVF   4A,W
0DAE:  BSF    03.6
0DAF:  MOVWF  34
0DB0:  MOVLW  0A
0DB1:  MOVWF  38
0DB2:  CLRF   3A
0DB3:  MOVLW  6F
0DB4:  MOVWF  39
0DB5:  BCF    0A.3
0DB6:  BCF    03.6
0DB7:  CALL   3F3
0DB8:  BSF    0A.3
....................    PRINTF (LCD_PUTC,TEMP_CHAR);    
0DB9:  MOVLW  6F
0DBA:  MOVWF  04
0DBB:  BCF    03.7
0DBC:  BCF    0A.3
0DBD:  CALL   513
0DBE:  BSF    0A.3
....................    PRINTF (LCD_PUTC,"    CB:");    
0DBF:  MOVLW  EB
0DC0:  BSF    03.6
0DC1:  MOVWF  0D
0DC2:  MOVLW  00
0DC3:  MOVWF  0F
0DC4:  BCF    0A.3
0DC5:  BCF    03.6
0DC6:  CALL   327
0DC7:  BSF    0A.3
....................    ITOA (SOLUONGCAMBIEN_CONFIG, 10, TEMP_CHAR);    
0DC8:  BSF    03.6
0DC9:  CLRF   37
0DCA:  CLRF   36
0DCB:  CLRF   35
0DCC:  BCF    03.6
0DCD:  MOVF   4B,W
0DCE:  BSF    03.6
0DCF:  MOVWF  34
0DD0:  MOVLW  0A
0DD1:  MOVWF  38
0DD2:  CLRF   3A
0DD3:  MOVLW  6F
0DD4:  MOVWF  39
0DD5:  BCF    0A.3
0DD6:  BCF    03.6
0DD7:  CALL   3F3
0DD8:  BSF    0A.3
....................    PRINTF (LCD_PUTC,TEMP_CHAR);       
0DD9:  MOVLW  6F
0DDA:  MOVWF  04
0DDB:  BCF    03.7
0DDC:  BCF    0A.3
0DDD:  CALL   513
0DDE:  BSF    0A.3
....................    OUTPUT_D (0X00); 
0DDF:  BSF    03.5
0DE0:  CLRF   08
0DE1:  BCF    03.5
0DE2:  CLRF   08
....................    DELAY_MS(500); 
0DE3:  MOVLW  02
0DE4:  BSF    03.5
0DE5:  MOVWF  55
0DE6:  MOVLW  FA
0DE7:  BCF    03.5
0DE8:  BSF    03.6
0DE9:  MOVWF  36
0DEA:  BCF    0A.3
0DEB:  BCF    03.6
0DEC:  CALL   14F
0DED:  BSF    0A.3
0DEE:  BSF    03.5
0DEF:  DECFSZ 55,F
0DF0:  GOTO   5E6
....................    OUTPUT_D (0XFF);     
0DF1:  CLRF   08
0DF2:  MOVLW  FF
0DF3:  BCF    03.5
0DF4:  MOVWF  08
....................    DELAY_MS(500); 
0DF5:  MOVLW  02
0DF6:  BSF    03.5
0DF7:  MOVWF  55
0DF8:  MOVLW  FA
0DF9:  BCF    03.5
0DFA:  BSF    03.6
0DFB:  MOVWF  36
0DFC:  BCF    0A.3
0DFD:  BCF    03.6
0DFE:  CALL   14F
0DFF:  BSF    0A.3
0E00:  BSF    03.5
0E01:  DECFSZ 55,F
0E02:  GOTO   5F8
....................    OUTPUT_D (0X00); 
0E03:  CLRF   08
0E04:  BCF    03.5
0E05:  CLRF   08
....................     
....................  }  
.................... //--------------------------------------------------------------------// 
....................  
....................  
....................  
....................  
....................  
.................... VOID QUET_PHIM() 
*
00EF:  BSF    03.6
00F0:  CLRF   59
.................... { 
....................    INT BDT = 0; 
....................  
....................    WHILE (!INPUT (BT1_PIN)) //NEU NUT BAM DUOC BAM 
00F1:  BSF    03.5
00F2:  BCF    03.6
00F3:  BSF    06.1
00F4:  BCF    03.5
00F5:  BTFSC  06.1
00F6:  GOTO   10A
....................    { 
....................       IF (TMR1IF) 
00F7:  BTFSS  0C.0
00F8:  GOTO   107
....................       { 
....................          OUTPUT_TOGGLE (PIN_D2); 
00F9:  BSF    03.5
00FA:  BCF    08.2
00FB:  MOVLW  04
00FC:  BCF    03.5
00FD:  XORWF  08,F
....................          TMR1IF = 0; SET_TIMER1 (3036); BDT++; 
00FE:  BCF    0C.0
00FF:  CLRF   0E
0100:  MOVLW  0B
0101:  MOVWF  0F
0102:  MOVLW  DC
0103:  MOVWF  0E
0104:  BSF    03.6
0105:  INCF   59,F
0106:  BCF    03.6
....................       } 
0107:  BSF    03.6
0108:  GOTO   0F1
0109:  BCF    03.6
....................    } 
....................  
....................    IF (BDT > 20) 
010A:  BSF    03.6
010B:  MOVF   59,W
010C:  SUBLW  14
010D:  BTFSC  03.0
010E:  GOTO   118
....................    { 
....................       //CONFIG NODE 
....................       TT_CONFIG = ~TT_CONFIG; // VAO TRANG THAI CONFIG 
010F:  MOVLW  02
0110:  BCF    03.6
0111:  XORWF  4E,F
....................       TT_CONTROL = ~TT_CONTROL; 
0112:  MOVLW  04
0113:  XORWF  4E,F
....................       //CONFIG_DONE (); 
....................       TT_CONFIG_DONE = 1; 
0114:  BSF    4E.3
....................       TT_FUN = 0; 
0115:  BCF    4E.4
....................    } 
0116:  GOTO   11C
0117:  BSF    03.6
....................  
....................    ELSE 
....................    { 
....................       BUTT_OKE (); //OKE 
....................    } 
.................... } 
....................  
.................... #INT_EXT 
....................  
....................  VOID NGAT_NGOAI () 
....................  { 
....................     QUET_PHIM (); 
....................  } 
....................  
*
011C:  BCF    0B.1
011D:  BCF    0A.3
011E:  BCF    0A.4
011F:  GOTO   031
....................  #INT_RDA 
....................  VOID NGAT () 
....................  { 
....................     KYTUCHAR[VT] = GETCH (); 
0120:  MOVLW  A0
0121:  ADDWF  39,W
0122:  MOVWF  04
0123:  BCF    03.7
0124:  BTFSS  0C.5
0125:  GOTO   124
0126:  MOVF   1A,W
0127:  MOVWF  00
....................  
....................     IF (KYTUCHAR[VT] == '.') 
0128:  MOVLW  A0
0129:  ADDWF  39,W
012A:  MOVWF  04
012B:  BCF    03.7
012C:  MOVF   00,W
012D:  SUBLW  2E
012E:  BTFSS  03.2
012F:  GOTO   138
....................     { 
....................        KYTUCHAR[VT] = '\0'; 
0130:  MOVLW  A0
0131:  ADDWF  39,W
0132:  MOVWF  04
0133:  BCF    03.7
0134:  CLRF   00
....................        VT = 0; 
0135:  CLRF   39
....................        TTNHAN = 1; 
0136:  BSF    4E.0
....................     } 
0137:  GOTO   139
....................     ELSE 
....................     VT++; 
0138:  INCF   39,F
0139:  BCF    0C.5
013A:  BCF    0A.3
013B:  BCF    0A.4
013C:  GOTO   031
....................  } 
....................  
....................  VOID XUATLCD ( CHAR CHUOI_PRINT[]) 
....................  { 
....................     LCD_GOTOXY (1, 1) ; 
....................     DELAY_MS (10); 
....................     PRINTF (LCD_PUTC, CHUOI_PRINT); 
....................     DELAY_MS (1); 
....................  } 
....................  
....................  VOID DIEUKHIENTHIETBI() 
....................  { 
....................     /* LAY TOKEN DAU TIEN */     
....................     KYTU = 0; 
*
0E07:  CLRF   3A
....................     TEMP_CHAR = "_"; 
0E08:  BSF    03.5
0E09:  CLRF   55
0E0A:  CLRF   56
0E0B:  MOVLW  6F
0E0C:  MOVWF  04
0E0D:  BCF    03.7
0E0E:  MOVF   55,W
0E0F:  ADDWF  04,F
0E10:  MOVF   56,W
0E11:  BCF    0A.3
0E12:  BCF    03.5
0E13:  CALL   05E
0E14:  BSF    0A.3
0E15:  MOVWF  00
0E16:  IORLW  00
0E17:  BTFSC  03.2
0E18:  GOTO   61E
0E19:  BSF    03.5
0E1A:  INCF   56,F
0E1B:  INCF   55,F
0E1C:  GOTO   60B
0E1D:  BCF    03.5
....................     LCD_GOTOXY (1, 1) ; 
0E1E:  MOVLW  01
0E1F:  BSF    03.6
0E20:  MOVWF  36
0E21:  MOVWF  37
0E22:  BCF    0A.3
0E23:  BCF    03.6
0E24:  CALL   2D9
0E25:  BSF    0A.3
....................     DELAY_MS (10);        
0E26:  MOVLW  0A
0E27:  BSF    03.6
0E28:  MOVWF  36
0E29:  BCF    0A.3
0E2A:  BCF    03.6
0E2B:  CALL   14F
0E2C:  BSF    0A.3
....................     PRINTF (LCD_PUTC, KYTUCHAR2);    
0E2D:  MOVLW  BE
0E2E:  MOVWF  04
0E2F:  BCF    03.7
0E30:  BCF    0A.3
0E31:  CALL   513
0E32:  BSF    0A.3
....................     PRINTF (LCD_PUTC, "                 "); 
0E33:  MOVLW  3D
0E34:  BSF    03.6
0E35:  MOVWF  0D
0E36:  MOVLW  01
0E37:  MOVWF  0F
0E38:  BCF    0A.3
0E39:  BCF    03.6
0E3A:  CALL   327
0E3B:  BSF    0A.3
....................     LCD_GOTOXY (1, 2) ; 
0E3C:  MOVLW  01
0E3D:  BSF    03.6
0E3E:  MOVWF  36
0E3F:  MOVLW  02
0E40:  MOVWF  37
0E41:  BCF    0A.3
0E42:  BCF    03.6
0E43:  CALL   2D9
0E44:  BSF    0A.3
....................     DELAY_MS (10);           
0E45:  MOVLW  0A
0E46:  BSF    03.6
0E47:  MOVWF  36
0E48:  BCF    0A.3
0E49:  BCF    03.6
0E4A:  CALL   14F
0E4B:  BSF    0A.3
....................     PRINTF (LCD_PUTC, "                 ");     
0E4C:  MOVLW  46
0E4D:  BSF    03.6
0E4E:  MOVWF  0D
0E4F:  MOVLW  01
0E50:  MOVWF  0F
0E51:  BCF    0A.3
0E52:  BCF    03.6
0E53:  CALL   327
0E54:  BSF    0A.3
....................     CHAR * TOKEN; 
....................     TOKEN = STRTOK (KYTUCHAR2, TEMP_CHAR);    
0E55:  BSF    03.5
0E56:  CLRF   56
0E57:  MOVLW  BE
0E58:  MOVWF  55
0E59:  CLRF   58
0E5A:  MOVLW  6F
0E5B:  MOVWF  57
0E5C:  BCF    03.5
0E5D:  CALL   18D
0E5E:  MOVF   79,W
0E5F:  BSF    03.5
0E60:  MOVWF  54
0E61:  MOVF   78,W
0E62:  MOVWF  53
....................      
....................     /* DUYET QUA CAC TOKEN CON LAI */                 
....................     WHILE (TOKEN != NULL) 
0E63:  MOVF   53,F
0E64:  BTFSS  03.2
0E65:  GOTO   669
0E66:  MOVF   54,F
0E67:  BTFSC  03.2
0E68:  GOTO   6C7
....................     {                 
....................        SWITCH(KYTU) 
0E69:  BCF    03.5
0E6A:  MOVF   3A,W
0E6B:  BTFSC  03.2
0E6C:  GOTO   674
0E6D:  XORLW  01
0E6E:  BTFSC  03.2
0E6F:  GOTO   67E
0E70:  XORLW  03
0E71:  BTFSC  03.2
0E72:  GOTO   688
0E73:  GOTO   69C
....................        { 
....................          CASE 0: 
....................          ID_DEVICE_NHAN =  ATOI(TOKEN) +64 ;        
0E74:  BSF    03.5
0E75:  MOVF   54,W
0E76:  MOVWF  56
0E77:  MOVF   53,W
0E78:  MOVWF  55
0E79:  BCF    03.5
0E7A:  CALL   27E
0E7B:  MOVLW  40
0E7C:  ADDWF  78,W
0E7D:  MOVWF  3B
....................          CASE 1:  
....................          TT_DEVICE_NHAN =  ATOI(TOKEN);        
0E7E:  BSF    03.5
0E7F:  MOVF   54,W
0E80:  MOVWF  56
0E81:  MOVF   53,W
0E82:  MOVWF  55
0E83:  BCF    03.5
0E84:  CALL   27E
0E85:  MOVF   78,W
0E86:  MOVWF  3C
....................          BREAK;                      
0E87:  GOTO   69C
....................          CASE 2: 
....................          STRCAT (ID_NODE_NHAN, TOKEN); 
0E88:  BSF    03.6
0E89:  CLRF   34
0E8A:  MOVLW  5F
0E8B:  MOVWF  33
0E8C:  BSF    03.5
0E8D:  BCF    03.6
0E8E:  MOVF   54,W
0E8F:  BCF    03.5
0E90:  BSF    03.6
0E91:  MOVWF  36
0E92:  BSF    03.5
0E93:  BCF    03.6
0E94:  MOVF   53,W
0E95:  BCF    03.5
0E96:  BSF    03.6
0E97:  MOVWF  35
0E98:  BCF    0A.3
0E99:  BCF    03.6
0E9A:  CALL   766
0E9B:  BSF    0A.3
....................          BREAK;               
....................        }  
....................        LCD_GOTOXY (7, 2) ; 
0E9C:  MOVLW  07
0E9D:  BSF    03.6
0E9E:  MOVWF  36
0E9F:  MOVLW  02
0EA0:  MOVWF  37
0EA1:  BCF    0A.3
0EA2:  BCF    03.6
0EA3:  CALL   2D9
0EA4:  BSF    0A.3
....................        DELAY_MS (10);        
0EA5:  MOVLW  0A
0EA6:  BSF    03.6
0EA7:  MOVWF  36
0EA8:  BCF    0A.3
0EA9:  BCF    03.6
0EAA:  CALL   14F
0EAB:  BSF    0A.3
....................        PRINTF (LCD_PUTC, TOKEN); 
0EAC:  BSF    03.5
0EAD:  MOVF   53,W
0EAE:  MOVWF  04
0EAF:  BCF    03.7
0EB0:  BTFSC  54.0
0EB1:  BSF    03.7
0EB2:  BCF    0A.3
0EB3:  BCF    03.5
0EB4:  CALL   513
0EB5:  BSF    0A.3
....................       TOKEN = STRTOK(NULL, TEMP_CHAR); 
0EB6:  BSF    03.5
0EB7:  CLRF   56
0EB8:  CLRF   55
0EB9:  CLRF   58
0EBA:  MOVLW  6F
0EBB:  MOVWF  57
0EBC:  BCF    03.5
0EBD:  CALL   18D
0EBE:  MOVF   79,W
0EBF:  BSF    03.5
0EC0:  MOVWF  54
0EC1:  MOVF   78,W
0EC2:  MOVWF  53
....................       KYTU++;         
0EC3:  BCF    03.5
0EC4:  INCF   3A,F
0EC5:  BSF    03.5
0EC6:  GOTO   663
....................     }  
....................     OUTPUT_BIT (ID_DEVICE_NHAN, TT_DEVICE_NHAN); 
0EC7:  BCF    03.5
0EC8:  MOVF   3C,F
0EC9:  BTFSS  03.2
0ECA:  GOTO   6CD
0ECB:  MOVLW  00
0ECC:  GOTO   6CE
0ECD:  MOVLW  01
0ECE:  MOVWF  77
0ECF:  MOVF   3B,W
0ED0:  BSF    03.5
0ED1:  MOVWF  55
0ED2:  MOVF   77,W
0ED3:  MOVWF  56
0ED4:  CLRF   58
0ED5:  CLRF   57
0ED6:  BCF    0A.3
0ED7:  BCF    03.5
0ED8:  CALL   7DA
0ED9:  BSF    0A.3
0EDA:  MOVF   3B,W
0EDB:  BSF    03.5
0EDC:  MOVWF  55
0EDD:  CLRF   56
0EDE:  CLRF   58
0EDF:  MOVLW  80
0EE0:  MOVWF  57
0EE1:  BCF    0A.3
0EE2:  BCF    03.5
0EE3:  CALL   7DA
0EE4:  BSF    0A.3
....................  } 
....................  
....................  VOID XU_LY_UART() 
*
0BC6:  MOVLW  2A
0BC7:  BSF    03.5
0BC8:  MOVWF  4D
....................  { 
....................      //ID_NODE_NHAN = KYTU[1] - 48; 
....................     //ID_DEVICE_NHAN = KYTU[2] - 48 + 64; 
....................     //TT_DEVICE_NHAN = KYTU[3] - 48; // - 48 ASCII -- > S?. + 64 -- > PORT_D (D0 = 64)                
....................  
....................     /*TINH DO DAI*/ 
....................     CHAR CH = '*'; 
....................     CHAR *RET; 
....................     *ID_NODE_NHAN = '\0'; 
0BC9:  CLRF   7A
0BCA:  MOVLW  5F
0BCB:  MOVWF  04
0BCC:  BCF    03.7
0BCD:  BTFSC  7A.0
0BCE:  BSF    03.7
0BCF:  CLRF   00
....................     *ID_GW_NHAN = '\0'; 
0BD0:  CLRF   7A
0BD1:  MOVLW  66
0BD2:  MOVWF  04
0BD3:  BCF    03.7
0BD4:  BTFSC  7A.0
0BD5:  BSF    03.7
0BD6:  CLRF   00
....................     KYTUCHAR2 = ""; 
0BD7:  CLRF   53
0BD8:  CLRF   54
0BD9:  MOVLW  BE
0BDA:  MOVWF  04
0BDB:  BCF    03.7
0BDC:  MOVF   53,W
0BDD:  ADDWF  04,F
0BDE:  MOVF   54,W
0BDF:  BCF    0A.3
0BE0:  BCF    03.5
0BE1:  CALL   064
0BE2:  BSF    0A.3
0BE3:  MOVWF  00
0BE4:  IORLW  00
0BE5:  BTFSC  03.2
0BE6:  GOTO   3EC
0BE7:  BSF    03.5
0BE8:  INCF   54,F
0BE9:  INCF   53,F
0BEA:  GOTO   3D9
0BEB:  BCF    03.5
....................     UNSIGNED INT8 LEN_RET;     
....................     RET = STRCHR(KYTUCHAR,CH); 
0BEC:  BSF    03.5
0BED:  CLRF   54
0BEE:  MOVLW  A0
0BEF:  MOVWF  53
0BF0:  MOVF   4D,W
0BF1:  MOVWF  55
*
0C13:  MOVF   79,W
0C14:  MOVWF  4F
0C15:  MOVF   78,W
0C16:  MOVWF  4E
....................     LEN_RET = STRLEN(RET);  
0C17:  MOVF   4F,W
0C18:  BCF    03.5
0C19:  BSF    03.6
0C1A:  MOVWF  35
0C1B:  BSF    03.5
0C1C:  BCF    03.6
0C1D:  MOVF   4E,W
0C1E:  BCF    03.5
0C1F:  BSF    03.6
0C20:  MOVWF  34
0C21:  BCF    0A.3
0C22:  BCF    03.6
0C23:  CALL   7A4
0C24:  BSF    0A.3
0C25:  MOVF   78,W
0C26:  BSF    03.5
0C27:  MOVWF  50
....................     /* LAY TOKEN DAU TIEN */     
....................     KYTU = 0; 
0C28:  BCF    03.5
0C29:  CLRF   3A
....................     TEMP_CHAR = "#"; 
0C2A:  BSF    03.5
0C2B:  CLRF   53
0C2C:  CLRF   54
0C2D:  MOVLW  6F
0C2E:  MOVWF  04
0C2F:  BCF    03.7
0C30:  MOVF   53,W
0C31:  ADDWF  04,F
0C32:  MOVF   54,W
0C33:  BCF    0A.3
0C34:  BCF    03.5
0C35:  CALL   069
0C36:  BSF    0A.3
0C37:  MOVWF  00
0C38:  IORLW  00
0C39:  BTFSC  03.2
0C3A:  GOTO   440
0C3B:  BSF    03.5
0C3C:  INCF   54,F
0C3D:  INCF   53,F
0C3E:  GOTO   42D
0C3F:  BCF    03.5
....................     CHAR * TOKEN; 
....................     TOKEN = STRTOK (KYTUCHAR, TEMP_CHAR);                 
0C40:  BSF    03.5
0C41:  CLRF   56
0C42:  MOVLW  A0
0C43:  MOVWF  55
0C44:  CLRF   58
0C45:  MOVLW  6F
0C46:  MOVWF  57
0C47:  BCF    03.5
0C48:  CALL   18D
0C49:  MOVF   79,W
0C4A:  BSF    03.5
0C4B:  MOVWF  52
0C4C:  MOVF   78,W
0C4D:  MOVWF  51
....................     /* DUYET QUA CAC TOKEN CON LAI */                 
....................     WHILE (TOKEN != NULL) 
0C4E:  MOVF   51,F
0C4F:  BTFSS  03.2
0C50:  GOTO   454
0C51:  MOVF   52,F
0C52:  BTFSC  03.2
0C53:  GOTO   4BF
....................     {                 
....................        SWITCH(KYTU) 
0C54:  BCF    03.5
0C55:  MOVF   3A,W
0C56:  ADDLW  FA
0C57:  BTFSC  03.0
0C58:  GOTO   4AE
0C59:  ADDLW  06
0C5A:  GOTO   6F0
....................        { 
....................          CASE 0: 
....................          BREAK; 
0C5B:  GOTO   4AE
....................          CASE 1:  
....................          STRCAT (ID_GW_NHAN, TOKEN); 
0C5C:  BSF    03.6
0C5D:  CLRF   34
0C5E:  MOVLW  66
0C5F:  MOVWF  33
0C60:  BSF    03.5
0C61:  BCF    03.6
0C62:  MOVF   52,W
0C63:  BCF    03.5
0C64:  BSF    03.6
0C65:  MOVWF  36
0C66:  BSF    03.5
0C67:  BCF    03.6
0C68:  MOVF   51,W
0C69:  BCF    03.5
0C6A:  BSF    03.6
0C6B:  MOVWF  35
0C6C:  BCF    0A.3
0C6D:  BCF    03.6
0C6E:  CALL   766
0C6F:  BSF    0A.3
....................          BREAK;                      
0C70:  GOTO   4AE
....................          CASE 2: 
....................          STRCAT (ID_NODE_NHAN, TOKEN); 
0C71:  BSF    03.6
0C72:  CLRF   34
0C73:  MOVLW  5F
0C74:  MOVWF  33
0C75:  BSF    03.5
0C76:  BCF    03.6
0C77:  MOVF   52,W
0C78:  BCF    03.5
0C79:  BSF    03.6
0C7A:  MOVWF  36
0C7B:  BSF    03.5
0C7C:  BCF    03.6
0C7D:  MOVF   51,W
0C7E:  BCF    03.5
0C7F:  BSF    03.6
0C80:  MOVWF  35
0C81:  BCF    0A.3
0C82:  BCF    03.6
0C83:  CALL   766
0C84:  BSF    0A.3
....................          BREAK;       
0C85:  GOTO   4AE
....................          CASE 3: 
....................          LENHDIEUKHIEN =  ATOI(TOKEN);                  
0C86:  BSF    03.5
0C87:  MOVF   52,W
0C88:  MOVWF  56
0C89:  MOVF   51,W
0C8A:  MOVWF  55
0C8B:  BCF    03.5
0C8C:  CALL   27E
0C8D:  MOVF   78,W
0C8E:  MOVWF  48
....................          BREAK;     
0C8F:  GOTO   4AE
....................          CASE 4: 
....................          DODAI_DATA_NHAN =  ATOI(TOKEN);                  
0C90:  BSF    03.5
0C91:  MOVF   52,W
0C92:  MOVWF  56
0C93:  MOVF   51,W
0C94:  MOVWF  55
0C95:  BCF    03.5
0C96:  CALL   27E
0C97:  MOVF   78,W
0C98:  MOVWF  49
....................          BREAK;   
0C99:  GOTO   4AE
....................          CASE 5:   
....................          STRCAT (KYTUCHAR2, TOKEN); 
0C9A:  BSF    03.6
0C9B:  CLRF   34
0C9C:  MOVLW  BE
0C9D:  MOVWF  33
0C9E:  BSF    03.5
0C9F:  BCF    03.6
0CA0:  MOVF   52,W
0CA1:  BCF    03.5
0CA2:  BSF    03.6
0CA3:  MOVWF  36
0CA4:  BSF    03.5
0CA5:  BCF    03.6
0CA6:  MOVF   51,W
0CA7:  BCF    03.5
0CA8:  BSF    03.6
0CA9:  MOVWF  35
0CAA:  BCF    0A.3
0CAB:  BCF    03.6
0CAC:  CALL   766
0CAD:  BSF    0A.3
....................          BREAK;          
....................        }          
....................       TOKEN = STRTOK(NULL, TEMP_CHAR); 
0CAE:  BSF    03.5
0CAF:  CLRF   56
0CB0:  CLRF   55
0CB1:  CLRF   58
0CB2:  MOVLW  6F
0CB3:  MOVWF  57
0CB4:  BCF    03.5
0CB5:  CALL   18D
0CB6:  MOVF   79,W
0CB7:  BSF    03.5
0CB8:  MOVWF  52
0CB9:  MOVF   78,W
0CBA:  MOVWF  51
....................       KYTU++;         
0CBB:  BCF    03.5
0CBC:  INCF   3A,F
0CBD:  BSF    03.5
0CBE:  GOTO   44E
....................     }               
....................       /* SO SANH ID returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................       SOSANH_IDGW = STRCMP(ID_GW_NHAN,ID_GATEWAY_CHAR);       
0CBF:  CLRF   54
0CC0:  MOVLW  66
0CC1:  MOVWF  53
0CC2:  CLRF   56
0CC3:  MOVLW  56
0CC4:  MOVWF  55
0CC5:  BCF    03.5
0CC6:  CALL   380
0CC7:  MOVF   78,W
0CC8:  MOVWF  4D
....................       SOSANH_IDNODE = STRCMP(ID_NODE_NHAN,ID_NODE_CHAR);     
0CC9:  BSF    03.5
0CCA:  CLRF   54
0CCB:  MOVLW  5F
0CCC:  MOVWF  53
0CCD:  CLRF   56
0CCE:  MOVLW  4F
0CCF:  MOVWF  55
0CD0:  BCF    03.5
0CD1:  CALL   380
0CD2:  MOVF   78,W
0CD3:  MOVWF  4C
....................     IF ( SOSANH_IDGW == 0 && SOSANH_IDNODE == 0 && LEN_RET == DODAI_DATA_NHAN) 
0CD4:  MOVF   4D,F
0CD5:  BTFSS  03.2
0CD6:  GOTO   6E6
0CD7:  MOVF   4C,F
0CD8:  BTFSS  03.2
0CD9:  GOTO   6E6
0CDA:  MOVF   49,W
0CDB:  BSF    03.5
0CDC:  SUBWF  50,W
0CDD:  BTFSC  03.2
0CDE:  GOTO   4E1
0CDF:  BCF    03.5
0CE0:  GOTO   6E6
....................     {                       
....................       SWITCH(LENHDIEUKHIEN) 
0CE1:  BCF    03.5
0CE2:  MOVF   48,W
0CE3:  BTFSC  03.2
0CE4:  GOTO   4EC
0CE5:  XORLW  01
0CE6:  BTFSC  03.2
0CE7:  GOTO   4ED
0CE8:  XORLW  03
0CE9:  BTFSC  03.2
0CEA:  GOTO   607
0CEB:  GOTO   6E5
....................        { 
....................          CASE 0: 
....................          BREAK; 
0CEC:  GOTO   6E5
....................          CASE 1: 
....................          XACNHANCONFIG(); 
....................          BREAK;                      
*
0E06:  GOTO   6E5
....................          CASE 2: 
....................          DIEUKHIENTHIETBI(); 
....................          BREAK;               
....................        }  
....................     } 
*
0EE5:  GOTO   6ED
....................     ELSE{ 
....................       DELAY_MS (10); 
0EE6:  MOVLW  0A
0EE7:  BSF    03.6
0EE8:  MOVWF  36
0EE9:  BCF    0A.3
0EEA:  BCF    03.6
0EEB:  CALL   14F
0EEC:  BSF    0A.3
....................       /*DATA RCV SAI ID NODE, ID GW HOAC LA SAI DO DAI*/ 
....................     } 
0EED:  BSF    0A.3
0EEE:  BCF    0A.4
0EEF:  GOTO   7DB (RETURN)
....................      
....................  } 
....................  
....................  INT ADC_READ (INT KENH) 
....................  { 
....................     SET_ADC_CHANNEL (KENH); 
....................     KQADC = 0; 
....................     FOR (INT I = 0; I < 100; I++) 
....................     { 
....................        KQADC = KQADC + READ_ADC () ; 
....................        DELAY_MS (1); 
....................     } 
....................  
....................     KQADC = KQADC / (100 * 2.046); 
....................     RETURN KQADC; 
....................  } 
....................  
....................  VOID CHUONG_TRINH_CON () 
....................  { 
....................     FOR (INT I = 0; I <= 30; I++) 
*
07C4:  BSF    03.5
07C5:  CLRF   4D
07C6:  MOVF   4D,W
07C7:  SUBLW  1E
07C8:  BTFSS  03.0
07C9:  GOTO   7D6
....................     { 
....................        OUTPUT_TOGGLE (PIN_D1); 
07CA:  BCF    08.1
07CB:  MOVLW  02
07CC:  BCF    03.5
07CD:  XORWF  08,F
....................        DELAY_MS (100); 
07CE:  MOVLW  64
07CF:  BSF    03.6
07D0:  MOVWF  36
07D1:  BCF    03.6
07D2:  CALL   14F
07D3:  BSF    03.5
07D4:  INCF   4D,F
07D5:  GOTO   7C6
....................     } 
07D6:  BCF    03.5
07D7:  BSF    0A.3
07D8:  BCF    0A.4
07D9:  GOTO   7D6 (RETURN)
....................  } 
....................  
....................  VOID MAIN  () 
*
0EFA:  MOVF   03,W
0EFB:  ANDLW  1F
0EFC:  MOVWF  03
0EFD:  BSF    03.5
0EFE:  BSF    03.6
0EFF:  BSF    07.3
0F00:  MOVLW  08
0F01:  BCF    03.6
0F02:  MOVWF  19
0F03:  MOVLW  02
0F04:  MOVWF  1A
0F05:  MOVLW  A6
0F06:  MOVWF  18
0F07:  MOVLW  90
0F08:  BCF    03.5
0F09:  MOVWF  18
0F0A:  MOVLW  FF
0F0B:  MOVWF  31
0F0C:  CLRF   38
0F0D:  CLRF   39
0F0E:  CLRF   3A
0F0F:  CLRF   47
0F10:  CLRF   48
0F11:  CLRF   49
0F12:  CLRF   4A
0F13:  CLRF   4B
0F14:  CLRF   4C
0F15:  CLRF   4D
0F16:  BCF    4E.0
0F17:  BCF    4E.1
0F18:  BCF    4E.2
0F19:  BCF    4E.3
0F1A:  BCF    4E.4
0F1B:  BCF    4E.5
0F1C:  BSF    03.5
0F1D:  BSF    03.6
0F1E:  MOVF   09,W
0F1F:  ANDLW  C0
0F20:  MOVWF  09
0F21:  BCF    03.6
0F22:  BCF    1F.4
0F23:  BCF    1F.5
0F24:  MOVLW  00
0F25:  BSF    03.6
0F26:  MOVWF  08
0F27:  BCF    03.5
0F28:  CLRF   07
0F29:  CLRF   08
0F2A:  CLRF   09
0F2B:  BCF    03.7
....................  { 
....................     SET_TRIS_D (0X00); 
*
0F8C:  MOVLW  00
0F8D:  BSF    03.5
0F8E:  MOVWF  08
....................     SET_TRIS_B (0XFF); 
0F8F:  MOVLW  FF
0F90:  MOVWF  06
....................     SET_TRIS_E (0); 
0F91:  BCF    09.0
0F92:  BCF    09.1
0F93:  BCF    09.2
0F94:  BCF    09.3
....................     SET_TRIS_C (0X80); 
0F95:  MOVLW  80
0F96:  MOVWF  07
0F97:  BCF    03.5
0F98:  MOVWF  31
....................     SETUP_ADC (ADC_CLOCK_DIV_8); 
0F99:  BSF    1F.6
0F9A:  BCF    1F.7
0F9B:  BSF    03.5
0F9C:  BSF    1F.7
0F9D:  BCF    03.5
0F9E:  BSF    1F.0
....................     SETUP_ADC_PORTS (SAN0); 
0F9F:  BSF    03.5
0FA0:  BSF    03.6
0FA1:  MOVF   09,W
0FA2:  ANDLW  C0
0FA3:  MOVWF  09
0FA4:  BCF    03.6
0FA5:  BCF    1F.4
0FA6:  BCF    1F.5
0FA7:  MOVLW  01
0FA8:  BSF    03.6
0FA9:  MOVWF  08
....................     ENABLE_INTERRUPTS (INT_TIMER0); 
0FAA:  BCF    03.5
0FAB:  BCF    03.6
0FAC:  BSF    0B.5
....................     ENABLE_INTERRUPTS (INT_EXT); //CHO PHEP NGAT NGOAI 
0FAD:  BSF    0B.4
....................     ENABLE_INTERRUPTS (INT_EXT_H2L); //NGAT XAY RA KHI CO XUNG TU CAO XUONG THAP 
0FAE:  BSF    0B.4
0FAF:  BSF    03.5
0FB0:  BCF    01.6
....................     ENABLE_INTERRUPTS (INT_RDA); 
0FB1:  BSF    0C.5
....................     ENABLE_INTERRUPTS (GLOBAL); 
0FB2:  MOVLW  C0
0FB3:  BCF    03.5
0FB4:  IORWF  0B,F
....................      
....................     SETUP_TIMER_1 (T1_INTERNAL|T1_DIV_BY_8); 
0FB5:  MOVLW  35
0FB6:  MOVWF  10
....................     //SET_TIMER1 (0); 
....................     SET_TIMER1 (3036); 
0FB7:  CLRF   0E
0FB8:  MOVLW  0B
0FB9:  MOVWF  0F
0FBA:  MOVLW  DC
0FBB:  MOVWF  0E
....................     TMR1IF = 0; 
0FBC:  BCF    0C.0
....................     LCD_INIT (); // KHOI TAO LCD 
0FBD:  BCF    0A.3
0FBE:  GOTO   269
0FBF:  BSF    0A.3
....................  
....................     TT_CONFIG = 0; 
0FC0:  BCF    4E.1
....................     TT_CONFIG_DONE = 0; 
0FC1:  BCF    4E.3
....................     TT_CONTROL = 1; 
0FC2:  BSF    4E.2
....................     OUTPUT_D (0X00); 
0FC3:  BSF    03.5
0FC4:  CLRF   08
0FC5:  BCF    03.5
0FC6:  CLRF   08
....................     TTNHAN = 0; 
0FC7:  BCF    4E.0
....................      
....................     
....................     WHILE (TRUE) 
....................     { 
....................        IF (TT_CONFIG)             {BUTT_FUN (); } // GOI HAM CHON LENH (SWITCH CASE) 
0FC8:  BTFSS  4E.1
0FC9:  GOTO   7CE
0FCA:  BCF    0A.3
0FCB:  GOTO   549
0FCC:  BSF    0A.3
0FCD:  GOTO   7DC
....................        ELSE IF (TT_CONFIG_DONE)   { CONFIG_DONE ();}        
0FCE:  BTFSS  4E.3
0FCF:  GOTO   7D2
0FD0:  GOTO   000
0FD1:  GOTO   7DC
....................        ELSE 
....................        { 
....................           WHILE (!TT_CONFIG) 
0FD2:  BTFSC  4E.1
0FD3:  GOTO   7DC
....................           { 
....................              CHUONG_TRINH_CON ();              
0FD4:  BCF    0A.3
0FD5:  GOTO   7C4
0FD6:  BSF    0A.3
....................              IF (TTNHAN == 1) 
0FD7:  BTFSS  4E.0
0FD8:  GOTO   7DB
....................              { 
....................                 TTNHAN = 0; 
0FD9:  BCF    4E.0
....................                 XU_LY_UART(); 
0FDA:  GOTO   3C6
....................              } 
0FDB:  GOTO   7D2
....................           } 
....................        } 
0FDC:  GOTO   7C8
....................     } 
....................  } 
....................  
0FDD:  SLEEP

Configuration Fuses:
   Word  1: 2FE2   HS NOWDT PUT MCLR NOPROTECT NOCPD BROWNOUT IESO FCMEN NOLVP NODEBUG
   Word  2: 3FFF   BORV40 NOWRT
