CCS PCM C Compiler, Version 5.015, 5967               28-Oct-21 22:35

               Filename:   E:\DATN\NODE\pic\pic16f887\hellopic.lst

               ROM used:   3380 words (41%)
                           Largest free fragment is 2048
               RAM used:   112 (30%) at main() level
                           204 (55%) worst case
               Stack used: 7 locations (6 in main + 1 for interrupts)
               Stack size: 8

*
0000:  MOVLW  0C
0001:  MOVWF  0A
0002:  GOTO   49A
0003:  NOP
0004:  MOVWF  7F
0005:  SWAPF  03,W
0006:  CLRF   03
0007:  MOVWF  21
0008:  MOVF   0A,W
0009:  MOVWF  20
000A:  CLRF   0A
000B:  MOVF   04,W
000C:  MOVWF  22
000D:  MOVF   77,W
000E:  MOVWF  23
000F:  MOVF   78,W
0010:  MOVWF  24
0011:  MOVF   79,W
0012:  MOVWF  25
0013:  MOVF   7A,W
0014:  MOVWF  26
0015:  BSF    03.6
0016:  MOVF   0D,W
0017:  BCF    03.6
0018:  MOVWF  27
0019:  BSF    03.6
001A:  MOVF   0F,W
001B:  BCF    03.6
001C:  MOVWF  28
001D:  BSF    03.6
001E:  MOVF   0C,W
001F:  BCF    03.6
0020:  MOVWF  29
0021:  BSF    03.6
0022:  MOVF   0E,W
0023:  BCF    03.6
0024:  MOVWF  2A
0025:  BCF    03.7
0026:  BCF    03.5
0027:  BTFSS  0B.4
0028:  GOTO   02B
0029:  BTFSC  0B.1
002A:  GOTO   052
002B:  MOVLW  8C
002C:  MOVWF  04
002D:  BTFSS  00.5
002E:  GOTO   031
002F:  BTFSC  0C.5
0030:  GOTO   055
0031:  MOVF   22,W
0032:  MOVWF  04
0033:  MOVF   23,W
0034:  MOVWF  77
0035:  MOVF   24,W
0036:  MOVWF  78
0037:  MOVF   25,W
0038:  MOVWF  79
0039:  MOVF   26,W
003A:  MOVWF  7A
003B:  MOVF   27,W
003C:  BSF    03.6
003D:  MOVWF  0D
003E:  BCF    03.6
003F:  MOVF   28,W
0040:  BSF    03.6
0041:  MOVWF  0F
0042:  BCF    03.6
0043:  MOVF   29,W
0044:  BSF    03.6
0045:  MOVWF  0C
0046:  BCF    03.6
0047:  MOVF   2A,W
0048:  BSF    03.6
0049:  MOVWF  0E
004A:  BCF    03.6
004B:  MOVF   20,W
004C:  MOVWF  0A
004D:  SWAPF  21,W
004E:  MOVWF  03
004F:  SWAPF  7F,F
0050:  SWAPF  7F,W
0051:  RETFIE
0052:  BCF    0A.3
0053:  BCF    0A.4
0054:  GOTO   0D6
0055:  BCF    0A.3
0056:  BCF    0A.4
0057:  GOTO   107
....................  
.................... #INCLUDE <thuvien.c> 
.................... #INCLUDE <16F887.H> 
.................... //////////// Standard Header file for the PIC16F887 device //////////////// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2013 Custom Computer Services          //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... #device PIC16F887 
0058:  BCF    0A.0
0059:  BCF    0A.1
005A:  BCF    0A.2
005B:  ADDWF  02,F
005C:  RETLW  30
005D:  RETLW  00
005E:  BCF    0A.0
005F:  BCF    0A.1
0060:  BCF    0A.2
0061:  ADDWF  02,F
0062:  RETLW  23
0063:  RETLW  00
0064:  DATA CE,27
0065:  DATA C4,22
0066:  DATA 3A,10
0067:  DATA 00,00
0068:  DATA 30,18
0069:  DATA 30,18
006A:  DATA 20,10
006B:  DATA 20,10
006C:  DATA 20,10
006D:  DATA 20,10
006E:  DATA 20,10
006F:  DATA 00,01
0070:  DATA 20,10
0071:  DATA 20,10
0072:  DATA 20,10
0073:  DATA 5F,10
0074:  DATA 20,10
0075:  DATA 20,10
0076:  DATA 20,10
0077:  DATA 20,10
0078:  DATA 20,10
0079:  DATA 20,10
007A:  DATA 20,00
007B:  DATA 20,10
007C:  DATA 20,10
007D:  DATA 5F,10
007E:  DATA 20,10
007F:  DATA 20,00
0080:  DATA 49,22
0081:  DATA DF,23
0082:  DATA 57,1D
0083:  DATA 00,01
0084:  DATA 30,18
0085:  DATA 30,18
0086:  DATA 30,18
0087:  DATA 20,10
0088:  DATA 20,10
0089:  DATA 20,10
008A:  DATA 20,10
008B:  DATA 00,01
008C:  DATA 20,10
008D:  DATA 20,10
008E:  DATA 20,10
008F:  DATA 5F,10
0090:  DATA 20,10
0091:  DATA 20,10
0092:  DATA 20,10
0093:  DATA 20,10
0094:  DATA 20,10
0095:  DATA 20,10
0096:  DATA 20,10
0097:  DATA 20,00
0098:  DATA 20,10
0099:  DATA 20,10
009A:  DATA 5F,10
009B:  DATA 20,10
009C:  DATA 20,10
009D:  DATA 20,10
009E:  DATA 20,00
009F:  DATA C3,27
00A0:  DATA 4E,23
00A1:  DATA C9,23
00A2:  DATA 3A,10
00A3:  DATA 20,10
00A4:  DATA 20,10
00A5:  DATA 20,10
00A6:  DATA 20,00
00A7:  DATA C3,20
00A8:  DATA D3,22
00A9:  DATA 3A,10
00AA:  DATA 20,10
00AB:  DATA 20,10
00AC:  DATA 20,10
00AD:  DATA 20,10
00AE:  DATA 20,00
00AF:  DATA A0,16
00B0:  DATA A0,24
00B1:  DATA C4,16
00B2:  DATA CE,27
00B3:  DATA C4,22
00B4:  DATA 20,10
00B5:  DATA 20,10
00B6:  DATA 20,10
00B7:  DATA 00,01
00B8:  DATA A0,16
00B9:  DATA A0,24
00BA:  DATA C4,16
00BB:  DATA C7,2B
00BC:  DATA 20,10
00BD:  DATA 20,10
00BE:  DATA 20,10
00BF:  DATA 20,00
00C0:  DATA D7,20
00C1:  DATA 49,2A
00C2:  DATA 49,27
00C3:  DATA 47,10
00C4:  DATA 2E,17
00C5:  DATA 2E,17
00C6:  DATA 20,10
00C7:  DATA 20,10
00C8:  DATA 20,10
00C9:  DATA 20,10
00CA:  DATA 00,01
00CB:  DATA D7,20
00CC:  DATA 49,2A
00CD:  DATA 49,27
00CE:  DATA 47,10
00CF:  DATA 2E,17
00D0:  DATA 2E,17
00D1:  DATA 20,10
00D2:  DATA 20,10
00D3:  DATA 20,10
00D4:  DATA 20,10
00D5:  DATA 00,00
*
0300:  MOVF   0B,W
0301:  BSF    03.5
0302:  MOVWF  6C
0303:  BCF    03.5
0304:  BCF    0B.7
0305:  BSF    03.5
0306:  BSF    03.6
0307:  BSF    0C.7
0308:  BSF    0C.0
0309:  NOP
030A:  NOP
030B:  BCF    03.6
030C:  BTFSS  6C.7
030D:  GOTO   311
030E:  BCF    03.5
030F:  BSF    0B.7
0310:  BSF    03.5
0311:  BCF    03.5
0312:  BSF    03.6
0313:  MOVF   0C,W
0314:  ANDLW  7F
0315:  BTFSC  03.2
0316:  GOTO   372
0317:  BSF    03.5
0318:  BCF    03.6
0319:  MOVWF  6C
031A:  BCF    03.5
031B:  BSF    03.6
031C:  MOVF   0D,W
031D:  BSF    03.5
031E:  BCF    03.6
031F:  MOVWF  6D
0320:  BCF    03.5
0321:  BSF    03.6
0322:  MOVF   0F,W
0323:  BSF    03.5
0324:  BCF    03.6
0325:  MOVWF  6E
0326:  MOVF   6C,W
0327:  MOVWF  6F
0328:  BCF    03.5
0329:  CALL   2C2
032A:  BSF    03.5
032B:  MOVF   6D,W
032C:  BCF    03.5
032D:  BSF    03.6
032E:  MOVWF  0D
032F:  BSF    03.5
0330:  BCF    03.6
0331:  MOVF   6E,W
0332:  BCF    03.5
0333:  BSF    03.6
0334:  MOVWF  0F
0335:  BCF    03.6
0336:  MOVF   0B,W
0337:  BSF    03.5
0338:  MOVWF  6F
0339:  BCF    03.5
033A:  BCF    0B.7
033B:  BSF    03.5
033C:  BSF    03.6
033D:  BSF    0C.7
033E:  BSF    0C.0
033F:  NOP
0340:  NOP
0341:  BCF    03.6
0342:  BTFSS  6F.7
0343:  GOTO   347
0344:  BCF    03.5
0345:  BSF    0B.7
0346:  BSF    03.5
0347:  BCF    03.5
0348:  BSF    03.6
0349:  RLF    0C,W
034A:  RLF    0E,W
034B:  ANDLW  7F
034C:  BTFSC  03.2
034D:  GOTO   372
034E:  BSF    03.5
034F:  BCF    03.6
0350:  MOVWF  6C
0351:  BCF    03.5
0352:  BSF    03.6
0353:  MOVF   0D,W
0354:  BSF    03.5
0355:  BCF    03.6
0356:  MOVWF  6D
0357:  BCF    03.5
0358:  BSF    03.6
0359:  MOVF   0F,W
035A:  BSF    03.5
035B:  BCF    03.6
035C:  MOVWF  6E
035D:  MOVF   6C,W
035E:  MOVWF  6F
035F:  BCF    03.5
0360:  CALL   2C2
0361:  BSF    03.5
0362:  MOVF   6D,W
0363:  BCF    03.5
0364:  BSF    03.6
0365:  MOVWF  0D
0366:  BSF    03.5
0367:  BCF    03.6
0368:  MOVF   6E,W
0369:  BCF    03.5
036A:  BSF    03.6
036B:  MOVWF  0F
036C:  INCF   0D,F
036D:  BTFSC  03.2
036E:  INCF   0F,F
036F:  BCF    03.6
0370:  GOTO   300
0371:  BSF    03.6
0372:  BCF    03.6
0373:  RETURN
0374:  BTFSC  03.1
0375:  GOTO   379
0376:  MOVLW  30
0377:  MOVWF  04
0378:  BSF    03.7
0379:  BSF    03.6
037A:  MOVF   2B,W
037B:  XORWF  2F,W
037C:  ANDLW  80
037D:  MOVWF  35
037E:  BTFSS  2B.7
037F:  GOTO   38B
0380:  COMF   28,F
0381:  COMF   29,F
0382:  COMF   2A,F
0383:  COMF   2B,F
0384:  INCF   28,F
0385:  BTFSC  03.2
0386:  INCF   29,F
0387:  BTFSC  03.2
0388:  INCF   2A,F
0389:  BTFSC  03.2
038A:  INCF   2B,F
038B:  BTFSS  2F.7
038C:  GOTO   398
038D:  COMF   2C,F
038E:  COMF   2D,F
038F:  COMF   2E,F
0390:  COMF   2F,F
0391:  INCF   2C,F
0392:  BTFSC  03.2
0393:  INCF   2D,F
0394:  BTFSC  03.2
0395:  INCF   2E,F
0396:  BTFSC  03.2
0397:  INCF   2F,F
0398:  CLRF   77
0399:  CLRF   78
039A:  CLRF   79
039B:  CLRF   7A
039C:  CLRF   30
039D:  CLRF   31
039E:  CLRF   32
039F:  CLRF   33
03A0:  MOVF   2F,W
03A1:  IORWF  2E,W
03A2:  IORWF  2D,W
03A3:  IORWF  2C,W
03A4:  BTFSC  03.2
03A5:  GOTO   3D6
03A6:  MOVLW  20
03A7:  MOVWF  34
03A8:  BCF    03.0
03A9:  RLF    28,F
03AA:  RLF    29,F
03AB:  RLF    2A,F
03AC:  RLF    2B,F
03AD:  RLF    30,F
03AE:  RLF    31,F
03AF:  RLF    32,F
03B0:  RLF    33,F
03B1:  MOVF   2F,W
03B2:  SUBWF  33,W
03B3:  BTFSS  03.2
03B4:  GOTO   3BF
03B5:  MOVF   2E,W
03B6:  SUBWF  32,W
03B7:  BTFSS  03.2
03B8:  GOTO   3BF
03B9:  MOVF   2D,W
03BA:  SUBWF  31,W
03BB:  BTFSS  03.2
03BC:  GOTO   3BF
03BD:  MOVF   2C,W
03BE:  SUBWF  30,W
03BF:  BTFSS  03.0
03C0:  GOTO   3D0
03C1:  MOVF   2C,W
03C2:  SUBWF  30,F
03C3:  MOVF   2D,W
03C4:  BTFSS  03.0
03C5:  INCFSZ 2D,W
03C6:  SUBWF  31,F
03C7:  MOVF   2E,W
03C8:  BTFSS  03.0
03C9:  INCFSZ 2E,W
03CA:  SUBWF  32,F
03CB:  MOVF   2F,W
03CC:  BTFSS  03.0
03CD:  INCFSZ 2F,W
03CE:  SUBWF  33,F
03CF:  BSF    03.0
03D0:  RLF    77,F
03D1:  RLF    78,F
03D2:  RLF    79,F
03D3:  RLF    7A,F
03D4:  DECFSZ 34,F
03D5:  GOTO   3A8
03D6:  BTFSS  35.7
03D7:  GOTO   3E3
03D8:  COMF   77,F
03D9:  COMF   78,F
03DA:  COMF   79,F
03DB:  COMF   7A,F
03DC:  INCF   77,F
03DD:  BTFSC  03.2
03DE:  INCF   78,F
03DF:  BTFSC  03.2
03E0:  INCF   79,F
03E1:  BTFSC  03.2
03E2:  INCF   7A,F
03E3:  MOVF   30,W
03E4:  MOVWF  00
03E5:  INCF   04,F
03E6:  MOVF   31,W
03E7:  MOVWF  00
03E8:  INCF   04,F
03E9:  MOVF   32,W
03EA:  MOVWF  00
03EB:  INCF   04,F
03EC:  MOVF   33,W
03ED:  MOVWF  00
03EE:  BCF    03.6
03EF:  RETURN
*
0409:  MOVLW  20
040A:  MOVWF  2C
040B:  CLRF   28
040C:  CLRF   29
040D:  CLRF   2A
040E:  CLRF   2B
040F:  MOVF   23,W
0410:  MOVWF  7A
0411:  MOVF   22,W
0412:  MOVWF  79
0413:  MOVF   21,W
0414:  MOVWF  78
0415:  MOVF   20,W
0416:  MOVWF  77
0417:  BCF    03.0
0418:  BTFSS  77.0
0419:  GOTO   428
041A:  MOVF   24,W
041B:  ADDWF  28,F
041C:  MOVF   25,W
041D:  BTFSC  03.0
041E:  INCFSZ 25,W
041F:  ADDWF  29,F
0420:  MOVF   26,W
0421:  BTFSC  03.0
0422:  INCFSZ 26,W
0423:  ADDWF  2A,F
0424:  MOVF   27,W
0425:  BTFSC  03.0
0426:  INCFSZ 27,W
0427:  ADDWF  2B,F
0428:  RRF    2B,F
0429:  RRF    2A,F
042A:  RRF    29,F
042B:  RRF    28,F
042C:  RRF    7A,F
042D:  RRF    79,F
042E:  RRF    78,F
042F:  RRF    77,F
0430:  DECFSZ 2C,F
0431:  GOTO   417
*
0510:  MOVF   00,F
0511:  BTFSC  03.2
0512:  GOTO   52C
0513:  BSF    03.5
0514:  CLRF   40
0515:  MOVF   04,W
0516:  MOVWF  3F
0517:  BCF    40.0
0518:  BTFSC  03.7
0519:  BSF    40.0
051A:  MOVF   00,W
051B:  MOVWF  6F
051C:  BCF    03.5
051D:  CALL   2C2
051E:  BSF    03.5
051F:  MOVF   3F,W
0520:  MOVWF  04
0521:  BCF    03.7
0522:  BTFSC  40.0
0523:  BSF    03.7
0524:  INCF   04,F
0525:  BTFSS  03.2
0526:  GOTO   52A
0527:  BCF    03.5
0528:  INCF   05,F
0529:  BSF    03.5
052A:  BCF    03.5
052B:  GOTO   510
052C:  RETURN
052D:  BSF    03.5
052E:  MOVF   43,W
052F:  CLRF   78
0530:  SUBWF  42,W
0531:  BTFSC  03.0
0532:  GOTO   536
0533:  MOVF   42,W
0534:  MOVWF  77
0535:  GOTO   542
0536:  CLRF   77
0537:  MOVLW  08
0538:  MOVWF  44
0539:  RLF    42,F
053A:  RLF    77,F
053B:  MOVF   43,W
053C:  SUBWF  77,W
053D:  BTFSC  03.0
053E:  MOVWF  77
053F:  RLF    78,F
0540:  DECFSZ 44,F
0541:  GOTO   539
0542:  BCF    03.5
0543:  RETURN
*
0926:  MOVF   00,F
0927:  BTFSC  03.2
0928:  GOTO   141
0929:  CLRF   6F
092A:  MOVF   04,W
092B:  MOVWF  6E
092C:  BCF    6F.0
092D:  BTFSC  03.7
092E:  BSF    6F.0
092F:  MOVF   00,W
0930:  BCF    03.5
0931:  BTFSS  0C.4
0932:  GOTO   131
0933:  MOVWF  19
0934:  BSF    03.5
0935:  MOVF   6E,W
0936:  MOVWF  04
0937:  BCF    03.7
0938:  BTFSC  6F.0
0939:  BSF    03.7
093A:  INCF   04,F
093B:  BTFSS  03.2
093C:  GOTO   140
093D:  BCF    03.5
093E:  INCF   05,F
093F:  BSF    03.5
0940:  GOTO   126
*
09ED:  CLRF   77
09EE:  CLRF   78
09EF:  MOVF   4B,W
09F0:  BCF    03.0
09F1:  BTFSC  4C.0
09F2:  ADDWF  77,F
09F3:  RRF    77,F
09F4:  RRF    78,F
09F5:  BTFSC  4C.1
09F6:  ADDWF  77,F
09F7:  RRF    77,F
09F8:  RRF    78,F
09F9:  BTFSC  4C.2
09FA:  ADDWF  77,F
09FB:  RRF    77,F
09FC:  RRF    78,F
09FD:  BTFSC  4C.3
09FE:  ADDWF  77,F
09FF:  RRF    77,F
0A00:  RRF    78,F
0A01:  BTFSC  4C.4
0A02:  ADDWF  77,F
0A03:  RRF    77,F
0A04:  RRF    78,F
0A05:  BTFSC  4C.5
0A06:  ADDWF  77,F
0A07:  RRF    77,F
0A08:  RRF    78,F
0A09:  BTFSC  4C.6
0A0A:  ADDWF  77,F
0A0B:  RRF    77,F
0A0C:  RRF    78,F
0A0D:  BTFSC  4C.7
0A0E:  ADDWF  77,F
0A0F:  RRF    77,F
0A10:  RRF    78,F
*
0C91:  BCF    0A.0
0C92:  BCF    0A.1
0C93:  BSF    0A.2
0C94:  ADDWF  02,F
0C95:  GOTO   3F8
0C96:  GOTO   3F9
0C97:  GOTO   40E
0C98:  GOTO   41B
0C99:  GOTO   425
....................  
.................... #list 
....................  
.................... #DEVICE ADC=10 
.................... #INCLUDE <STRING.H> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
*
0761:  BSF    03.6
0762:  MOVF   11,W
0763:  MOVWF  15
0764:  MOVF   10,W
0765:  MOVWF  14
0766:  MOVF   15,W
0767:  MOVWF  7A
0768:  MOVF   14,W
0769:  MOVWF  04
076A:  BCF    03.7
076B:  BTFSC  7A.0
076C:  BSF    03.7
076D:  MOVF   00,F
076E:  BTFSC  03.2
076F:  GOTO   774
0770:  INCF   14,F
0771:  BTFSC  03.2
0772:  INCF   15,F
0773:  GOTO   766
....................    while(*s2 != '\0') 
0774:  MOVF   13,W
0775:  MOVWF  7A
0776:  MOVF   12,W
0777:  MOVWF  04
0778:  BCF    03.7
0779:  BTFSC  7A.0
077A:  BSF    03.7
077B:  MOVF   00,F
077C:  BTFSC  03.2
077D:  GOTO   793
....................    { 
....................       *s = *s2; 
077E:  MOVF   12,W
077F:  MOVWF  04
0780:  BCF    03.7
0781:  BTFSC  13.0
0782:  BSF    03.7
0783:  MOVF   00,W
0784:  MOVWF  18
0785:  MOVF   14,W
0786:  MOVWF  04
0787:  BCF    03.7
0788:  BTFSC  15.0
0789:  BSF    03.7
078A:  MOVF   18,W
078B:  MOVWF  00
....................       ++s; 
078C:  INCF   14,F
078D:  BTFSC  03.2
078E:  INCF   15,F
....................       ++s2; 
078F:  INCF   12,F
0790:  BTFSC  03.2
0791:  INCF   13,F
0792:  GOTO   774
....................    } 
....................  
....................    *s = '\0'; 
0793:  MOVF   14,W
0794:  MOVWF  04
0795:  BCF    03.7
0796:  BTFSC  15.0
0797:  BSF    03.7
0798:  CLRF   00
....................    return(s1); 
0799:  MOVF   10,W
079A:  MOVWF  78
079B:  MOVF   11,W
079C:  MOVWF  79
079D:  BCF    03.6
079E:  RETURN
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
*
0B79:  MOVF   45,W
0B7A:  MOVWF  7A
0B7B:  MOVF   44,W
0B7C:  MOVWF  04
0B7D:  BCF    03.7
0B7E:  BTFSC  7A.0
0B7F:  BSF    03.7
0B80:  MOVF   46,W
0B81:  SUBWF  00,W
0B82:  BTFSC  03.2
0B83:  GOTO   396
....................       if (*s == '\0') 
0B84:  MOVF   45,W
0B85:  MOVWF  7A
0B86:  MOVF   44,W
0B87:  MOVWF  04
0B88:  BCF    03.7
0B89:  BTFSC  7A.0
0B8A:  BSF    03.7
0B8B:  MOVF   00,F
0B8C:  BTFSS  03.2
0B8D:  GOTO   392
....................          return(0); 
0B8E:  MOVLW  00
0B8F:  MOVWF  78
0B90:  MOVWF  79
0B91:  GOTO   39A
0B92:  INCF   44,F
0B93:  BTFSC  03.2
0B94:  INCF   45,F
0B95:  GOTO   379
....................    return(s); 
0B96:  MOVF   44,W
0B97:  MOVWF  78
0B98:  MOVF   45,W
0B99:  MOVWF  79
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
*
0B0C:  MOVF   4D,W
0B0D:  MOVWF  51
0B0E:  MOVF   4C,W
0B0F:  MOVWF  50
0B10:  MOVF   51,W
0B11:  MOVWF  7A
0B12:  MOVF   50,W
0B13:  MOVWF  04
0B14:  BCF    03.7
0B15:  BTFSC  7A.0
0B16:  BSF    03.7
0B17:  MOVF   00,F
0B18:  BTFSC  03.2
0B19:  GOTO   349
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
0B1A:  MOVF   4F,W
0B1B:  MOVWF  53
0B1C:  MOVF   4E,W
0B1D:  MOVWF  52
0B1E:  MOVF   53,W
0B1F:  MOVWF  7A
0B20:  MOVF   52,W
0B21:  MOVWF  04
0B22:  BCF    03.7
0B23:  BTFSC  7A.0
0B24:  BSF    03.7
0B25:  MOVF   00,F
0B26:  BTFSC  03.2
0B27:  GOTO   345
....................          if (*sc1 == *sc2) 
0B28:  MOVF   51,W
0B29:  MOVWF  7A
0B2A:  MOVF   50,W
0B2B:  MOVWF  04
0B2C:  BCF    03.7
0B2D:  BTFSC  7A.0
0B2E:  BSF    03.7
0B2F:  MOVF   00,W
0B30:  MOVWF  54
0B31:  MOVF   53,W
0B32:  MOVWF  7A
0B33:  MOVF   52,W
0B34:  MOVWF  04
0B35:  BCF    03.7
0B36:  BTFSC  7A.0
0B37:  BSF    03.7
0B38:  MOVF   00,W
0B39:  SUBWF  54,W
0B3A:  BTFSS  03.2
0B3B:  GOTO   341
....................             return(sc1); 
0B3C:  MOVF   50,W
0B3D:  MOVWF  78
0B3E:  MOVF   51,W
0B3F:  MOVWF  79
0B40:  GOTO   34C
0B41:  INCF   52,F
0B42:  BTFSC  03.2
0B43:  INCF   53,F
0B44:  GOTO   31E
0B45:  INCF   50,F
0B46:  BTFSC  03.2
0B47:  INCF   51,F
0B48:  GOTO   310
....................    return(0); 
0B49:  MOVLW  00
0B4A:  MOVWF  78
0B4B:  MOVWF  79
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
*
0A99:  MOVF   4D,W
0A9A:  MOVWF  51
0A9B:  MOVF   4C,W
0A9C:  MOVWF  50
0A9D:  MOVF   51,W
0A9E:  MOVWF  7A
0A9F:  MOVF   50,W
0AA0:  MOVWF  04
0AA1:  BCF    03.7
0AA2:  BTFSC  7A.0
0AA3:  BSF    03.7
0AA4:  MOVF   00,F
0AA5:  BTFSC  03.2
0AA6:  GOTO   2DE
....................       for (sc2 = s2; ; sc2++) 
0AA7:  MOVF   4F,W
0AA8:  MOVWF  53
0AA9:  MOVF   4E,W
0AAA:  MOVWF  52
....................     if (*sc2 == '\0') 
0AAB:  MOVF   53,W
0AAC:  MOVWF  7A
0AAD:  MOVF   52,W
0AAE:  MOVWF  04
0AAF:  BCF    03.7
0AB0:  BTFSC  7A.0
0AB1:  BSF    03.7
0AB2:  MOVF   00,F
0AB3:  BTFSS  03.2
0AB4:  GOTO   2C2
....................        return(sc1 - s1); 
0AB5:  MOVF   4C,W
0AB6:  SUBWF  50,W
0AB7:  MOVWF  77
0AB8:  MOVF   51,W
0AB9:  MOVWF  7A
0ABA:  MOVF   4D,W
0ABB:  BTFSS  03.0
0ABC:  INCFSZ 4D,W
0ABD:  SUBWF  7A,F
0ABE:  MOVF   77,W
0ABF:  MOVWF  78
0AC0:  GOTO   2E9
0AC1:  GOTO   2D6
....................          else if (*sc1 == *sc2) 
0AC2:  MOVF   51,W
0AC3:  MOVWF  7A
0AC4:  MOVF   50,W
0AC5:  MOVWF  04
0AC6:  BCF    03.7
0AC7:  BTFSC  7A.0
0AC8:  BSF    03.7
0AC9:  MOVF   00,W
0ACA:  MOVWF  54
0ACB:  MOVF   53,W
0ACC:  MOVWF  7A
0ACD:  MOVF   52,W
0ACE:  MOVWF  04
0ACF:  BCF    03.7
0AD0:  BTFSC  7A.0
0AD1:  BSF    03.7
0AD2:  MOVF   00,W
0AD3:  SUBWF  54,W
0AD4:  BTFSC  03.2
....................             break; 
0AD5:  GOTO   2DA
0AD6:  INCF   52,F
0AD7:  BTFSC  03.2
0AD8:  INCF   53,F
0AD9:  GOTO   2AB
0ADA:  INCF   50,F
0ADB:  BTFSC  03.2
0ADC:  INCF   51,F
0ADD:  GOTO   29D
....................    return(sc1 - s1); 
0ADE:  MOVF   4C,W
0ADF:  SUBWF  50,W
0AE0:  MOVWF  77
0AE1:  MOVF   51,W
0AE2:  MOVWF  7A
0AE3:  MOVF   4D,W
0AE4:  BTFSS  03.0
0AE5:  INCFSZ 4D,W
0AE6:  SUBWF  7A,F
0AE7:  MOVF   77,W
0AE8:  MOVWF  78
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
*
0CC8:  BCF    03.6
0CC9:  CLRF   2B
0CCA:  CLRF   2C
....................  
....................    beg = (s1)? s1: save; 
*
0A80:  BSF    03.5
0A81:  MOVF   44,W
0A82:  IORWF  45,W
0A83:  BTFSC  03.2
0A84:  GOTO   289
0A85:  MOVF   45,W
0A86:  MOVWF  7A
0A87:  MOVF   44,W
0A88:  GOTO   28E
0A89:  BCF    03.5
0A8A:  MOVF   2C,W
0A8B:  MOVWF  7A
0A8C:  MOVF   2B,W
0A8D:  BSF    03.5
0A8E:  MOVWF  48
0A8F:  MOVF   7A,W
0A90:  MOVWF  49
....................    beg += strspn(beg, s2); 
0A91:  MOVF   49,W
0A92:  MOVWF  4D
0A93:  MOVF   48,W
0A94:  MOVWF  4C
0A95:  MOVF   47,W
0A96:  MOVWF  4F
0A97:  MOVF   46,W
0A98:  MOVWF  4E
*
0AE9:  MOVF   78,W
0AEA:  ADDWF  48,F
0AEB:  BTFSC  03.0
0AEC:  INCF   49,F
....................    if (*beg == '\0') 
0AED:  MOVF   49,W
0AEE:  MOVWF  7A
0AEF:  MOVF   48,W
0AF0:  MOVWF  04
0AF1:  BCF    03.7
0AF2:  BTFSC  7A.0
0AF3:  BSF    03.7
0AF4:  MOVF   00,F
0AF5:  BTFSS  03.2
0AF6:  GOTO   304
....................    { 
....................       *save = ' '; 
0AF7:  BCF    03.5
0AF8:  MOVF   2B,W
0AF9:  MOVWF  04
0AFA:  BCF    03.7
0AFB:  BTFSC  2C.0
0AFC:  BSF    03.7
0AFD:  MOVLW  20
0AFE:  MOVWF  00
....................       return(0); 
0AFF:  MOVLW  00
0B00:  MOVWF  78
0B01:  MOVWF  79
0B02:  GOTO   370
0B03:  BSF    03.5
....................    } 
....................    end = strpbrk(beg, s2); 
0B04:  MOVF   49,W
0B05:  MOVWF  4D
0B06:  MOVF   48,W
0B07:  MOVWF  4C
0B08:  MOVF   47,W
0B09:  MOVWF  4F
0B0A:  MOVF   46,W
0B0B:  MOVWF  4E
*
0B4C:  MOVF   79,W
0B4D:  MOVWF  4B
0B4E:  MOVF   78,W
0B4F:  MOVWF  4A
....................    if (*end != '\0') 
0B50:  MOVF   4B,W
0B51:  MOVWF  7A
0B52:  MOVF   4A,W
0B53:  MOVWF  04
0B54:  BCF    03.7
0B55:  BTFSC  7A.0
0B56:  BSF    03.7
0B57:  MOVF   00,F
0B58:  BTFSC  03.2
0B59:  GOTO   363
....................    { 
....................       *end = '\0'; 
0B5A:  MOVF   4A,W
0B5B:  MOVWF  04
0B5C:  BCF    03.7
0B5D:  BTFSC  4B.0
0B5E:  BSF    03.7
0B5F:  CLRF   00
....................       end++; 
0B60:  INCF   4A,F
0B61:  BTFSC  03.2
0B62:  INCF   4B,F
....................    } 
....................    save = end; 
0B63:  MOVF   4B,W
0B64:  BCF    03.5
0B65:  MOVWF  2C
0B66:  BSF    03.5
0B67:  MOVF   4A,W
0B68:  BCF    03.5
0B69:  MOVWF  2B
....................    return(beg); 
0B6A:  BSF    03.5
0B6B:  MOVF   48,W
0B6C:  MOVWF  78
0B6D:  MOVF   49,W
0B6E:  MOVWF  79
0B6F:  BCF    03.5
0B70:  RETURN
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
*
079F:  BSF    03.5
07A0:  MOVF   6F,W
07A1:  BCF    03.5
07A2:  BSF    03.6
07A3:  MOVWF  11
07A4:  BSF    03.5
07A5:  BCF    03.6
07A6:  MOVF   6E,W
07A7:  BCF    03.5
07A8:  BSF    03.6
07A9:  MOVWF  10
07AA:  MOVF   11,W
07AB:  MOVWF  7A
07AC:  MOVF   10,W
07AD:  MOVWF  04
07AE:  BCF    03.7
07AF:  BTFSC  7A.0
07B0:  BSF    03.7
07B1:  MOVF   00,F
07B2:  BTFSC  03.2
07B3:  GOTO   7B8
07B4:  INCF   10,F
07B5:  BTFSC  03.2
07B6:  INCF   11,F
07B7:  GOTO   7AA
....................    return(sc - s); 
07B8:  BSF    03.5
07B9:  BCF    03.6
07BA:  MOVF   6E,W
07BB:  BCF    03.5
07BC:  BSF    03.6
07BD:  SUBWF  10,W
07BE:  MOVWF  77
07BF:  MOVF   11,W
07C0:  MOVWF  7A
07C1:  BSF    03.5
07C2:  BCF    03.6
07C3:  MOVF   6F,W
07C4:  BTFSS  03.0
07C5:  INCFSZ 6F,W
07C6:  SUBWF  7A,F
07C7:  MOVF   77,W
07C8:  MOVWF  78
07C9:  BCF    03.5
07CA:  RETURN
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #INCLUDE <STDLIB.H> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... /* Standart template: float strtof(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... float strtof(char *s,char *endptr); 
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s,char *endptr); 
.................... float64 strtod(char *s,char *endptr); 
.................... #else 
.................... //provided for compatibility 
.................... #define strtof48(s, e) strtof(s, e) 
.................... #define strtod(s, e) strtof(s, e) 
.................... #endif 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof(s)   strtof(s, 0) 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof48(s) strtof48(s, 0) 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof64(s) strtod(s, 0) 
.................... #endif 
....................  
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float atoe(char * s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s); 
.................... #endif 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... unsigned int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................  
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
*
097E:  BSF    03.5
097F:  CLRF   49
....................    sign = 0; 
0980:  CLRF   47
....................    base = 10; 
0981:  MOVLW  0A
0982:  MOVWF  48
....................    result = 0; 
0983:  CLRF   46
....................  
....................    if (!s) 
0984:  MOVF   44,W
0985:  IORWF  45,W
0986:  BTFSS  03.2
0987:  GOTO   18B
....................       return 0; 
0988:  MOVLW  00
0989:  MOVWF  78
098A:  GOTO   27E
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
098B:  MOVF   49,W
098C:  INCF   49,F
098D:  ADDWF  44,W
098E:  MOVWF  04
098F:  BCF    03.7
0990:  BTFSC  45.0
0991:  BSF    03.7
0992:  MOVF   00,W
0993:  MOVWF  4A
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
0994:  MOVF   4A,W
0995:  SUBLW  2D
0996:  BTFSS  03.2
0997:  GOTO   1A4
....................    { 
....................       sign = 1;         // Set the sign to negative 
0998:  MOVLW  01
0999:  MOVWF  47
....................       c = s[index++]; 
099A:  MOVF   49,W
099B:  INCF   49,F
099C:  ADDWF  44,W
099D:  MOVWF  04
099E:  BCF    03.7
099F:  BTFSC  45.0
09A0:  BSF    03.7
09A1:  MOVF   00,W
09A2:  MOVWF  4A
....................    } 
09A3:  GOTO   1B1
....................    else if (c == '+') 
09A4:  MOVF   4A,W
09A5:  SUBLW  2B
09A6:  BTFSS  03.2
09A7:  GOTO   1B1
....................    { 
....................       c = s[index++]; 
09A8:  MOVF   49,W
09A9:  INCF   49,F
09AA:  ADDWF  44,W
09AB:  MOVWF  04
09AC:  BCF    03.7
09AD:  BTFSC  45.0
09AE:  BSF    03.7
09AF:  MOVF   00,W
09B0:  MOVWF  4A
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
09B1:  MOVF   4A,W
09B2:  SUBLW  2F
09B3:  BTFSC  03.0
09B4:  GOTO   274
09B5:  MOVF   4A,W
09B6:  SUBLW  39
09B7:  BTFSS  03.0
09B8:  GOTO   274
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
09B9:  MOVF   4A,W
09BA:  SUBLW  30
09BB:  BTFSS  03.2
09BC:  GOTO   1DD
09BD:  MOVF   49,W
09BE:  ADDWF  44,W
09BF:  MOVWF  04
09C0:  BCF    03.7
09C1:  BTFSC  45.0
09C2:  BSF    03.7
09C3:  MOVF   00,W
09C4:  SUBLW  78
09C5:  BTFSC  03.2
09C6:  GOTO   1D1
09C7:  MOVF   49,W
09C8:  ADDWF  44,W
09C9:  MOVWF  04
09CA:  BCF    03.7
09CB:  BTFSC  45.0
09CC:  BSF    03.7
09CD:  MOVF   00,W
09CE:  SUBLW  58
09CF:  BTFSS  03.2
09D0:  GOTO   1DD
....................       { 
....................          base = 16; 
09D1:  MOVLW  10
09D2:  MOVWF  48
....................          index++; 
09D3:  INCF   49,F
....................          c = s[index++]; 
09D4:  MOVF   49,W
09D5:  INCF   49,F
09D6:  ADDWF  44,W
09D7:  MOVWF  04
09D8:  BCF    03.7
09D9:  BTFSC  45.0
09DA:  BSF    03.7
09DB:  MOVF   00,W
09DC:  MOVWF  4A
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
09DD:  MOVF   48,W
09DE:  SUBLW  0A
09DF:  BTFSS  03.2
09E0:  GOTO   222
....................       { 
....................          while (c >= '0' && c <= '9') 
09E1:  MOVF   4A,W
09E2:  SUBLW  2F
09E3:  BTFSC  03.0
09E4:  GOTO   221
09E5:  MOVF   4A,W
09E6:  SUBLW  39
09E7:  BTFSS  03.0
09E8:  GOTO   221
....................          { 
....................             result = 10*result + (c - '0'); 
09E9:  MOVLW  0A
09EA:  MOVWF  4B
09EB:  MOVF   46,W
09EC:  MOVWF  4C
*
0A11:  MOVF   78,W
0A12:  MOVWF  4B
0A13:  MOVLW  30
0A14:  SUBWF  4A,W
0A15:  ADDWF  4B,W
0A16:  MOVWF  46
....................             c = s[index++]; 
0A17:  MOVF   49,W
0A18:  INCF   49,F
0A19:  ADDWF  44,W
0A1A:  MOVWF  04
0A1B:  BCF    03.7
0A1C:  BTFSC  45.0
0A1D:  BSF    03.7
0A1E:  MOVF   00,W
0A1F:  MOVWF  4A
0A20:  GOTO   1E1
....................          } 
....................       } 
0A21:  GOTO   274
....................       else if (base == 16)    // The number is a hexa number 
0A22:  MOVF   48,W
0A23:  SUBLW  10
0A24:  BTFSS  03.2
0A25:  GOTO   274
....................       { 
....................          c = toupper(c); 
0A26:  MOVF   4A,W
0A27:  SUBLW  60
0A28:  BTFSC  03.0
0A29:  GOTO   231
0A2A:  MOVF   4A,W
0A2B:  SUBLW  7A
0A2C:  BTFSS  03.0
0A2D:  GOTO   231
0A2E:  MOVF   4A,W
0A2F:  ANDLW  DF
0A30:  GOTO   232
0A31:  MOVF   4A,W
0A32:  MOVWF  4A
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
0A33:  MOVF   4A,W
0A34:  SUBLW  2F
0A35:  BTFSC  03.0
0A36:  GOTO   23B
0A37:  MOVF   4A,W
0A38:  SUBLW  39
0A39:  BTFSC  03.0
0A3A:  GOTO   243
0A3B:  MOVF   4A,W
0A3C:  SUBLW  40
0A3D:  BTFSC  03.0
0A3E:  GOTO   274
0A3F:  MOVF   4A,W
0A40:  SUBLW  46
0A41:  BTFSS  03.0
0A42:  GOTO   274
....................          { 
....................             if (c >= '0' && c <= '9') 
0A43:  MOVF   4A,W
0A44:  SUBLW  2F
0A45:  BTFSC  03.0
0A46:  GOTO   254
0A47:  MOVF   4A,W
0A48:  SUBLW  39
0A49:  BTFSS  03.0
0A4A:  GOTO   254
....................                result = (result << 4) + (c - '0'); 
0A4B:  SWAPF  46,W
0A4C:  MOVWF  4B
0A4D:  MOVLW  F0
0A4E:  ANDWF  4B,F
0A4F:  MOVLW  30
0A50:  SUBWF  4A,W
0A51:  ADDWF  4B,W
0A52:  MOVWF  46
0A53:  GOTO   25D
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
0A54:  SWAPF  46,W
0A55:  MOVWF  4B
0A56:  MOVLW  F0
0A57:  ANDWF  4B,F
0A58:  MOVLW  41
0A59:  SUBWF  4A,W
0A5A:  ADDLW  0A
0A5B:  ADDWF  4B,W
0A5C:  MOVWF  46
....................  
....................             c = s[index++]; 
0A5D:  MOVF   49,W
0A5E:  INCF   49,F
0A5F:  ADDWF  44,W
0A60:  MOVWF  04
0A61:  BCF    03.7
0A62:  BTFSC  45.0
0A63:  BSF    03.7
0A64:  MOVF   00,W
0A65:  MOVWF  4A
....................             c = toupper(c); 
0A66:  MOVF   4A,W
0A67:  SUBLW  60
0A68:  BTFSC  03.0
0A69:  GOTO   271
0A6A:  MOVF   4A,W
0A6B:  SUBLW  7A
0A6C:  BTFSS  03.0
0A6D:  GOTO   271
0A6E:  MOVF   4A,W
0A6F:  ANDLW  DF
0A70:  GOTO   272
0A71:  MOVF   4A,W
0A72:  MOVWF  4A
0A73:  GOTO   233
....................          } 
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
0A74:  DECFSZ 47,W
0A75:  GOTO   27C
0A76:  MOVF   48,W
0A77:  SUBLW  0A
0A78:  BTFSS  03.2
0A79:  GOTO   27C
....................        result = -result; 
0A7A:  COMF   46,F
0A7B:  INCF   46,F
....................  
....................    return(result); 
0A7C:  MOVF   46,W
0A7D:  MOVWF  78
0A7E:  BCF    03.5
0A7F:  RETURN
.................... } 
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
*
03F0:  BSF    03.6
03F1:  CLRF   1B
03F2:  CLRF   1A
03F3:  CLRF   19
03F4:  MOVLW  01
03F5:  MOVWF  18
03F6:  CLRF   1D
03F7:  CLRF   1E
.................... { 
....................      unsigned int32 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
03F8:  BTFSS  14.7
03F9:  GOTO   43A
....................          sign=1;        // Check for negative number 
03FA:  MOVLW  01
03FB:  MOVWF  1D
....................          num*=-1; 
03FC:  MOVF   14,W
03FD:  MOVWF  23
03FE:  MOVF   13,W
03FF:  MOVWF  22
0400:  MOVF   12,W
0401:  MOVWF  21
0402:  MOVF   11,W
0403:  MOVWF  20
0404:  MOVLW  FF
0405:  MOVWF  27
0406:  MOVWF  26
0407:  MOVWF  25
0408:  MOVWF  24
*
0432:  MOVF   7A,W
0433:  MOVWF  14
0434:  MOVF   79,W
0435:  MOVWF  13
0436:  MOVF   78,W
0437:  MOVWF  12
0438:  MOVF   77,W
0439:  MOVWF  11
....................      } 
....................  
....................      while(temp>0) { 
043A:  MOVF   18,F
043B:  BTFSS  03.2
043C:  GOTO   446
043D:  MOVF   19,F
043E:  BTFSS  03.2
043F:  GOTO   446
0440:  MOVF   1A,F
0441:  BTFSS  03.2
0442:  GOTO   446
0443:  MOVF   1B,F
0444:  BTFSC  03.2
0445:  GOTO   4C2
....................          temp=(num/base); 
0446:  BCF    03.1
0447:  MOVF   14,W
0448:  MOVWF  2B
0449:  MOVF   13,W
044A:  MOVWF  2A
044B:  MOVF   12,W
044C:  MOVWF  29
044D:  MOVF   11,W
044E:  MOVWF  28
044F:  CLRF   2F
0450:  CLRF   2E
0451:  CLRF   2D
0452:  MOVF   15,W
0453:  MOVWF  2C
0454:  BCF    03.6
0455:  CALL   374
0456:  MOVF   7A,W
0457:  BSF    03.6
0458:  MOVWF  1B
0459:  MOVF   79,W
045A:  MOVWF  1A
045B:  MOVF   78,W
045C:  MOVWF  19
045D:  MOVF   77,W
045E:  MOVWF  18
....................          s[cnt]=(num%base)+'0';    // Conversion 
045F:  MOVF   1E,W
0460:  ADDWF  16,W
0461:  MOVWF  78
0462:  MOVF   17,W
0463:  MOVWF  7A
0464:  BTFSC  03.0
0465:  INCF   7A,F
0466:  MOVF   78,W
0467:  MOVWF  20
0468:  MOVF   7A,W
0469:  MOVWF  21
046A:  CLRF   23
046B:  MOVF   04,W
046C:  MOVWF  22
046D:  BCF    23.0
046E:  BTFSC  03.7
046F:  BSF    23.0
0470:  BSF    03.1
0471:  MOVLW  24
0472:  MOVWF  04
0473:  BSF    03.7
0474:  MOVF   14,W
0475:  MOVWF  2B
0476:  MOVF   13,W
0477:  MOVWF  2A
0478:  MOVF   12,W
0479:  MOVWF  29
047A:  MOVF   11,W
047B:  MOVWF  28
047C:  CLRF   2F
047D:  CLRF   2E
047E:  CLRF   2D
047F:  MOVF   15,W
0480:  MOVWF  2C
0481:  BCF    03.6
0482:  CALL   374
0483:  BSF    03.6
0484:  MOVF   22,W
0485:  MOVWF  04
0486:  BCF    03.7
0487:  BTFSC  23.0
0488:  BSF    03.7
0489:  MOVLW  30
048A:  ADDWF  24,W
048B:  MOVWF  77
048C:  MOVF   25,W
048D:  MOVWF  78
048E:  MOVLW  00
048F:  BTFSC  03.0
0490:  MOVLW  01
0491:  ADDWF  78,F
0492:  MOVF   26,W
0493:  MOVWF  79
0494:  MOVLW  00
0495:  BTFSC  03.0
0496:  MOVLW  01
0497:  ADDWF  79,F
0498:  MOVF   27,W
0499:  MOVWF  7A
049A:  MOVLW  00
049B:  BTFSC  03.0
049C:  MOVLW  01
049D:  ADDWF  7A,F
049E:  MOVF   20,W
049F:  MOVWF  04
04A0:  BCF    03.7
04A1:  BTFSC  21.0
04A2:  BSF    03.7
04A3:  MOVF   77,W
04A4:  MOVWF  00
....................  
....................          if(s[cnt]>0x39) 
04A5:  MOVF   1E,W
04A6:  ADDWF  16,W
04A7:  MOVWF  04
04A8:  BCF    03.7
04A9:  BTFSC  17.0
04AA:  BSF    03.7
04AB:  MOVF   00,W
04AC:  SUBLW  39
04AD:  BTFSC  03.0
04AE:  GOTO   4B8
....................             s[cnt]+=0x7; 
04AF:  MOVF   1E,W
04B0:  ADDWF  16,W
04B1:  MOVWF  04
04B2:  BCF    03.7
04B3:  BTFSC  17.0
04B4:  BSF    03.7
04B5:  MOVLW  07
04B6:  ADDWF  00,W
04B7:  MOVWF  00
....................  
....................          cnt++; 
04B8:  INCF   1E,F
....................          num=temp; 
04B9:  MOVF   1B,W
04BA:  MOVWF  14
04BB:  MOVF   1A,W
04BC:  MOVWF  13
04BD:  MOVF   19,W
04BE:  MOVWF  12
04BF:  MOVF   18,W
04C0:  MOVWF  11
04C1:  GOTO   43A
....................      } 
....................  
....................      if(sign==1) { 
04C2:  DECFSZ 1D,W
04C3:  GOTO   4CD
....................          s[cnt]=0x2D;      // Negative sign 
04C4:  MOVF   1E,W
04C5:  ADDWF  16,W
04C6:  MOVWF  04
04C7:  BCF    03.7
04C8:  BTFSC  17.0
04C9:  BSF    03.7
04CA:  MOVLW  2D
04CB:  MOVWF  00
....................          cnt++; 
04CC:  INCF   1E,F
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
04CD:  CLRF   1C
04CE:  BCF    03.0
04CF:  RRF    1E,W
04D0:  SUBWF  1C,W
04D1:  BTFSC  03.0
04D2:  GOTO   503
....................  
....................          c=s[i]; 
04D3:  MOVF   1C,W
04D4:  ADDWF  16,W
04D5:  MOVWF  04
04D6:  BCF    03.7
04D7:  BTFSC  17.0
04D8:  BSF    03.7
04D9:  MOVF   00,W
04DA:  MOVWF  1F
....................          s[i]=s[cnt-i-1];        // Reverse the number 
04DB:  MOVF   1C,W
04DC:  ADDWF  16,W
04DD:  MOVWF  78
04DE:  MOVF   17,W
04DF:  MOVWF  7A
04E0:  BTFSC  03.0
04E1:  INCF   7A,F
04E2:  MOVF   78,W
04E3:  MOVWF  20
04E4:  MOVF   7A,W
04E5:  MOVWF  21
04E6:  MOVF   1C,W
04E7:  SUBWF  1E,W
04E8:  ADDLW  FF
04E9:  ADDWF  16,W
04EA:  MOVWF  04
04EB:  BCF    03.7
04EC:  BTFSC  17.0
04ED:  BSF    03.7
04EE:  MOVF   00,W
04EF:  MOVWF  22
04F0:  MOVF   20,W
04F1:  MOVWF  04
04F2:  BCF    03.7
04F3:  BTFSC  21.0
04F4:  BSF    03.7
04F5:  MOVF   22,W
04F6:  MOVWF  00
....................          s[cnt-i-1]=c; 
04F7:  MOVF   1C,W
04F8:  SUBWF  1E,W
04F9:  ADDLW  FF
04FA:  ADDWF  16,W
04FB:  MOVWF  04
04FC:  BCF    03.7
04FD:  BTFSC  17.0
04FE:  BSF    03.7
04FF:  MOVF   1F,W
0500:  MOVWF  00
0501:  INCF   1C,F
0502:  GOTO   4CE
....................      } 
....................      s[cnt]='\0';     // End the string 
0503:  MOVF   1E,W
0504:  ADDWF  16,W
0505:  MOVWF  04
0506:  BCF    03.7
0507:  BTFSC  17.0
0508:  BSF    03.7
0509:  CLRF   00
....................      return s; 
050A:  MOVF   16,W
050B:  MOVWF  78
050C:  MOVF   17,W
050D:  MOVWF  79
050E:  BCF    03.6
050F:  RETURN
.................... } 
....................  
.................... #if defined(__PCD__) 
....................  
.................... char * itoa(signed int48 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int48 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... char * itoa(signed int64 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int64 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................       
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1;         
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................              
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #endif 
....................  
.................... float strtof(char *s, char *endptr) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s, char *endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float48)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float48)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s, char *endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float64)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float64)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtoulGO; 
....................  
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................    { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... int8 mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #if !defined(__PCD__) 
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2);  
.................... #else  
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2);  
.................... #endif 
....................  
....................  
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    unsigned int8 t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=1; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = 0; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
.................... #INCLUDE <STDIO.H> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDIO 
.................... #define _STDIO 
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #ifndef getc 
.................... #define getc getch 
.................... #define getchar getch 
.................... #define puts(s) {printf(s); putchar(13); putchar(10);} 
.................... #define putc putchar 
.................... #endif 
.................... /* maps error number to an error message. Writes a sequence of characters to 
.................... stderr stream thus: if s is not null then string pointed to by s follwed by 
.................... a colon (:) and a space and the appropriate error message returned by strerror 
.................... function with argument errno 
....................  
.................... Returns: no value 
.................... */ 
....................  
.................... #ifdef _ERRNO 
.................... void perror(char *s) 
.................... { 
....................   if(s) 
....................   fprintf(STDERR,"%s: ",s); 
....................   fprintf(STDERR,"%s\r\n",strerror(errno)); 
.................... } 
.................... #endif 
.................... #endif 
....................  
.................... #FUSES NOWDT, PUT, HS 
.................... #USE DELAY(CLOCK=20M) 
*
0124:  MOVLW  10
0125:  MOVWF  04
0126:  BSF    03.7
0127:  MOVF   00,W
0128:  BTFSC  03.2
0129:  GOTO   137
012A:  MOVLW  06
012B:  MOVWF  78
012C:  CLRF   77
012D:  DECFSZ 77,F
012E:  GOTO   12D
012F:  DECFSZ 78,F
0130:  GOTO   12C
0131:  MOVLW  7B
0132:  MOVWF  77
0133:  DECFSZ 77,F
0134:  GOTO   133
0135:  DECFSZ 00,F
0136:  GOTO   12A
0137:  RETURN
.................... #USE RS232(BAUD=9600,XMIT=PIN_C6,RCV=PIN_C7) 
.................... #DEFINE BT1_PIN PIN_B1 
.................... #DEFINE BT2_PIN PIN_B2 
.................... #DEFINE BT3_PIN PIN_B3 
.................... #DEFINE LCD_ENABLE_PIN  PIN_E0                                    
.................... #DEFINE LCD_RS_PIN      PIN_E1                                 
.................... #DEFINE LCD_RW_PIN      PIN_E2   
.................... #DEFINE LCD_DATA4       PIN_C0                                
.................... #DEFINE LCD_DATA5       PIN_C1                                  
.................... #DEFINE LCD_DATA6       PIN_C2                                    
.................... #DEFINE LCD_DATA7       PIN_C3   
.................... #INCLUDE <LCD.C> 
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... ////                             LCD.C                                     //// 
.................... ////                 Driver for common LCD modules                         //// 
.................... ////                                                                       //// 
.................... ////  lcd_init()   Must be called before any other function.               //// 
.................... ////                                                                       //// 
.................... ////  lcd_putc(c)  Will display c on the next position of the LCD.         //// 
.................... ////                 \a  Set cursor position to upper left                 //// 
.................... ////                 \f  Clear display, set cursor to upper left           //// 
.................... ////                 \n  Go to start of second line                        //// 
.................... ////                 \b  Move back one position                            //// 
.................... ////              If LCD_EXTENDED_NEWLINE is defined, the \n character     //// 
.................... ////              will erase all remanining characters on the current      //// 
.................... ////              line, and move the cursor to the beginning of the next   //// 
.................... ////              line.                                                    //// 
.................... ////              If LCD_EXTENDED_NEWLINE is defined, the \r character     //// 
.................... ////              will move the cursor to the start of the current         //// 
.................... ////              line.                                                    //// 
.................... ////                                                                       //// 
.................... ////  lcd_gotoxy(x,y) Set write position on LCD (upper left is 1,1)        //// 
.................... ////                                                                       //// 
.................... ////  lcd_getc(x,y)   Returns character at position x,y on LCD             //// 
.................... ////                                                                       //// 
.................... ////  lcd_cursor_on(int1 on)   Turn the cursor on (on=TRUE) or off         //// 
.................... ////              (on=FALSE).                                              //// 
.................... ////                                                                       //// 
.................... ////  lcd_set_cgram_char(w, *p)   Write a custom character to the CGRAM.   //// 
.................... ////                                                                       //// 
.................... ////                                                                       //// 
.................... ////  CONFIGURATION                                                        //// 
.................... ////  The LCD can be configured in one of two ways: a.) port access or     //// 
.................... ////  b.) pin access.  Port access requires the entire 7 bit interface     //// 
.................... ////  connected to one GPIO port, and the data bits (D4:D7 of the LCD)     //// 
.................... ////  connected to sequential pins on the GPIO.  Pin access                //// 
.................... ////  has no requirements, all 7 bits of the control interface can         //// 
.................... ////  can be connected to any GPIO using several ports.                    //// 
.................... ////                                                                       //// 
.................... ////  To use port access, #define LCD_DATA_PORT to the SFR location of     //// 
.................... ////  of the GPIO port that holds the interface, -AND- edit LCD_PIN_MAP    //// 
.................... ////  of this file to configure the pin order.  If you are using a         //// 
.................... ////  baseline PIC (PCB), then LCD_OUTPUT_MAP and LCD_INPUT_MAP also must  //// 
.................... ////  be defined.                                                          //// 
.................... ////                                                                       //// 
.................... ////  Example of port access:                                              //// 
.................... ////     #define LCD_DATA_PORT getenv("SFR:PORTD")                         //// 
.................... ////                                                                       //// 
.................... ////  To use pin access, the following pins must be defined:               //// 
.................... ////     LCD_ENABLE_PIN                                                    //// 
.................... ////     LCD_RS_PIN                                                        //// 
.................... ////     LCD_RW_PIN                                                        //// 
.................... ////     LCD_DATA4                                                         //// 
.................... ////     LCD_DATA5                                                         //// 
.................... ////     LCD_DATA6                                                         //// 
.................... ////     LCD_DATA7                                                         //// 
.................... ////                                                                       //// 
.................... ////  Example of pin access:                                               //// 
.................... ////     #define LCD_ENABLE_PIN  PIN_E0                                    //// 
.................... ////     #define LCD_RS_PIN      PIN_E1                                    //// 
.................... ////     #define LCD_RW_PIN      PIN_E2                                    //// 
.................... ////     #define LCD_DATA4       PIN_D4                                    //// 
.................... ////     #define LCD_DATA5       PIN_D5                                    //// 
.................... ////     #define LCD_DATA6       PIN_D6                                    //// 
.................... ////     #define LCD_DATA7       PIN_D7                                    //// 
.................... ////                                                                       //// 
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2010 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef __LCD_C__ 
.................... #define __LCD_C__ 
....................  
.................... // define the pinout. 
.................... // only required if port access is being used. 
.................... typedef struct   
.................... {                            // This structure is overlayed 
....................    int1 enable;           // on to an I/O port to gain 
....................    int1 rs;               // access to the LCD pins. 
....................    int1 rw;               // The bits are allocated from 
....................    int1 unused;           // low order up.  ENABLE will 
....................    unsigned int     data : 4;         // be LSB pin of that port. 
....................   #if defined(__PCD__)       // The port used will be LCD_DATA_PORT. 
....................    unsigned int    reserved: 8; 
....................   #endif 
.................... } LCD_PIN_MAP; 
....................  
.................... // this is to improve compatability with previous LCD drivers that accepted 
.................... // a define labeled 'use_portb_lcd' that configured the LCD onto port B. 
.................... #if ((defined(use_portb_lcd)) && (use_portb_lcd==TRUE)) 
....................  #define LCD_DATA_PORT getenv("SFR:PORTB") 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
....................    // these definitions only need to be modified for baseline PICs. 
....................    // all other PICs use LCD_PIN_MAP or individual LCD_xxx pin definitions. 
.................... /*                                    EN, RS,   RW,   UNUSED,  DATA  */ 
....................  const LCD_PIN_MAP LCD_OUTPUT_MAP =  {0,  0,    0,    0,       0}; 
....................  const LCD_PIN_MAP LCD_INPUT_MAP =   {0,  0,    0,    0,       0xF}; 
.................... #endif 
....................  
.................... ////////////////////// END CONFIGURATION /////////////////////////////////// 
....................  
.................... #ifndef LCD_ENABLE_PIN 
....................    #define lcd_output_enable(x) lcdlat.enable=x 
....................    #define lcd_enable_tris()   lcdtris.enable=0 
.................... #else 
....................    #define lcd_output_enable(x) output_bit(LCD_ENABLE_PIN, x) 
....................    #define lcd_enable_tris()  output_drive(LCD_ENABLE_PIN) 
.................... #endif 
....................  
.................... #ifndef LCD_RS_PIN 
....................    #define lcd_output_rs(x) lcdlat.rs=x 
....................    #define lcd_rs_tris()   lcdtris.rs=0 
.................... #else 
....................    #define lcd_output_rs(x) output_bit(LCD_RS_PIN, x) 
....................    #define lcd_rs_tris()  output_drive(LCD_RS_PIN) 
.................... #endif 
....................  
.................... #ifndef LCD_RW_PIN 
....................    #define lcd_output_rw(x) lcdlat.rw=x 
....................    #define lcd_rw_tris()   lcdtris.rw=0 
.................... #else 
....................    #define lcd_output_rw(x) output_bit(LCD_RW_PIN, x) 
....................    #define lcd_rw_tris()  output_drive(LCD_RW_PIN) 
.................... #endif 
....................  
.................... // original version of this library incorrectly labeled LCD_DATA0 as LCD_DATA4, 
.................... // LCD_DATA1 as LCD_DATA5, and so on.  this block of code makes the driver 
.................... // compatible with any code written for the original library 
.................... #if (defined(LCD_DATA0) && defined(LCD_DATA1) && defined(LCD_DATA2) && defined(LCD_DATA3) && !defined(LCD_DATA4) && !defined(LCD_DATA5) && !defined(LCD_DATA6) && !defined(LCD_DATA7)) 
....................    #define  LCD_DATA4    LCD_DATA0 
....................    #define  LCD_DATA5    LCD_DATA1 
....................    #define  LCD_DATA6    LCD_DATA2 
....................    #define  LCD_DATA7    LCD_DATA3 
.................... #endif 
....................  
.................... #ifndef LCD_DATA4 
.................... #ifndef LCD_DATA_PORT 
....................    #if defined(__PCB__) 
....................       #define LCD_DATA_PORT      0x06     //portb 
....................       #define set_tris_lcd(x)   set_tris_b(x) 
....................    #else 
....................      #if defined(PIN_D0) 
....................       #define LCD_DATA_PORT      getenv("SFR:PORTD")     //portd 
....................      #else 
....................       #define LCD_DATA_PORT      getenv("SFR:PORTB")     //portb 
....................      #endif 
....................    #endif    
.................... #endif 
....................  
.................... #if defined(__PCB__) 
....................    LCD_PIN_MAP lcd, lcdlat; 
....................    #byte lcd = LCD_DATA_PORT 
....................    #byte lcdlat = LCD_DATA_PORT 
.................... #elif defined(__PCM__) 
....................    LCD_PIN_MAP lcd, lcdlat, lcdtris; 
....................    #byte lcd = LCD_DATA_PORT 
....................    #byte lcdlat = LCD_DATA_PORT 
....................    #byte lcdtris = LCD_DATA_PORT+0x80 
.................... #elif defined(__PCH__) 
....................    LCD_PIN_MAP lcd, lcdlat, lcdtris; 
....................    #byte lcd = LCD_DATA_PORT 
....................    #byte lcdlat = LCD_DATA_PORT+9 
....................    #byte lcdtris = LCD_DATA_PORT+0x12 
.................... #elif defined(__PCD__) 
....................    LCD_PIN_MAP lcd, lcdlat, lcdtris; 
....................    #word lcd = LCD_DATA_PORT 
....................    #word lcdlat = LCD_DATA_PORT+2 
....................    #word lcdtris = LCD_DATA_PORT-0x02 
.................... #endif 
.................... #endif   //LCD_DATA4 not defined 
....................  
.................... #ifndef LCD_TYPE 
....................    #define LCD_TYPE 2           // 0=5x7, 1=5x10, 2=2 lines 
.................... #endif 
....................  
.................... #ifndef LCD_LINE_TWO 
....................    #define LCD_LINE_TWO 0x40    // LCD RAM address for the second line 
.................... #endif 
....................  
.................... #ifndef LCD_LINE_LENGTH 
....................    #define LCD_LINE_LENGTH 20 
.................... #endif 
....................  
.................... unsigned int8 lcd_read_nibble(void); 
....................  
.................... unsigned int8 lcd_read_byte(void) 
.................... { 
....................    unsigned int8 low,high; 
....................  
....................  #if defined(__PCB__) 
....................    set_tris_lcd(LCD_INPUT_MAP); 
....................  #else 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    output_float(LCD_DATA4); 
*
01CB:  BSF    07.0
....................    output_float(LCD_DATA5); 
01CC:  BSF    07.1
....................    output_float(LCD_DATA6); 
01CD:  BSF    07.2
....................    output_float(LCD_DATA7); 
01CE:  BSF    07.3
....................   #else 
....................    lcdtris.data = 0xF; 
....................   #endif 
....................  #endif 
....................          
....................    lcd_output_rw(1); 
01CF:  BCF    03.5
01D0:  BSF    09.2
01D1:  BSF    03.5
01D2:  BCF    09.2
....................    delay_cycles(1); 
01D3:  NOP
....................    lcd_output_enable(1); 
01D4:  BCF    03.5
01D5:  BSF    09.0
01D6:  BSF    03.5
01D7:  BCF    09.0
....................    delay_cycles(1); 
01D8:  NOP
....................    high = lcd_read_nibble(); 
01D9:  BCF    03.5
01DA:  CALL   180
01DB:  MOVF   78,W
01DC:  BSF    03.6
01DD:  MOVWF  17
....................        
....................    lcd_output_enable(0); 
01DE:  BCF    03.6
01DF:  BCF    09.0
01E0:  BSF    03.5
01E1:  BCF    09.0
....................    delay_cycles(1); 
01E2:  NOP
....................    lcd_output_enable(1); 
01E3:  BCF    03.5
01E4:  BSF    09.0
01E5:  BSF    03.5
01E6:  BCF    09.0
....................    delay_us(1); 
01E7:  GOTO   1E8
01E8:  GOTO   1E9
01E9:  NOP
....................    low = lcd_read_nibble(); 
01EA:  BCF    03.5
01EB:  CALL   180
01EC:  MOVF   78,W
01ED:  BSF    03.6
01EE:  MOVWF  16
....................        
....................    lcd_output_enable(0); 
01EF:  BCF    03.6
01F0:  BCF    09.0
01F1:  BSF    03.5
01F2:  BCF    09.0
....................  
....................  #if defined(__PCB__) 
....................    set_tris_lcd(LCD_OUTPUT_MAP); 
....................  #else 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    output_drive(LCD_DATA4); 
01F3:  BCF    03.5
01F4:  BCF    31.0
01F5:  MOVF   31,W
01F6:  BSF    03.5
01F7:  MOVWF  07
....................    output_drive(LCD_DATA5); 
01F8:  BCF    03.5
01F9:  BCF    31.1
01FA:  MOVF   31,W
01FB:  BSF    03.5
01FC:  MOVWF  07
....................    output_drive(LCD_DATA6); 
01FD:  BCF    03.5
01FE:  BCF    31.2
01FF:  MOVF   31,W
0200:  BSF    03.5
0201:  MOVWF  07
....................    output_drive(LCD_DATA7); 
0202:  BCF    03.5
0203:  BCF    31.3
0204:  MOVF   31,W
0205:  BSF    03.5
0206:  MOVWF  07
....................   #else 
....................    lcdtris.data = 0x0; 
....................   #endif 
....................  #endif 
....................  
....................    return( (high<<4) | low); 
0207:  BCF    03.5
0208:  BSF    03.6
0209:  SWAPF  17,W
020A:  MOVWF  77
020B:  MOVLW  F0
020C:  ANDWF  77,F
020D:  MOVF   77,W
020E:  IORWF  16,W
020F:  MOVWF  78
.................... } 
....................  
.................... unsigned int8 lcd_read_nibble(void) 
.................... { 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
*
0180:  BSF    03.6
0181:  CLRF   18
....................    unsigned int8 n = 0x00; 
....................  
....................    /* Read the data port */ 
....................    n |= input(LCD_DATA4); 
0182:  BCF    03.6
0183:  BSF    31.0
0184:  MOVF   31,W
0185:  BSF    03.5
0186:  MOVWF  07
0187:  MOVLW  00
0188:  BCF    03.5
0189:  BTFSC  07.0
018A:  MOVLW  01
018B:  BSF    03.6
018C:  IORWF  18,F
....................    n |= input(LCD_DATA5) << 1; 
018D:  BCF    03.6
018E:  BSF    31.1
018F:  MOVF   31,W
0190:  BSF    03.5
0191:  MOVWF  07
0192:  MOVLW  00
0193:  BCF    03.5
0194:  BTFSC  07.1
0195:  MOVLW  01
0196:  MOVWF  77
0197:  BCF    03.0
0198:  RLF    77,F
0199:  MOVF   77,W
019A:  BSF    03.6
019B:  IORWF  18,F
....................    n |= input(LCD_DATA6) << 2; 
019C:  BCF    03.6
019D:  BSF    31.2
019E:  MOVF   31,W
019F:  BSF    03.5
01A0:  MOVWF  07
01A1:  MOVLW  00
01A2:  BCF    03.5
01A3:  BTFSC  07.2
01A4:  MOVLW  01
01A5:  MOVWF  77
01A6:  RLF    77,F
01A7:  RLF    77,F
01A8:  MOVLW  FC
01A9:  ANDWF  77,F
01AA:  MOVF   77,W
01AB:  BSF    03.6
01AC:  IORWF  18,F
....................    n |= input(LCD_DATA7) << 3; 
01AD:  BCF    03.6
01AE:  BSF    31.3
01AF:  MOVF   31,W
01B0:  BSF    03.5
01B1:  MOVWF  07
01B2:  MOVLW  00
01B3:  BCF    03.5
01B4:  BTFSC  07.3
01B5:  MOVLW  01
01B6:  MOVWF  77
01B7:  RLF    77,F
01B8:  RLF    77,F
01B9:  RLF    77,F
01BA:  MOVLW  F8
01BB:  ANDWF  77,F
01BC:  MOVF   77,W
01BD:  BSF    03.6
01BE:  IORWF  18,F
....................     
....................    return(n); 
01BF:  MOVF   18,W
01C0:  MOVWF  78
....................   #else 
01C1:  BCF    03.6
01C2:  RETURN
....................    return(lcd.data); 
....................   #endif 
.................... } 
....................  
.................... void lcd_send_nibble(unsigned int8 n) 
.................... { 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    /* Write to the data port */ 
....................    output_bit(LCD_DATA4, bit_test(n, 0)); 
*
0138:  BSF    03.6
0139:  BTFSC  17.0
013A:  GOTO   13F
013B:  BCF    03.6
013C:  BCF    07.0
013D:  GOTO   141
013E:  BSF    03.6
013F:  BCF    03.6
0140:  BSF    07.0
0141:  BCF    31.0
0142:  MOVF   31,W
0143:  BSF    03.5
0144:  MOVWF  07
....................    output_bit(LCD_DATA5, bit_test(n, 1)); 
0145:  BCF    03.5
0146:  BSF    03.6
0147:  BTFSC  17.1
0148:  GOTO   14D
0149:  BCF    03.6
014A:  BCF    07.1
014B:  GOTO   14F
014C:  BSF    03.6
014D:  BCF    03.6
014E:  BSF    07.1
014F:  BCF    31.1
0150:  MOVF   31,W
0151:  BSF    03.5
0152:  MOVWF  07
....................    output_bit(LCD_DATA6, bit_test(n, 2)); 
0153:  BCF    03.5
0154:  BSF    03.6
0155:  BTFSC  17.2
0156:  GOTO   15B
0157:  BCF    03.6
0158:  BCF    07.2
0159:  GOTO   15D
015A:  BSF    03.6
015B:  BCF    03.6
015C:  BSF    07.2
015D:  BCF    31.2
015E:  MOVF   31,W
015F:  BSF    03.5
0160:  MOVWF  07
....................    output_bit(LCD_DATA7, bit_test(n, 3)); 
0161:  BCF    03.5
0162:  BSF    03.6
0163:  BTFSC  17.3
0164:  GOTO   169
0165:  BCF    03.6
0166:  BCF    07.3
0167:  GOTO   16B
0168:  BSF    03.6
0169:  BCF    03.6
016A:  BSF    07.3
016B:  BCF    31.3
016C:  MOVF   31,W
016D:  BSF    03.5
016E:  MOVWF  07
....................   #else       
....................    lcdlat.data = n; 
....................   #endif 
....................        
....................    delay_cycles(1); 
016F:  NOP
....................    lcd_output_enable(1); 
0170:  BCF    03.5
0171:  BSF    09.0
0172:  BSF    03.5
0173:  BCF    09.0
....................    delay_us(2); 
0174:  MOVLW  02
0175:  MOVWF  77
0176:  DECFSZ 77,F
0177:  GOTO   176
0178:  GOTO   179
0179:  NOP
....................    lcd_output_enable(0); 
017A:  BCF    03.5
017B:  BCF    09.0
017C:  BSF    03.5
017D:  BCF    09.0
017E:  BCF    03.5
017F:  RETURN
.................... } 
....................  
.................... void lcd_send_byte(unsigned int8 address, unsigned int8 n) 
.................... { 
....................   #if defined(__PCB__) 
....................    set_tris_lcd(LCD_OUTPUT_MAP); 
....................   #else 
....................    lcd_enable_tris(); 
*
01C3:  BSF    03.5
01C4:  BCF    09.0
....................    lcd_rs_tris(); 
01C5:  BCF    09.1
....................    lcd_rw_tris(); 
01C6:  BCF    09.2
....................   #endif 
....................  
....................    lcd_output_rs(0); 
01C7:  BCF    03.5
01C8:  BCF    09.1
01C9:  BSF    03.5
01CA:  BCF    09.1
....................    while ( bit_test(lcd_read_byte(),7) ) ; 
*
0210:  MOVF   78,W
0211:  MOVWF  16
0212:  BTFSS  16.7
0213:  GOTO   217
0214:  BSF    03.5
0215:  BCF    03.6
0216:  GOTO   1CB
....................    lcd_output_rs(address); 
0217:  MOVF   14,F
0218:  BTFSS  03.2
0219:  GOTO   21E
021A:  BCF    03.6
021B:  BCF    09.1
021C:  GOTO   220
021D:  BSF    03.6
021E:  BCF    03.6
021F:  BSF    09.1
0220:  BSF    03.5
0221:  BCF    09.1
....................    delay_cycles(1); 
0222:  NOP
....................    lcd_output_rw(0); 
0223:  BCF    03.5
0224:  BCF    09.2
0225:  BSF    03.5
0226:  BCF    09.2
....................    delay_cycles(1); 
0227:  NOP
....................    lcd_output_enable(0); 
0228:  BCF    03.5
0229:  BCF    09.0
022A:  BSF    03.5
022B:  BCF    09.0
....................    lcd_send_nibble(n >> 4); 
022C:  BCF    03.5
022D:  BSF    03.6
022E:  SWAPF  15,W
022F:  MOVWF  16
0230:  MOVLW  0F
0231:  ANDWF  16,F
0232:  MOVF   16,W
0233:  MOVWF  17
0234:  BCF    03.6
0235:  CALL   138
....................    lcd_send_nibble(n & 0xf); 
0236:  BSF    03.6
0237:  MOVF   15,W
0238:  ANDLW  0F
0239:  MOVWF  16
023A:  MOVWF  17
023B:  BCF    03.6
023C:  CALL   138
023D:  RETURN
.................... } 
....................  
.................... #if defined(LCD_EXTENDED_NEWLINE) 
.................... unsigned int8 g_LcdX, g_LcdY; 
.................... #endif 
....................  
.................... void lcd_init(void)  
.................... { 
....................    unsigned int8 i; 
....................    unsigned int8 LCD_INIT_STRING[4] = {0x20 | (LCD_TYPE << 2), 0xc, 1, 6}; 
023E:  MOVLW  28
023F:  BSF    03.5
0240:  MOVWF  3F
0241:  MOVLW  0C
0242:  MOVWF  40
0243:  MOVLW  01
0244:  MOVWF  41
0245:  MOVLW  06
0246:  MOVWF  42
....................                              // These bytes need to be sent to the LCD 
....................                              // to start it up. 
....................     
....................  
....................    lcd_output_enable(0); 
0247:  BCF    03.5
0248:  BCF    09.0
0249:  BSF    03.5
024A:  BCF    09.0
....................    lcd_output_rs(0); 
024B:  BCF    03.5
024C:  BCF    09.1
024D:  BSF    03.5
024E:  BCF    09.1
....................    lcd_output_rw(0); 
024F:  BCF    03.5
0250:  BCF    09.2
0251:  BSF    03.5
0252:  BCF    09.2
....................  
....................  #if defined(__PCB__) 
....................    set_tris_lcd(LCD_OUTPUT_MAP); 
....................  #else 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    output_drive(LCD_DATA4); 
0253:  BCF    03.5
0254:  BCF    31.0
0255:  MOVF   31,W
0256:  BSF    03.5
0257:  MOVWF  07
....................    output_drive(LCD_DATA5); 
0258:  BCF    03.5
0259:  BCF    31.1
025A:  MOVF   31,W
025B:  BSF    03.5
025C:  MOVWF  07
....................    output_drive(LCD_DATA6); 
025D:  BCF    03.5
025E:  BCF    31.2
025F:  MOVF   31,W
0260:  BSF    03.5
0261:  MOVWF  07
....................    output_drive(LCD_DATA7); 
0262:  BCF    03.5
0263:  BCF    31.3
0264:  MOVF   31,W
0265:  BSF    03.5
0266:  MOVWF  07
....................   #else 
....................    lcdtris.data = 0x0; 
....................   #endif 
....................    lcd_enable_tris(); 
0267:  BCF    09.0
....................    lcd_rs_tris(); 
0268:  BCF    09.1
....................    lcd_rw_tris(); 
0269:  BCF    09.2
....................  #endif 
....................      
....................    delay_ms(15); 
026A:  MOVLW  0F
026B:  BCF    03.5
026C:  BSF    03.6
026D:  MOVWF  10
026E:  BCF    03.6
026F:  CALL   124
....................    for(i=1;i<=3;++i) 
0270:  MOVLW  01
0271:  BSF    03.5
0272:  MOVWF  3E
0273:  MOVF   3E,W
0274:  SUBLW  03
0275:  BTFSS  03.0
0276:  GOTO   285
....................    { 
....................        lcd_send_nibble(3); 
0277:  MOVLW  03
0278:  BCF    03.5
0279:  BSF    03.6
027A:  MOVWF  17
027B:  BCF    03.6
027C:  CALL   138
....................        delay_ms(5); 
027D:  MOVLW  05
027E:  BSF    03.6
027F:  MOVWF  10
0280:  BCF    03.6
0281:  CALL   124
0282:  BSF    03.5
0283:  INCF   3E,F
0284:  GOTO   273
....................    } 
....................     
....................    lcd_send_nibble(2); 
0285:  MOVLW  02
0286:  BCF    03.5
0287:  BSF    03.6
0288:  MOVWF  17
0289:  BCF    03.6
028A:  CALL   138
....................    delay_ms(5); 
028B:  MOVLW  05
028C:  BSF    03.6
028D:  MOVWF  10
028E:  BCF    03.6
028F:  CALL   124
....................    for(i=0;i<=3;++i) 
0290:  BSF    03.5
0291:  CLRF   3E
0292:  MOVF   3E,W
0293:  SUBLW  03
0294:  BTFSS  03.0
0295:  GOTO   2AA
....................       lcd_send_byte(0,LCD_INIT_STRING[i]); 
0296:  MOVLW  BF
0297:  ADDWF  3E,W
0298:  MOVWF  04
0299:  BCF    03.7
029A:  MOVF   00,W
029B:  MOVWF  43
029C:  BCF    03.5
029D:  BSF    03.6
029E:  CLRF   14
029F:  BSF    03.5
02A0:  BCF    03.6
02A1:  MOVF   43,W
02A2:  BCF    03.5
02A3:  BSF    03.6
02A4:  MOVWF  15
02A5:  BCF    03.6
02A6:  CALL   1C3
....................  
....................   #if defined(LCD_EXTENDED_NEWLINE) 
02A7:  BSF    03.5
02A8:  INCF   3E,F
02A9:  GOTO   292
02AA:  BCF    03.5
02AB:  BSF    0A.3
02AC:  BCF    0A.4
02AD:  GOTO   534 (RETURN)
....................    g_LcdX = 0; 
....................    g_LcdY = 0; 
....................   #endif 
.................... } 
....................  
.................... void lcd_gotoxy(unsigned int8 x, unsigned int8 y) 
.................... { 
....................    unsigned int8 address; 
....................     
....................    if(y!=1) 
02AE:  BSF    03.6
02AF:  DECFSZ 11,W
02B0:  GOTO   2B2
02B1:  GOTO   2B5
....................       address=LCD_LINE_TWO; 
02B2:  MOVLW  40
02B3:  MOVWF  12
02B4:  GOTO   2B6
....................    else 
....................       address=0; 
02B5:  CLRF   12
....................       
....................    address+=x-1; 
02B6:  MOVLW  01
02B7:  SUBWF  10,W
02B8:  ADDWF  12,F
....................    lcd_send_byte(0,0x80|address); 
02B9:  MOVF   12,W
02BA:  IORLW  80
02BB:  MOVWF  13
02BC:  CLRF   14
02BD:  MOVF   13,W
02BE:  MOVWF  15
02BF:  BCF    03.6
02C0:  CALL   1C3
....................  
....................   #if defined(LCD_EXTENDED_NEWLINE) 
02C1:  RETURN
....................    g_LcdX = x - 1; 
....................    g_LcdY = y - 1; 
....................   #endif 
.................... } 
....................  
.................... void lcd_putc(char c) 
.................... { 
....................    switch (c) 
02C2:  BSF    03.5
02C3:  MOVF   6F,W
02C4:  XORLW  07
02C5:  BCF    03.5
02C6:  BTFSC  03.2
02C7:  GOTO   2D2
02C8:  XORLW  0B
02C9:  BTFSC  03.2
02CA:  GOTO   2D9
02CB:  XORLW  06
02CC:  BTFSC  03.2
02CD:  GOTO   2E5
02CE:  XORLW  02
02CF:  BTFSC  03.2
02D0:  GOTO   2ED
02D1:  GOTO   2F4
....................    { 
....................       case '\a'   :  lcd_gotoxy(1,1);     break; 
02D2:  MOVLW  01
02D3:  BSF    03.6
02D4:  MOVWF  10
02D5:  MOVWF  11
02D6:  BCF    03.6
02D7:  CALL   2AE
02D8:  GOTO   2FF
....................  
....................       case '\f'   :  lcd_send_byte(0,1); 
02D9:  BSF    03.6
02DA:  CLRF   14
02DB:  MOVLW  01
02DC:  MOVWF  15
02DD:  BCF    03.6
02DE:  CALL   1C3
....................                      delay_ms(2); 
02DF:  MOVLW  02
02E0:  BSF    03.6
02E1:  MOVWF  10
02E2:  BCF    03.6
02E3:  CALL   124
....................                     #if defined(LCD_EXTENDED_NEWLINE) 
....................                      g_LcdX = 0; 
....................                      g_LcdY = 0; 
....................                     #endif 
....................                      break; 
02E4:  GOTO   2FF
....................  
....................      #if defined(LCD_EXTENDED_NEWLINE) 
....................       case '\r'   :  lcd_gotoxy(1, g_LcdY+1);   break; 
....................       case '\n'   : 
....................          while (g_LcdX++ < LCD_LINE_LENGTH) 
....................          { 
....................             lcd_send_byte(1, ' '); 
....................          } 
....................          lcd_gotoxy(1, g_LcdY+2); 
....................          break; 
....................      #else 
....................       case '\n'   : lcd_gotoxy(1,2);        break; 
02E5:  MOVLW  01
02E6:  BSF    03.6
02E7:  MOVWF  10
02E8:  MOVLW  02
02E9:  MOVWF  11
02EA:  BCF    03.6
02EB:  CALL   2AE
02EC:  GOTO   2FF
....................      #endif 
....................       
....................       case '\b'   : lcd_send_byte(0,0x10);  break; 
02ED:  BSF    03.6
02EE:  CLRF   14
02EF:  MOVLW  10
02F0:  MOVWF  15
02F1:  BCF    03.6
02F2:  CALL   1C3
02F3:  GOTO   2FF
....................       
....................      #if defined(LCD_EXTENDED_NEWLINE) 
....................       default     :  
....................          if (g_LcdX < LCD_LINE_LENGTH) 
....................          { 
....................             lcd_send_byte(1, c); 
....................             g_LcdX++; 
....................          } 
....................          break; 
....................      #else 
....................       default     : lcd_send_byte(1,c);     break; 
02F4:  MOVLW  01
02F5:  BSF    03.6
02F6:  MOVWF  14
02F7:  BSF    03.5
02F8:  BCF    03.6
02F9:  MOVF   6F,W
02FA:  BCF    03.5
02FB:  BSF    03.6
02FC:  MOVWF  15
02FD:  BCF    03.6
02FE:  CALL   1C3
....................      #endif 
....................    } 
02FF:  RETURN
.................... } 
....................   
.................... char lcd_getc(unsigned int8 x, unsigned int8 y) 
.................... { 
....................    char value; 
....................  
....................    lcd_gotoxy(x,y); 
....................    while ( bit_test(lcd_read_byte(),7) ); // wait until busy flag is low 
....................    lcd_output_rs(1); 
....................    value = lcd_read_byte(); 
....................    lcd_output_rs(0); 
....................     
....................    return(value); 
.................... } 
....................  
.................... // write a custom character to the ram 
.................... // which is 0-7 and specifies which character array we are modifying. 
.................... // ptr points to an array of 8 bytes, where each byte is the next row of 
.................... //    pixels.  only bits 0-4 are used.  the last row is the cursor row, and 
.................... //    usually you will want to leave this byte 0x00. 
.................... void lcd_set_cgram_char(unsigned int8 which, unsigned int8 *ptr) 
.................... { 
....................    unsigned int i; 
....................  
....................    which <<= 3; 
....................    which &= 0x38; 
....................  
....................    lcd_send_byte(0, 0x40 | which);  //set cgram address 
....................  
....................    for(i=0; i<8; i++) 
....................    { 
....................       lcd_send_byte(1, *ptr++); 
....................    } 
....................    
....................    #if defined(LCD_EXTENDED_NEWLINE) 
....................     lcd_gotoxy(g_LcdX+1, g_LcdY+1);  //set ddram address 
....................    #endif 
.................... } 
....................  
.................... void lcd_cursor_on(int1 on) 
.................... { 
....................    if (on) 
....................    { 
....................       lcd_send_byte(0,0x0F);           //turn LCD cursor ON 
....................    } 
....................    else 
....................    { 
....................       lcd_send_byte(0,0x0C);           //turn LCD cursor OFF 
....................    } 
.................... } 
....................  
.................... #endif 
....................  
.................... #BIT TMR1IF = 0x0C.0 //bit thu 0 (TMR1IF) cua PIR1 
....................  
.................... #INCLUDE <khaibaobien.c> // VARIABLE. 
.................... UNSIGNED INT16 KQADC,AN0, AN1; 
.................... UNSIGNED INT8 CONFIG_FUN=0; 
.................... UNSIGNED INT8 VT=0, KYTU=0;// KYTU[30],  
.................... UNSIGNED INT8 ID_DEVICE_NHAN,TT_DEVICE_NHAN; 
.................... UNSIGNED INT8 ID_GATEWAY[6] = {5,7,3,5,4,5}; 
*
0CCB:  MOVLW  05
0CCC:  MOVWF  3D
0CCD:  MOVLW  07
0CCE:  MOVWF  3E
0CCF:  MOVLW  03
0CD0:  MOVWF  3F
0CD1:  MOVLW  05
0CD2:  MOVWF  40
0CD3:  MOVLW  04
0CD4:  MOVWF  41
0CD5:  MOVLW  05
0CD6:  MOVWF  42
.................... UNSIGNED INT8 ID_NODE[4] = {0,0,0,0}; 
0CD7:  CLRF   43
0CD8:  CLRF   44
0CD9:  CLRF   45
0CDA:  CLRF   46
.................... UNSIGNED INT8 LEN_PACKAGES = 0; 
.................... UNSIGNED INT32 ID_GW_NHAN, ID_GW_NUMBER; 
.................... UNSIGNED INT16 ID_NODE_NHAN, ID_NODE_NUMBER; 
.................... UNSIGNED INT8 LENHDIEUKHIEN =0, DODAI_DATA_NHAN =0; 
.................... INT1 TTNHAN = 0, TT_CONFIG=0, TT_CONTROL=0,TT_CONFIG_DONE=0, TT_FUN=0, TT_STT=0; 
....................  
.................... CHAR *ID_NODE_CHAR[]= "0000"; 
0CDB:  MOVLW  30
0CDC:  MOVWF  59
0CDD:  MOVWF  5A
0CDE:  MOVWF  5B
0CDF:  MOVWF  5C
0CE0:  CLRF   5D
0CE1:  CLRF   58
0CE2:  MOVLW  59
0CE3:  MOVWF  57
.................... CHAR *ID_GATEWAY_CHAR[]= "000000"; 
0CE4:  MOVLW  30
0CE5:  MOVWF  60
0CE6:  MOVWF  61
0CE7:  MOVWF  62
0CE8:  MOVWF  63
0CE9:  MOVWF  64
0CEA:  MOVWF  65
0CEB:  CLRF   66
0CEC:  CLRF   5F
0CED:  MOVLW  60
0CEE:  MOVWF  5E
.................... CHAR KYTUCHAR[30]="HIHI"; 
0CEF:  MOVLW  48
0CF0:  BSF    03.5
0CF1:  MOVWF  20
0CF2:  MOVLW  49
0CF3:  MOVWF  21
0CF4:  MOVLW  48
0CF5:  MOVWF  22
0CF6:  MOVLW  49
0CF7:  MOVWF  23
0CF8:  CLRF   24
.................... //CHAR *DATA_NHANDUOC[]={"IDGW","IDNODE","COMMAN","DATA"}; 
.................... CHAR *TEMP_CHAR[]="00";  
0CF9:  MOVLW  30
0CFA:  BCF    03.5
0CFB:  MOVWF  69
0CFC:  MOVWF  6A
0CFD:  CLRF   6B
0CFE:  CLRF   68
0CFF:  MOVLW  69
0D00:  MOVWF  67
.................... //CHAR *TEMP_CHAR3[]="0000";  
....................  
....................  
....................  
.................... //#INCLUDE <CONFIG_NODE.C> // CU HINH NODE. 
.................... #INCLUDE <config_1.C> // CU HINH NODE. 
....................  
.................... //--------------------------------------------------------------------// 
.................... VOID CHON_ID() 
.................... { 
....................    // TT_CONFIG_DONE; 
....................    TT_CONFIG_DONE = 0; 
*
05C1:  BCF    56.3
....................    TT_STT = 1; 
05C2:  BSF    56.5
....................    UNSIGNED INT8 NUM = 0; 
05C3:  BSF    03.5
05C4:  CLRF   3E
....................    TEMP_CHAR = "0"; 
05C5:  CLRF   3F
05C6:  CLRF   40
05C7:  MOVLW  67
05C8:  MOVWF  04
05C9:  BCF    03.7
05CA:  MOVF   3F,W
05CB:  ADDWF  04,F
05CC:  MOVF   40,W
05CD:  BCF    03.5
05CE:  CALL   058
05CF:  MOVWF  00
05D0:  IORLW  00
05D1:  BTFSC  03.2
05D2:  GOTO   5D8
05D3:  BSF    03.5
05D4:  INCF   40,F
05D5:  INCF   3F,F
05D6:  GOTO   5C7
05D7:  BCF    03.5
....................    LCD_GOTOXY (1, 2) ; 
05D8:  MOVLW  01
05D9:  BSF    03.6
05DA:  MOVWF  10
05DB:  MOVLW  02
05DC:  MOVWF  11
05DD:  BCF    03.6
05DE:  CALL   2AE
....................    DELAY_MS (10); 
05DF:  MOVLW  0A
05E0:  BSF    03.6
05E1:  MOVWF  10
05E2:  BCF    03.6
05E3:  CALL   124
....................    PRINTF (LCD_PUTC, "NODE: "); 
05E4:  MOVLW  64
05E5:  BSF    03.6
05E6:  MOVWF  0D
05E7:  MOVLW  00
05E8:  MOVWF  0F
05E9:  BCF    03.6
05EA:  CALL   300
....................    PRINTF (LCD_PUTC, "0000          "); 
05EB:  MOVLW  68
05EC:  BSF    03.6
05ED:  MOVWF  0D
05EE:  MOVLW  00
05EF:  MOVWF  0F
05F0:  BCF    03.6
05F1:  CALL   300
....................    LCD_GOTOXY (1, 1) ; 
05F2:  MOVLW  01
05F3:  BSF    03.6
05F4:  MOVWF  10
05F5:  MOVWF  11
05F6:  BCF    03.6
05F7:  CALL   2AE
....................    PRINTF (LCD_PUTC, "      _              ");//6 SPACE PHIA TRUOC "_" 
05F8:  MOVLW  70
05F9:  BSF    03.6
05FA:  MOVWF  0D
05FB:  MOVLW  00
05FC:  MOVWF  0F
05FD:  BCF    03.6
05FE:  CALL   300
....................    //ID_GW = "1234";     
....................  
....................    WHILE (TT_STT) 
05FF:  BTFSS  56.5
0600:  GOTO   68B
....................    { 
....................       IF (!INPUT (BT2_PIN)) //NEU NUT BAM DUOC BAM 
0601:  BSF    03.5
0602:  BSF    06.2
0603:  BCF    03.5
0604:  BTFSC  06.2
0605:  GOTO   628
....................       { 
....................           
....................          NUM++; 
0606:  BSF    03.5
0607:  INCF   3E,F
....................          NUM = NUM % 4; 
0608:  MOVLW  03
0609:  ANDWF  3E,F
....................          LCD_GOTOXY (3 + NUM, 1); 
060A:  ADDWF  3E,W
060B:  MOVWF  3F
060C:  BCF    03.5
060D:  BSF    03.6
060E:  MOVWF  10
060F:  MOVLW  01
0610:  MOVWF  11
0611:  BCF    03.6
0612:  CALL   2AE
....................          PRINTF (LCD_PUTC, "    _    ");//4SPACE 
0613:  MOVLW  7B
0614:  BSF    03.6
0615:  MOVWF  0D
0616:  MOVLW  00
0617:  MOVWF  0F
0618:  BCF    03.6
0619:  CALL   300
....................          DELAY_MS (300);  
061A:  MOVLW  02
061B:  BSF    03.5
061C:  MOVWF  3F
061D:  MOVLW  96
061E:  BCF    03.5
061F:  BSF    03.6
0620:  MOVWF  10
0621:  BCF    03.6
0622:  CALL   124
0623:  BSF    03.5
0624:  DECFSZ 3F,F
0625:  GOTO   61D
....................       } 
0626:  GOTO   689
0627:  BCF    03.5
....................  
....................       ELSE IF (!INPUT (BT3_PIN)) 
0628:  BSF    03.5
0629:  BSF    06.3
062A:  BCF    03.5
062B:  BTFSC  06.3
062C:  GOTO   68A
....................       { 
....................          ID_NODE[NUM]++; 
062D:  MOVLW  43
062E:  BSF    03.5
062F:  ADDWF  3E,W
0630:  MOVWF  04
0631:  BCF    03.7
0632:  INCF   00,F
....................          ID_NODE[NUM] = ID_NODE[NUM] % 10; 
0633:  MOVLW  43
0634:  ADDWF  3E,W
0635:  MOVWF  78
0636:  CLRF   7A
0637:  BTFSC  03.0
0638:  INCF   7A,F
0639:  MOVF   78,W
063A:  MOVWF  3F
063B:  MOVF   7A,W
063C:  MOVWF  40
063D:  MOVLW  43
063E:  ADDWF  3E,W
063F:  MOVWF  04
0640:  BCF    03.7
0641:  MOVF   00,W
0642:  MOVWF  42
0643:  MOVLW  0A
0644:  MOVWF  43
0645:  BCF    03.5
0646:  CALL   52D
0647:  MOVF   77,W
0648:  BSF    03.5
0649:  MOVWF  41
064A:  MOVF   3F,W
064B:  MOVWF  04
064C:  BCF    03.7
064D:  BTFSC  40.0
064E:  BSF    03.7
064F:  MOVF   41,W
0650:  MOVWF  00
....................          ITOA (ID_NODE[NUM], 10, TEMP_CHAR); 
0651:  MOVLW  43
0652:  ADDWF  3E,W
0653:  MOVWF  04
0654:  BCF    03.7
0655:  MOVF   00,W
0656:  MOVWF  3F
0657:  BCF    03.5
0658:  BSF    03.6
0659:  CLRF   14
065A:  CLRF   13
065B:  CLRF   12
065C:  BSF    03.5
065D:  BCF    03.6
065E:  MOVF   3F,W
065F:  BCF    03.5
0660:  BSF    03.6
0661:  MOVWF  11
0662:  MOVLW  0A
0663:  MOVWF  15
0664:  CLRF   17
0665:  MOVLW  67
0666:  MOVWF  16
0667:  BCF    03.6
0668:  CALL   3F0
....................          LCD_GOTOXY (7 + NUM, 2); 
0669:  MOVLW  07
066A:  BSF    03.5
066B:  ADDWF  3E,W
066C:  MOVWF  3F
066D:  BCF    03.5
066E:  BSF    03.6
066F:  MOVWF  10
0670:  MOVLW  02
0671:  MOVWF  11
0672:  BCF    03.6
0673:  CALL   2AE
....................          DELAY_MS (10); 
0674:  MOVLW  0A
0675:  BSF    03.6
0676:  MOVWF  10
0677:  BCF    03.6
0678:  CALL   124
....................          PRINTF (LCD_PUTC, TEMP_CHAR); 
0679:  MOVLW  67
067A:  MOVWF  04
067B:  BCF    03.7
067C:  CALL   510
....................          DELAY_MS (300); 
067D:  MOVLW  02
067E:  BSF    03.5
067F:  MOVWF  3F
0680:  MOVLW  96
0681:  BCF    03.5
0682:  BSF    03.6
0683:  MOVWF  10
0684:  BCF    03.6
0685:  CALL   124
0686:  BSF    03.5
0687:  DECFSZ 3F,F
0688:  GOTO   680
0689:  BCF    03.5
....................       } 
068A:  GOTO   5FF
....................    } 
.................... } 
....................  
.................... VOID NHAPID_GW() 
*
068C:  BSF    03.5
068D:  CLRF   3E
.................... { 
....................    UNSIGNED INT8 NUM = 0; 
....................    TEMP_CHAR = "0"; 
068E:  CLRF   3F
068F:  CLRF   40
0690:  MOVLW  67
0691:  MOVWF  04
0692:  BCF    03.7
0693:  MOVF   3F,W
0694:  ADDWF  04,F
0695:  MOVF   40,W
0696:  BCF    03.5
0697:  CALL   058
0698:  MOVWF  00
0699:  IORLW  00
069A:  BTFSC  03.2
069B:  GOTO   6A1
069C:  BSF    03.5
069D:  INCF   40,F
069E:  INCF   3F,F
069F:  GOTO   690
06A0:  BCF    03.5
....................    TT_CONFIG_DONE = 0; 
06A1:  BCF    56.3
....................    TT_STT = 1; 
06A2:  BSF    56.5
....................    LCD_GOTOXY (1, 2) ; 
06A3:  MOVLW  01
06A4:  BSF    03.6
06A5:  MOVWF  10
06A6:  MOVLW  02
06A7:  MOVWF  11
06A8:  BCF    03.6
06A9:  CALL   2AE
....................    DELAY_MS (10); 
06AA:  MOVLW  0A
06AB:  BSF    03.6
06AC:  MOVWF  10
06AD:  BCF    03.6
06AE:  CALL   124
....................    PRINTF (LCD_PUTC, "ID_GW:"); 
06AF:  MOVLW  80
06B0:  BSF    03.6
06B1:  MOVWF  0D
06B2:  MOVLW  00
06B3:  MOVWF  0F
06B4:  BCF    03.6
06B5:  CALL   300
....................    PRINTF (LCD_PUTC, "000000        "); 
06B6:  MOVLW  84
06B7:  BSF    03.6
06B8:  MOVWF  0D
06B9:  MOVLW  00
06BA:  MOVWF  0F
06BB:  BCF    03.6
06BC:  CALL   300
....................    LCD_GOTOXY (1, 1) ; 
06BD:  MOVLW  01
06BE:  BSF    03.6
06BF:  MOVWF  10
06C0:  MOVWF  11
06C1:  BCF    03.6
06C2:  CALL   2AE
....................    PRINTF (LCD_PUTC, "      _                ");//6 SPACE PHIA TRUOC "_" 
06C3:  MOVLW  8C
06C4:  BSF    03.6
06C5:  MOVWF  0D
06C6:  MOVLW  00
06C7:  MOVWF  0F
06C8:  BCF    03.6
06C9:  CALL   300
....................    //ID_GW = "1234";     
....................  
....................    WHILE (TT_STT) 
06CA:  BTFSS  56.5
06CB:  GOTO   75E
....................    { 
....................       IF (!INPUT (BT2_PIN)) //NEU NUT BAM DUOC BAM 
06CC:  BSF    03.5
06CD:  BSF    06.2
06CE:  BCF    03.5
06CF:  BTFSC  06.2
06D0:  GOTO   6FB
....................       { 
....................           
....................          NUM++; 
06D1:  BSF    03.5
06D2:  INCF   3E,F
....................          NUM = NUM % 6; 
06D3:  MOVF   3E,W
06D4:  MOVWF  42
06D5:  MOVLW  06
06D6:  MOVWF  43
06D7:  BCF    03.5
06D8:  CALL   52D
06D9:  MOVF   77,W
06DA:  BSF    03.5
06DB:  MOVWF  3E
....................          LCD_GOTOXY (3 + NUM, 1); 
06DC:  MOVLW  03
06DD:  ADDWF  3E,W
06DE:  MOVWF  3F
06DF:  BCF    03.5
06E0:  BSF    03.6
06E1:  MOVWF  10
06E2:  MOVLW  01
06E3:  MOVWF  11
06E4:  BCF    03.6
06E5:  CALL   2AE
....................          PRINTF (LCD_PUTC, "    _        ");//4SPACE 
06E6:  MOVLW  98
06E7:  BSF    03.6
06E8:  MOVWF  0D
06E9:  MOVLW  00
06EA:  MOVWF  0F
06EB:  BCF    03.6
06EC:  CALL   300
....................          DELAY_MS (300);  
06ED:  MOVLW  02
06EE:  BSF    03.5
06EF:  MOVWF  3F
06F0:  MOVLW  96
06F1:  BCF    03.5
06F2:  BSF    03.6
06F3:  MOVWF  10
06F4:  BCF    03.6
06F5:  CALL   124
06F6:  BSF    03.5
06F7:  DECFSZ 3F,F
06F8:  GOTO   6F0
....................       } 
06F9:  GOTO   75C
06FA:  BCF    03.5
....................  
....................       ELSE IF (!INPUT (BT3_PIN)) 
06FB:  BSF    03.5
06FC:  BSF    06.3
06FD:  BCF    03.5
06FE:  BTFSC  06.3
06FF:  GOTO   75D
....................       { 
....................          ID_GATEWAY[NUM]++; 
0700:  MOVLW  3D
0701:  BSF    03.5
0702:  ADDWF  3E,W
0703:  MOVWF  04
0704:  BCF    03.7
0705:  INCF   00,F
....................          ID_GATEWAY[NUM] = ID_GATEWAY[NUM] % 10; 
0706:  MOVLW  3D
0707:  ADDWF  3E,W
0708:  MOVWF  78
0709:  CLRF   7A
070A:  BTFSC  03.0
070B:  INCF   7A,F
070C:  MOVF   78,W
070D:  MOVWF  3F
070E:  MOVF   7A,W
070F:  MOVWF  40
0710:  MOVLW  3D
0711:  ADDWF  3E,W
0712:  MOVWF  04
0713:  BCF    03.7
0714:  MOVF   00,W
0715:  MOVWF  42
0716:  MOVLW  0A
0717:  MOVWF  43
0718:  BCF    03.5
0719:  CALL   52D
071A:  MOVF   77,W
071B:  BSF    03.5
071C:  MOVWF  41
071D:  MOVF   3F,W
071E:  MOVWF  04
071F:  BCF    03.7
0720:  BTFSC  40.0
0721:  BSF    03.7
0722:  MOVF   41,W
0723:  MOVWF  00
....................          ITOA (ID_GATEWAY[NUM], 10, TEMP_CHAR); 
0724:  MOVLW  3D
0725:  ADDWF  3E,W
0726:  MOVWF  04
0727:  BCF    03.7
0728:  MOVF   00,W
0729:  MOVWF  3F
072A:  BCF    03.5
072B:  BSF    03.6
072C:  CLRF   14
072D:  CLRF   13
072E:  CLRF   12
072F:  BSF    03.5
0730:  BCF    03.6
0731:  MOVF   3F,W
0732:  BCF    03.5
0733:  BSF    03.6
0734:  MOVWF  11
0735:  MOVLW  0A
0736:  MOVWF  15
0737:  CLRF   17
0738:  MOVLW  67
0739:  MOVWF  16
073A:  BCF    03.6
073B:  CALL   3F0
....................          LCD_GOTOXY (7 + NUM, 2); 
073C:  MOVLW  07
073D:  BSF    03.5
073E:  ADDWF  3E,W
073F:  MOVWF  3F
0740:  BCF    03.5
0741:  BSF    03.6
0742:  MOVWF  10
0743:  MOVLW  02
0744:  MOVWF  11
0745:  BCF    03.6
0746:  CALL   2AE
....................          DELAY_MS (10); 
0747:  MOVLW  0A
0748:  BSF    03.6
0749:  MOVWF  10
074A:  BCF    03.6
074B:  CALL   124
....................          PRINTF (LCD_PUTC, TEMP_CHAR); 
074C:  MOVLW  67
074D:  MOVWF  04
074E:  BCF    03.7
074F:  CALL   510
....................          DELAY_MS (300); 
0750:  MOVLW  02
0751:  BSF    03.5
0752:  MOVWF  3F
0753:  MOVLW  96
0754:  BCF    03.5
0755:  BSF    03.6
0756:  MOVWF  10
0757:  BCF    03.6
0758:  CALL   124
0759:  BSF    03.5
075A:  DECFSZ 3F,F
075B:  GOTO   753
075C:  BCF    03.5
....................       } 
075D:  GOTO   6CA
....................    } 
.................... } 
....................  
.................... VOID BUTT_OKE() 
.................... { 
....................    TT_CONFIG_DONE = 0; 
*
00FF:  BCF    03.6
0100:  BCF    56.3
....................    TT_FUN = 0;//BREAK WHILE BUTT_FUN 
0101:  BCF    56.4
....................    TT_STT = 0;// BREAK WHILE CHONID/NHAPID_GW 
0102:  BCF    56.5
.................... } 
....................  
.................... VOID SELLECT_FUN() 
.................... { 
....................    TT_CONFIG_DONE = 0; 
*
05B9:  BCF    56.3
....................  
....................    SWITCH (CONFIG_FUN) 
05BA:  MOVF   38,W
05BB:  BTFSC  03.2
05BC:  GOTO   5C1
05BD:  XORLW  01
05BE:  BTFSC  03.2
05BF:  GOTO   68C
05C0:  GOTO   75E
....................    { 
....................       CASE 0: 
....................       CHON_ID (); 
....................       BREAK; 
*
068B:  GOTO   75E
....................  
....................       CASE 1:     
....................       NHAPID_GW (); 
....................       BREAK; 
....................    } 
.................... } 
....................  
.................... VOID BUTT_FUN() 
.................... { 
....................    TT_FUN = 1; 
*
0544:  BSF    56.4
....................    LCD_GOTOXY (1, 1) ; 
0545:  MOVLW  01
0546:  BSF    03.6
0547:  MOVWF  10
0548:  MOVWF  11
0549:  BCF    03.6
054A:  CALL   2AE
....................    DELAY_MS (10); 
054B:  MOVLW  0A
054C:  BSF    03.6
054D:  MOVWF  10
054E:  BCF    03.6
054F:  CALL   124
....................    PRINTF (LCD_PUTC, "CONFIG:        "); 
0550:  MOVLW  9F
0551:  BSF    03.6
0552:  MOVWF  0D
0553:  MOVLW  00
0554:  MOVWF  0F
0555:  BCF    03.6
0556:  CALL   300
....................  
....................    // HIEN THI LCD 
....................    LCD_GOTOXY (1, 2) ; 
0557:  MOVLW  01
0558:  BSF    03.6
0559:  MOVWF  10
055A:  MOVLW  02
055B:  MOVWF  11
055C:  BCF    03.6
055D:  CALL   2AE
....................    DELAY_MS (10); 
055E:  MOVLW  0A
055F:  BSF    03.6
0560:  MOVWF  10
0561:  BCF    03.6
0562:  CALL   124
....................    PRINTF (LCD_PUTC, "CASE:          ") ; 
0563:  MOVLW  A7
0564:  BSF    03.6
0565:  MOVWF  0D
0566:  MOVLW  00
0567:  MOVWF  0F
0568:  BCF    03.6
0569:  CALL   300
....................  
....................    WHILE (TT_FUN) 
056A:  BTFSS  56.4
056B:  GOTO   5B7
....................    { 
....................       IF (INPUT (BT2_PIN) == 0) //NEU NUT BAM DUOC BAM 
056C:  BSF    03.5
056D:  BSF    06.2
056E:  BCF    03.5
056F:  BTFSC  06.2
0570:  GOTO   5B6
....................       { 
....................          CONFIG_FUN ++; 
0571:  INCF   38,F
....................          CONFIG_FUN = CONFIG_FUN % 2; 
0572:  MOVLW  01
0573:  ANDWF  38,F
....................          DELAY_MS (300); 
0574:  MOVLW  02
0575:  BSF    03.5
0576:  MOVWF  3E
0577:  MOVLW  96
0578:  BCF    03.5
0579:  BSF    03.6
057A:  MOVWF  10
057B:  BCF    03.6
057C:  CALL   124
057D:  BSF    03.5
057E:  DECFSZ 3E,F
057F:  GOTO   577
....................          //HIEN THI 
....................          LCD_GOTOXY (6, 2) ; 
0580:  MOVLW  06
0581:  BCF    03.5
0582:  BSF    03.6
0583:  MOVWF  10
0584:  MOVLW  02
0585:  MOVWF  11
0586:  BCF    03.6
0587:  CALL   2AE
....................          ITOA (CONFIG_FUN, 10, TEMP_CHAR); 
0588:  BSF    03.6
0589:  CLRF   14
058A:  CLRF   13
058B:  CLRF   12
058C:  BCF    03.6
058D:  MOVF   38,W
058E:  BSF    03.6
058F:  MOVWF  11
0590:  MOVLW  0A
0591:  MOVWF  15
0592:  CLRF   17
0593:  MOVLW  67
0594:  MOVWF  16
0595:  BCF    03.6
0596:  CALL   3F0
....................          DELAY_MS (10); 
0597:  MOVLW  0A
0598:  BSF    03.6
0599:  MOVWF  10
059A:  BCF    03.6
059B:  CALL   124
....................          PRINTF (LCD_PUTC, TEMP_CHAR); 
059C:  MOVLW  67
059D:  MOVWF  04
059E:  BCF    03.7
059F:  CALL   510
....................  
....................          SWITCH (CONFIG_FUN) 
05A0:  MOVF   38,W
05A1:  BTFSC  03.2
05A2:  GOTO   5A7
05A3:  XORLW  01
05A4:  BTFSC  03.2
05A5:  GOTO   5AF
05A6:  GOTO   5B6
....................          { 
....................             CASE 0: 
....................             PRINTF (LCD_PUTC, " - ID-NODE      "); 
05A7:  MOVLW  AF
05A8:  BSF    03.6
05A9:  MOVWF  0D
05AA:  MOVLW  00
05AB:  MOVWF  0F
05AC:  BCF    03.6
05AD:  CALL   300
....................             BREAK; 
05AE:  GOTO   5B6
....................  
....................             CASE 1: 
....................             PRINTF (LCD_PUTC, " - ID-GW       "); 
05AF:  MOVLW  B8
05B0:  BSF    03.6
05B1:  MOVWF  0D
05B2:  MOVLW  00
05B3:  MOVWF  0F
05B4:  BCF    03.6
05B5:  CALL   300
....................             BREAK;             
....................          } 
....................       } 
05B6:  GOTO   56A
....................    } 
....................  
....................    ////// 
....................    IF (!TT_CONFIG_DONE) 
05B7:  BTFSC  56.3
05B8:  GOTO   75E
....................    { 
....................       SELLECT_FUN (); 
....................    } 
*
075E:  BSF    0A.3
075F:  BCF    0A.4
0760:  GOTO   541 (RETURN)
.................... } 
.................... VOID XULY_IDNODE_NHAP(){ 
....................    //*TEMP_CHAR3 = "\0"; 
....................    *ID_NODE_CHAR = "\0"; 
*
0893:  CLRF   7A
0894:  MOVLW  57
0895:  BCF    03.5
0896:  BSF    03.6
0897:  MOVWF  10
0898:  MOVF   7A,W
0899:  MOVWF  11
089A:  MOVF   10,W
089B:  MOVWF  04
089C:  BCF    03.7
089D:  BTFSC  11.0
089E:  BSF    03.7
089F:  CLRF   00
....................    FOR (int j = 0; j < 4; j++) 
08A0:  BSF    03.5
08A1:  BCF    03.6
08A2:  CLRF   6C
08A3:  MOVF   6C,W
08A4:  SUBLW  03
08A5:  BTFSS  03.0
08A6:  GOTO   0D2
....................    { 
....................       ITOA (ID_NODE[j], 10, TEMP_CHAR); 
08A7:  MOVLW  43
08A8:  ADDWF  6C,W
08A9:  MOVWF  04
08AA:  BCF    03.7
08AB:  MOVF   00,W
08AC:  BCF    03.5
08AD:  BSF    03.6
08AE:  MOVWF  10
08AF:  CLRF   14
08B0:  CLRF   13
08B1:  CLRF   12
08B2:  MOVF   10,W
08B3:  MOVWF  11
08B4:  MOVLW  0A
08B5:  MOVWF  15
08B6:  CLRF   17
08B7:  MOVLW  67
08B8:  MOVWF  16
08B9:  BCF    0A.3
08BA:  BCF    03.6
08BB:  CALL   3F0
08BC:  BSF    0A.3
....................       DELAY_MS (1); 
08BD:  MOVLW  01
08BE:  BSF    03.6
08BF:  MOVWF  10
08C0:  BCF    0A.3
08C1:  BCF    03.6
08C2:  CALL   124
08C3:  BSF    0A.3
....................       STRCAT (ID_NODE_CHAR, TEMP_CHAR); 
08C4:  BSF    03.6
08C5:  CLRF   11
08C6:  MOVLW  57
08C7:  MOVWF  10
08C8:  CLRF   13
08C9:  MOVLW  67
08CA:  MOVWF  12
08CB:  BCF    0A.3
08CC:  BCF    03.6
08CD:  CALL   761
08CE:  BSF    0A.3
08CF:  BSF    03.5
08D0:  INCF   6C,F
08D1:  GOTO   0A3
....................    }   
....................    //ID_NODE_CHAR = TEMP_CHAR3;    
....................    //STRCPY(ID_NODE_CHAR,TEMP_CHAR3); 
....................    //strcpy 
.................... } 
.................... VOID XULY_IDGW_NHAP(){ 
....................  
....................    *ID_GATEWAY_CHAR = "\0"; 
*
0851:  CLRF   7A
0852:  MOVLW  5E
0853:  BCF    03.5
0854:  BSF    03.6
0855:  MOVWF  10
0856:  MOVF   7A,W
0857:  MOVWF  11
0858:  MOVF   10,W
0859:  MOVWF  04
085A:  BCF    03.7
085B:  BTFSC  11.0
085C:  BSF    03.7
085D:  CLRF   00
....................    FOR (int j = 0; j < 6; j++) 
085E:  BSF    03.5
085F:  BCF    03.6
0860:  CLRF   6C
0861:  MOVF   6C,W
0862:  SUBLW  05
0863:  BTFSS  03.0
0864:  GOTO   090
....................    { 
....................       ITOA (ID_GATEWAY[j], 10, TEMP_CHAR); 
0865:  MOVLW  3D
0866:  ADDWF  6C,W
0867:  MOVWF  04
0868:  BCF    03.7
0869:  MOVF   00,W
086A:  BCF    03.5
086B:  BSF    03.6
086C:  MOVWF  10
086D:  CLRF   14
086E:  CLRF   13
086F:  CLRF   12
0870:  MOVF   10,W
0871:  MOVWF  11
0872:  MOVLW  0A
0873:  MOVWF  15
0874:  CLRF   17
0875:  MOVLW  67
0876:  MOVWF  16
0877:  BCF    0A.3
0878:  BCF    03.6
0879:  CALL   3F0
087A:  BSF    0A.3
....................       DELAY_MS (1); 
087B:  MOVLW  01
087C:  BSF    03.6
087D:  MOVWF  10
087E:  BCF    0A.3
087F:  BCF    03.6
0880:  CALL   124
0881:  BSF    0A.3
....................       STRCAT (ID_GATEWAY_CHAR, TEMP_CHAR); 
0882:  BSF    03.6
0883:  CLRF   11
0884:  MOVLW  5E
0885:  MOVWF  10
0886:  CLRF   13
0887:  MOVLW  67
0888:  MOVWF  12
0889:  BCF    0A.3
088A:  BCF    03.6
088B:  CALL   761
088C:  BSF    0A.3
088D:  BSF    03.5
088E:  INCF   6C,F
088F:  GOTO   061
....................    }   
.................... } 
....................  
....................  
.................... VOID CONFIG_DONE() 
.................... { 
....................    TT_FUN = 0; 
*
0800:  BCF    56.4
....................    TT_STT = 0; 
0801:  BCF    56.5
....................    CHAR *PACKAGE_CONFIG[]={"*", "LENGHT","C_F", "ID_GW1234" ,"ID_NODE","#"}; 
0802:  MOVLW  2A
0803:  BSF    03.5
0804:  MOVWF  4A
0805:  CLRF   4B
0806:  MOVLW  4C
0807:  MOVWF  4C
0808:  MOVLW  45
0809:  MOVWF  4D
080A:  MOVLW  4E
080B:  MOVWF  4E
080C:  MOVLW  47
080D:  MOVWF  4F
080E:  MOVLW  48
080F:  MOVWF  50
0810:  MOVLW  54
0811:  MOVWF  51
0812:  CLRF   52
0813:  MOVLW  43
0814:  MOVWF  53
0815:  MOVLW  5F
0816:  MOVWF  54
0817:  MOVLW  46
0818:  MOVWF  55
0819:  CLRF   56
081A:  MOVLW  49
081B:  MOVWF  57
081C:  MOVLW  44
081D:  MOVWF  58
081E:  MOVLW  5F
081F:  MOVWF  59
0820:  MOVLW  47
0821:  MOVWF  5A
0822:  MOVLW  57
0823:  MOVWF  5B
0824:  MOVLW  31
0825:  MOVWF  5C
0826:  MOVLW  32
0827:  MOVWF  5D
0828:  MOVLW  33
0829:  MOVWF  5E
082A:  MOVLW  34
082B:  MOVWF  5F
082C:  CLRF   60
082D:  MOVLW  49
082E:  MOVWF  61
082F:  MOVLW  44
0830:  MOVWF  62
0831:  MOVLW  5F
0832:  MOVWF  63
0833:  MOVLW  4E
0834:  MOVWF  64
0835:  MOVLW  4F
0836:  MOVWF  65
0837:  MOVLW  44
0838:  MOVWF  66
0839:  MOVLW  45
083A:  MOVWF  67
083B:  CLRF   68
083C:  MOVLW  23
083D:  MOVWF  69
083E:  CLRF   6A
083F:  CLRF   3F
0840:  MOVLW  CA
0841:  MOVWF  3E
0842:  CLRF   41
0843:  MOVLW  CC
0844:  MOVWF  40
0845:  CLRF   43
0846:  MOVLW  D3
0847:  MOVWF  42
0848:  CLRF   45
0849:  MOVLW  D7
084A:  MOVWF  44
084B:  CLRF   47
084C:  MOVLW  E1
084D:  MOVWF  46
084E:  CLRF   49
084F:  MOVLW  E9
0850:  MOVWF  48
....................    XULY_IDGW_NHAP(); 
....................    PACKAGE_CONFIG[3] = ID_GATEWAY_CHAR; 
*
0890:  CLRF   45
0891:  MOVLW  5E
0892:  MOVWF  44
....................     
....................    XULY_IDNODE_NHAP(); 
....................    PACKAGE_CONFIG[4] = ID_NODE_CHAR;          
*
08D2:  CLRF   47
08D3:  MOVLW  57
08D4:  MOVWF  46
....................    LEN_PACKAGES = 0; 
08D5:  BCF    03.5
08D6:  CLRF   47
....................    PACKAGE_CONFIG[1] = "12"; //DO DAI CUA LENGHT CO DO DAI = 2 
08D7:  MOVLW  31
08D8:  BSF    03.5
08D9:  MOVWF  40
08DA:  MOVLW  32
08DB:  MOVWF  41
....................    FOR (int J = 0; J < 6; J++) 
08DC:  CLRF   6B
08DD:  MOVF   6B,W
08DE:  SUBLW  05
08DF:  BTFSS  03.0
08E0:  GOTO   0F9
....................    { 
....................       LEN_PACKAGES += strlen(PACKAGE_CONFIG[J]); 
08E1:  BCF    03.0
08E2:  RLF    6B,W
08E3:  ADDLW  BE
08E4:  MOVWF  04
08E5:  BCF    03.7
08E6:  INCF   04,F
08E7:  MOVF   00,W
08E8:  MOVWF  6D
08E9:  DECF   04,F
08EA:  MOVF   00,W
08EB:  MOVWF  6C
08EC:  MOVF   6D,W
08ED:  MOVWF  6F
08EE:  MOVF   6C,W
08EF:  MOVWF  6E
08F0:  BCF    0A.3
08F1:  BCF    03.5
08F2:  CALL   79F
08F3:  BSF    0A.3
08F4:  MOVF   78,W
08F5:  ADDWF  47,F
08F6:  BSF    03.5
08F7:  INCF   6B,F
08F8:  GOTO   0DD
....................    }    
....................    LEN_PACKAGES = LEN_PACKAGES+5; //5 @ 
08F9:  MOVLW  05
08FA:  BCF    03.5
08FB:  ADDWF  47,F
....................    ITOA (LEN_PACKAGES, 10, TEMP_CHAR); 
08FC:  BSF    03.6
08FD:  CLRF   14
08FE:  CLRF   13
08FF:  CLRF   12
0900:  BCF    03.6
0901:  MOVF   47,W
0902:  BSF    03.6
0903:  MOVWF  11
0904:  MOVLW  0A
0905:  MOVWF  15
0906:  CLRF   17
0907:  MOVLW  67
0908:  MOVWF  16
0909:  BCF    0A.3
090A:  BCF    03.6
090B:  CALL   3F0
090C:  BSF    0A.3
....................    PACKAGE_CONFIG[1] = TEMP_CHAR; 
090D:  BSF    03.5
090E:  CLRF   41
090F:  MOVLW  67
0910:  MOVWF  40
....................     
....................    FOR ( J = 0; J < 6; J++) 
0911:  CLRF   6B
0912:  MOVF   6B,W
0913:  SUBLW  05
0914:  BTFSS  03.0
0915:  GOTO   149
....................    { 
....................       PRINTF (PACKAGE_CONFIG[J]); 
0916:  BCF    03.0
0917:  RLF    6B,W
0918:  ADDLW  BE
0919:  MOVWF  04
091A:  BCF    03.7
091B:  INCF   04,F
091C:  MOVF   00,W
091D:  MOVWF  6D
091E:  DECF   04,F
091F:  MOVF   00,W
0920:  MOVWF  6C
0921:  MOVF   6C,W
0922:  MOVWF  04
0923:  BCF    03.7
0924:  BTFSC  6D.0
0925:  BSF    03.7
....................       PRINTF ("@"); 
*
0941:  MOVLW  40
0942:  BCF    03.5
0943:  BTFSS  0C.4
0944:  GOTO   143
0945:  MOVWF  19
0946:  BSF    03.5
0947:  INCF   6B,F
0948:  GOTO   112
....................    } 
....................  
....................  
....................    LCD_GOTOXY (1, 1) ; 
0949:  MOVLW  01
094A:  BCF    03.5
094B:  BSF    03.6
094C:  MOVWF  10
094D:  MOVWF  11
094E:  BCF    0A.3
094F:  BCF    03.6
0950:  CALL   2AE
0951:  BSF    0A.3
....................    DELAY_MS (10); 
0952:  MOVLW  0A
0953:  BSF    03.6
0954:  MOVWF  10
0955:  BCF    0A.3
0956:  BCF    03.6
0957:  CALL   124
0958:  BSF    0A.3
....................    PRINTF (LCD_PUTC, "WAITING ....        ") ; 
0959:  MOVLW  C0
095A:  BSF    03.6
095B:  MOVWF  0D
095C:  MOVLW  00
095D:  MOVWF  0F
095E:  BCF    0A.3
095F:  BCF    03.6
0960:  CALL   300
0961:  BSF    0A.3
....................    LCD_GOTOXY (1, 1) ; 
0962:  MOVLW  01
0963:  BSF    03.6
0964:  MOVWF  10
0965:  MOVWF  11
0966:  BCF    0A.3
0967:  BCF    03.6
0968:  CALL   2AE
0969:  BSF    0A.3
....................    DELAY_MS (10); 
096A:  MOVLW  0A
096B:  BSF    03.6
096C:  MOVWF  10
096D:  BCF    0A.3
096E:  BCF    03.6
096F:  CALL   124
0970:  BSF    0A.3
....................    PRINTF (LCD_PUTC, "WAITING ....        ") ;    
0971:  MOVLW  CB
0972:  BSF    03.6
0973:  MOVWF  0D
0974:  MOVLW  00
0975:  MOVWF  0F
0976:  BCF    0A.3
0977:  BCF    03.6
0978:  CALL   300
0979:  BSF    0A.3
....................    TT_CONFIG_DONE = 0; 
097A:  BCF    56.3
097B:  BSF    0A.3
097C:  BCF    0A.4
097D:  GOTO   546 (RETURN)
.................... } 
....................  
.................... //--------------------------------------------------------------------// 
....................  
....................  
....................  
....................  
....................  
.................... VOID QUET_PHIM() 
*
00D6:  BSF    03.6
00D7:  CLRF   39
.................... { 
....................    INT BDT = 0; 
....................  
....................    WHILE (!INPUT (BT1_PIN)) //NEU NUT BAM DUOC BAM 
00D8:  BSF    03.5
00D9:  BCF    03.6
00DA:  BSF    06.1
00DB:  BCF    03.5
00DC:  BTFSC  06.1
00DD:  GOTO   0F1
....................    { 
....................       IF (TMR1IF) 
00DE:  BTFSS  0C.0
00DF:  GOTO   0EE
....................       { 
....................          OUTPUT_TOGGLE (PIN_D2); 
00E0:  BSF    03.5
00E1:  BCF    08.2
00E2:  MOVLW  04
00E3:  BCF    03.5
00E4:  XORWF  08,F
....................          TMR1IF = 0; SET_TIMER1 (3036); BDT++; 
00E5:  BCF    0C.0
00E6:  CLRF   0E
00E7:  MOVLW  0B
00E8:  MOVWF  0F
00E9:  MOVLW  DC
00EA:  MOVWF  0E
00EB:  BSF    03.6
00EC:  INCF   39,F
00ED:  BCF    03.6
....................       } 
00EE:  BSF    03.6
00EF:  GOTO   0D8
00F0:  BCF    03.6
....................    } 
....................  
....................    IF (BDT > 20) 
00F1:  BSF    03.6
00F2:  MOVF   39,W
00F3:  SUBLW  14
00F4:  BTFSC  03.0
00F5:  GOTO   0FF
....................    { 
....................       //CONFIG NODE 
....................       TT_CONFIG = ~TT_CONFIG; // VAO TRANG THAI CONFIG 
00F6:  MOVLW  02
00F7:  BCF    03.6
00F8:  XORWF  56,F
....................       TT_CONTROL = ~TT_CONTROL; 
00F9:  MOVLW  04
00FA:  XORWF  56,F
....................       //CONFIG_DONE (); 
....................       TT_CONFIG_DONE = 1; 
00FB:  BSF    56.3
....................       TT_FUN = 0; 
00FC:  BCF    56.4
....................    } 
00FD:  GOTO   103
00FE:  BSF    03.6
....................  
....................    ELSE 
....................    { 
....................       BUTT_OKE (); //OKE 
....................    } 
.................... } 
....................  
.................... #INT_EXT 
....................  
....................  VOID NGAT_NGOAI () 
....................  { 
....................     QUET_PHIM (); 
....................  } 
....................  
*
0103:  BCF    0B.1
0104:  BCF    0A.3
0105:  BCF    0A.4
0106:  GOTO   031
....................  #INT_RDA 
....................  VOID NGAT () 
....................  { 
....................     KYTUCHAR[VT] = GETCH (); 
0107:  MOVLW  A0
0108:  ADDWF  39,W
0109:  MOVWF  04
010A:  BCF    03.7
010B:  BTFSS  0C.5
010C:  GOTO   10B
010D:  MOVF   1A,W
010E:  MOVWF  00
....................  
....................     IF (KYTUCHAR[VT] == '.') 
010F:  MOVLW  A0
0110:  ADDWF  39,W
0111:  MOVWF  04
0112:  BCF    03.7
0113:  MOVF   00,W
0114:  SUBLW  2E
0115:  BTFSS  03.2
0116:  GOTO   11F
....................     { 
....................        KYTUCHAR[VT] = '\0'; 
0117:  MOVLW  A0
0118:  ADDWF  39,W
0119:  MOVWF  04
011A:  BCF    03.7
011B:  CLRF   00
....................        VT = 0; 
011C:  CLRF   39
....................        TTNHAN = 1; 
011D:  BSF    56.0
....................     } 
011E:  GOTO   120
....................  
....................     ELSE 
....................     VT++; 
011F:  INCF   39,F
0120:  BCF    0C.5
0121:  BCF    0A.3
0122:  BCF    0A.4
0123:  GOTO   031
....................  } 
....................  
....................  VOID XUATLCD ( CHAR CHUOI_PRINT[]) 
....................  { 
....................     LCD_GOTOXY (1, 1) ; 
....................     DELAY_MS (10); 
....................     PRINTF (LCD_PUTC, CHUOI_PRINT); 
....................     DELAY_MS (1); 
....................  } 
....................  
....................  VOID XU_LY_UART() 
*
0B71:  MOVLW  2A
0B72:  BSF    03.5
0B73:  MOVWF  3E
....................  { 
....................      //ID_NODE_NHAN = KYTU[1] - 48; 
....................     //ID_DEVICE_NHAN = KYTU[2] - 48 + 64; 
....................     //TT_DEVICE_NHAN = KYTU[3] - 48; // - 48 ASCII -- > S?. + 64 -- > PORT_D (D0 = 64)                
....................      
....................     /*TINH DO DAI*/ 
....................     CHAR CH = '*'; 
....................     CHAR *RET; 
....................     UNSIGNED INT8 LEN_RET; 
....................     RET = STRCHR(KYTUCHAR,CH); 
0B74:  CLRF   45
0B75:  MOVLW  A0
0B76:  MOVWF  44
0B77:  MOVF   3E,W
0B78:  MOVWF  46
*
0B9A:  MOVF   79,W
0B9B:  MOVWF  40
0B9C:  MOVF   78,W
0B9D:  MOVWF  3F
....................     LEN_RET = STRLEN(RET); 
0B9E:  MOVF   40,W
0B9F:  MOVWF  6F
0BA0:  MOVF   3F,W
0BA1:  MOVWF  6E
0BA2:  BCF    0A.3
0BA3:  BCF    03.5
0BA4:  CALL   79F
0BA5:  BSF    0A.3
0BA6:  MOVF   78,W
0BA7:  BSF    03.5
0BA8:  MOVWF  41
....................     /* TINH ID_NODE, ID_GW LUU TRONG PIC*/ 
....................     ID_NODE_NUMBER = ATOI(ID_NODE_CHAR);   
0BA9:  CLRF   45
0BAA:  MOVLW  57
0BAB:  MOVWF  44
0BAC:  BCF    03.5
0BAD:  CALL   17E
0BAE:  CLRF   7A
0BAF:  MOVF   78,W
0BB0:  MOVWF  52
0BB1:  MOVF   7A,W
0BB2:  MOVWF  53
....................     ID_GW_NUMBER =  ATOI(ID_GATEWAY_CHAR);   
0BB3:  BSF    03.5
0BB4:  CLRF   45
0BB5:  MOVLW  5E
0BB6:  MOVWF  44
0BB7:  BCF    03.5
0BB8:  CALL   17E
0BB9:  MOVF   78,W
0BBA:  MOVWF  77
0BBB:  CLRF   78
0BBC:  CLRF   79
0BBD:  CLRF   7A
0BBE:  MOVF   7A,W
0BBF:  MOVWF  4F
0BC0:  MOVF   79,W
0BC1:  MOVWF  4E
0BC2:  MOVF   78,W
0BC3:  MOVWF  4D
0BC4:  MOVF   77,W
0BC5:  MOVWF  4C
....................     /* LAY TOKEN DAU TIEN */     
....................     KYTU = 0; 
0BC6:  CLRF   3A
....................     TEMP_CHAR = "#"; 
0BC7:  BSF    03.5
0BC8:  CLRF   44
0BC9:  CLRF   45
0BCA:  MOVLW  67
0BCB:  MOVWF  04
0BCC:  BCF    03.7
0BCD:  MOVF   44,W
0BCE:  ADDWF  04,F
0BCF:  MOVF   45,W
0BD0:  BCF    0A.3
0BD1:  BCF    03.5
0BD2:  CALL   05E
0BD3:  BSF    0A.3
0BD4:  MOVWF  00
0BD5:  IORLW  00
0BD6:  BTFSC  03.2
0BD7:  GOTO   3DD
0BD8:  BSF    03.5
0BD9:  INCF   45,F
0BDA:  INCF   44,F
0BDB:  GOTO   3CA
0BDC:  BCF    03.5
....................     CHAR * TOKEN; 
....................     TOKEN = STRTOK (KYTUCHAR, TEMP_CHAR);                 
0BDD:  BSF    03.5
0BDE:  CLRF   45
0BDF:  MOVLW  A0
0BE0:  MOVWF  44
0BE1:  CLRF   47
0BE2:  MOVLW  67
0BE3:  MOVWF  46
0BE4:  BCF    03.5
0BE5:  CALL   280
0BE6:  MOVF   79,W
0BE7:  BSF    03.5
0BE8:  MOVWF  43
0BE9:  MOVF   78,W
0BEA:  MOVWF  42
....................     /* DUYET QUA CAC TOKEN CON LAI */                 
....................     WHILE (TOKEN != NULL) 
0BEB:  MOVF   42,F
0BEC:  BTFSS  03.2
0BED:  GOTO   3F1
0BEE:  MOVF   43,F
0BEF:  BTFSC  03.2
0BF0:  GOTO   446
....................     {                 
....................        SWITCH(KYTU) 
0BF1:  BCF    03.5
0BF2:  MOVF   3A,W
0BF3:  ADDLW  FB
0BF4:  BTFSC  03.0
0BF5:  GOTO   42E
0BF6:  ADDLW  05
0BF7:  GOTO   491
....................        { 
....................          CASE 0: 
....................          BREAK; 
0BF8:  GOTO   42E
....................          CASE 1: 
....................          ID_GW_NHAN = ATOI(TOKEN);   
0BF9:  BSF    03.5
0BFA:  MOVF   43,W
0BFB:  MOVWF  45
0BFC:  MOVF   42,W
0BFD:  MOVWF  44
0BFE:  BCF    03.5
0BFF:  CALL   17E
0C00:  MOVF   78,W
0C01:  MOVWF  77
0C02:  CLRF   78
0C03:  CLRF   79
0C04:  CLRF   7A
0C05:  MOVF   7A,W
0C06:  MOVWF  4B
0C07:  MOVF   79,W
0C08:  MOVWF  4A
0C09:  MOVF   78,W
0C0A:  MOVWF  49
0C0B:  MOVF   77,W
0C0C:  MOVWF  48
....................          BREAK;                      
0C0D:  GOTO   42E
....................          CASE 2: 
....................          ID_NODE_NHAN = ATOI(TOKEN);   
0C0E:  BSF    03.5
0C0F:  MOVF   43,W
0C10:  MOVWF  45
0C11:  MOVF   42,W
0C12:  MOVWF  44
0C13:  BCF    03.5
0C14:  CALL   17E
0C15:  CLRF   7A
0C16:  MOVF   78,W
0C17:  MOVWF  50
0C18:  MOVF   7A,W
0C19:  MOVWF  51
....................          BREAK;       
0C1A:  GOTO   42E
....................          CASE 3: 
....................          LENHDIEUKHIEN =  ATOI(TOKEN);                  
0C1B:  BSF    03.5
0C1C:  MOVF   43,W
0C1D:  MOVWF  45
0C1E:  MOVF   42,W
0C1F:  MOVWF  44
0C20:  BCF    03.5
0C21:  CALL   17E
0C22:  MOVF   78,W
0C23:  MOVWF  54
....................          BREAK;     
0C24:  GOTO   42E
....................          CASE 4: 
....................          DODAI_DATA_NHAN =  ATOI(TOKEN);                  
0C25:  BSF    03.5
0C26:  MOVF   43,W
0C27:  MOVWF  45
0C28:  MOVF   42,W
0C29:  MOVWF  44
0C2A:  BCF    03.5
0C2B:  CALL   17E
0C2C:  MOVF   78,W
0C2D:  MOVWF  55
....................          BREAK;           
....................        }   
....................       DELAY_MS (1);                       
0C2E:  MOVLW  01
0C2F:  BSF    03.6
0C30:  MOVWF  10
0C31:  BCF    0A.3
0C32:  BCF    03.6
0C33:  CALL   124
0C34:  BSF    0A.3
....................       TOKEN = STRTOK(NULL, TEMP_CHAR); 
0C35:  BSF    03.5
0C36:  CLRF   45
0C37:  CLRF   44
0C38:  CLRF   47
0C39:  MOVLW  67
0C3A:  MOVWF  46
0C3B:  BCF    03.5
0C3C:  CALL   280
0C3D:  MOVF   79,W
0C3E:  BSF    03.5
0C3F:  MOVWF  43
0C40:  MOVF   78,W
0C41:  MOVWF  42
....................       KYTU++;          
0C42:  BCF    03.5
0C43:  INCF   3A,F
0C44:  BSF    03.5
0C45:  GOTO   3EB
....................     } 
....................     IF (LEN_RET == DODAI_DATA_NHAN){ 
0C46:  BCF    03.5
0C47:  MOVF   55,W
0C48:  BSF    03.5
0C49:  SUBWF  41,W
0C4A:  BTFSS  03.2
0C4B:  GOTO   45E
....................       OUTPUT_D (0XFF); 
0C4C:  CLRF   08
0C4D:  MOVLW  FF
0C4E:  BCF    03.5
0C4F:  MOVWF  08
....................       DELAY_MS (2500) ; 
0C50:  MOVLW  0A
0C51:  BSF    03.5
0C52:  MOVWF  44
0C53:  MOVLW  FA
0C54:  BCF    03.5
0C55:  BSF    03.6
0C56:  MOVWF  10
0C57:  BCF    0A.3
0C58:  BCF    03.6
0C59:  CALL   124
0C5A:  BSF    0A.3
0C5B:  BSF    03.5
0C5C:  DECFSZ 44,F
0C5D:  GOTO   453
....................     } 
....................     IF (ID_NODE_NHAN == ID_NODE_NUMBER && ID_GW_NHAN == ID_GW_NUMBER) 
0C5E:  BCF    03.5
0C5F:  MOVF   52,W
0C60:  SUBWF  50,W
0C61:  BTFSS  03.2
0C62:  GOTO   48E
0C63:  MOVF   53,W
0C64:  SUBWF  51,W
0C65:  BTFSS  03.2
0C66:  GOTO   48E
0C67:  MOVF   4C,W
0C68:  SUBWF  48,W
0C69:  BTFSS  03.2
0C6A:  GOTO   48E
0C6B:  MOVF   4D,W
0C6C:  SUBWF  49,W
0C6D:  BTFSS  03.2
0C6E:  GOTO   48E
0C6F:  MOVF   4E,W
0C70:  SUBWF  4A,W
0C71:  BTFSS  03.2
0C72:  GOTO   48E
0C73:  MOVF   4F,W
0C74:  SUBWF  4B,W
0C75:  BTFSS  03.2
0C76:  GOTO   48E
....................     { 
....................       OUTPUT_D (0XF0); 
0C77:  BSF    03.5
0C78:  CLRF   08
0C79:  MOVLW  F0
0C7A:  BCF    03.5
0C7B:  MOVWF  08
....................       DELAY_MS (2500);  
0C7C:  MOVLW  0A
0C7D:  BSF    03.5
0C7E:  MOVWF  44
0C7F:  MOVLW  FA
0C80:  BCF    03.5
0C81:  BSF    03.6
0C82:  MOVWF  10
0C83:  BCF    0A.3
0C84:  BCF    03.6
0C85:  CALL   124
0C86:  BSF    0A.3
0C87:  BSF    03.5
0C88:  DECFSZ 44,F
0C89:  GOTO   47F
....................       OUTPUT_D (0X0F); 
0C8A:  CLRF   08
0C8B:  MOVLW  0F
0C8C:  BCF    03.5
0C8D:  MOVWF  08
....................     } 
0C8E:  BSF    0A.3
0C8F:  BCF    0A.4
0C90:  GOTO   550 (RETURN)
....................  } 
....................  
....................  INT ADC_READ (INT KENH) 
....................  { 
....................     SET_ADC_CHANNEL (KENH); 
....................     KQADC = 0; 
....................     FOR (INT I = 0; I < 100; I++) 
....................     { 
....................        KQADC = KQADC + READ_ADC () ; 
....................        DELAY_MS (1); 
....................     } 
....................  
....................     KQADC = KQADC / (100 * 2.046); 
....................     RETURN KQADC; 
....................  } 
....................  
....................  VOID CHUONG_TRINH_CON () 
....................  { 
....................     FOR (INT I = 0; I <= 30; I++) 
*
07CB:  BSF    03.5
07CC:  CLRF   3E
07CD:  MOVF   3E,W
07CE:  SUBLW  1E
07CF:  BTFSS  03.0
07D0:  GOTO   7DD
....................     { 
....................        OUTPUT_TOGGLE (PIN_D1); 
07D1:  BCF    08.1
07D2:  MOVLW  02
07D3:  BCF    03.5
07D4:  XORWF  08,F
....................        DELAY_MS (100); 
07D5:  MOVLW  64
07D6:  BSF    03.6
07D7:  MOVWF  10
07D8:  BCF    03.6
07D9:  CALL   124
07DA:  BSF    03.5
07DB:  INCF   3E,F
07DC:  GOTO   7CD
....................     } 
07DD:  BCF    03.5
07DE:  BSF    0A.3
07DF:  BCF    0A.4
07E0:  GOTO   54B (RETURN)
....................  } 
....................  
....................  VOID MAIN  () 
*
0C9A:  MOVF   03,W
0C9B:  ANDLW  1F
0C9C:  MOVWF  03
0C9D:  BSF    03.5
0C9E:  BSF    03.6
0C9F:  BSF    07.3
0CA0:  MOVLW  08
0CA1:  BCF    03.6
0CA2:  MOVWF  19
0CA3:  MOVLW  02
0CA4:  MOVWF  1A
0CA5:  MOVLW  A6
0CA6:  MOVWF  18
0CA7:  MOVLW  90
0CA8:  BCF    03.5
0CA9:  MOVWF  18
0CAA:  MOVLW  FF
0CAB:  MOVWF  31
0CAC:  CLRF   38
0CAD:  CLRF   39
0CAE:  CLRF   3A
0CAF:  CLRF   47
0CB0:  CLRF   54
0CB1:  CLRF   55
0CB2:  BCF    56.0
0CB3:  BCF    56.1
0CB4:  BCF    56.2
0CB5:  BCF    56.3
0CB6:  BCF    56.4
0CB7:  BCF    56.5
0CB8:  BSF    03.5
0CB9:  BSF    03.6
0CBA:  MOVF   09,W
0CBB:  ANDLW  C0
0CBC:  MOVWF  09
0CBD:  BCF    03.6
0CBE:  BCF    1F.4
0CBF:  BCF    1F.5
0CC0:  MOVLW  00
0CC1:  BSF    03.6
0CC2:  MOVWF  08
0CC3:  BCF    03.5
0CC4:  CLRF   07
0CC5:  CLRF   08
0CC6:  CLRF   09
0CC7:  BCF    03.7
....................  { 
....................     SET_TRIS_D (0X00); 
*
0D01:  MOVLW  00
0D02:  BSF    03.5
0D03:  MOVWF  08
....................     SET_TRIS_B (0XFF); 
0D04:  MOVLW  FF
0D05:  MOVWF  06
....................     SET_TRIS_E (0); 
0D06:  BCF    09.0
0D07:  BCF    09.1
0D08:  BCF    09.2
0D09:  BCF    09.3
....................     SET_TRIS_C (0X80); 
0D0A:  MOVLW  80
0D0B:  MOVWF  07
0D0C:  BCF    03.5
0D0D:  MOVWF  31
....................     SETUP_ADC (ADC_CLOCK_DIV_8); 
0D0E:  BSF    1F.6
0D0F:  BCF    1F.7
0D10:  BSF    03.5
0D11:  BSF    1F.7
0D12:  BCF    03.5
0D13:  BSF    1F.0
....................     SETUP_ADC_PORTS (SAN0); 
0D14:  BSF    03.5
0D15:  BSF    03.6
0D16:  MOVF   09,W
0D17:  ANDLW  C0
0D18:  MOVWF  09
0D19:  BCF    03.6
0D1A:  BCF    1F.4
0D1B:  BCF    1F.5
0D1C:  MOVLW  01
0D1D:  BSF    03.6
0D1E:  MOVWF  08
....................     ENABLE_INTERRUPTS (INT_TIMER0); 
0D1F:  BCF    03.5
0D20:  BCF    03.6
0D21:  BSF    0B.5
....................     ENABLE_INTERRUPTS (INT_EXT); //CHO PHEP NGAT NGOAI 
0D22:  BSF    0B.4
....................     ENABLE_INTERRUPTS (INT_EXT_H2L); //NGAT XAY RA KHI CO XUNG TU CAO XUONG THAP 
0D23:  BSF    0B.4
0D24:  BSF    03.5
0D25:  BCF    01.6
....................     ENABLE_INTERRUPTS (INT_RDA); 
0D26:  BSF    0C.5
....................     ENABLE_INTERRUPTS (GLOBAL); 
0D27:  MOVLW  C0
0D28:  BCF    03.5
0D29:  IORWF  0B,F
....................      
....................     SETUP_TIMER_1 (T1_INTERNAL|T1_DIV_BY_8); 
0D2A:  MOVLW  35
0D2B:  MOVWF  10
....................     //SET_TIMER1 (0); 
....................     SET_TIMER1 (3036); 
0D2C:  CLRF   0E
0D2D:  MOVLW  0B
0D2E:  MOVWF  0F
0D2F:  MOVLW  DC
0D30:  MOVWF  0E
....................     TMR1IF = 0; 
0D31:  BCF    0C.0
....................     LCD_INIT (); // KHOI TAO LCD 
0D32:  BCF    0A.3
0D33:  GOTO   23E
0D34:  BSF    0A.3
....................  
....................     TT_CONFIG = 0; 
0D35:  BCF    56.1
....................     TT_CONFIG_DONE = 0; 
0D36:  BCF    56.3
....................     TT_CONTROL = 1; 
0D37:  BSF    56.2
....................     OUTPUT_D (0X00); 
0D38:  BSF    03.5
0D39:  CLRF   08
0D3A:  BCF    03.5
0D3B:  CLRF   08
....................     TTNHAN = 0; 
0D3C:  BCF    56.0
....................      
....................      
....................      
....................     WHILE (TRUE) 
....................     { 
....................        IF (TT_CONFIG)             {BUTT_FUN (); } // GOI HAM CHON LENH (SWITCH CASE) 
0D3D:  BTFSS  56.1
0D3E:  GOTO   543
0D3F:  BCF    0A.3
0D40:  GOTO   544
0D41:  BSF    0A.3
0D42:  GOTO   551
....................        ELSE IF (TT_CONFIG_DONE)   { CONFIG_DONE ();}        
0D43:  BTFSS  56.3
0D44:  GOTO   547
0D45:  GOTO   000
0D46:  GOTO   551
....................        ELSE 
....................        { 
....................           WHILE (!TT_CONFIG) 
0D47:  BTFSC  56.1
0D48:  GOTO   551
....................           { 
....................              CHUONG_TRINH_CON ();              
0D49:  BCF    0A.3
0D4A:  GOTO   7CB
0D4B:  BSF    0A.3
....................              IF (TTNHAN == 1) 
0D4C:  BTFSS  56.0
0D4D:  GOTO   550
....................              { 
....................                 TTNHAN = 0; 
0D4E:  BCF    56.0
....................                 XU_LY_UART(); 
0D4F:  GOTO   371
....................              } 
0D50:  GOTO   547
....................           } 
....................        } 
0D51:  GOTO   53D
....................     } 
....................  } 
....................  
0D52:  SLEEP

Configuration Fuses:
   Word  1: 2FE2   HS NOWDT PUT MCLR NOPROTECT NOCPD BROWNOUT IESO FCMEN NOLVP NODEBUG
   Word  2: 3FFF   BORV40 NOWRT
