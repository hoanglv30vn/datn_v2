CCS PCM C Compiler, Version 5.015, 5967               09-Nov-21 14:50

               Filename:   E:\DATN_V2\NODE\pic\pic16f887\hellopic.lst

               ROM used:   4950 words (60%)
                           Largest free fragment is 2048
               RAM used:   174 (47%) at main() level
                           259 (70%) worst case
               Stack used: 8 locations (7 in main + 1 for interrupts)
               Stack size: 8

*
0000:  MOVLW  12
0001:  MOVWF  0A
0002:  GOTO   279
0003:  NOP
0004:  MOVWF  7F
0005:  SWAPF  03,W
0006:  CLRF   03
0007:  MOVWF  21
0008:  MOVF   0A,W
0009:  MOVWF  20
000A:  CLRF   0A
000B:  MOVF   04,W
000C:  MOVWF  22
000D:  MOVF   77,W
000E:  MOVWF  23
000F:  MOVF   78,W
0010:  MOVWF  24
0011:  MOVF   79,W
0012:  MOVWF  25
0013:  MOVF   7A,W
0014:  MOVWF  26
0015:  BSF    03.6
0016:  MOVF   0D,W
0017:  BCF    03.6
0018:  MOVWF  27
0019:  BSF    03.6
001A:  MOVF   0F,W
001B:  BCF    03.6
001C:  MOVWF  28
001D:  BSF    03.6
001E:  MOVF   0C,W
001F:  BCF    03.6
0020:  MOVWF  29
0021:  BSF    03.6
0022:  MOVF   0E,W
0023:  BCF    03.6
0024:  MOVWF  2A
0025:  BCF    03.7
0026:  BCF    03.5
0027:  BTFSS  0B.4
0028:  GOTO   02B
0029:  BTFSC  0B.1
002A:  GOTO   052
002B:  MOVLW  8C
002C:  MOVWF  04
002D:  BTFSS  00.5
002E:  GOTO   031
002F:  BTFSC  0C.5
0030:  GOTO   055
0031:  MOVF   22,W
0032:  MOVWF  04
0033:  MOVF   23,W
0034:  MOVWF  77
0035:  MOVF   24,W
0036:  MOVWF  78
0037:  MOVF   25,W
0038:  MOVWF  79
0039:  MOVF   26,W
003A:  MOVWF  7A
003B:  MOVF   27,W
003C:  BSF    03.6
003D:  MOVWF  0D
003E:  BCF    03.6
003F:  MOVF   28,W
0040:  BSF    03.6
0041:  MOVWF  0F
0042:  BCF    03.6
0043:  MOVF   29,W
0044:  BSF    03.6
0045:  MOVWF  0C
0046:  BCF    03.6
0047:  MOVF   2A,W
0048:  BSF    03.6
0049:  MOVWF  0E
004A:  BCF    03.6
004B:  MOVF   20,W
004C:  MOVWF  0A
004D:  SWAPF  21,W
004E:  MOVWF  03
004F:  SWAPF  7F,F
0050:  SWAPF  7F,W
0051:  RETFIE
0052:  BCF    0A.3
0053:  BCF    0A.4
0054:  GOTO   10D
0055:  BCF    0A.3
0056:  BCF    0A.4
0057:  GOTO   153
....................  
.................... #INCLUDE <thuvien.c> 
.................... #INCLUDE <16F887.H> 
.................... //////////// Standard Header file for the PIC16F887 device //////////////// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2013 Custom Computer Services          //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... #device PIC16F887 
0058:  BCF    0A.0
0059:  BCF    0A.1
005A:  BCF    0A.2
005B:  ADDWF  02,F
005C:  RETLW  30
005D:  RETLW  00
005E:  BCF    0A.0
005F:  BCF    0A.1
0060:  BCF    0A.2
0061:  ADDWF  02,F
0062:  RETLW  5F
0063:  RETLW  00
0064:  BCF    0A.0
0065:  BCF    0A.1
0066:  BCF    0A.2
0067:  ADDWF  02,F
0068:  RETLW  32
0069:  RETLW  32
006A:  RETLW  00
006B:  BCF    0A.0
006C:  BCF    0A.1
006D:  BCF    0A.2
006E:  ADDWF  02,F
006F:  RETLW  32
0070:  RETLW  33
0071:  RETLW  00
0072:  BCF    0A.0
0073:  BCF    0A.1
0074:  BCF    0A.2
0075:  ADDWF  02,F
0076:  RETLW  32
0077:  RETLW  34
0078:  RETLW  00
0079:  BCF    0A.0
007A:  BCF    0A.1
007B:  BCF    0A.2
007C:  ADDWF  02,F
007D:  RETLW  23
007E:  RETLW  00
007F:  BCF    0A.0
0080:  BCF    0A.1
0081:  BCF    0A.2
0082:  ADDWF  02,F
0083:  RETLW  00
0084:  DATA CE,27
0085:  DATA C4,22
0086:  DATA 3A,10
0087:  DATA 00,00
0088:  DATA 30,18
0089:  DATA 30,18
008A:  DATA 20,10
008B:  DATA 20,10
008C:  DATA 20,10
008D:  DATA 20,10
008E:  DATA 20,10
008F:  DATA 00,01
0090:  DATA 20,10
0091:  DATA 20,10
0092:  DATA 20,10
0093:  DATA 5F,10
0094:  DATA 20,10
0095:  DATA 20,10
0096:  DATA 20,10
0097:  DATA 20,10
0098:  DATA 20,10
0099:  DATA 20,10
009A:  DATA 20,00
009B:  DATA 20,10
009C:  DATA 20,10
009D:  DATA 5F,10
009E:  DATA 20,10
009F:  DATA 20,00
00A0:  DATA 49,22
00A1:  DATA DF,23
00A2:  DATA 57,1D
00A3:  DATA 00,01
00A4:  DATA 30,18
00A5:  DATA 30,18
00A6:  DATA 30,18
00A7:  DATA 20,10
00A8:  DATA 20,10
00A9:  DATA 20,10
00AA:  DATA 20,10
00AB:  DATA 00,01
00AC:  DATA 20,10
00AD:  DATA 20,10
00AE:  DATA 20,10
00AF:  DATA 5F,10
00B0:  DATA 20,10
00B1:  DATA 20,10
00B2:  DATA 20,10
00B3:  DATA 20,10
00B4:  DATA 20,10
00B5:  DATA 20,10
00B6:  DATA 20,10
00B7:  DATA 20,00
00B8:  DATA 20,10
00B9:  DATA 20,10
00BA:  DATA 5F,10
00BB:  DATA 20,10
00BC:  DATA 20,10
00BD:  DATA 20,10
00BE:  DATA 20,00
00BF:  DATA C3,27
00C0:  DATA 4E,23
00C1:  DATA C9,23
00C2:  DATA 3A,10
00C3:  DATA 20,10
00C4:  DATA 20,10
00C5:  DATA 20,10
00C6:  DATA 20,00
00C7:  DATA C3,20
00C8:  DATA D3,22
00C9:  DATA 3A,10
00CA:  DATA 20,10
00CB:  DATA 20,10
00CC:  DATA 20,10
00CD:  DATA 20,10
00CE:  DATA 20,00
00CF:  DATA A0,16
00D0:  DATA A0,24
00D1:  DATA C4,16
00D2:  DATA CE,27
00D3:  DATA C4,22
00D4:  DATA 20,10
00D5:  DATA 20,10
00D6:  DATA 20,10
00D7:  DATA 00,01
00D8:  DATA A0,16
00D9:  DATA A0,24
00DA:  DATA C4,16
00DB:  DATA C7,2B
00DC:  DATA 20,10
00DD:  DATA 20,10
00DE:  DATA 20,10
00DF:  DATA 20,00
00E0:  DATA D7,20
00E1:  DATA 49,2A
00E2:  DATA 49,27
00E3:  DATA 47,10
00E4:  DATA 2E,17
00E5:  DATA 2E,17
00E6:  DATA 20,10
00E7:  DATA 20,10
00E8:  DATA 20,10
00E9:  DATA 20,10
00EA:  DATA 00,01
00EB:  DATA D7,20
00EC:  DATA 49,2A
00ED:  DATA 49,27
00EE:  DATA 47,10
00EF:  DATA 2E,17
00F0:  DATA 2E,17
00F1:  DATA 20,10
00F2:  DATA 20,10
00F3:  DATA 20,10
00F4:  DATA 20,10
00F5:  DATA 00,00
00F6:  DATA 20,10
00F7:  DATA 20,10
00F8:  DATA 20,10
00F9:  DATA 20,10
00FA:  DATA 20,10
00FB:  DATA 20,10
00FC:  DATA 00,01
00FD:  DATA 54,21
00FE:  DATA 3A,10
00FF:  DATA 00,01
0100:  DATA 20,10
0101:  DATA 20,10
0102:  DATA 43,21
0103:  DATA 3A,00
0104:  DATA 40,22
0105:  DATA 4B,20
0106:  DATA 00,00
0107:  DATA D3,2B
0108:  DATA 3A,10
0109:  DATA 00,01
010A:  DATA C0,29
010B:  DATA 53,20
010C:  DATA 00,01
*
033E:  MOVF   0B,W
033F:  BSF    03.6
0340:  MOVWF  3D
0341:  BCF    03.6
0342:  BCF    0B.7
0343:  BSF    03.5
0344:  BSF    03.6
0345:  BSF    0C.7
0346:  BSF    0C.0
0347:  NOP
0348:  NOP
0349:  BCF    03.5
034A:  BTFSS  3D.7
034B:  GOTO   34F
034C:  BCF    03.6
034D:  BSF    0B.7
034E:  BSF    03.6
034F:  MOVF   0C,W
0350:  ANDLW  7F
0351:  BTFSC  03.2
0352:  GOTO   38C
0353:  MOVWF  3D
0354:  MOVF   0D,W
0355:  MOVWF  3E
0356:  MOVF   0F,W
0357:  MOVWF  3F
0358:  MOVF   3D,W
0359:  MOVWF  40
035A:  BCF    03.6
035B:  CALL   304
035C:  BSF    03.6
035D:  MOVF   3E,W
035E:  MOVWF  0D
035F:  MOVF   3F,W
0360:  MOVWF  0F
0361:  BCF    03.6
0362:  MOVF   0B,W
0363:  BSF    03.6
0364:  MOVWF  40
0365:  BCF    03.6
0366:  BCF    0B.7
0367:  BSF    03.5
0368:  BSF    03.6
0369:  BSF    0C.7
036A:  BSF    0C.0
036B:  NOP
036C:  NOP
036D:  BCF    03.5
036E:  BTFSS  40.7
036F:  GOTO   373
0370:  BCF    03.6
0371:  BSF    0B.7
0372:  BSF    03.6
0373:  RLF    0C,W
0374:  RLF    0E,W
0375:  ANDLW  7F
0376:  BTFSC  03.2
0377:  GOTO   38C
0378:  MOVWF  3D
0379:  MOVF   0D,W
037A:  MOVWF  3E
037B:  MOVF   0F,W
037C:  MOVWF  3F
037D:  MOVF   3D,W
037E:  MOVWF  40
037F:  BCF    03.6
0380:  CALL   304
0381:  BSF    03.6
0382:  MOVF   3E,W
0383:  MOVWF  0D
0384:  MOVF   3F,W
0385:  MOVWF  0F
0386:  INCF   0D,F
0387:  BTFSC  03.2
0388:  INCF   0F,F
0389:  BCF    03.6
038A:  GOTO   33E
038B:  BSF    03.6
038C:  BCF    03.6
038D:  RETURN
038E:  BTFSC  03.1
038F:  GOTO   393
0390:  MOVLW  5E
0391:  MOVWF  04
0392:  BSF    03.7
0393:  BSF    03.6
0394:  MOVF   59,W
0395:  XORWF  5D,W
0396:  ANDLW  80
0397:  MOVWF  63
0398:  BTFSS  59.7
0399:  GOTO   3A5
039A:  COMF   56,F
039B:  COMF   57,F
039C:  COMF   58,F
039D:  COMF   59,F
039E:  INCF   56,F
039F:  BTFSC  03.2
03A0:  INCF   57,F
03A1:  BTFSC  03.2
03A2:  INCF   58,F
03A3:  BTFSC  03.2
03A4:  INCF   59,F
03A5:  BTFSS  5D.7
03A6:  GOTO   3B2
03A7:  COMF   5A,F
03A8:  COMF   5B,F
03A9:  COMF   5C,F
03AA:  COMF   5D,F
03AB:  INCF   5A,F
03AC:  BTFSC  03.2
03AD:  INCF   5B,F
03AE:  BTFSC  03.2
03AF:  INCF   5C,F
03B0:  BTFSC  03.2
03B1:  INCF   5D,F
03B2:  CLRF   77
03B3:  CLRF   78
03B4:  CLRF   79
03B5:  CLRF   7A
03B6:  CLRF   5E
03B7:  CLRF   5F
03B8:  CLRF   60
03B9:  CLRF   61
03BA:  MOVF   5D,W
03BB:  IORWF  5C,W
03BC:  IORWF  5B,W
03BD:  IORWF  5A,W
03BE:  BTFSC  03.2
03BF:  GOTO   3F0
03C0:  MOVLW  20
03C1:  MOVWF  62
03C2:  BCF    03.0
03C3:  RLF    56,F
03C4:  RLF    57,F
03C5:  RLF    58,F
03C6:  RLF    59,F
03C7:  RLF    5E,F
03C8:  RLF    5F,F
03C9:  RLF    60,F
03CA:  RLF    61,F
03CB:  MOVF   5D,W
03CC:  SUBWF  61,W
03CD:  BTFSS  03.2
03CE:  GOTO   3D9
03CF:  MOVF   5C,W
03D0:  SUBWF  60,W
03D1:  BTFSS  03.2
03D2:  GOTO   3D9
03D3:  MOVF   5B,W
03D4:  SUBWF  5F,W
03D5:  BTFSS  03.2
03D6:  GOTO   3D9
03D7:  MOVF   5A,W
03D8:  SUBWF  5E,W
03D9:  BTFSS  03.0
03DA:  GOTO   3EA
03DB:  MOVF   5A,W
03DC:  SUBWF  5E,F
03DD:  MOVF   5B,W
03DE:  BTFSS  03.0
03DF:  INCFSZ 5B,W
03E0:  SUBWF  5F,F
03E1:  MOVF   5C,W
03E2:  BTFSS  03.0
03E3:  INCFSZ 5C,W
03E4:  SUBWF  60,F
03E5:  MOVF   5D,W
03E6:  BTFSS  03.0
03E7:  INCFSZ 5D,W
03E8:  SUBWF  61,F
03E9:  BSF    03.0
03EA:  RLF    77,F
03EB:  RLF    78,F
03EC:  RLF    79,F
03ED:  RLF    7A,F
03EE:  DECFSZ 62,F
03EF:  GOTO   3C2
03F0:  BTFSS  63.7
03F1:  GOTO   3FD
03F2:  COMF   77,F
03F3:  COMF   78,F
03F4:  COMF   79,F
03F5:  COMF   7A,F
03F6:  INCF   77,F
03F7:  BTFSC  03.2
03F8:  INCF   78,F
03F9:  BTFSC  03.2
03FA:  INCF   79,F
03FB:  BTFSC  03.2
03FC:  INCF   7A,F
03FD:  MOVF   5E,W
03FE:  MOVWF  00
03FF:  INCF   04,F
0400:  MOVF   5F,W
0401:  MOVWF  00
0402:  INCF   04,F
0403:  MOVF   60,W
0404:  MOVWF  00
0405:  INCF   04,F
0406:  MOVF   61,W
0407:  MOVWF  00
0408:  BCF    03.6
0409:  RETURN
*
0423:  MOVLW  20
0424:  MOVWF  5A
0425:  CLRF   56
0426:  CLRF   57
0427:  CLRF   58
0428:  CLRF   59
0429:  MOVF   51,W
042A:  MOVWF  7A
042B:  MOVF   50,W
042C:  MOVWF  79
042D:  MOVF   4F,W
042E:  MOVWF  78
042F:  MOVF   4E,W
0430:  MOVWF  77
0431:  BCF    03.0
0432:  BTFSS  77.0
0433:  GOTO   442
0434:  MOVF   52,W
0435:  ADDWF  56,F
0436:  MOVF   53,W
0437:  BTFSC  03.0
0438:  INCFSZ 53,W
0439:  ADDWF  57,F
043A:  MOVF   54,W
043B:  BTFSC  03.0
043C:  INCFSZ 54,W
043D:  ADDWF  58,F
043E:  MOVF   55,W
043F:  BTFSC  03.0
0440:  INCFSZ 55,W
0441:  ADDWF  59,F
0442:  RRF    59,F
0443:  RRF    58,F
0444:  RRF    57,F
0445:  RRF    56,F
0446:  RRF    7A,F
0447:  RRF    79,F
0448:  RRF    78,F
0449:  RRF    77,F
044A:  DECFSZ 5A,F
044B:  GOTO   431
*
052A:  MOVF   00,F
052B:  BTFSC  03.2
052C:  GOTO   546
052D:  BSF    03.6
052E:  CLRF   1A
052F:  MOVF   04,W
0530:  MOVWF  19
0531:  BCF    1A.0
0532:  BTFSC  03.7
0533:  BSF    1A.0
0534:  MOVF   00,W
0535:  MOVWF  40
0536:  BCF    03.6
0537:  CALL   304
0538:  BSF    03.6
0539:  MOVF   19,W
053A:  MOVWF  04
053B:  BCF    03.7
053C:  BTFSC  1A.0
053D:  BSF    03.7
053E:  INCF   04,F
053F:  BTFSS  03.2
0540:  GOTO   544
0541:  BCF    03.6
0542:  INCF   05,F
0543:  BSF    03.6
0544:  BCF    03.6
0545:  GOTO   52A
0546:  RETURN
0547:  BSF    03.6
0548:  MOVF   15,W
0549:  CLRF   78
054A:  SUBWF  14,W
054B:  BTFSC  03.0
054C:  GOTO   550
054D:  MOVF   14,W
054E:  MOVWF  77
054F:  GOTO   55C
0550:  CLRF   77
0551:  MOVLW  08
0552:  MOVWF  16
0553:  RLF    14,F
0554:  RLF    77,F
0555:  MOVF   15,W
0556:  SUBWF  77,W
0557:  BTFSC  03.0
0558:  MOVWF  77
0559:  RLF    78,F
055A:  DECFSZ 16,F
055B:  GOTO   553
055C:  BCF    03.6
055D:  RETURN
*
0799:  MOVF   00,F
079A:  BTFSC  03.2
079B:  GOTO   7B6
079C:  BSF    03.6
079D:  CLRF   40
079E:  MOVF   04,W
079F:  MOVWF  3F
07A0:  BCF    40.0
07A1:  BTFSC  03.7
07A2:  BSF    40.0
07A3:  MOVF   00,W
07A4:  BCF    03.6
07A5:  BTFSS  0C.4
07A6:  GOTO   7A5
07A7:  MOVWF  19
07A8:  BSF    03.6
07A9:  MOVF   3F,W
07AA:  MOVWF  04
07AB:  BCF    03.7
07AC:  BTFSC  40.0
07AD:  BSF    03.7
07AE:  INCF   04,F
07AF:  BTFSS  03.2
07B0:  GOTO   7B4
07B1:  BCF    03.6
07B2:  INCF   05,F
07B3:  BSF    03.6
07B4:  BCF    03.6
07B5:  GOTO   799
07B6:  RETURN
07B7:  CLRF   77
07B8:  CLRF   78
07B9:  BSF    03.6
07BA:  MOVF   1F,W
07BB:  BCF    03.0
07BC:  BTFSC  20.0
07BD:  ADDWF  77,F
07BE:  RRF    77,F
07BF:  RRF    78,F
07C0:  BTFSC  20.1
07C1:  ADDWF  77,F
07C2:  RRF    77,F
07C3:  RRF    78,F
07C4:  BTFSC  20.2
07C5:  ADDWF  77,F
07C6:  RRF    77,F
07C7:  RRF    78,F
07C8:  BTFSC  20.3
07C9:  ADDWF  77,F
07CA:  RRF    77,F
07CB:  RRF    78,F
07CC:  BTFSC  20.4
07CD:  ADDWF  77,F
07CE:  RRF    77,F
07CF:  RRF    78,F
07D0:  BTFSC  20.5
07D1:  ADDWF  77,F
07D2:  RRF    77,F
07D3:  RRF    78,F
07D4:  BTFSC  20.6
07D5:  ADDWF  77,F
07D6:  RRF    77,F
07D7:  RRF    78,F
07D8:  BTFSC  20.7
07D9:  ADDWF  77,F
07DA:  RRF    77,F
07DB:  RRF    78,F
07DC:  BCF    03.6
07DD:  RETURN
07DE:  BSF    03.6
07DF:  MOVF   19,W
07E0:  ANDLW  07
07E1:  MOVWF  77
07E2:  RRF    19,W
07E3:  MOVWF  78
07E4:  RRF    78,F
07E5:  RRF    78,F
07E6:  MOVLW  1F
07E7:  ANDWF  78,F
07E8:  MOVF   78,W
07E9:  ADDWF  1B,W
07EA:  MOVWF  04
07EB:  BCF    03.7
07EC:  BTFSC  1C.0
07ED:  BSF    03.7
07EE:  CLRF   78
07EF:  INCF   78,F
07F0:  INCF   77,F
07F1:  GOTO   7F3
07F2:  RLF    78,F
07F3:  DECFSZ 77,F
07F4:  GOTO   7F2
07F5:  MOVF   1A,F
07F6:  BTFSC  03.2
07F7:  GOTO   7FB
07F8:  MOVF   78,W
07F9:  IORWF  00,F
07FA:  GOTO   7FE
07FB:  COMF   78,F
07FC:  MOVF   78,W
07FD:  ANDWF  00,F
07FE:  BCF    03.6
07FF:  RETURN
*
0B52:  BSF    03.6
0B53:  MOVF   1C,W
0B54:  ANDLW  07
0B55:  MOVWF  77
0B56:  RRF    1C,W
0B57:  MOVWF  78
0B58:  RRF    78,F
0B59:  RRF    78,F
0B5A:  MOVLW  1F
0B5B:  ANDWF  78,F
0B5C:  MOVF   78,W
0B5D:  ADDWF  1D,W
0B5E:  MOVWF  04
0B5F:  BCF    03.7
0B60:  BTFSC  1E.0
0B61:  BSF    03.7
0B62:  MOVF   00,W
0B63:  MOVWF  78
0B64:  INCF   77,F
0B65:  GOTO   367
0B66:  RRF    78,F
0B67:  DECFSZ 77,F
0B68:  GOTO   366
0B69:  BCF    03.6
0B6A:  RETURN
0B6B:  MOVF   0B,W
0B6C:  BSF    03.6
0B6D:  MOVWF  2B
0B6E:  BCF    03.6
0B6F:  BCF    0B.7
0B70:  BSF    03.5
0B71:  BSF    03.6
0B72:  BSF    0C.7
0B73:  BSF    0C.0
0B74:  NOP
0B75:  NOP
0B76:  BCF    03.5
0B77:  BTFSS  2B.7
0B78:  GOTO   37C
0B79:  BCF    03.6
0B7A:  BSF    0B.7
0B7B:  BSF    03.6
0B7C:  MOVF   0C,W
0B7D:  ANDLW  7F
0B7E:  BTFSC  03.2
0B7F:  GOTO   3BB
0B80:  MOVWF  2B
0B81:  MOVF   0D,W
0B82:  MOVWF  2C
0B83:  MOVF   0F,W
0B84:  MOVWF  2D
0B85:  MOVF   2B,W
0B86:  BCF    03.6
0B87:  BTFSS  0C.4
0B88:  GOTO   387
0B89:  MOVWF  19
0B8A:  BSF    03.6
0B8B:  MOVF   2C,W
0B8C:  MOVWF  0D
0B8D:  MOVF   2D,W
0B8E:  MOVWF  0F
0B8F:  BCF    03.6
0B90:  MOVF   0B,W
0B91:  BSF    03.6
0B92:  MOVWF  2E
0B93:  BCF    03.6
0B94:  BCF    0B.7
0B95:  BSF    03.5
0B96:  BSF    03.6
0B97:  BSF    0C.7
0B98:  BSF    0C.0
0B99:  NOP
0B9A:  NOP
0B9B:  BCF    03.5
0B9C:  BTFSS  2E.7
0B9D:  GOTO   3A1
0B9E:  BCF    03.6
0B9F:  BSF    0B.7
0BA0:  BSF    03.6
0BA1:  RLF    0C,W
0BA2:  RLF    0E,W
0BA3:  ANDLW  7F
0BA4:  BTFSC  03.2
0BA5:  GOTO   3BB
0BA6:  MOVWF  2B
0BA7:  MOVF   0D,W
0BA8:  MOVWF  2C
0BA9:  MOVF   0F,W
0BAA:  MOVWF  2D
0BAB:  MOVF   2B,W
0BAC:  BCF    03.6
0BAD:  BTFSS  0C.4
0BAE:  GOTO   3AD
0BAF:  MOVWF  19
0BB0:  BSF    03.6
0BB1:  MOVF   2C,W
0BB2:  MOVWF  0D
0BB3:  MOVF   2D,W
0BB4:  MOVWF  0F
0BB5:  INCF   0D,F
0BB6:  BTFSC  03.2
0BB7:  INCF   0F,F
0BB8:  BCF    03.6
0BB9:  GOTO   36B
0BBA:  BSF    03.6
0BBB:  BCF    03.6
0BBC:  RETURN
*
0F6B:  BSF    0A.0
0F6C:  BSF    0A.1
0F6D:  BSF    0A.2
0F6E:  ADDWF  02,F
0F6F:  GOTO   5E6
0F70:  GOTO   5E7
0F71:  GOTO   5F4
0F72:  GOTO   601
0F73:  GOTO   60B
0F74:  GOTO   615
*
1079:  MOVLW  8E
107A:  MOVWF  77
107B:  MOVF   1D,W
107C:  MOVWF  78
107D:  MOVF   1C,W
107E:  MOVWF  79
107F:  CLRF   7A
1080:  MOVF   78,F
1081:  BTFSS  03.2
1082:  GOTO   08D
1083:  MOVF   79,W
1084:  MOVWF  78
1085:  CLRF   79
1086:  MOVLW  08
1087:  SUBWF  77,F
1088:  MOVF   78,F
1089:  BTFSS  03.2
108A:  GOTO   08D
108B:  CLRF   77
108C:  GOTO   095
108D:  BCF    03.0
108E:  BTFSC  78.7
108F:  GOTO   094
1090:  RLF    79,F
1091:  RLF    78,F
1092:  DECF   77,F
1093:  GOTO   08D
1094:  BCF    78.7
*
10A5:  MOVF   1C,W
10A6:  BTFSC  03.2
10A7:  GOTO   16A
10A8:  MOVWF  28
10A9:  MOVF   20,W
10AA:  BTFSC  03.2
10AB:  GOTO   16A
10AC:  SUBWF  28,F
10AD:  BTFSS  03.0
10AE:  GOTO   0B4
10AF:  MOVLW  7F
10B0:  ADDWF  28,F
10B1:  BTFSC  03.0
10B2:  GOTO   16A
10B3:  GOTO   0BA
10B4:  MOVLW  81
10B5:  SUBWF  28,F
10B6:  BTFSS  03.0
10B7:  GOTO   16A
10B8:  BTFSC  03.2
10B9:  GOTO   16A
10BA:  MOVF   28,W
10BB:  MOVWF  77
10BC:  CLRF   78
10BD:  CLRF   79
10BE:  CLRF   7A
10BF:  CLRF   27
10C0:  MOVF   1D,W
10C1:  MOVWF  26
10C2:  BSF    26.7
10C3:  MOVF   1E,W
10C4:  MOVWF  25
10C5:  MOVF   1F,W
10C6:  MOVWF  24
10C7:  MOVLW  19
10C8:  MOVWF  28
10C9:  MOVF   23,W
10CA:  SUBWF  24,F
10CB:  BTFSC  03.0
10CC:  GOTO   0DD
10CD:  MOVLW  01
10CE:  SUBWF  25,F
10CF:  BTFSC  03.0
10D0:  GOTO   0DD
10D1:  SUBWF  26,F
10D2:  BTFSC  03.0
10D3:  GOTO   0DD
10D4:  SUBWF  27,F
10D5:  BTFSC  03.0
10D6:  GOTO   0DD
10D7:  INCF   27,F
10D8:  INCF   26,F
10D9:  INCF   25,F
10DA:  MOVF   23,W
10DB:  ADDWF  24,F
10DC:  GOTO   10F
10DD:  MOVF   22,W
10DE:  SUBWF  25,F
10DF:  BTFSC  03.0
10E0:  GOTO   0F8
10E1:  MOVLW  01
10E2:  SUBWF  26,F
10E3:  BTFSC  03.0
10E4:  GOTO   0F8
10E5:  SUBWF  27,F
10E6:  BTFSC  03.0
10E7:  GOTO   0F8
10E8:  INCF   27,F
10E9:  INCF   26,F
10EA:  MOVF   22,W
10EB:  ADDWF  25,F
10EC:  MOVF   23,W
10ED:  ADDWF  24,F
10EE:  BTFSS  03.0
10EF:  GOTO   10F
10F0:  INCF   25,F
10F1:  BTFSS  03.2
10F2:  GOTO   10F
10F3:  INCF   26,F
10F4:  BTFSS  03.2
10F5:  GOTO   10F
10F6:  INCF   27,F
10F7:  GOTO   10F
10F8:  MOVF   21,W
10F9:  IORLW  80
10FA:  SUBWF  26,F
10FB:  BTFSC  03.0
10FC:  GOTO   10E
10FD:  MOVLW  01
10FE:  SUBWF  27,F
10FF:  BTFSC  03.0
1100:  GOTO   10E
1101:  INCF   27,F
1102:  MOVF   21,W
1103:  IORLW  80
1104:  ADDWF  26,F
1105:  MOVF   22,W
1106:  ADDWF  25,F
1107:  BTFSS  03.0
1108:  GOTO   0EC
1109:  INCF   26,F
110A:  BTFSS  03.2
110B:  GOTO   0EC
110C:  INCF   27,F
110D:  GOTO   0EC
110E:  BSF    7A.0
110F:  DECFSZ 28,F
1110:  GOTO   112
1111:  GOTO   11D
1112:  BCF    03.0
1113:  RLF    24,F
1114:  RLF    25,F
1115:  RLF    26,F
1116:  RLF    27,F
1117:  BCF    03.0
1118:  RLF    7A,F
1119:  RLF    79,F
111A:  RLF    78,F
111B:  RLF    29,F
111C:  GOTO   0C9
111D:  BTFSS  29.0
111E:  GOTO   125
111F:  BCF    03.0
1120:  RRF    78,F
1121:  RRF    79,F
1122:  RRF    7A,F
1123:  RRF    29,F
1124:  GOTO   128
1125:  DECF   77,F
1126:  BTFSC  03.2
1127:  GOTO   16A
1128:  BTFSC  29.7
1129:  GOTO   151
112A:  BCF    03.0
112B:  RLF    24,F
112C:  RLF    25,F
112D:  RLF    26,F
112E:  RLF    27,F
112F:  MOVF   23,W
1130:  SUBWF  24,F
1131:  BTFSC  03.0
1132:  GOTO   13D
1133:  MOVLW  01
1134:  SUBWF  25,F
1135:  BTFSC  03.0
1136:  GOTO   13D
1137:  SUBWF  26,F
1138:  BTFSC  03.0
1139:  GOTO   13D
113A:  SUBWF  27,F
113B:  BTFSS  03.0
113C:  GOTO   160
113D:  MOVF   22,W
113E:  SUBWF  25,F
113F:  BTFSC  03.0
1140:  GOTO   148
1141:  MOVLW  01
1142:  SUBWF  26,F
1143:  BTFSC  03.0
1144:  GOTO   148
1145:  SUBWF  27,F
1146:  BTFSS  03.0
1147:  GOTO   160
1148:  MOVF   21,W
1149:  IORLW  80
114A:  SUBWF  26,F
114B:  BTFSC  03.0
114C:  GOTO   151
114D:  MOVLW  01
114E:  SUBWF  27,F
114F:  BTFSS  03.0
1150:  GOTO   160
1151:  INCF   7A,F
1152:  BTFSS  03.2
1153:  GOTO   160
1154:  INCF   79,F
1155:  BTFSS  03.2
1156:  GOTO   160
1157:  INCF   78,F
1158:  BTFSS  03.2
1159:  GOTO   160
115A:  INCF   77,F
115B:  BTFSC  03.2
115C:  GOTO   16A
115D:  RRF    78,F
115E:  RRF    79,F
115F:  RRF    7A,F
1160:  MOVF   1D,W
1161:  MOVWF  28
1162:  MOVF   21,W
1163:  XORWF  28,F
1164:  BTFSS  28.7
1165:  GOTO   168
1166:  BSF    78.7
1167:  GOTO   16E
1168:  BCF    78.7
1169:  GOTO   16E
116A:  CLRF   77
116B:  CLRF   78
116C:  CLRF   79
116D:  CLRF   7A
*
1176:  MOVLW  8E
1177:  MOVWF  77
1178:  MOVF   1C,W
1179:  SUBWF  77,F
117A:  MOVF   1D,W
117B:  MOVWF  79
117C:  MOVF   1E,W
117D:  MOVWF  78
117E:  BSF    79.7
117F:  MOVF   77,F
1180:  BTFSC  03.2
1181:  GOTO   18D
1182:  BCF    03.0
1183:  MOVF   79,F
1184:  BTFSS  03.2
1185:  GOTO   189
1186:  MOVF   78,F
1187:  BTFSC  03.2
1188:  GOTO   18D
1189:  RRF    79,F
118A:  RRF    78,F
118B:  DECFSZ 77,F
118C:  GOTO   182
118D:  BTFSS  1D.7
118E:  GOTO   194
118F:  COMF   78,F
1190:  COMF   79,F
1191:  INCF   78,F
1192:  BTFSC  03.2
1193:  INCF   79,F
....................  
.................... #list 
....................  
.................... #DEVICE ADC=10 
.................... #INCLUDE <STRING.H> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
*
075B:  BSF    03.6
075C:  MOVF   3F,W
075D:  MOVWF  43
075E:  MOVF   3E,W
075F:  MOVWF  42
0760:  MOVF   43,W
0761:  MOVWF  7A
0762:  MOVF   42,W
0763:  MOVWF  04
0764:  BCF    03.7
0765:  BTFSC  7A.0
0766:  BSF    03.7
0767:  MOVF   00,F
0768:  BTFSC  03.2
0769:  GOTO   76E
076A:  INCF   42,F
076B:  BTFSC  03.2
076C:  INCF   43,F
076D:  GOTO   760
....................    while(*s2 != '\0') 
076E:  MOVF   41,W
076F:  MOVWF  7A
0770:  MOVF   40,W
0771:  MOVWF  04
0772:  BCF    03.7
0773:  BTFSC  7A.0
0774:  BSF    03.7
0775:  MOVF   00,F
0776:  BTFSC  03.2
0777:  GOTO   78D
....................    { 
....................       *s = *s2; 
0778:  MOVF   40,W
0779:  MOVWF  04
077A:  BCF    03.7
077B:  BTFSC  41.0
077C:  BSF    03.7
077D:  MOVF   00,W
077E:  MOVWF  46
077F:  MOVF   42,W
0780:  MOVWF  04
0781:  BCF    03.7
0782:  BTFSC  43.0
0783:  BSF    03.7
0784:  MOVF   46,W
0785:  MOVWF  00
....................       ++s; 
0786:  INCF   42,F
0787:  BTFSC  03.2
0788:  INCF   43,F
....................       ++s2; 
0789:  INCF   40,F
078A:  BTFSC  03.2
078B:  INCF   41,F
078C:  GOTO   76E
....................    } 
....................  
....................    *s = '\0'; 
078D:  MOVF   42,W
078E:  MOVWF  04
078F:  BCF    03.7
0790:  BTFSC  43.0
0791:  BSF    03.7
0792:  CLRF   00
....................    return(s1); 
0793:  MOVF   3E,W
0794:  MOVWF  78
0795:  MOVF   3F,W
0796:  MOVWF  79
0797:  BCF    03.6
0798:  RETURN
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
*
0B0C:  BSF    03.6
0B0D:  MOVF   17,W
0B0E:  MOVWF  7A
0B0F:  MOVF   16,W
0B10:  MOVWF  04
0B11:  BCF    03.7
0B12:  BTFSC  7A.0
0B13:  BSF    03.7
0B14:  MOVF   00,W
0B15:  MOVWF  1A
0B16:  MOVF   19,W
0B17:  MOVWF  7A
0B18:  MOVF   18,W
0B19:  MOVWF  04
0B1A:  BCF    03.7
0B1B:  BTFSC  7A.0
0B1C:  BSF    03.7
0B1D:  MOVF   00,W
0B1E:  SUBWF  1A,W
0B1F:  BTFSS  03.2
0B20:  GOTO   338
....................       if (*s1 == '\0') 
0B21:  MOVF   17,W
0B22:  MOVWF  7A
0B23:  MOVF   16,W
0B24:  MOVWF  04
0B25:  BCF    03.7
0B26:  BTFSC  7A.0
0B27:  BSF    03.7
0B28:  MOVF   00,F
0B29:  BTFSS  03.2
0B2A:  GOTO   32E
....................          return(0); 
0B2B:  MOVLW  00
0B2C:  MOVWF  78
0B2D:  GOTO   350
0B2E:  MOVF   17,W
0B2F:  MOVWF  7A
0B30:  MOVF   16,W
0B31:  INCF   16,F
0B32:  BTFSC  03.2
0B33:  INCF   17,F
0B34:  INCF   18,F
0B35:  BTFSC  03.2
0B36:  INCF   19,F
0B37:  GOTO   30D
....................    return((*s1 < *s2) ? -1: 1); 
0B38:  MOVF   17,W
0B39:  MOVWF  7A
0B3A:  MOVF   16,W
0B3B:  MOVWF  04
0B3C:  BCF    03.7
0B3D:  BTFSC  17.0
0B3E:  BSF    03.7
0B3F:  MOVF   00,W
0B40:  MOVWF  1A
0B41:  MOVF   19,W
0B42:  MOVWF  7A
0B43:  MOVF   18,W
0B44:  MOVWF  04
0B45:  BCF    03.7
0B46:  BTFSC  19.0
0B47:  BSF    03.7
0B48:  MOVF   00,W
0B49:  SUBWF  1A,W
0B4A:  BTFSC  03.0
0B4B:  GOTO   34E
0B4C:  MOVLW  FF
0B4D:  GOTO   34F
0B4E:  MOVLW  01
0B4F:  MOVWF  78
0B50:  BCF    03.6
0B51:  RETURN
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
*
0D6B:  MOVF   17,W
0D6C:  MOVWF  7A
0D6D:  MOVF   16,W
0D6E:  MOVWF  04
0D6F:  BCF    03.7
0D70:  BTFSC  7A.0
0D71:  BSF    03.7
0D72:  MOVF   18,W
0D73:  SUBWF  00,W
0D74:  BTFSC  03.2
0D75:  GOTO   588
....................       if (*s == '\0') 
0D76:  MOVF   17,W
0D77:  MOVWF  7A
0D78:  MOVF   16,W
0D79:  MOVWF  04
0D7A:  BCF    03.7
0D7B:  BTFSC  7A.0
0D7C:  BSF    03.7
0D7D:  MOVF   00,F
0D7E:  BTFSS  03.2
0D7F:  GOTO   584
....................          return(0); 
0D80:  MOVLW  00
0D81:  MOVWF  78
0D82:  MOVWF  79
0D83:  GOTO   58C
0D84:  INCF   16,F
0D85:  BTFSC  03.2
0D86:  INCF   17,F
0D87:  GOTO   56B
....................    return(s); 
0D88:  MOVF   16,W
0D89:  MOVWF  78
0D8A:  MOVF   17,W
0D8B:  MOVWF  79
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
*
09C4:  MOVF   21,W
09C5:  MOVWF  25
09C6:  MOVF   20,W
09C7:  MOVWF  24
09C8:  MOVF   25,W
09C9:  MOVWF  7A
09CA:  MOVF   24,W
09CB:  MOVWF  04
09CC:  BCF    03.7
09CD:  BTFSC  7A.0
09CE:  BSF    03.7
09CF:  MOVF   00,F
09D0:  BTFSC  03.2
09D1:  GOTO   201
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
09D2:  MOVF   23,W
09D3:  MOVWF  27
09D4:  MOVF   22,W
09D5:  MOVWF  26
09D6:  MOVF   27,W
09D7:  MOVWF  7A
09D8:  MOVF   26,W
09D9:  MOVWF  04
09DA:  BCF    03.7
09DB:  BTFSC  7A.0
09DC:  BSF    03.7
09DD:  MOVF   00,F
09DE:  BTFSC  03.2
09DF:  GOTO   1FD
....................          if (*sc1 == *sc2) 
09E0:  MOVF   25,W
09E1:  MOVWF  7A
09E2:  MOVF   24,W
09E3:  MOVWF  04
09E4:  BCF    03.7
09E5:  BTFSC  7A.0
09E6:  BSF    03.7
09E7:  MOVF   00,W
09E8:  MOVWF  28
09E9:  MOVF   27,W
09EA:  MOVWF  7A
09EB:  MOVF   26,W
09EC:  MOVWF  04
09ED:  BCF    03.7
09EE:  BTFSC  7A.0
09EF:  BSF    03.7
09F0:  MOVF   00,W
09F1:  SUBWF  28,W
09F2:  BTFSS  03.2
09F3:  GOTO   1F9
....................             return(sc1); 
09F4:  MOVF   24,W
09F5:  MOVWF  78
09F6:  MOVF   25,W
09F7:  MOVWF  79
09F8:  GOTO   204
09F9:  INCF   26,F
09FA:  BTFSC  03.2
09FB:  INCF   27,F
09FC:  GOTO   1D6
09FD:  INCF   24,F
09FE:  BTFSC  03.2
09FF:  INCF   25,F
0A00:  GOTO   1C8
....................    return(0); 
0A01:  MOVLW  00
0A02:  MOVWF  78
0A03:  MOVWF  79
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
*
0951:  MOVF   21,W
0952:  MOVWF  25
0953:  MOVF   20,W
0954:  MOVWF  24
0955:  MOVF   25,W
0956:  MOVWF  7A
0957:  MOVF   24,W
0958:  MOVWF  04
0959:  BCF    03.7
095A:  BTFSC  7A.0
095B:  BSF    03.7
095C:  MOVF   00,F
095D:  BTFSC  03.2
095E:  GOTO   196
....................       for (sc2 = s2; ; sc2++) 
095F:  MOVF   23,W
0960:  MOVWF  27
0961:  MOVF   22,W
0962:  MOVWF  26
....................     if (*sc2 == '\0') 
0963:  MOVF   27,W
0964:  MOVWF  7A
0965:  MOVF   26,W
0966:  MOVWF  04
0967:  BCF    03.7
0968:  BTFSC  7A.0
0969:  BSF    03.7
096A:  MOVF   00,F
096B:  BTFSS  03.2
096C:  GOTO   17A
....................        return(sc1 - s1); 
096D:  MOVF   20,W
096E:  SUBWF  24,W
096F:  MOVWF  77
0970:  MOVF   25,W
0971:  MOVWF  7A
0972:  MOVF   21,W
0973:  BTFSS  03.0
0974:  INCFSZ 21,W
0975:  SUBWF  7A,F
0976:  MOVF   77,W
0977:  MOVWF  78
0978:  GOTO   1A1
0979:  GOTO   18E
....................          else if (*sc1 == *sc2) 
097A:  MOVF   25,W
097B:  MOVWF  7A
097C:  MOVF   24,W
097D:  MOVWF  04
097E:  BCF    03.7
097F:  BTFSC  7A.0
0980:  BSF    03.7
0981:  MOVF   00,W
0982:  MOVWF  28
0983:  MOVF   27,W
0984:  MOVWF  7A
0985:  MOVF   26,W
0986:  MOVWF  04
0987:  BCF    03.7
0988:  BTFSC  7A.0
0989:  BSF    03.7
098A:  MOVF   00,W
098B:  SUBWF  28,W
098C:  BTFSC  03.2
....................             break; 
098D:  GOTO   192
098E:  INCF   26,F
098F:  BTFSC  03.2
0990:  INCF   27,F
0991:  GOTO   163
0992:  INCF   24,F
0993:  BTFSC  03.2
0994:  INCF   25,F
0995:  GOTO   155
....................    return(sc1 - s1); 
0996:  MOVF   20,W
0997:  SUBWF  24,W
0998:  MOVWF  77
0999:  MOVF   25,W
099A:  MOVWF  7A
099B:  MOVF   21,W
099C:  BTFSS  03.0
099D:  INCFSZ 21,W
099E:  SUBWF  7A,F
099F:  MOVF   77,W
09A0:  MOVWF  78
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
*
12AF:  BCF    03.6
12B0:  CLRF   2B
12B1:  CLRF   2C
....................  
....................    beg = (s1)? s1: save; 
*
0938:  BSF    03.6
0939:  MOVF   18,W
093A:  IORWF  19,W
093B:  BTFSC  03.2
093C:  GOTO   141
093D:  MOVF   19,W
093E:  MOVWF  7A
093F:  MOVF   18,W
0940:  GOTO   146
0941:  BCF    03.6
0942:  MOVF   2C,W
0943:  MOVWF  7A
0944:  MOVF   2B,W
0945:  BSF    03.6
0946:  MOVWF  1C
0947:  MOVF   7A,W
0948:  MOVWF  1D
....................    beg += strspn(beg, s2); 
0949:  MOVF   1D,W
094A:  MOVWF  21
094B:  MOVF   1C,W
094C:  MOVWF  20
094D:  MOVF   1B,W
094E:  MOVWF  23
094F:  MOVF   1A,W
0950:  MOVWF  22
*
09A1:  MOVF   78,W
09A2:  ADDWF  1C,F
09A3:  BTFSC  03.0
09A4:  INCF   1D,F
....................    if (*beg == '\0') 
09A5:  MOVF   1D,W
09A6:  MOVWF  7A
09A7:  MOVF   1C,W
09A8:  MOVWF  04
09A9:  BCF    03.7
09AA:  BTFSC  7A.0
09AB:  BSF    03.7
09AC:  MOVF   00,F
09AD:  BTFSS  03.2
09AE:  GOTO   1BC
....................    { 
....................       *save = ' '; 
09AF:  BCF    03.6
09B0:  MOVF   2B,W
09B1:  MOVWF  04
09B2:  BCF    03.7
09B3:  BTFSC  2C.0
09B4:  BSF    03.7
09B5:  MOVLW  20
09B6:  MOVWF  00
....................       return(0); 
09B7:  MOVLW  00
09B8:  MOVWF  78
09B9:  MOVWF  79
09BA:  GOTO   228
09BB:  BSF    03.6
....................    } 
....................    end = strpbrk(beg, s2); 
09BC:  MOVF   1D,W
09BD:  MOVWF  21
09BE:  MOVF   1C,W
09BF:  MOVWF  20
09C0:  MOVF   1B,W
09C1:  MOVWF  23
09C2:  MOVF   1A,W
09C3:  MOVWF  22
*
0A04:  MOVF   79,W
0A05:  MOVWF  1F
0A06:  MOVF   78,W
0A07:  MOVWF  1E
....................    if (*end != '\0') 
0A08:  MOVF   1F,W
0A09:  MOVWF  7A
0A0A:  MOVF   1E,W
0A0B:  MOVWF  04
0A0C:  BCF    03.7
0A0D:  BTFSC  7A.0
0A0E:  BSF    03.7
0A0F:  MOVF   00,F
0A10:  BTFSC  03.2
0A11:  GOTO   21B
....................    { 
....................       *end = '\0'; 
0A12:  MOVF   1E,W
0A13:  MOVWF  04
0A14:  BCF    03.7
0A15:  BTFSC  1F.0
0A16:  BSF    03.7
0A17:  CLRF   00
....................       end++; 
0A18:  INCF   1E,F
0A19:  BTFSC  03.2
0A1A:  INCF   1F,F
....................    } 
....................    save = end; 
0A1B:  MOVF   1F,W
0A1C:  BCF    03.6
0A1D:  MOVWF  2C
0A1E:  BSF    03.6
0A1F:  MOVF   1E,W
0A20:  BCF    03.6
0A21:  MOVWF  2B
....................    return(beg); 
0A22:  BSF    03.6
0A23:  MOVF   1C,W
0A24:  MOVWF  78
0A25:  MOVF   1D,W
0A26:  MOVWF  79
0A27:  BCF    03.6
0A28:  RETURN
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
*
0D94:  MOVF   17,W
0D95:  MOVWF  19
0D96:  MOVF   16,W
0D97:  MOVWF  18
0D98:  MOVF   19,W
0D99:  MOVWF  7A
0D9A:  MOVF   18,W
0D9B:  MOVWF  04
0D9C:  BCF    03.7
0D9D:  BTFSC  7A.0
0D9E:  BSF    03.7
0D9F:  MOVF   00,F
0DA0:  BTFSC  03.2
0DA1:  GOTO   5A6
0DA2:  INCF   18,F
0DA3:  BTFSC  03.2
0DA4:  INCF   19,F
0DA5:  GOTO   598
....................    return(sc - s); 
0DA6:  MOVF   16,W
0DA7:  SUBWF  18,W
0DA8:  MOVWF  77
0DA9:  MOVF   19,W
0DAA:  MOVWF  7A
0DAB:  MOVF   17,W
0DAC:  BTFSS  03.0
0DAD:  INCFSZ 17,W
0DAE:  SUBWF  7A,F
0DAF:  MOVF   77,W
0DB0:  MOVWF  78
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #INCLUDE <STDLIB.H> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... /* Standart template: float strtof(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... float strtof(char *s,char *endptr); 
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s,char *endptr); 
.................... float64 strtod(char *s,char *endptr); 
.................... #else 
.................... //provided for compatibility 
.................... #define strtof48(s, e) strtof(s, e) 
.................... #define strtod(s, e) strtof(s, e) 
.................... #endif 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof(s)   strtof(s, 0) 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof48(s) strtof48(s, 0) 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof64(s) strtod(s, 0) 
.................... #endif 
....................  
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float atoe(char * s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s); 
.................... #endif 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... unsigned int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................  
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
*
0A29:  BSF    03.6
0A2A:  CLRF   1D
....................    sign = 0; 
0A2B:  CLRF   1B
....................    base = 10; 
0A2C:  MOVLW  0A
0A2D:  MOVWF  1C
....................    result = 0; 
0A2E:  CLRF   1A
....................  
....................    if (!s) 
0A2F:  MOVF   18,W
0A30:  IORWF  19,W
0A31:  BTFSS  03.2
0A32:  GOTO   236
....................       return 0; 
0A33:  MOVLW  00
0A34:  MOVWF  78
0A35:  GOTO   30A
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
0A36:  MOVF   1D,W
0A37:  INCF   1D,F
0A38:  ADDWF  18,W
0A39:  MOVWF  04
0A3A:  BCF    03.7
0A3B:  BTFSC  19.0
0A3C:  BSF    03.7
0A3D:  MOVF   00,W
0A3E:  MOVWF  1E
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
0A3F:  MOVF   1E,W
0A40:  SUBLW  2D
0A41:  BTFSS  03.2
0A42:  GOTO   24F
....................    { 
....................       sign = 1;         // Set the sign to negative 
0A43:  MOVLW  01
0A44:  MOVWF  1B
....................       c = s[index++]; 
0A45:  MOVF   1D,W
0A46:  INCF   1D,F
0A47:  ADDWF  18,W
0A48:  MOVWF  04
0A49:  BCF    03.7
0A4A:  BTFSC  19.0
0A4B:  BSF    03.7
0A4C:  MOVF   00,W
0A4D:  MOVWF  1E
....................    } 
0A4E:  GOTO   25C
....................    else if (c == '+') 
0A4F:  MOVF   1E,W
0A50:  SUBLW  2B
0A51:  BTFSS  03.2
0A52:  GOTO   25C
....................    { 
....................       c = s[index++]; 
0A53:  MOVF   1D,W
0A54:  INCF   1D,F
0A55:  ADDWF  18,W
0A56:  MOVWF  04
0A57:  BCF    03.7
0A58:  BTFSC  19.0
0A59:  BSF    03.7
0A5A:  MOVF   00,W
0A5B:  MOVWF  1E
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
0A5C:  MOVF   1E,W
0A5D:  SUBLW  2F
0A5E:  BTFSC  03.0
0A5F:  GOTO   300
0A60:  MOVF   1E,W
0A61:  SUBLW  39
0A62:  BTFSS  03.0
0A63:  GOTO   300
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
0A64:  MOVF   1E,W
0A65:  SUBLW  30
0A66:  BTFSS  03.2
0A67:  GOTO   288
0A68:  MOVF   1D,W
0A69:  ADDWF  18,W
0A6A:  MOVWF  04
0A6B:  BCF    03.7
0A6C:  BTFSC  19.0
0A6D:  BSF    03.7
0A6E:  MOVF   00,W
0A6F:  SUBLW  78
0A70:  BTFSC  03.2
0A71:  GOTO   27C
0A72:  MOVF   1D,W
0A73:  ADDWF  18,W
0A74:  MOVWF  04
0A75:  BCF    03.7
0A76:  BTFSC  19.0
0A77:  BSF    03.7
0A78:  MOVF   00,W
0A79:  SUBLW  58
0A7A:  BTFSS  03.2
0A7B:  GOTO   288
....................       { 
....................          base = 16; 
0A7C:  MOVLW  10
0A7D:  MOVWF  1C
....................          index++; 
0A7E:  INCF   1D,F
....................          c = s[index++]; 
0A7F:  MOVF   1D,W
0A80:  INCF   1D,F
0A81:  ADDWF  18,W
0A82:  MOVWF  04
0A83:  BCF    03.7
0A84:  BTFSC  19.0
0A85:  BSF    03.7
0A86:  MOVF   00,W
0A87:  MOVWF  1E
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
0A88:  MOVF   1C,W
0A89:  SUBLW  0A
0A8A:  BTFSS  03.2
0A8B:  GOTO   2AE
....................       { 
....................          while (c >= '0' && c <= '9') 
0A8C:  MOVF   1E,W
0A8D:  SUBLW  2F
0A8E:  BTFSC  03.0
0A8F:  GOTO   2AD
0A90:  MOVF   1E,W
0A91:  SUBLW  39
0A92:  BTFSS  03.0
0A93:  GOTO   2AD
....................          { 
....................             result = 10*result + (c - '0'); 
0A94:  MOVLW  0A
0A95:  MOVWF  1F
0A96:  MOVF   1A,W
0A97:  MOVWF  20
0A98:  BCF    0A.3
0A99:  BCF    03.6
0A9A:  CALL   7B7
0A9B:  BSF    0A.3
0A9C:  MOVF   78,W
0A9D:  BSF    03.6
0A9E:  MOVWF  1F
0A9F:  MOVLW  30
0AA0:  SUBWF  1E,W
0AA1:  ADDWF  1F,W
0AA2:  MOVWF  1A
....................             c = s[index++]; 
0AA3:  MOVF   1D,W
0AA4:  INCF   1D,F
0AA5:  ADDWF  18,W
0AA6:  MOVWF  04
0AA7:  BCF    03.7
0AA8:  BTFSC  19.0
0AA9:  BSF    03.7
0AAA:  MOVF   00,W
0AAB:  MOVWF  1E
0AAC:  GOTO   28C
....................          } 
....................       } 
0AAD:  GOTO   300
....................       else if (base == 16)    // The number is a hexa number 
0AAE:  MOVF   1C,W
0AAF:  SUBLW  10
0AB0:  BTFSS  03.2
0AB1:  GOTO   300
....................       { 
....................          c = toupper(c); 
0AB2:  MOVF   1E,W
0AB3:  SUBLW  60
0AB4:  BTFSC  03.0
0AB5:  GOTO   2BD
0AB6:  MOVF   1E,W
0AB7:  SUBLW  7A
0AB8:  BTFSS  03.0
0AB9:  GOTO   2BD
0ABA:  MOVF   1E,W
0ABB:  ANDLW  DF
0ABC:  GOTO   2BE
0ABD:  MOVF   1E,W
0ABE:  MOVWF  1E
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
0ABF:  MOVF   1E,W
0AC0:  SUBLW  2F
0AC1:  BTFSC  03.0
0AC2:  GOTO   2C7
0AC3:  MOVF   1E,W
0AC4:  SUBLW  39
0AC5:  BTFSC  03.0
0AC6:  GOTO   2CF
0AC7:  MOVF   1E,W
0AC8:  SUBLW  40
0AC9:  BTFSC  03.0
0ACA:  GOTO   300
0ACB:  MOVF   1E,W
0ACC:  SUBLW  46
0ACD:  BTFSS  03.0
0ACE:  GOTO   300
....................          { 
....................             if (c >= '0' && c <= '9') 
0ACF:  MOVF   1E,W
0AD0:  SUBLW  2F
0AD1:  BTFSC  03.0
0AD2:  GOTO   2E0
0AD3:  MOVF   1E,W
0AD4:  SUBLW  39
0AD5:  BTFSS  03.0
0AD6:  GOTO   2E0
....................                result = (result << 4) + (c - '0'); 
0AD7:  SWAPF  1A,W
0AD8:  MOVWF  1F
0AD9:  MOVLW  F0
0ADA:  ANDWF  1F,F
0ADB:  MOVLW  30
0ADC:  SUBWF  1E,W
0ADD:  ADDWF  1F,W
0ADE:  MOVWF  1A
0ADF:  GOTO   2E9
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
0AE0:  SWAPF  1A,W
0AE1:  MOVWF  1F
0AE2:  MOVLW  F0
0AE3:  ANDWF  1F,F
0AE4:  MOVLW  41
0AE5:  SUBWF  1E,W
0AE6:  ADDLW  0A
0AE7:  ADDWF  1F,W
0AE8:  MOVWF  1A
....................  
....................             c = s[index++]; 
0AE9:  MOVF   1D,W
0AEA:  INCF   1D,F
0AEB:  ADDWF  18,W
0AEC:  MOVWF  04
0AED:  BCF    03.7
0AEE:  BTFSC  19.0
0AEF:  BSF    03.7
0AF0:  MOVF   00,W
0AF1:  MOVWF  1E
....................             c = toupper(c); 
0AF2:  MOVF   1E,W
0AF3:  SUBLW  60
0AF4:  BTFSC  03.0
0AF5:  GOTO   2FD
0AF6:  MOVF   1E,W
0AF7:  SUBLW  7A
0AF8:  BTFSS  03.0
0AF9:  GOTO   2FD
0AFA:  MOVF   1E,W
0AFB:  ANDLW  DF
0AFC:  GOTO   2FE
0AFD:  MOVF   1E,W
0AFE:  MOVWF  1E
0AFF:  GOTO   2BF
....................          } 
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
0B00:  DECFSZ 1B,W
0B01:  GOTO   308
0B02:  MOVF   1C,W
0B03:  SUBLW  0A
0B04:  BTFSS  03.2
0B05:  GOTO   308
....................        result = -result; 
0B06:  COMF   1A,F
0B07:  INCF   1A,F
....................  
....................    return(result); 
0B08:  MOVF   1A,W
0B09:  MOVWF  78
0B0A:  BCF    03.6
0B0B:  RETURN
.................... } 
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
*
040A:  BSF    03.6
040B:  CLRF   49
040C:  CLRF   48
040D:  CLRF   47
040E:  MOVLW  01
040F:  MOVWF  46
0410:  CLRF   4B
0411:  CLRF   4C
.................... { 
....................      unsigned int32 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
0412:  BTFSS  42.7
0413:  GOTO   454
....................          sign=1;        // Check for negative number 
0414:  MOVLW  01
0415:  MOVWF  4B
....................          num*=-1; 
0416:  MOVF   42,W
0417:  MOVWF  51
0418:  MOVF   41,W
0419:  MOVWF  50
041A:  MOVF   40,W
041B:  MOVWF  4F
041C:  MOVF   3F,W
041D:  MOVWF  4E
041E:  MOVLW  FF
041F:  MOVWF  55
0420:  MOVWF  54
0421:  MOVWF  53
0422:  MOVWF  52
*
044C:  MOVF   7A,W
044D:  MOVWF  42
044E:  MOVF   79,W
044F:  MOVWF  41
0450:  MOVF   78,W
0451:  MOVWF  40
0452:  MOVF   77,W
0453:  MOVWF  3F
....................      } 
....................  
....................      while(temp>0) { 
0454:  MOVF   46,F
0455:  BTFSS  03.2
0456:  GOTO   460
0457:  MOVF   47,F
0458:  BTFSS  03.2
0459:  GOTO   460
045A:  MOVF   48,F
045B:  BTFSS  03.2
045C:  GOTO   460
045D:  MOVF   49,F
045E:  BTFSC  03.2
045F:  GOTO   4DC
....................          temp=(num/base); 
0460:  BCF    03.1
0461:  MOVF   42,W
0462:  MOVWF  59
0463:  MOVF   41,W
0464:  MOVWF  58
0465:  MOVF   40,W
0466:  MOVWF  57
0467:  MOVF   3F,W
0468:  MOVWF  56
0469:  CLRF   5D
046A:  CLRF   5C
046B:  CLRF   5B
046C:  MOVF   43,W
046D:  MOVWF  5A
046E:  BCF    03.6
046F:  CALL   38E
0470:  MOVF   7A,W
0471:  BSF    03.6
0472:  MOVWF  49
0473:  MOVF   79,W
0474:  MOVWF  48
0475:  MOVF   78,W
0476:  MOVWF  47
0477:  MOVF   77,W
0478:  MOVWF  46
....................          s[cnt]=(num%base)+'0';    // Conversion 
0479:  MOVF   4C,W
047A:  ADDWF  44,W
047B:  MOVWF  78
047C:  MOVF   45,W
047D:  MOVWF  7A
047E:  BTFSC  03.0
047F:  INCF   7A,F
0480:  MOVF   78,W
0481:  MOVWF  4E
0482:  MOVF   7A,W
0483:  MOVWF  4F
0484:  CLRF   51
0485:  MOVF   04,W
0486:  MOVWF  50
0487:  BCF    51.0
0488:  BTFSC  03.7
0489:  BSF    51.0
048A:  BSF    03.1
048B:  MOVLW  52
048C:  MOVWF  04
048D:  BSF    03.7
048E:  MOVF   42,W
048F:  MOVWF  59
0490:  MOVF   41,W
0491:  MOVWF  58
0492:  MOVF   40,W
0493:  MOVWF  57
0494:  MOVF   3F,W
0495:  MOVWF  56
0496:  CLRF   5D
0497:  CLRF   5C
0498:  CLRF   5B
0499:  MOVF   43,W
049A:  MOVWF  5A
049B:  BCF    03.6
049C:  CALL   38E
049D:  BSF    03.6
049E:  MOVF   50,W
049F:  MOVWF  04
04A0:  BCF    03.7
04A1:  BTFSC  51.0
04A2:  BSF    03.7
04A3:  MOVLW  30
04A4:  ADDWF  52,W
04A5:  MOVWF  77
04A6:  MOVF   53,W
04A7:  MOVWF  78
04A8:  MOVLW  00
04A9:  BTFSC  03.0
04AA:  MOVLW  01
04AB:  ADDWF  78,F
04AC:  MOVF   54,W
04AD:  MOVWF  79
04AE:  MOVLW  00
04AF:  BTFSC  03.0
04B0:  MOVLW  01
04B1:  ADDWF  79,F
04B2:  MOVF   55,W
04B3:  MOVWF  7A
04B4:  MOVLW  00
04B5:  BTFSC  03.0
04B6:  MOVLW  01
04B7:  ADDWF  7A,F
04B8:  MOVF   4E,W
04B9:  MOVWF  04
04BA:  BCF    03.7
04BB:  BTFSC  4F.0
04BC:  BSF    03.7
04BD:  MOVF   77,W
04BE:  MOVWF  00
....................  
....................          if(s[cnt]>0x39) 
04BF:  MOVF   4C,W
04C0:  ADDWF  44,W
04C1:  MOVWF  04
04C2:  BCF    03.7
04C3:  BTFSC  45.0
04C4:  BSF    03.7
04C5:  MOVF   00,W
04C6:  SUBLW  39
04C7:  BTFSC  03.0
04C8:  GOTO   4D2
....................             s[cnt]+=0x7; 
04C9:  MOVF   4C,W
04CA:  ADDWF  44,W
04CB:  MOVWF  04
04CC:  BCF    03.7
04CD:  BTFSC  45.0
04CE:  BSF    03.7
04CF:  MOVLW  07
04D0:  ADDWF  00,W
04D1:  MOVWF  00
....................  
....................          cnt++; 
04D2:  INCF   4C,F
....................          num=temp; 
04D3:  MOVF   49,W
04D4:  MOVWF  42
04D5:  MOVF   48,W
04D6:  MOVWF  41
04D7:  MOVF   47,W
04D8:  MOVWF  40
04D9:  MOVF   46,W
04DA:  MOVWF  3F
04DB:  GOTO   454
....................      } 
....................  
....................      if(sign==1) { 
04DC:  DECFSZ 4B,W
04DD:  GOTO   4E7
....................          s[cnt]=0x2D;      // Negative sign 
04DE:  MOVF   4C,W
04DF:  ADDWF  44,W
04E0:  MOVWF  04
04E1:  BCF    03.7
04E2:  BTFSC  45.0
04E3:  BSF    03.7
04E4:  MOVLW  2D
04E5:  MOVWF  00
....................          cnt++; 
04E6:  INCF   4C,F
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
04E7:  CLRF   4A
04E8:  BCF    03.0
04E9:  RRF    4C,W
04EA:  SUBWF  4A,W
04EB:  BTFSC  03.0
04EC:  GOTO   51D
....................  
....................          c=s[i]; 
04ED:  MOVF   4A,W
04EE:  ADDWF  44,W
04EF:  MOVWF  04
04F0:  BCF    03.7
04F1:  BTFSC  45.0
04F2:  BSF    03.7
04F3:  MOVF   00,W
04F4:  MOVWF  4D
....................          s[i]=s[cnt-i-1];        // Reverse the number 
04F5:  MOVF   4A,W
04F6:  ADDWF  44,W
04F7:  MOVWF  78
04F8:  MOVF   45,W
04F9:  MOVWF  7A
04FA:  BTFSC  03.0
04FB:  INCF   7A,F
04FC:  MOVF   78,W
04FD:  MOVWF  4E
04FE:  MOVF   7A,W
04FF:  MOVWF  4F
0500:  MOVF   4A,W
0501:  SUBWF  4C,W
0502:  ADDLW  FF
0503:  ADDWF  44,W
0504:  MOVWF  04
0505:  BCF    03.7
0506:  BTFSC  45.0
0507:  BSF    03.7
0508:  MOVF   00,W
0509:  MOVWF  50
050A:  MOVF   4E,W
050B:  MOVWF  04
050C:  BCF    03.7
050D:  BTFSC  4F.0
050E:  BSF    03.7
050F:  MOVF   50,W
0510:  MOVWF  00
....................          s[cnt-i-1]=c; 
0511:  MOVF   4A,W
0512:  SUBWF  4C,W
0513:  ADDLW  FF
0514:  ADDWF  44,W
0515:  MOVWF  04
0516:  BCF    03.7
0517:  BTFSC  45.0
0518:  BSF    03.7
0519:  MOVF   4D,W
051A:  MOVWF  00
051B:  INCF   4A,F
051C:  GOTO   4E8
....................      } 
....................      s[cnt]='\0';     // End the string 
051D:  MOVF   4C,W
051E:  ADDWF  44,W
051F:  MOVWF  04
0520:  BCF    03.7
0521:  BTFSC  45.0
0522:  BSF    03.7
0523:  CLRF   00
....................      return s; 
0524:  MOVF   44,W
0525:  MOVWF  78
0526:  MOVF   45,W
0527:  MOVWF  79
0528:  BCF    03.6
0529:  RETURN
.................... } 
....................  
.................... #if defined(__PCD__) 
....................  
.................... char * itoa(signed int48 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int48 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... char * itoa(signed int64 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int64 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................       
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1;         
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................              
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #endif 
....................  
.................... float strtof(char *s, char *endptr) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s, char *endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float48)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float48)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s, char *endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float64)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float64)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtoulGO; 
....................  
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................    { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... int8 mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #if !defined(__PCD__) 
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2);  
.................... #else  
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2);  
.................... #endif 
....................  
....................  
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    unsigned int8 t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=1; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = 0; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
.................... #INCLUDE <STDIO.H> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDIO 
.................... #define _STDIO 
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #ifndef getc 
.................... #define getc getch 
.................... #define getchar getch 
.................... #define puts(s) {printf(s); putchar(13); putchar(10);} 
.................... #define putc putchar 
.................... #endif 
.................... /* maps error number to an error message. Writes a sequence of characters to 
.................... stderr stream thus: if s is not null then string pointed to by s follwed by 
.................... a colon (:) and a space and the appropriate error message returned by strerror 
.................... function with argument errno 
....................  
.................... Returns: no value 
.................... */ 
....................  
.................... #ifdef _ERRNO 
.................... void perror(char *s) 
.................... { 
....................   if(s) 
....................   fprintf(STDERR,"%s: ",s); 
....................   fprintf(STDERR,"%s\r\n",strerror(errno)); 
.................... } 
.................... #endif 
.................... #endif 
....................  
.................... #INCLUDE <MATH.H> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2011 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                    //// 
.................... //// History:                                                           //// 
.................... ////  * 9/20/2001 :  Improvments are made to sin/cos code.              //// 
.................... ////                 The code now is small, much faster,                //// 
.................... ////                 and more accurate.                                 //// 
.................... ////  * 2/21/2007 :  Compiler handles & operator differently and does   //// 
.................... ////                 not return generic (int8 *) so type cast is done   //// 
.................... ////  * 6/19/2010 :  Divisions by constants converted to multiplication //// 
.................... ////                 by its inverse to improve computation speed        //// 
.................... ////  * 1/21/2011 :  Constants used for double precision math updated   //// 
.................... ////                 Updated routines include 64 bit versions of cos,   //// 
.................... ////                 asin,atan,exp,log and dependant functions          //// 
.................... ////  * 1/31/2011 :  Optimized current 32-bit float routines for cos    //// 
.................... ////                 and log function                                   //// 
.................... ////  * 6/13/2011 :  Fixed PCD overload CEIL_FLOOR functions for values //// 
.................... ////                 greater then 10000000 and less then -10000000      //// 
.................... ////                                                                    //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef MATH_H 
.................... #define MATH_H 
....................  
.................... #ifdef PI 
.................... #undef  PI 
.................... #endif 
.................... #define PI     3.1415926535897932 
....................  
....................  
.................... #define SQRT2  1.4142135623730950 
....................  
.................... //float const ps[4] = {5.9304945, 21.125224, 8.9403076, 0.29730279}; 
.................... //float const qs[4] = {1.0000000, 15.035723, 17.764134, 2.4934718}; 
....................  
.................... ///////////////////////////// Round Functions ////////////////////////////// 
....................  
.................... float32 CEIL_FLOOR(float32 x, unsigned int8 n) 
.................... { 
....................    float32 y, res; 
....................    unsigned int16 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................       res = (float32)(unsigned int16)y; 
....................  
....................  else if (y < 10000000.0) 
....................    {  
....................       l = (unsigned int16)(y*0.000030517578125); 
....................       y = 32768.0*(y*0.000030517578125 - (float32)l); 
....................       res = 32768.0*(float32)l; 
....................       res += (float32)(unsigned int16)y; 
....................    } 
....................  
....................  else 
....................   res = y; 
....................  
....................  y = y - (float32)(unsigned int16)y; 
....................  
....................  if (s) 
....................   res = -res; 
....................  
....................  if (y != 0) 
....................  { 
....................   if (s == 1 && n == 0) 
....................    res -= 1.0; 
....................  
....................   if (s == 0 && n == 1) 
....................    res += 1.0; 
....................  } 
....................  if (x == 0) 
....................     res = 0; 
....................  
....................  return (res); 
.................... } 
....................  
.................... // Overloaded Functions to take care for new Data types in PCD 
.................... // Overloaded function CEIL_FLOOR() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 CEIL_FLOOR(float48 x, unsigned int8 n) 
.................... { 
....................    float48 y, res; 
....................    unsigned int32 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................       res = (float48)(unsigned int16)y; 
....................  
....................    else if (y < 549755813888.0) 
....................    { 
....................       l = (unsigned int32)(y*0.000030517578125); 
....................       y = 32768.0*(y*0.000030517578125 - (float48)l); 
....................       res = 32768.0*(float48)l; 
....................       res += (float48)(unsigned int16)y; 
....................    } 
....................    else 
....................    {   
....................       res = y; 
....................       y = 0.0; 
....................    } 
....................     
....................    if(y != 0) 
....................       y = y - (float48)(unsigned int16)y; 
....................  
....................    if (s) 
....................       res = -res; 
....................  
....................    if (y != 0) 
....................    { 
....................       if (s == 1 && n == 0) 
....................          res -= 1.0; 
....................  
....................       if (s == 0 && n == 1) 
....................          res += 1.0; 
....................    } 
....................    if (x == 0) 
....................       res = 0; 
....................  
....................    return (res); 
.................... } 
....................  
....................  
.................... // Overloaded function CEIL_FLOOR() for data type - Float64 
.................... float64 CEIL_FLOOR(float64 x, unsigned int8 n) 
.................... { 
....................    float64 y, res; 
....................    int64 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................       res = (float64)(unsigned int16)y; 
....................    else if (y < 4503599627370496.0) 
....................    { 
....................       l = (int64)(y*0.000030517578125); 
....................       y = 32768.0*(y*0.000030517578125 - (float64)l); 
....................       res = 32768.0*(float64)l; 
....................       res += (float64)(unsigned int16)y; 
....................    } 
....................    else 
....................    { 
....................       res = y; 
....................       y = 0.0; 
....................    } 
....................     
....................    if(y != 0) 
....................       y = y - (float64)(unsigned int16)y; 
....................  
....................    if (s) 
....................       res = -res; 
....................  
....................    if (y != 0) 
....................    { 
....................       if (s == 1 && n == 0) 
....................          res -= 1.0; 
....................  
....................       if (s == 0 && n == 1) 
....................          res += 1.0; 
....................    } 
....................     
....................    if (x == 0) 
....................       res = 0; 
....................  
....................    return (res); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float floor(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : rounds down the number x. 
.................... // Date : N/A 
.................... // 
.................... float32 floor(float32 x) 
.................... { 
....................    return CEIL_FLOOR(x,0); 
.................... } 
.................... // Following 2 functions are overloaded functions of floor() for PCD 
.................... // Overloaded function floor() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 floor(float48 x) 
.................... { 
....................    return CEIL_FLOOR(x, 0); 
.................... } 
....................  
.................... // Overloaded function floor() for data type - Float64 
.................... float64 floor(float64 x) 
.................... { 
....................    return CEIL_FLOOR(x, 0); 
.................... } 
.................... #endif 
....................  
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float ceil(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : rounds up the number x. 
.................... // Date : N/A 
.................... // 
.................... float32 ceil(float32 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
.................... // Following 2 functions are overloaded functions of ceil() for PCD 
.................... // Overloaded function ceil() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 ceil(float48 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
....................  
.................... // Overloaded function ceil() for data type - Float64 
.................... float64 ceil(float64 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
.................... #endif 
....................  
....................  //////////////////////////////////////////////////////////////////////////// 
.................... //   float fabs(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the absolute value of floating point number x 
.................... // Returns : returns the absolute value of x 
.................... // Date : N/A 
.................... // 
.................... #define fabs abs 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float fmod(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the floating point remainder of x/y 
.................... // Returns : returns the value of x= i*y, for some integer i such that, if y 
.................... // is non zero, the result has the same isgn of x na dmagnitude less than the 
.................... // magnitude of y. If y is zero then a domain error occurs. 
.................... // Date : N/A 
.................... // 
....................  
.................... float fmod(float32 x,float32 y) 
.................... { 
....................    float32 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... //Overloaded function for fmod() for PCD 
.................... // Overloaded function fmod() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 fmod(float48 x,float48 y) 
.................... { 
....................    float48 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... // Overloaded function fmod() for data type - Float64 
.................... float64 fmod(float64 x,float64 y) 
.................... { 
....................    float64 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... #endif 
.................... //////////////////// Exponential and logarithmic functions //////////////////// 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float exp(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (e^x) 
.................... // Date : N/A 
.................... // 
.................... #define LN2 0.6931471805599453 
.................... #define LN2_INV 1.4426950408889634073 
....................  
.................... float const pe[6] = {0.000207455774, 0.00127100575, 0.00965065093, 
....................                      0.0554965651,  0.240227138,  0.693147172}; 
....................  
....................  
.................... float32 exp(float32 x) 
.................... { 
....................    float32 y, res, r; 
....................    #if defined(__PCD__) 
....................    int8 data1; 
....................    #endif 
....................    signed int8 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 88.722838) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    n = (signed int16)(x*LN2_INV); 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
.................... #if !defined(__PCD__) 
....................    *((unsigned int8 *)(&res)) = n + 0x7F; 
.................... #endif 
....................  
.................... #if defined(__PCD__)  // Takes care of IEEE format for PCD 
....................    data1 = n+0x7F; 
....................    if(bit_test(data1,0)) 
....................    bit_set(*(((unsigned int8 *)(&res)+2)),7); 
....................    rotate_right(&data1,1); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&res)+3)) = data1; 
.................... #endif 
....................  
....................    y = y*LN2_INV - (float32)n; 
....................  
....................    r = pe[0]*y + pe[1]; 
....................    r = r*y + pe[2]; 
....................    r = r*y + pe[3]; 
....................    r = r*y + pe[4]; 
....................    r = r*y + pe[5]; 
....................  
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
....................  
....................  
.................... //Overloaded function for exp() for PCD 
.................... // Overloaded function exp() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 exp(float48 x) 
.................... { 
....................    float48 y, res, r; 
....................    int8 data1; 
....................    signed int8 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 88.722838) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    n = (signed int16)(x*LN2_INV); 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
....................  
....................    data1 = n+0x7F; 
....................    if(bit_test(data1,0)) 
....................    bit_set(*(((unsigned int8 *)(&res)+4)),7); 
....................    rotate_right(&data1,1); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&res)+5)) = data1; 
....................  
....................    y = y*LN2_INV - (float48)n; 
....................  
....................    r = pe[0]*y + pe[1]; 
....................    r = r*y + pe[2]; 
....................    r = r*y + pe[3]; 
....................    r = r*y + pe[4]; 
....................    r = r*y + pe[5]; 
....................  
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function exp() for data type - Float64 
.................... float64 const pe_64[12] ={9.30741400474913e-011,-4.28655416283316e-011, 
....................                           8.71486547014137e-009,9.84458531538385e-008, 
....................                           1.32588296983536e-006,1.52489283823016e-005, 
....................                           0.000154037598423921,0.00133335487036216, 
....................                           0.00961812936407326,0.0555041086222122, 
....................                           0.240226506962827,0.693147180559823}; 
....................  
.................... float64 exp(float64 x) 
.................... { 
....................    float64 y, res, r; 
....................    unsigned int16 data1, data2; 
....................    unsigned int16 *p; 
....................    signed int16 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 709.7827128) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x*LN2_INV; 
....................    n = (signed int16)y; 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
....................  
.................... #if !defined(__PCD__) 
....................    *((unsigned int16 *)(&res)) = n + 0x7F; 
.................... #endif 
....................    p= (((unsigned int16 *)(&res))+3); 
....................    data1 = *p; 
....................    data2 = *p;    
....................    data1 = n + 0x3FF; 
....................    data1 = data1 <<4; 
....................    if(bit_test(data2,15)) 
....................    bit_set(data1,15); 
....................    data2 = data2 & 0x000F; 
....................    data1 ^= data2; 
....................  
....................    *(((unsigned int16 *)(&res)+3)) = data1; 
....................  
....................  
....................    y = y*LN2_INV - (float64)n; 
....................  
....................    r = pe_64[0]*y + pe_64[1]; 
....................    r = r*y + pe_64[2]; 
....................    r = r*y + pe_64[3]; 
....................    r = r*y + pe_64[4]; 
....................    r = r*y + pe_64[5]; 
....................    r = r*y + pe_64[6]; 
....................    r = r*y + pe_64[7]; 
....................    r = r*y + pe_64[8]; 
....................    r = r*y + pe_64[9]; 
....................    r = r*y + pe_64[10]; 
....................    r = r*y + pe_64[11]; 
....................     
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
.................... #ENDIF 
....................  
....................  
.................... /************************************************************/ 
....................  
.................... float32 const pl[4] = {-1.080310025160955, 1.999999947089217}; 
.................... float32 const ql[4] = {0.091284365719509, -0.873491916557671}; 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float log(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the the natural log of x 
.................... // Date : N/A 
.................... // 
.................... float32 log(float32 x) 
.................... { 
....................    float32 y, res, r, y2; 
....................    #if defined(__PCD__) 
....................    unsigned int8  data1,data2; 
....................    #endif 
....................    signed int8 n; 
....................    #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
.................... #if !defined(__PCD__) 
....................     *((unsigned int8 *)(&y)) = 0x7E;  
.................... #endif 
....................  
.................... #if defined(__PCD__) // Takes care of IEEE format 
....................    data2 = *(((unsigned int8 *)(&y))+3); 
....................    *(((unsigned int8 *)(&y))+3) = 0x3F; 
....................    data1 = *(((unsigned int8 *)(&y))+2); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&y))+2) = data1; 
....................    if(bit_test(data2,7)) 
....................      bit_set(*(((unsigned int8 *)(&y))+3),7); 
.................... #endif 
....................  
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl[0]*y2 + pl[1]; 
....................  
....................       r = ql[0]*y2 + ql[1]; 
....................       r = r*y2 + 1.0; 
....................  
....................       res = y*res/r; 
.................... #if !defined(__PCD__) 
....................       n = *((unsigned int8 *)(&x)) - 0x7E; 
.................... #endif 
.................... #if defined(__PCD__)  
....................     data1 = *(((unsigned int8 *)(&x)+3)); 
....................     rotate_left(&data1,1); 
....................     data2 = *(((unsigned int8 *)(&x)+2)); 
....................     if(bit_test (data2,7)) 
....................       bit_set(data1,0); 
....................     n = data1 - 0x7E; 
.................... #endif 
....................  
....................       if (n<0)  
....................          r = -(float32)-n; 
....................       else 
....................          r = (float32)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................       res = 0.0; 
....................  
....................    return(res); 
.................... } 
....................  
.................... //Overloaded function for log() for PCD 
.................... // Overloaded function log() for data type - Float48 
.................... #if defined(__PCD__) 
.................... // Overloaded function log() for data type - float64 
.................... float64 const pl_64[4] = {-0.145694052150681, 1.365485300000370, 
....................                           -3.120535668274329, 2.000000000000000}; 
....................  
.................... float64 const ql_64[4] = {0.006047500465908, -0.208298281937234, 
....................                           1.113943039156721, -1.893601167470470}; 
....................  
.................... float48 log(float48 x) 
.................... { 
....................    float48 y, res, r, y2; 
....................    unsigned int8  data1,data2; 
....................    signed int8 n; 
.................... #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
.................... #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
....................  
.................... #if !defined(__PCD__) 
....................       *((unsigned int8 *)(&y)) = 0x7E;  
.................... #endif 
....................       data2 = *(((unsigned int8 *)(&y))+5); 
....................       *(((unsigned int8 *)(&y))+5) = 0x3F; 
....................       data1 = *(((unsigned int8 *)(&y))+4); 
....................       bit_clear(data1,7); 
....................       *(((unsigned int8 *)(&y))+4) = data1; 
....................  
....................       if(bit_test(data2,7)) 
....................       bit_set(*(((unsigned int8 *)(&y))+4),7); 
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl_64[0]*y2 + pl_64[1]; 
....................       res = res*y2 + pl_64[2]; 
....................       res = res*y2 + pl_64[3]; 
....................  
....................       r = ql_64[0]*y2 + ql_64[1]; 
....................       r = r*y2 + ql_64[2]; 
....................       r = r*y2 + ql_64[3]; 
....................       r = r*y2 + 1.0;  
....................       res = y*res/r; 
....................  
....................       data1 = *(((unsigned int8 *)(&x)+5)); 
....................       rotate_left(&data1,1); 
....................       data2 = *(((unsigned int8 *)(&x)+4)); 
....................       if(bit_test (data2,7)) 
....................       bit_set(data1,0); 
....................        
....................       n = data1 - 0x7E; 
....................  
....................       if (n<0) 
....................       r = -(float48)-n; 
....................       else 
....................       r = (float48)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................    res = 0.0; 
....................  
....................    return(res); 
.................... } 
....................  
.................... float64 log(float64 x) 
.................... { 
....................    float64 y, res, r, y2; 
....................    unsigned int16  data1,data2; 
....................    unsigned int16 *p; 
....................    signed int16 n; 
....................    #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
....................    #if !defined(__PCD__) 
....................        *((unsigned int8 *)(&y)) = 0x7E;  
....................    #endif 
....................       p= (((unsigned int16 *)(&y))+3); 
....................       data1 = *p; 
....................       data2 = *p; 
....................       data1 = 0x3FE; 
....................       data1 = data1 <<4; 
....................       if(bit_test (data2,15)) 
....................          bit_set(data1,15); 
....................       data2 = data2 & 0x000F; 
....................       data1 ^=data2; 
....................  
....................       *p = data1; 
....................  
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl_64[0]*y2 + pl_64[1]; 
....................       res = res*y2 + pl_64[2]; 
....................       res = res*y2 + pl_64[3]; 
....................  
....................       r = ql_64[0]*y2 + ql_64[1]; 
....................       r = r*y2 + ql_64[2]; 
....................       r = r*y2 + ql_64[3]; 
....................       r = r*y2 + 1.0; 
....................  
....................       res = y*res/r; 
....................   
....................       p= (((unsigned int16 *)(&x))+3); 
....................       data1 = *p; 
....................       bit_clear(data1,15); 
....................       data1 = data1 >>4;     
....................       n = data1 - 0x3FE; 
....................  
....................  
....................       if (n<0) 
....................          r = -(float64)-n; 
....................       else 
....................          r = (float64)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................       res = 0.0; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
....................  
.................... #define LN10 2.3025850929940456 
.................... #define LN10_INV 0.4342944819032518276 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float log10(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the the log base 10 of x 
.................... // Date : N/A 
.................... // 
.................... float32 log10(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = log(x); 
....................    r = r*LN10_INV; 
....................    return(r); 
.................... } 
....................  
.................... //Overloaded functions for log10() for PCD 
.................... // Overloaded function log10() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 log10(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = log(x); 
....................    r = r*LN10_INV; 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function log10() for data type - Float64 
.................... float64 log10(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = log(x); 
....................    r = r*LN10_INV; 
....................    return(r); 
.................... } 
.................... #endif 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float modf(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description :breaks the argument value int integral and fractional parts, 
.................... // ach of which have the same sign as the argument.  It stores the integral part 
.................... // as a float in the object pointed to by the iptr 
.................... // Returns : returns the signed fractional part of value. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 modf(float32 value,float32 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... //Overloaded functions for modf() for PCD 
.................... // Overloaded function modf() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 modf(float48 value,float48 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... // Overloaded function modf() for data type - Float64 
.................... float64 modf(float64 value,float64 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float pwr(float x,float y) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (x^y) 
.................... // Date : N/A 
.................... // Note : 0 is returned when the function will generate an imaginary number 
.................... // 
.................... float32 pwr(float32 x,float32 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... //Overloaded functions for pwr() for PCD 
.................... // Overloaded function pwr() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 pwr(float48 x,float48 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... // Overloaded function pwr() for data type - Float64 
.................... float64 pwr(float64 x,float64 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////// Power functions //////////////////// 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float pow(float x,float y) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (x^y) 
.................... // Date : N/A 
.................... // Note : 0 is returned when the function will generate an imaginary number 
.................... // 
.................... float32 pow(float32 x,float32 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... //Overloaded functions for pow() for PCD 
.................... // Overloaded function for pow() data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 pow(float48 x,float48 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
....................  
.................... // Overloaded function pow() for data type - Float64 
.................... float64 pow(float64 x,float64 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sqrt(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the square root of x 
.................... // Date : N/A 
.................... // 
.................... float32 sqrt(float32 x) 
.................... { 
....................    float32 y, res; 
....................    #if defined(__PCD__) 
....................    unsigned int16 data1,data2; 
....................    #endif 
....................    unsigned int8 *p; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................     
....................    #if !defined(__PCD__) 
....................     p=&y; 
....................    (*p)=(unsigned int8)((((unsigned int16)(*p)) + 127) >> 1); 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     p = (((unsigned int8 *)(&y))+3); 
....................     data1 = *(((unsigned int8 *)(&y))+3); 
....................     data2 = *(((unsigned int8 *)(&y))+2); 
....................     rotate_left(&data1,1);     
....................     if(bit_test(data2,7))     
....................        bit_set(data1,0);     
....................     data1 = ((data1+127) >>1); 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+3) = data1; 
....................     *(((unsigned int8 *)(&y))+2) = data2; 
....................      
....................   #endif 
....................  
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................  
....................       #if !defined(__PCD__) 
....................      (*p)--; 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     data1 = *(((unsigned int8 *)(&y))+3); 
....................     data2 = *(((unsigned int8 *)(&y))+2); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................        bit_set(data1,0);     
....................     data1--; 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+3) = data1; 
....................     *(((unsigned int8 *)(&y))+2) = data2; 
....................      
....................   #endif 
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
.................... //Overloaded functions for sqrt() for PCD 
.................... // Overloaded function sqrt() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sqrt(float48 x) 
.................... { 
....................    float48 y, res; 
....................    unsigned int16 data1,data2; 
....................    unsigned int8 *p; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................     
....................    #if !defined(__PCD__) 
....................     p=&y; 
....................    (*p)=(unsigned int8)((((unsigned int16)(*p)) + 127) >> 1); 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     p = (((unsigned int8 *)(&y))+5); 
....................     data1 = *(((unsigned int8 *)(&y))+5); 
....................     data2 = *(((unsigned int8 *)(&y))+4); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................        bit_set(data1,0);     
....................     data1 = ((data1+127) >>1); 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+5) = data1; 
....................     *(((unsigned int8 *)(&y))+4) = data2; 
....................      
....................   #endif 
....................  
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................  
....................       #if !defined(__PCD__) 
....................      (*p)--; 
....................    #endif 
....................     
....................     data1 = *(((unsigned int8 *)(&y))+5); 
....................     data2 = *(((unsigned int8 *)(&y))+4); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................        bit_set(data1,0);     
....................     data1--; 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+5) = data1; 
....................     *(((unsigned int8 *)(&y))+4) = data2; 
....................      
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function sqrt() for data type - Float64 
.................... float64 sqrt(float64 x) 
.................... { 
....................    float64 y, res; 
....................    unsigned int16 *p; 
....................    unsigned int16 temp1,temp2; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................    p= (((unsigned int16 *)(&y))+3); 
....................    temp1 = *p; 
....................    temp2 = *p; 
....................    bit_clear(temp1,15); 
....................    temp1 = (temp1>>4)+1023; 
....................    temp1 = temp1 >> 1; 
....................    temp1 = (temp1<<4) & 0xFFF0; 
....................    if(bit_test(temp2,15)) 
....................       bit_set(temp1,15); 
....................    temp2 = temp2 & 0x000F; 
....................    temp1 ^= temp2; 
....................     
....................    (*p) = temp1; 
....................     
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................      temp1 = *p; 
....................      temp2 = *p; 
....................      bit_clear(temp1,15); 
....................      temp1 = (temp1>>4); 
....................      temp1--; 
....................      temp1 = (temp1<<4) & 0xFFF0; 
....................      if(bit_test(temp2,15)) 
....................         bit_set(temp1,15); 
....................      temp2 = temp2 & 0x000F; 
....................      temp1 ^= temp2; 
....................      (*p) = temp1; 
....................  
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... ////////////////////////////// Trig Functions ////////////////////////////// 
.................... #ifdef PI_DIV_BY_TWO_INV 
.................... #undef PI_DIV_BY_TWO_INV 
.................... #endif 
.................... #define PI_DIV_BY_TWO_INV 0.63661977236758134 
.................... #ifdef PI_DIV_BY_TWO 
.................... #undef PI_DIV_BY_TWO 
.................... #endif 
.................... #define PI_DIV_BY_TWO   1.5707963267948966 
.................... #ifdef TWOBYPI 
.................... #undef TWOBYPI 
.................... #endif 
.................... #define TWOBYPI          0.6366197723675813 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float cos(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the cosine value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 cos(float32 x) 
.................... { 
....................    float32 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float32 frac; 
....................    float32 p[5] = {                    //by the series definition for cosine 
....................       -0.49999999456337096,            // sum ( ( (-1)^n * x^2n )/(2n)! ) 
....................        0.04166663896921267, 
....................       -0.00138883894522527, 
....................        0.00002476138231734, 
....................       -0.00000026070414770 
....................       //-0.00000000001147, 
....................       // 0.00000000000005 
....................    }; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant 
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 1.0; 
....................    t = t * t; 
....................    for (i = 0; i <= 4; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
....................  
.................... //Overloaded functions for cos() for PCD 
.................... // Overloaded function cos() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 cos(float48 x) 
.................... { 
....................    float48 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float48 frac; 
....................    float48 p[6] = {                    //by the series definition for cosine 
....................       -0.5,                            // sum ( ( (-1)^n * x^2n )/(2n)! ) 
....................        0.04166666666667, 
....................       -0.00138888888889, 
....................        0.00002480158730, 
....................       -0.00000027557319, 
....................        0.00000000208767, 
....................       //-0.00000000001147, 
....................       // 0.00000000000005 
....................    }; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant 
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 0.999999999781; 
....................    t = t * t; 
....................    for (i = 0; i <= 5; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
.................... // Overloaded function cos() for data type - Float64 
.................... float64 cos(float64 x) 
.................... { 
....................    float64 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float64 frac; 
....................    float64 p_64[9] = {               //by the series definition for cosine 
....................      -0.49999999999998740,           // sum ( ( (-1)^n * x^2n )/(2n)! )              
....................       0.04166666666656518, 
....................      -0.00138888888851691, 
....................       0.00002480158658490, 
....................      -0.00000027557239796, 
....................       0.00000000208715031, 
....................      -0.00000000001126577, 
....................       0.00000000000000427, 
....................       0.00000000000000372}; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant 
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 1.0; 
....................    t = t * t; 
....................    for (i = 0; i <= 8; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p_64[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sin(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the sine value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 sin(float32 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
....................  
.................... //Overloaded functions for sin() for PCD 
.................... // Overloaded function sin() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sin(float48 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
....................  
.................... // Overloaded function sin() for data type - Float48 
.................... float64 sin(float64 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float tan(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the tangent value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 tan(float32 x) 
.................... { 
....................    float32 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
.................... //Overloaded functions for tan() for PCD 
.................... // Overloaded function tan() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 tan(float48 x) 
.................... { 
....................    float48 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
....................  
.................... // Overloaded function tan() for data type - Float48 
.................... float64 tan(float64 x) 
.................... { 
....................    float64 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
.................... #endif 
....................  
.................... float32 const pas[3] = {0.49559947, -4.6145309, 5.6036290}; 
.................... float32 const qas[3] = {1.0000000,  -5.5484666, 5.6036290}; 
....................  
.................... float32 ASIN_COS(float32 x, unsigned int8 n) 
.................... { 
....................    float32 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)*0.5); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas[0]*y2 + pas[1]; 
....................    res = res*y2 + pas[2]; 
....................  
....................    r = qas[0]*y2 + qas[1]; 
....................    r = r*y2 + qas[2]; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
....................  
....................  
.................... //Overloaded functions for ASIN_COS() for PCD 
.................... // Overloaded function ASIN_COS() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 ASIN_COS(float48 x, unsigned int8 n) 
.................... { 
....................    float48 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)*0.5); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas[0]*y2 + pas[1]; 
....................    res = res*y2 + pas[2]; 
....................  
....................    r = qas[0]*y2 + qas[1]; 
....................    r = r*y2 + qas[2]; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function ASIN_COS() for data type - Float64 
.................... double pas_64[5]={1.000000000000000,-2.069938587724477,1.421444580548907, 
....................                  -0.360690137621842,0.024929451660228}; 
....................  
.................... double qas_64[5]={-2.236605254391134,1.719212122946451,-0.524122954476133, 
....................                    0.052808872045749,-0.000662536036570}; 
....................                     
.................... float64 ASIN_COS(float64 x, unsigned int8 n) 
.................... { 
....................    float64 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)*0.5); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas_64[4]*y2 + pas_64[3]; 
....................    res = res*y2 + pas_64[2]; 
....................    res = res*y2 + pas_64[1]; 
....................    res = res*y2 + pas_64[0]; 
....................  
....................    r = qas_64[4]*y2 + qas_64[3]; 
....................    r = r*y2 + qas_64[2]; 
....................    r = r*y2 + qas_64[1]; 
....................    r = r*y2 + qas_64[0]; 
....................    r = r*y2 + 1.0; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float asin(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arcsine value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 asin(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
.................... //Overloaded functions for asin() for PCD 
.................... // Overloaded function asin() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 asin(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function asin() for data type - Float64 
.................... float64 asin(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float acos(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arccosine value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 acos(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
.................... //Overloaded functions for acos() for PCD 
.................... // Overloaded function acos() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 acos(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function acos() for data type - Float64 
.................... float64 acos(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
.................... #endif 
....................  
.................... float32 const pat[4] = {0.17630401, 5.6710795, 22.376096, 19.818457}; 
.................... float32 const qat[4] = {1.0000000,  11.368190, 28.982246, 19.818457}; 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float atan(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arctangent value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 atan(float32 x) 
.................... { 
....................    float32 y, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................  
....................    res = pat[0]*y*y + pat[1]; 
....................    res = res*y*y + pat[2]; 
....................    res = res*y*y + pat[3]; 
....................  
....................    r = qat[0]*y*y + qat[1]; 
....................    r = r*y*y + qat[2]; 
....................    r = r*y*y + qat[3]; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
.................... //Overloaded functions for atan() for PCD 
.................... // Overloaded function atan() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 atan(float48 x) 
.................... { 
....................    float48 y, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................  
....................    res = pat[0]*y*y + pat[1]; 
....................    res = res*y*y + pat[2]; 
....................    res = res*y*y + pat[3]; 
....................  
....................    r = qat[0]*y*y + qat[1]; 
....................    r = r*y*y + qat[2]; 
....................    r = r*y*y + qat[3]; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
....................  
.................... float64 pat_64[6]={0.999999999999999,2.249923645595566,1.771541617806449, 
....................                    0.579678874003185,0.072162702162882,0.002281100141660}; 
....................  
.................... float64 qat_64[6]={2.583256978928510,2.432627277466967,1.016760379885393, 
....................                    0.182482977188688,0.011155377971690,0.000100013019160}; 
.................... // Overloaded function atan() for data type - Float64 
.................... float64 atan(float64 x) 
.................... { 
....................    float64 y,y2, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................    y2 = y*y; 
....................    res = pat_64[5]*y2 + pat_64[4]; 
....................    res = res*y2 + pat_64[3]; 
....................    res = res*y2 + pat_64[2]; 
....................    res = res*y2 + pat_64[1]; 
....................    res = res*y2 + pat_64[0]; 
....................  
....................    r = qat_64[5]*y2 + qat_64[4]; 
....................    r = r*y2 + qat_64[3]; 
....................    r = r*y2 + qat_64[2]; 
....................    r = r*y2 + qat_64[1]; 
....................    r = r*y2 + qat_64[0]; 
....................    r = r*y2 + 1.0; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... ///////////////////////////////////////////////////////////////////////////// 
.................... //   float atan2(float y, float x) 
.................... ///////////////////////////////////////////////////////////////////////////// 
.................... // Description :computes the principal value of arc tangent of y/x, using the 
.................... // signs of both the arguments to determine the quadrant of the return value 
.................... // Returns : returns the arc tangent of y/x. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 atan2(float32 y,float32 x) 
.................... { 
....................    float32 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
....................  
.................... //Overloaded functions for atan2() for PCD 
.................... // Overloaded function atan2() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 atan2(float48 y,float48 x) 
.................... { 
....................    float48 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
....................  
.................... // Overloaded function atan2() for data type - Float64 
.................... float64 atan2(float64 y,float64 x) 
.................... { 
....................    float64 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////// Hyperbolic functions //////////////////// 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float cosh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic cosine value of x 
.................... // Returns : returns the hyperbolic cosine value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 cosh(float32 x) 
.................... { 
....................    return ((exp(x)+exp(-x))*0.5); 
.................... } 
.................... //Overloaded functions for cosh() for PCD 
.................... // Overloaded function cosh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 cosh(float48 x) 
.................... { 
....................    return ((exp(x)+exp(-x))*0.5); 
.................... } 
....................  
.................... // Overloaded function cosh() for data type - Float64 
.................... float64 cosh(float64 x) 
.................... { 
....................    return ((exp(x)+exp(-x))*0.5); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sinh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic sine value of x 
.................... // Returns : returns the hyperbolic sine value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 sinh(float32 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))*0.5); 
.................... } 
.................... //Overloaded functions for sinh() for PCD 
.................... // Overloaded function sinh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sinh(float48 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))*0.5); 
.................... } 
....................  
.................... // Overloaded function sinh() for data type - Float48 
.................... float64 sinh(float64 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))*0.5); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float tanh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic tangent value of x 
.................... // Returns : returns the hyperbolic tangent value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 tanh(float32 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
.................... //Overloaded functions for tanh() for PCD 
.................... // Overloaded function tanh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 tanh(float48 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
....................  
.................... // Overloaded function tanh() for data type - Float64 
.................... float64 tanh(float64 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float frexp(float x, signed int *exp) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : breaks a floating point number into a normalized fraction and an integral 
.................... // power of 2. It stores the integer in the signed int object pointed to by exp. 
.................... // Returns : returns the value x, such that x is a double with magnitude in the interval 
.................... // [1/2,1) or zero, and value equals x times 2 raised to the power *exp.If value is zero, 
.................... // both parts of the result are zero. 
.................... // Date : N/A 
.................... // 
....................  
.................... #define LOG2 .30102999566398119521 
.................... #define LOG2_INV 3.32192809488736234787 
.................... float32 frexp(float32 x, signed int8 *exp) 
.................... { 
....................    float32 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)*LOG2_INV)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
....................  
.................... //Overloaded functions for frexp() for PCD 
.................... // Overloaded function frexp() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 frexp(float48 x, signed int8 *exp) 
.................... { 
....................    float48 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)*LOG2_INV)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
....................  
.................... // Overloaded function frexp() for data type - Float64 
.................... float64 frexp(float64 x, signed int8 *exp) 
.................... { 
....................    float64 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)*LOG2_INV)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
.................... #endif 
....................  
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... //   float ldexp(float x, signed int *exp) 
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... // Description : multiplies a floating point number by an integral power of 2. 
.................... // Returns : returns the value of x times 2 raised to the power exp. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 ldexp(float32 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... //Overloaded functions for ldexp() for PCD 
.................... // Overloaded function ldexp() for data type - Float48 
....................  
.................... #if defined(__PCD__) 
.................... float48 ldexp(float48 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... // Overloaded function ldexp() for data type - Float64 
.................... float64 ldexp(float64 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... #endif 
....................  
.................... #endif 
....................  
.................... #INCLUDE <xuatbyte74595.c> 
....................  
.................... #DEFINE      DS               PIN_D1 
.................... #DEFINE      SH_CP            PIN_D0   
.................... #DEFINE      STCP             PIN_D2 
.................... VOID XUATTRANGTHAI(UNSIGNED INT8 BYTEXUAT) 
.................... { 
....................    UNSIGNED INT8   SB;    
....................    #BIT BSERI  = BYTEXUAT.7 
....................     
....................    FOR (SB=0;SB<8;SB++) 
*
0BE9:  CLRF   1A
0BEA:  MOVF   1A,W
0BEB:  SUBLW  07
0BEC:  BTFSS  03.0
0BED:  GOTO   404
....................       {                                                  
....................          OUTPUT_BIT(DS,BSERI);     
0BEE:  BTFSC  19.7
0BEF:  GOTO   3F4
0BF0:  BCF    03.6
0BF1:  BCF    08.1
0BF2:  GOTO   3F6
0BF3:  BSF    03.6
0BF4:  BCF    03.6
0BF5:  BSF    08.1
0BF6:  BSF    03.5
0BF7:  BCF    08.1
....................          OUTPUT_LOW(SH_CP); OUTPUT_HIGH(SH_CP); 
0BF8:  BCF    08.0
0BF9:  BCF    03.5
0BFA:  BCF    08.0
0BFB:  BSF    03.5
0BFC:  BCF    08.0
0BFD:  BCF    03.5
0BFE:  BSF    08.0
....................          BYTEXUAT=BYTEXUAT<<1; //10010010->00100100   
0BFF:  BCF    03.0
0C00:  BSF    03.6
0C01:  RLF    19,F
0C02:  INCF   1A,F
0C03:  GOTO   3EA
....................      } 
....................       OUTPUT_LOW(STCP); OUTPUT_HIGH(STCP); 
0C04:  BSF    03.5
0C05:  BCF    03.6
0C06:  BCF    08.2
0C07:  BCF    03.5
0C08:  BCF    08.2
0C09:  BSF    03.5
0C0A:  BCF    08.2
0C0B:  BCF    03.5
0C0C:  BSF    08.2
.................... } 
....................  
....................  
.................... #FUSES NOWDT, PUT, HS 
.................... #USE DELAY(CLOCK=20M) 
*
0170:  MOVLW  41
0171:  MOVWF  04
0172:  BSF    03.7
0173:  MOVF   00,W
0174:  BTFSC  03.2
0175:  GOTO   183
0176:  MOVLW  06
0177:  MOVWF  78
0178:  CLRF   77
0179:  DECFSZ 77,F
017A:  GOTO   179
017B:  DECFSZ 78,F
017C:  GOTO   178
017D:  MOVLW  7B
017E:  MOVWF  77
017F:  DECFSZ 77,F
0180:  GOTO   17F
0181:  DECFSZ 00,F
0182:  GOTO   176
0183:  RETURN
.................... #USE RS232(BAUD=9600,XMIT=PIN_C6,RCV=PIN_C7) 
.................... #DEFINE BT1_PIN PIN_B1 
.................... #DEFINE BT2_PIN PIN_B2 
.................... #DEFINE BT3_PIN PIN_B3 
.................... #DEFINE LCD_ENABLE_PIN  PIN_E0                                    
.................... #DEFINE LCD_RS_PIN      PIN_E1                                 
.................... #DEFINE LCD_RW_PIN      PIN_E2   
.................... #DEFINE LCD_DATA4       PIN_C0                                
.................... #DEFINE LCD_DATA5       PIN_C1                                  
.................... #DEFINE LCD_DATA6       PIN_C2                                    
.................... #DEFINE LCD_DATA7       PIN_C3   
.................... #INCLUDE <LCD.C> 
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... ////                             LCD.C                                     //// 
.................... ////                 Driver for common LCD modules                         //// 
.................... ////                                                                       //// 
.................... ////  lcd_init()   Must be called before any other function.               //// 
.................... ////                                                                       //// 
.................... ////  lcd_putc(c)  Will display c on the next position of the LCD.         //// 
.................... ////                 \a  Set cursor position to upper left                 //// 
.................... ////                 \f  Clear display, set cursor to upper left           //// 
.................... ////                 \n  Go to start of second line                        //// 
.................... ////                 \b  Move back one position                            //// 
.................... ////              If LCD_EXTENDED_NEWLINE is defined, the \n character     //// 
.................... ////              will erase all remanining characters on the current      //// 
.................... ////              line, and move the cursor to the beginning of the next   //// 
.................... ////              line.                                                    //// 
.................... ////              If LCD_EXTENDED_NEWLINE is defined, the \r character     //// 
.................... ////              will move the cursor to the start of the current         //// 
.................... ////              line.                                                    //// 
.................... ////                                                                       //// 
.................... ////  lcd_gotoxy(x,y) Set write position on LCD (upper left is 1,1)        //// 
.................... ////                                                                       //// 
.................... ////  lcd_getc(x,y)   Returns character at position x,y on LCD             //// 
.................... ////                                                                       //// 
.................... ////  lcd_cursor_on(int1 on)   Turn the cursor on (on=TRUE) or off         //// 
.................... ////              (on=FALSE).                                              //// 
.................... ////                                                                       //// 
.................... ////  lcd_set_cgram_char(w, *p)   Write a custom character to the CGRAM.   //// 
.................... ////                                                                       //// 
.................... ////                                                                       //// 
.................... ////  CONFIGURATION                                                        //// 
.................... ////  The LCD can be configured in one of two ways: a.) port access or     //// 
.................... ////  b.) pin access.  Port access requires the entire 7 bit interface     //// 
.................... ////  connected to one GPIO port, and the data bits (D4:D7 of the LCD)     //// 
.................... ////  connected to sequential pins on the GPIO.  Pin access                //// 
.................... ////  has no requirements, all 7 bits of the control interface can         //// 
.................... ////  can be connected to any GPIO using several ports.                    //// 
.................... ////                                                                       //// 
.................... ////  To use port access, #define LCD_DATA_PORT to the SFR location of     //// 
.................... ////  of the GPIO port that holds the interface, -AND- edit LCD_PIN_MAP    //// 
.................... ////  of this file to configure the pin order.  If you are using a         //// 
.................... ////  baseline PIC (PCB), then LCD_OUTPUT_MAP and LCD_INPUT_MAP also must  //// 
.................... ////  be defined.                                                          //// 
.................... ////                                                                       //// 
.................... ////  Example of port access:                                              //// 
.................... ////     #define LCD_DATA_PORT getenv("SFR:PORTD")                         //// 
.................... ////                                                                       //// 
.................... ////  To use pin access, the following pins must be defined:               //// 
.................... ////     LCD_ENABLE_PIN                                                    //// 
.................... ////     LCD_RS_PIN                                                        //// 
.................... ////     LCD_RW_PIN                                                        //// 
.................... ////     LCD_DATA4                                                         //// 
.................... ////     LCD_DATA5                                                         //// 
.................... ////     LCD_DATA6                                                         //// 
.................... ////     LCD_DATA7                                                         //// 
.................... ////                                                                       //// 
.................... ////  Example of pin access:                                               //// 
.................... ////     #define LCD_ENABLE_PIN  PIN_E0                                    //// 
.................... ////     #define LCD_RS_PIN      PIN_E1                                    //// 
.................... ////     #define LCD_RW_PIN      PIN_E2                                    //// 
.................... ////     #define LCD_DATA4       PIN_D4                                    //// 
.................... ////     #define LCD_DATA5       PIN_D5                                    //// 
.................... ////     #define LCD_DATA6       PIN_D6                                    //// 
.................... ////     #define LCD_DATA7       PIN_D7                                    //// 
.................... ////                                                                       //// 
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2010 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef __LCD_C__ 
.................... #define __LCD_C__ 
....................  
.................... // define the pinout. 
.................... // only required if port access is being used. 
.................... typedef struct   
.................... {                            // This structure is overlayed 
....................    int1 enable;           // on to an I/O port to gain 
....................    int1 rs;               // access to the LCD pins. 
....................    int1 rw;               // The bits are allocated from 
....................    int1 unused;           // low order up.  ENABLE will 
....................    unsigned int     data : 4;         // be LSB pin of that port. 
....................   #if defined(__PCD__)       // The port used will be LCD_DATA_PORT. 
....................    unsigned int    reserved: 8; 
....................   #endif 
.................... } LCD_PIN_MAP; 
....................  
.................... // this is to improve compatability with previous LCD drivers that accepted 
.................... // a define labeled 'use_portb_lcd' that configured the LCD onto port B. 
.................... #if ((defined(use_portb_lcd)) && (use_portb_lcd==TRUE)) 
....................  #define LCD_DATA_PORT getenv("SFR:PORTB") 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
....................    // these definitions only need to be modified for baseline PICs. 
....................    // all other PICs use LCD_PIN_MAP or individual LCD_xxx pin definitions. 
.................... /*                                    EN, RS,   RW,   UNUSED,  DATA  */ 
....................  const LCD_PIN_MAP LCD_OUTPUT_MAP =  {0,  0,    0,    0,       0}; 
....................  const LCD_PIN_MAP LCD_INPUT_MAP =   {0,  0,    0,    0,       0xF}; 
.................... #endif 
....................  
.................... ////////////////////// END CONFIGURATION /////////////////////////////////// 
....................  
.................... #ifndef LCD_ENABLE_PIN 
....................    #define lcd_output_enable(x) lcdlat.enable=x 
....................    #define lcd_enable_tris()   lcdtris.enable=0 
.................... #else 
....................    #define lcd_output_enable(x) output_bit(LCD_ENABLE_PIN, x) 
....................    #define lcd_enable_tris()  output_drive(LCD_ENABLE_PIN) 
.................... #endif 
....................  
.................... #ifndef LCD_RS_PIN 
....................    #define lcd_output_rs(x) lcdlat.rs=x 
....................    #define lcd_rs_tris()   lcdtris.rs=0 
.................... #else 
....................    #define lcd_output_rs(x) output_bit(LCD_RS_PIN, x) 
....................    #define lcd_rs_tris()  output_drive(LCD_RS_PIN) 
.................... #endif 
....................  
.................... #ifndef LCD_RW_PIN 
....................    #define lcd_output_rw(x) lcdlat.rw=x 
....................    #define lcd_rw_tris()   lcdtris.rw=0 
.................... #else 
....................    #define lcd_output_rw(x) output_bit(LCD_RW_PIN, x) 
....................    #define lcd_rw_tris()  output_drive(LCD_RW_PIN) 
.................... #endif 
....................  
.................... // original version of this library incorrectly labeled LCD_DATA0 as LCD_DATA4, 
.................... // LCD_DATA1 as LCD_DATA5, and so on.  this block of code makes the driver 
.................... // compatible with any code written for the original library 
.................... #if (defined(LCD_DATA0) && defined(LCD_DATA1) && defined(LCD_DATA2) && defined(LCD_DATA3) && !defined(LCD_DATA4) && !defined(LCD_DATA5) && !defined(LCD_DATA6) && !defined(LCD_DATA7)) 
....................    #define  LCD_DATA4    LCD_DATA0 
....................    #define  LCD_DATA5    LCD_DATA1 
....................    #define  LCD_DATA6    LCD_DATA2 
....................    #define  LCD_DATA7    LCD_DATA3 
.................... #endif 
....................  
.................... #ifndef LCD_DATA4 
.................... #ifndef LCD_DATA_PORT 
....................    #if defined(__PCB__) 
....................       #define LCD_DATA_PORT      0x06     //portb 
....................       #define set_tris_lcd(x)   set_tris_b(x) 
....................    #else 
....................      #if defined(PIN_D0) 
....................       #define LCD_DATA_PORT      getenv("SFR:PORTD")     //portd 
....................      #else 
....................       #define LCD_DATA_PORT      getenv("SFR:PORTB")     //portb 
....................      #endif 
....................    #endif    
.................... #endif 
....................  
.................... #if defined(__PCB__) 
....................    LCD_PIN_MAP lcd, lcdlat; 
....................    #byte lcd = LCD_DATA_PORT 
....................    #byte lcdlat = LCD_DATA_PORT 
.................... #elif defined(__PCM__) 
....................    LCD_PIN_MAP lcd, lcdlat, lcdtris; 
....................    #byte lcd = LCD_DATA_PORT 
....................    #byte lcdlat = LCD_DATA_PORT 
....................    #byte lcdtris = LCD_DATA_PORT+0x80 
.................... #elif defined(__PCH__) 
....................    LCD_PIN_MAP lcd, lcdlat, lcdtris; 
....................    #byte lcd = LCD_DATA_PORT 
....................    #byte lcdlat = LCD_DATA_PORT+9 
....................    #byte lcdtris = LCD_DATA_PORT+0x12 
.................... #elif defined(__PCD__) 
....................    LCD_PIN_MAP lcd, lcdlat, lcdtris; 
....................    #word lcd = LCD_DATA_PORT 
....................    #word lcdlat = LCD_DATA_PORT+2 
....................    #word lcdtris = LCD_DATA_PORT-0x02 
.................... #endif 
.................... #endif   //LCD_DATA4 not defined 
....................  
.................... #ifndef LCD_TYPE 
....................    #define LCD_TYPE 2           // 0=5x7, 1=5x10, 2=2 lines 
.................... #endif 
....................  
.................... #ifndef LCD_LINE_TWO 
....................    #define LCD_LINE_TWO 0x40    // LCD RAM address for the second line 
.................... #endif 
....................  
.................... #ifndef LCD_LINE_LENGTH 
....................    #define LCD_LINE_LENGTH 20 
.................... #endif 
....................  
.................... unsigned int8 lcd_read_nibble(void); 
....................  
.................... unsigned int8 lcd_read_byte(void) 
.................... { 
....................    unsigned int8 low,high; 
....................  
....................  #if defined(__PCB__) 
....................    set_tris_lcd(LCD_INPUT_MAP); 
....................  #else 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    output_float(LCD_DATA4); 
*
0217:  BSF    07.0
....................    output_float(LCD_DATA5); 
0218:  BSF    07.1
....................    output_float(LCD_DATA6); 
0219:  BSF    07.2
....................    output_float(LCD_DATA7); 
021A:  BSF    07.3
....................   #else 
....................    lcdtris.data = 0xF; 
....................   #endif 
....................  #endif 
....................          
....................    lcd_output_rw(1); 
021B:  BCF    03.5
021C:  BSF    09.2
021D:  BSF    03.5
021E:  BCF    09.2
....................    delay_cycles(1); 
021F:  NOP
....................    lcd_output_enable(1); 
0220:  BCF    03.5
0221:  BSF    09.0
0222:  BSF    03.5
0223:  BCF    09.0
....................    delay_cycles(1); 
0224:  NOP
....................    high = lcd_read_nibble(); 
0225:  BCF    03.5
0226:  CALL   1CC
0227:  MOVF   78,W
0228:  BSF    03.6
0229:  MOVWF  48
....................        
....................    lcd_output_enable(0); 
022A:  BCF    03.6
022B:  BCF    09.0
022C:  BSF    03.5
022D:  BCF    09.0
....................    delay_cycles(1); 
022E:  NOP
....................    lcd_output_enable(1); 
022F:  BCF    03.5
0230:  BSF    09.0
0231:  BSF    03.5
0232:  BCF    09.0
....................    delay_us(1); 
0233:  GOTO   234
0234:  GOTO   235
0235:  NOP
....................    low = lcd_read_nibble(); 
0236:  BCF    03.5
0237:  CALL   1CC
0238:  MOVF   78,W
0239:  BSF    03.6
023A:  MOVWF  47
....................        
....................    lcd_output_enable(0); 
023B:  BCF    03.6
023C:  BCF    09.0
023D:  BSF    03.5
023E:  BCF    09.0
....................  
....................  #if defined(__PCB__) 
....................    set_tris_lcd(LCD_OUTPUT_MAP); 
....................  #else 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    output_drive(LCD_DATA4); 
023F:  BCF    03.5
0240:  BCF    31.0
0241:  MOVF   31,W
0242:  BSF    03.5
0243:  MOVWF  07
....................    output_drive(LCD_DATA5); 
0244:  BCF    03.5
0245:  BCF    31.1
0246:  MOVF   31,W
0247:  BSF    03.5
0248:  MOVWF  07
....................    output_drive(LCD_DATA6); 
0249:  BCF    03.5
024A:  BCF    31.2
024B:  MOVF   31,W
024C:  BSF    03.5
024D:  MOVWF  07
....................    output_drive(LCD_DATA7); 
024E:  BCF    03.5
024F:  BCF    31.3
0250:  MOVF   31,W
0251:  BSF    03.5
0252:  MOVWF  07
....................   #else 
....................    lcdtris.data = 0x0; 
....................   #endif 
....................  #endif 
....................  
....................    return( (high<<4) | low); 
0253:  BCF    03.5
0254:  BSF    03.6
0255:  SWAPF  48,W
0256:  MOVWF  77
0257:  MOVLW  F0
0258:  ANDWF  77,F
0259:  MOVF   77,W
025A:  IORWF  47,W
025B:  MOVWF  78
.................... } 
....................  
.................... unsigned int8 lcd_read_nibble(void) 
.................... { 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
*
01CC:  BSF    03.6
01CD:  CLRF   49
....................    unsigned int8 n = 0x00; 
....................  
....................    /* Read the data port */ 
....................    n |= input(LCD_DATA4); 
01CE:  BCF    03.6
01CF:  BSF    31.0
01D0:  MOVF   31,W
01D1:  BSF    03.5
01D2:  MOVWF  07
01D3:  MOVLW  00
01D4:  BCF    03.5
01D5:  BTFSC  07.0
01D6:  MOVLW  01
01D7:  BSF    03.6
01D8:  IORWF  49,F
....................    n |= input(LCD_DATA5) << 1; 
01D9:  BCF    03.6
01DA:  BSF    31.1
01DB:  MOVF   31,W
01DC:  BSF    03.5
01DD:  MOVWF  07
01DE:  MOVLW  00
01DF:  BCF    03.5
01E0:  BTFSC  07.1
01E1:  MOVLW  01
01E2:  MOVWF  77
01E3:  BCF    03.0
01E4:  RLF    77,F
01E5:  MOVF   77,W
01E6:  BSF    03.6
01E7:  IORWF  49,F
....................    n |= input(LCD_DATA6) << 2; 
01E8:  BCF    03.6
01E9:  BSF    31.2
01EA:  MOVF   31,W
01EB:  BSF    03.5
01EC:  MOVWF  07
01ED:  MOVLW  00
01EE:  BCF    03.5
01EF:  BTFSC  07.2
01F0:  MOVLW  01
01F1:  MOVWF  77
01F2:  RLF    77,F
01F3:  RLF    77,F
01F4:  MOVLW  FC
01F5:  ANDWF  77,F
01F6:  MOVF   77,W
01F7:  BSF    03.6
01F8:  IORWF  49,F
....................    n |= input(LCD_DATA7) << 3; 
01F9:  BCF    03.6
01FA:  BSF    31.3
01FB:  MOVF   31,W
01FC:  BSF    03.5
01FD:  MOVWF  07
01FE:  MOVLW  00
01FF:  BCF    03.5
0200:  BTFSC  07.3
0201:  MOVLW  01
0202:  MOVWF  77
0203:  RLF    77,F
0204:  RLF    77,F
0205:  RLF    77,F
0206:  MOVLW  F8
0207:  ANDWF  77,F
0208:  MOVF   77,W
0209:  BSF    03.6
020A:  IORWF  49,F
....................     
....................    return(n); 
020B:  MOVF   49,W
020C:  MOVWF  78
....................   #else 
020D:  BCF    03.6
020E:  RETURN
....................    return(lcd.data); 
....................   #endif 
.................... } 
....................  
.................... void lcd_send_nibble(unsigned int8 n) 
.................... { 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    /* Write to the data port */ 
....................    output_bit(LCD_DATA4, bit_test(n, 0)); 
*
0184:  BSF    03.6
0185:  BTFSC  48.0
0186:  GOTO   18B
0187:  BCF    03.6
0188:  BCF    07.0
0189:  GOTO   18D
018A:  BSF    03.6
018B:  BCF    03.6
018C:  BSF    07.0
018D:  BCF    31.0
018E:  MOVF   31,W
018F:  BSF    03.5
0190:  MOVWF  07
....................    output_bit(LCD_DATA5, bit_test(n, 1)); 
0191:  BCF    03.5
0192:  BSF    03.6
0193:  BTFSC  48.1
0194:  GOTO   199
0195:  BCF    03.6
0196:  BCF    07.1
0197:  GOTO   19B
0198:  BSF    03.6
0199:  BCF    03.6
019A:  BSF    07.1
019B:  BCF    31.1
019C:  MOVF   31,W
019D:  BSF    03.5
019E:  MOVWF  07
....................    output_bit(LCD_DATA6, bit_test(n, 2)); 
019F:  BCF    03.5
01A0:  BSF    03.6
01A1:  BTFSC  48.2
01A2:  GOTO   1A7
01A3:  BCF    03.6
01A4:  BCF    07.2
01A5:  GOTO   1A9
01A6:  BSF    03.6
01A7:  BCF    03.6
01A8:  BSF    07.2
01A9:  BCF    31.2
01AA:  MOVF   31,W
01AB:  BSF    03.5
01AC:  MOVWF  07
....................    output_bit(LCD_DATA7, bit_test(n, 3)); 
01AD:  BCF    03.5
01AE:  BSF    03.6
01AF:  BTFSC  48.3
01B0:  GOTO   1B5
01B1:  BCF    03.6
01B2:  BCF    07.3
01B3:  GOTO   1B7
01B4:  BSF    03.6
01B5:  BCF    03.6
01B6:  BSF    07.3
01B7:  BCF    31.3
01B8:  MOVF   31,W
01B9:  BSF    03.5
01BA:  MOVWF  07
....................   #else       
....................    lcdlat.data = n; 
....................   #endif 
....................        
....................    delay_cycles(1); 
01BB:  NOP
....................    lcd_output_enable(1); 
01BC:  BCF    03.5
01BD:  BSF    09.0
01BE:  BSF    03.5
01BF:  BCF    09.0
....................    delay_us(2); 
01C0:  MOVLW  02
01C1:  MOVWF  77
01C2:  DECFSZ 77,F
01C3:  GOTO   1C2
01C4:  GOTO   1C5
01C5:  NOP
....................    lcd_output_enable(0); 
01C6:  BCF    03.5
01C7:  BCF    09.0
01C8:  BSF    03.5
01C9:  BCF    09.0
01CA:  BCF    03.5
01CB:  RETURN
.................... } 
....................  
.................... void lcd_send_byte(unsigned int8 address, unsigned int8 n) 
.................... { 
....................   #if defined(__PCB__) 
....................    set_tris_lcd(LCD_OUTPUT_MAP); 
....................   #else 
....................    lcd_enable_tris(); 
*
020F:  BSF    03.5
0210:  BCF    09.0
....................    lcd_rs_tris(); 
0211:  BCF    09.1
....................    lcd_rw_tris(); 
0212:  BCF    09.2
....................   #endif 
....................  
....................    lcd_output_rs(0); 
0213:  BCF    03.5
0214:  BCF    09.1
0215:  BSF    03.5
0216:  BCF    09.1
....................    while ( bit_test(lcd_read_byte(),7) ) ; 
*
025C:  MOVF   78,W
025D:  MOVWF  47
025E:  BTFSS  47.7
025F:  GOTO   263
0260:  BSF    03.5
0261:  BCF    03.6
0262:  GOTO   217
....................    lcd_output_rs(address); 
0263:  MOVF   45,F
0264:  BTFSS  03.2
0265:  GOTO   26A
0266:  BCF    03.6
0267:  BCF    09.1
0268:  GOTO   26C
0269:  BSF    03.6
026A:  BCF    03.6
026B:  BSF    09.1
026C:  BSF    03.5
026D:  BCF    09.1
....................    delay_cycles(1); 
026E:  NOP
....................    lcd_output_rw(0); 
026F:  BCF    03.5
0270:  BCF    09.2
0271:  BSF    03.5
0272:  BCF    09.2
....................    delay_cycles(1); 
0273:  NOP
....................    lcd_output_enable(0); 
0274:  BCF    03.5
0275:  BCF    09.0
0276:  BSF    03.5
0277:  BCF    09.0
....................    lcd_send_nibble(n >> 4); 
0278:  BCF    03.5
0279:  BSF    03.6
027A:  SWAPF  46,W
027B:  MOVWF  47
027C:  MOVLW  0F
027D:  ANDWF  47,F
027E:  MOVF   47,W
027F:  MOVWF  48
0280:  BCF    03.6
0281:  CALL   184
....................    lcd_send_nibble(n & 0xf); 
0282:  BSF    03.6
0283:  MOVF   46,W
0284:  ANDLW  0F
0285:  MOVWF  47
0286:  MOVWF  48
0287:  BCF    03.6
0288:  CALL   184
0289:  RETURN
.................... } 
....................  
.................... #if defined(LCD_EXTENDED_NEWLINE) 
.................... unsigned int8 g_LcdX, g_LcdY; 
.................... #endif 
....................  
.................... void lcd_init(void)  
.................... { 
....................    unsigned int8 i; 
....................    unsigned int8 LCD_INIT_STRING[4] = {0x20 | (LCD_TYPE << 2), 0xc, 1, 6}; 
028A:  MOVLW  28
028B:  BSF    03.6
028C:  MOVWF  11
028D:  MOVLW  0C
028E:  MOVWF  12
028F:  MOVLW  01
0290:  MOVWF  13
0291:  MOVLW  06
0292:  MOVWF  14
....................                              // These bytes need to be sent to the LCD 
....................                              // to start it up. 
....................     
....................  
....................    lcd_output_enable(0); 
0293:  BCF    03.6
0294:  BCF    09.0
0295:  BSF    03.5
0296:  BCF    09.0
....................    lcd_output_rs(0); 
0297:  BCF    03.5
0298:  BCF    09.1
0299:  BSF    03.5
029A:  BCF    09.1
....................    lcd_output_rw(0); 
029B:  BCF    03.5
029C:  BCF    09.2
029D:  BSF    03.5
029E:  BCF    09.2
....................  
....................  #if defined(__PCB__) 
....................    set_tris_lcd(LCD_OUTPUT_MAP); 
....................  #else 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    output_drive(LCD_DATA4); 
029F:  BCF    03.5
02A0:  BCF    31.0
02A1:  MOVF   31,W
02A2:  BSF    03.5
02A3:  MOVWF  07
....................    output_drive(LCD_DATA5); 
02A4:  BCF    03.5
02A5:  BCF    31.1
02A6:  MOVF   31,W
02A7:  BSF    03.5
02A8:  MOVWF  07
....................    output_drive(LCD_DATA6); 
02A9:  BCF    03.5
02AA:  BCF    31.2
02AB:  MOVF   31,W
02AC:  BSF    03.5
02AD:  MOVWF  07
....................    output_drive(LCD_DATA7); 
02AE:  BCF    03.5
02AF:  BCF    31.3
02B0:  MOVF   31,W
02B1:  BSF    03.5
02B2:  MOVWF  07
....................   #else 
....................    lcdtris.data = 0x0; 
....................   #endif 
....................    lcd_enable_tris(); 
02B3:  BCF    09.0
....................    lcd_rs_tris(); 
02B4:  BCF    09.1
....................    lcd_rw_tris(); 
02B5:  BCF    09.2
....................  #endif 
....................      
....................    delay_ms(15); 
02B6:  MOVLW  0F
02B7:  BCF    03.5
02B8:  BSF    03.6
02B9:  MOVWF  41
02BA:  BCF    03.6
02BB:  CALL   170
....................    for(i=1;i<=3;++i) 
02BC:  MOVLW  01
02BD:  BSF    03.6
02BE:  MOVWF  10
02BF:  MOVF   10,W
02C0:  SUBLW  03
02C1:  BTFSS  03.0
02C2:  GOTO   2CF
....................    { 
....................        lcd_send_nibble(3); 
02C3:  MOVLW  03
02C4:  MOVWF  48
02C5:  BCF    03.6
02C6:  CALL   184
....................        delay_ms(5); 
02C7:  MOVLW  05
02C8:  BSF    03.6
02C9:  MOVWF  41
02CA:  BCF    03.6
02CB:  CALL   170
02CC:  BSF    03.6
02CD:  INCF   10,F
02CE:  GOTO   2BF
....................    } 
....................     
....................    lcd_send_nibble(2); 
02CF:  MOVLW  02
02D0:  MOVWF  48
02D1:  BCF    03.6
02D2:  CALL   184
....................    delay_ms(5); 
02D3:  MOVLW  05
02D4:  BSF    03.6
02D5:  MOVWF  41
02D6:  BCF    03.6
02D7:  CALL   170
....................    for(i=0;i<=3;++i) 
02D8:  BSF    03.6
02D9:  CLRF   10
02DA:  MOVF   10,W
02DB:  SUBLW  03
02DC:  BTFSS  03.0
02DD:  GOTO   2EC
....................       lcd_send_byte(0,LCD_INIT_STRING[i]); 
02DE:  MOVLW  11
02DF:  ADDWF  10,W
02E0:  MOVWF  04
02E1:  BSF    03.7
02E2:  MOVF   00,W
02E3:  MOVWF  15
02E4:  CLRF   45
02E5:  MOVF   15,W
02E6:  MOVWF  46
02E7:  BCF    03.6
02E8:  CALL   20F
....................  
....................   #if defined(LCD_EXTENDED_NEWLINE) 
02E9:  BSF    03.6
02EA:  INCF   10,F
02EB:  GOTO   2DA
02EC:  BCF    03.6
02ED:  BCF    0A.3
02EE:  BSF    0A.4
02EF:  GOTO   347 (RETURN)
....................    g_LcdX = 0; 
....................    g_LcdY = 0; 
....................   #endif 
.................... } 
....................  
.................... void lcd_gotoxy(unsigned int8 x, unsigned int8 y) 
.................... { 
....................    unsigned int8 address; 
....................     
....................    if(y!=1) 
02F0:  BSF    03.6
02F1:  DECFSZ 42,W
02F2:  GOTO   2F4
02F3:  GOTO   2F7
....................       address=LCD_LINE_TWO; 
02F4:  MOVLW  40
02F5:  MOVWF  43
02F6:  GOTO   2F8
....................    else 
....................       address=0; 
02F7:  CLRF   43
....................       
....................    address+=x-1; 
02F8:  MOVLW  01
02F9:  SUBWF  41,W
02FA:  ADDWF  43,F
....................    lcd_send_byte(0,0x80|address); 
02FB:  MOVF   43,W
02FC:  IORLW  80
02FD:  MOVWF  44
02FE:  CLRF   45
02FF:  MOVF   44,W
0300:  MOVWF  46
0301:  BCF    03.6
0302:  CALL   20F
....................  
....................   #if defined(LCD_EXTENDED_NEWLINE) 
0303:  RETURN
....................    g_LcdX = x - 1; 
....................    g_LcdY = y - 1; 
....................   #endif 
.................... } 
....................  
.................... void lcd_putc(char c) 
.................... { 
....................    switch (c) 
0304:  BSF    03.6
0305:  MOVF   40,W
0306:  XORLW  07
0307:  BCF    03.6
0308:  BTFSC  03.2
0309:  GOTO   314
030A:  XORLW  0B
030B:  BTFSC  03.2
030C:  GOTO   31B
030D:  XORLW  06
030E:  BTFSC  03.2
030F:  GOTO   327
0310:  XORLW  02
0311:  BTFSC  03.2
0312:  GOTO   32F
0313:  GOTO   336
....................    { 
....................       case '\a'   :  lcd_gotoxy(1,1);     break; 
0314:  MOVLW  01
0315:  BSF    03.6
0316:  MOVWF  41
0317:  MOVWF  42
0318:  BCF    03.6
0319:  CALL   2F0
031A:  GOTO   33D
....................  
....................       case '\f'   :  lcd_send_byte(0,1); 
031B:  BSF    03.6
031C:  CLRF   45
031D:  MOVLW  01
031E:  MOVWF  46
031F:  BCF    03.6
0320:  CALL   20F
....................                      delay_ms(2); 
0321:  MOVLW  02
0322:  BSF    03.6
0323:  MOVWF  41
0324:  BCF    03.6
0325:  CALL   170
....................                     #if defined(LCD_EXTENDED_NEWLINE) 
....................                      g_LcdX = 0; 
....................                      g_LcdY = 0; 
....................                     #endif 
....................                      break; 
0326:  GOTO   33D
....................  
....................      #if defined(LCD_EXTENDED_NEWLINE) 
....................       case '\r'   :  lcd_gotoxy(1, g_LcdY+1);   break; 
....................       case '\n'   : 
....................          while (g_LcdX++ < LCD_LINE_LENGTH) 
....................          { 
....................             lcd_send_byte(1, ' '); 
....................          } 
....................          lcd_gotoxy(1, g_LcdY+2); 
....................          break; 
....................      #else 
....................       case '\n'   : lcd_gotoxy(1,2);        break; 
0327:  MOVLW  01
0328:  BSF    03.6
0329:  MOVWF  41
032A:  MOVLW  02
032B:  MOVWF  42
032C:  BCF    03.6
032D:  CALL   2F0
032E:  GOTO   33D
....................      #endif 
....................       
....................       case '\b'   : lcd_send_byte(0,0x10);  break; 
032F:  BSF    03.6
0330:  CLRF   45
0331:  MOVLW  10
0332:  MOVWF  46
0333:  BCF    03.6
0334:  CALL   20F
0335:  GOTO   33D
....................       
....................      #if defined(LCD_EXTENDED_NEWLINE) 
....................       default     :  
....................          if (g_LcdX < LCD_LINE_LENGTH) 
....................          { 
....................             lcd_send_byte(1, c); 
....................             g_LcdX++; 
....................          } 
....................          break; 
....................      #else 
....................       default     : lcd_send_byte(1,c);     break; 
0336:  MOVLW  01
0337:  BSF    03.6
0338:  MOVWF  45
0339:  MOVF   40,W
033A:  MOVWF  46
033B:  BCF    03.6
033C:  CALL   20F
....................      #endif 
....................    } 
033D:  RETURN
.................... } 
....................   
.................... char lcd_getc(unsigned int8 x, unsigned int8 y) 
.................... { 
....................    char value; 
....................  
....................    lcd_gotoxy(x,y); 
....................    while ( bit_test(lcd_read_byte(),7) ); // wait until busy flag is low 
....................    lcd_output_rs(1); 
....................    value = lcd_read_byte(); 
....................    lcd_output_rs(0); 
....................     
....................    return(value); 
.................... } 
....................  
.................... // write a custom character to the ram 
.................... // which is 0-7 and specifies which character array we are modifying. 
.................... // ptr points to an array of 8 bytes, where each byte is the next row of 
.................... //    pixels.  only bits 0-4 are used.  the last row is the cursor row, and 
.................... //    usually you will want to leave this byte 0x00. 
.................... void lcd_set_cgram_char(unsigned int8 which, unsigned int8 *ptr) 
.................... { 
....................    unsigned int i; 
....................  
....................    which <<= 3; 
....................    which &= 0x38; 
....................  
....................    lcd_send_byte(0, 0x40 | which);  //set cgram address 
....................  
....................    for(i=0; i<8; i++) 
....................    { 
....................       lcd_send_byte(1, *ptr++); 
....................    } 
....................    
....................    #if defined(LCD_EXTENDED_NEWLINE) 
....................     lcd_gotoxy(g_LcdX+1, g_LcdY+1);  //set ddram address 
....................    #endif 
.................... } 
....................  
.................... void lcd_cursor_on(int1 on) 
.................... { 
....................    if (on) 
....................    { 
....................       lcd_send_byte(0,0x0F);           //turn LCD cursor ON 
....................    } 
....................    else 
....................    { 
....................       lcd_send_byte(0,0x0C);           //turn LCD cursor OFF 
....................    } 
.................... } 
....................  
.................... #endif 
....................  
.................... #BIT TMR1IF = 0x0C.0 //bit thu 0 (TMR1IF) cua PIR1 
....................  
.................... #INCLUDE <khaibaobien.c> // VARIABLE. 
.................... UNSIGNED INT16 KQADC; 
.................... UNSIGNED INT8 KET_QUA_ANALOG[]={0,0,0,0}; 
*
12B2:  CLRF   34
12B3:  CLRF   35
12B4:  CLRF   36
12B5:  CLRF   37
.................... UNSIGNED INT8 CONFIG_FUN=0; 
.................... UNSIGNED INT8 VT=0, KYTU=0;// KYTU[30],  
.................... UNSIGNED INT8 LENH_DIEU_KHIEN = 0; 
.................... UNSIGNED INT8 ID_GATEWAY[6] = {3,8,6,9,0,7}; 
12B6:  MOVLW  03
12B7:  MOVWF  3C
12B8:  MOVLW  08
12B9:  MOVWF  3D
12BA:  MOVLW  06
12BB:  MOVWF  3E
12BC:  MOVLW  09
12BD:  MOVWF  3F
12BE:  CLRF   40
12BF:  MOVLW  07
12C0:  MOVWF  41
.................... UNSIGNED INT8 ID_NODE[4] = {0,1,5,2}; 
12C1:  CLRF   42
12C2:  MOVLW  01
12C3:  MOVWF  43
12C4:  MOVLW  05
12C5:  MOVWF  44
12C6:  MOVLW  02
12C7:  MOVWF  45
.................... UNSIGNED INT8 LEN_PACKAGES = 0; 
.................... UNSIGNED INT8 LENHDIEUKHIEN =0, DODAI_DATA_NHAN =0; 
.................... UNSIGNED INT8 SOLUONGTHIETBI_CONFIG=0, SOLUONGCAMBIEN_CONFIG = 3; 
.................... SIGNED INT8 SOSANH_IDNODE=0, SOSANH_IDGW=0; 
.................... //INT1 TT_THIETBI [8]={0,0,0,0,0,0,0,0}; 
.................... INT1 TT_THIETBI_TEMP [8]={0,0,0,0,0,0,0,0}; 
12C8:  CLRF   4D
.................... INT1 TTNHAN = 0, TT_CONFIG=0, TT_CONTROL=0,TT_CONFIG_DONE=0, TT_FUN=0, TT_STT=0 , TT_CONFIG_OKE_UART = 0, TT_SW = 0; 
....................  
.................... CHAR *ID_NODE_CHAR[]= "0589"; 
12C9:  MOVLW  30
12CA:  MOVWF  51
12CB:  MOVLW  35
12CC:  MOVWF  52
12CD:  MOVLW  38
12CE:  MOVWF  53
12CF:  MOVLW  39
12D0:  MOVWF  54
12D1:  CLRF   55
12D2:  CLRF   50
12D3:  MOVLW  51
12D4:  MOVWF  4F
.................... CHAR *ID_GATEWAY_CHAR[]= "127102"; 
12D5:  MOVLW  31
12D6:  MOVWF  58
12D7:  MOVLW  32
12D8:  MOVWF  59
12D9:  MOVLW  37
12DA:  MOVWF  5A
12DB:  MOVLW  31
12DC:  MOVWF  5B
12DD:  MOVLW  30
12DE:  MOVWF  5C
12DF:  MOVLW  32
12E0:  MOVWF  5D
12E1:  CLRF   5E
12E2:  CLRF   57
12E3:  MOVLW  58
12E4:  MOVWF  56
.................... CHAR *ID_NODE_NHAN[]= "0000"; 
12E5:  MOVLW  30
12E6:  MOVWF  61
12E7:  MOVWF  62
12E8:  MOVWF  63
12E9:  MOVWF  64
12EA:  CLRF   65
12EB:  CLRF   60
12EC:  MOVLW  61
12ED:  MOVWF  5F
.................... CHAR *ID_GW_NHAN[]= "000000"; 
12EE:  MOVLW  30
12EF:  MOVWF  68
12F0:  MOVWF  69
12F1:  MOVWF  6A
12F2:  MOVWF  6B
12F3:  MOVWF  6C
12F4:  MOVWF  6D
12F5:  CLRF   6E
12F6:  CLRF   67
12F7:  MOVLW  68
12F8:  MOVWF  66
.................... CHAR KYTUCHAR[50]="HIHI"; 
12F9:  MOVLW  48
12FA:  BSF    03.5
12FB:  MOVWF  20
12FC:  MOVLW  49
12FD:  MOVWF  21
12FE:  MOVLW  48
12FF:  MOVWF  22
1300:  MOVLW  49
1301:  MOVWF  23
1302:  CLRF   24
.................... CHAR KYTUCHAR2[25]="HIHI"; 
1303:  MOVLW  48
1304:  MOVWF  52
1305:  MOVLW  49
1306:  MOVWF  53
1307:  MOVLW  48
1308:  MOVWF  54
1309:  MOVLW  49
130A:  MOVWF  55
130B:  CLRF   56
.................... //CHAR *DATA_NHANDUOC[]={"IDGW","IDNODE","COMMAN","DATA"}; 
.................... CHAR *TEMP_CHAR[]="0000";   
130C:  MOVLW  30
130D:  MOVWF  71
130E:  MOVWF  72
130F:  MOVWF  73
1310:  MOVWF  74
1311:  CLRF   75
1312:  CLRF   70
1313:  MOVLW  71
1314:  BCF    03.5
1315:  MOVWF  6F
.................... CHAR *TEMP_CHAR2[]="2700";  
1316:  MOVLW  32
1317:  BSF    03.5
1318:  MOVWF  6B
1319:  MOVLW  37
131A:  MOVWF  6C
131B:  MOVLW  30
131C:  MOVWF  6D
131D:  MOVWF  6E
131E:  CLRF   6F
131F:  CLRF   7C
1320:  MOVLW  EB
1321:  MOVWF  7B
.................... //CHAR *TEMP_CHAR3[]="000000";  
....................  
....................  
....................  
.................... //#INCLUDE <CONFIG_NODE.C> // CU HINH NODE. 
.................... #INCLUDE <config_1.C> // CU HINH NODE. 
....................  
.................... //--------------------------------------------------------------------// 
.................... VOID CHON_ID() 
.................... { 
....................    // TT_CONFIG_DONE; 
....................    TT_CONFIG_DONE = 0; 
*
05D7:  BCF    4E.3
....................    TT_STT = 1; 
05D8:  BSF    4E.5
....................    UNSIGNED INT8 NUM = 0; 
05D9:  BSF    03.6
05DA:  CLRF   10
....................    TEMP_CHAR = "0"; 
05DB:  CLRF   11
05DC:  CLRF   12
05DD:  MOVLW  6F
05DE:  MOVWF  04
05DF:  BCF    03.7
05E0:  MOVF   11,W
05E1:  ADDWF  04,F
05E2:  MOVF   12,W
05E3:  BCF    03.6
05E4:  CALL   058
05E5:  MOVWF  00
05E6:  IORLW  00
05E7:  BTFSC  03.2
05E8:  GOTO   5EE
05E9:  BSF    03.6
05EA:  INCF   12,F
05EB:  INCF   11,F
05EC:  GOTO   5DD
05ED:  BCF    03.6
....................    LCD_GOTOXY (1, 2) ; 
05EE:  MOVLW  01
05EF:  BSF    03.6
05F0:  MOVWF  41
05F1:  MOVLW  02
05F2:  MOVWF  42
05F3:  BCF    03.6
05F4:  CALL   2F0
....................    DELAY_MS (10); 
05F5:  MOVLW  0A
05F6:  BSF    03.6
05F7:  MOVWF  41
05F8:  BCF    03.6
05F9:  CALL   170
....................    PRINTF (LCD_PUTC, "NODE: "); 
05FA:  MOVLW  84
05FB:  BSF    03.6
05FC:  MOVWF  0D
05FD:  MOVLW  00
05FE:  MOVWF  0F
05FF:  BCF    03.6
0600:  CALL   33E
....................    PRINTF (LCD_PUTC, "0000          "); 
0601:  MOVLW  88
0602:  BSF    03.6
0603:  MOVWF  0D
0604:  MOVLW  00
0605:  MOVWF  0F
0606:  BCF    03.6
0607:  CALL   33E
....................    LCD_GOTOXY (1, 1) ; 
0608:  MOVLW  01
0609:  BSF    03.6
060A:  MOVWF  41
060B:  MOVWF  42
060C:  BCF    03.6
060D:  CALL   2F0
....................    PRINTF (LCD_PUTC, "      _              ");//6 SPACE PHIA TRUOC "_" 
060E:  MOVLW  90
060F:  BSF    03.6
0610:  MOVWF  0D
0611:  MOVLW  00
0612:  MOVWF  0F
0613:  BCF    03.6
0614:  CALL   33E
....................    //ID_GW = "1234";     
....................  
....................    WHILE (TT_STT) 
0615:  BTFSS  4E.5
0616:  GOTO   693
....................    { 
....................       IF (!INPUT (BT2_PIN)) //NEU NUT BAM DUOC BAM 
0617:  BSF    03.5
0618:  BSF    06.2
0619:  BCF    03.5
061A:  BTFSC  06.2
061B:  GOTO   63A
....................       { 
....................           
....................          NUM++; 
061C:  BSF    03.6
061D:  INCF   10,F
....................          NUM = NUM % 4; 
061E:  MOVLW  03
061F:  ANDWF  10,F
....................          LCD_GOTOXY (3 + NUM, 1); 
0620:  ADDWF  10,W
0621:  MOVWF  11
0622:  MOVWF  41
0623:  MOVLW  01
0624:  MOVWF  42
0625:  BCF    03.6
0626:  CALL   2F0
....................          PRINTF (LCD_PUTC, "    _    ");//4SPACE 
0627:  MOVLW  9B
0628:  BSF    03.6
0629:  MOVWF  0D
062A:  MOVLW  00
062B:  MOVWF  0F
062C:  BCF    03.6
062D:  CALL   33E
....................          DELAY_MS (300);  
062E:  MOVLW  02
062F:  BSF    03.6
0630:  MOVWF  11
0631:  MOVLW  96
0632:  MOVWF  41
0633:  BCF    03.6
0634:  CALL   170
0635:  BSF    03.6
0636:  DECFSZ 11,F
0637:  GOTO   631
....................       } 
0638:  GOTO   691
0639:  BCF    03.6
....................  
....................       ELSE IF (!INPUT (BT3_PIN)) 
063A:  BSF    03.5
063B:  BSF    06.3
063C:  BCF    03.5
063D:  BTFSC  06.3
063E:  GOTO   692
....................       { 
....................          ID_NODE[NUM]++; 
063F:  MOVLW  42
0640:  BSF    03.6
0641:  ADDWF  10,W
0642:  MOVWF  04
0643:  BCF    03.7
0644:  INCF   00,F
....................          ID_NODE[NUM] = ID_NODE[NUM] % 10; 
0645:  MOVLW  42
0646:  ADDWF  10,W
0647:  MOVWF  78
0648:  CLRF   7A
0649:  BTFSC  03.0
064A:  INCF   7A,F
064B:  MOVF   78,W
064C:  MOVWF  11
064D:  MOVF   7A,W
064E:  MOVWF  12
064F:  MOVLW  42
0650:  ADDWF  10,W
0651:  MOVWF  04
0652:  BCF    03.7
0653:  MOVF   00,W
0654:  MOVWF  14
0655:  MOVLW  0A
0656:  MOVWF  15
0657:  BCF    03.6
0658:  CALL   547
0659:  MOVF   77,W
065A:  BSF    03.6
065B:  MOVWF  13
065C:  MOVF   11,W
065D:  MOVWF  04
065E:  BCF    03.7
065F:  BTFSC  12.0
0660:  BSF    03.7
0661:  MOVF   13,W
0662:  MOVWF  00
....................          ITOA (ID_NODE[NUM], 10, TEMP_CHAR); 
0663:  MOVLW  42
0664:  ADDWF  10,W
0665:  MOVWF  04
0666:  BCF    03.7
0667:  MOVF   00,W
0668:  MOVWF  11
0669:  CLRF   42
066A:  CLRF   41
066B:  CLRF   40
066C:  MOVF   11,W
066D:  MOVWF  3F
066E:  MOVLW  0A
066F:  MOVWF  43
0670:  CLRF   45
0671:  MOVLW  6F
0672:  MOVWF  44
0673:  BCF    03.6
0674:  CALL   40A
....................          LCD_GOTOXY (7 + NUM, 2); 
0675:  MOVLW  07
0676:  BSF    03.6
0677:  ADDWF  10,W
0678:  MOVWF  11
0679:  MOVWF  41
067A:  MOVLW  02
067B:  MOVWF  42
067C:  BCF    03.6
067D:  CALL   2F0
....................          DELAY_MS (10); 
067E:  MOVLW  0A
067F:  BSF    03.6
0680:  MOVWF  41
0681:  BCF    03.6
0682:  CALL   170
....................          PRINTF (LCD_PUTC, TEMP_CHAR); 
0683:  MOVLW  6F
0684:  MOVWF  04
0685:  BCF    03.7
0686:  CALL   52A
....................          DELAY_MS (300); 
0687:  MOVLW  02
0688:  BSF    03.6
0689:  MOVWF  11
068A:  MOVLW  96
068B:  MOVWF  41
068C:  BCF    03.6
068D:  CALL   170
068E:  BSF    03.6
068F:  DECFSZ 11,F
0690:  GOTO   68A
0691:  BCF    03.6
....................       } 
0692:  GOTO   615
....................    } 
.................... } 
....................  
.................... VOID NHAPID_GW() 
*
0694:  BSF    03.6
0695:  CLRF   10
.................... { 
....................    UNSIGNED INT8 NUM = 0; 
....................    TEMP_CHAR = "0"; 
0696:  CLRF   11
0697:  CLRF   12
0698:  MOVLW  6F
0699:  MOVWF  04
069A:  BCF    03.7
069B:  MOVF   11,W
069C:  ADDWF  04,F
069D:  MOVF   12,W
069E:  BCF    03.6
069F:  CALL   058
06A0:  MOVWF  00
06A1:  IORLW  00
06A2:  BTFSC  03.2
06A3:  GOTO   6A9
06A4:  BSF    03.6
06A5:  INCF   12,F
06A6:  INCF   11,F
06A7:  GOTO   698
06A8:  BCF    03.6
....................    TT_CONFIG_DONE = 0; 
06A9:  BCF    4E.3
....................    TT_STT = 1; 
06AA:  BSF    4E.5
....................    LCD_GOTOXY (1, 2) ; 
06AB:  MOVLW  01
06AC:  BSF    03.6
06AD:  MOVWF  41
06AE:  MOVLW  02
06AF:  MOVWF  42
06B0:  BCF    03.6
06B1:  CALL   2F0
....................    DELAY_MS (10); 
06B2:  MOVLW  0A
06B3:  BSF    03.6
06B4:  MOVWF  41
06B5:  BCF    03.6
06B6:  CALL   170
....................    PRINTF (LCD_PUTC, "ID_GW:"); 
06B7:  MOVLW  A0
06B8:  BSF    03.6
06B9:  MOVWF  0D
06BA:  MOVLW  00
06BB:  MOVWF  0F
06BC:  BCF    03.6
06BD:  CALL   33E
....................    PRINTF (LCD_PUTC, "000000        "); 
06BE:  MOVLW  A4
06BF:  BSF    03.6
06C0:  MOVWF  0D
06C1:  MOVLW  00
06C2:  MOVWF  0F
06C3:  BCF    03.6
06C4:  CALL   33E
....................    LCD_GOTOXY (1, 1) ; 
06C5:  MOVLW  01
06C6:  BSF    03.6
06C7:  MOVWF  41
06C8:  MOVWF  42
06C9:  BCF    03.6
06CA:  CALL   2F0
....................    PRINTF (LCD_PUTC, "      _                ");//6 SPACE PHIA TRUOC "_" 
06CB:  MOVLW  AC
06CC:  BSF    03.6
06CD:  MOVWF  0D
06CE:  MOVLW  00
06CF:  MOVWF  0F
06D0:  BCF    03.6
06D1:  CALL   33E
....................    //ID_GW = "1234";     
....................  
....................    WHILE (TT_STT) 
06D2:  BTFSS  4E.5
06D3:  GOTO   758
....................    { 
....................       IF (!INPUT (BT2_PIN)) //NEU NUT BAM DUOC BAM 
06D4:  BSF    03.5
06D5:  BSF    06.2
06D6:  BCF    03.5
06D7:  BTFSC  06.2
06D8:  GOTO   6FF
....................       { 
....................           
....................          NUM++; 
06D9:  BSF    03.6
06DA:  INCF   10,F
....................          NUM = NUM % 6; 
06DB:  MOVF   10,W
06DC:  MOVWF  14
06DD:  MOVLW  06
06DE:  MOVWF  15
06DF:  BCF    03.6
06E0:  CALL   547
06E1:  MOVF   77,W
06E2:  BSF    03.6
06E3:  MOVWF  10
....................          LCD_GOTOXY (3 + NUM, 1); 
06E4:  MOVLW  03
06E5:  ADDWF  10,W
06E6:  MOVWF  11
06E7:  MOVWF  41
06E8:  MOVLW  01
06E9:  MOVWF  42
06EA:  BCF    03.6
06EB:  CALL   2F0
....................          PRINTF (LCD_PUTC, "    _        ");//4SPACE 
06EC:  MOVLW  B8
06ED:  BSF    03.6
06EE:  MOVWF  0D
06EF:  MOVLW  00
06F0:  MOVWF  0F
06F1:  BCF    03.6
06F2:  CALL   33E
....................          DELAY_MS (300);  
06F3:  MOVLW  02
06F4:  BSF    03.6
06F5:  MOVWF  11
06F6:  MOVLW  96
06F7:  MOVWF  41
06F8:  BCF    03.6
06F9:  CALL   170
06FA:  BSF    03.6
06FB:  DECFSZ 11,F
06FC:  GOTO   6F6
....................       } 
06FD:  GOTO   756
06FE:  BCF    03.6
....................  
....................       ELSE IF (!INPUT (BT3_PIN)) 
06FF:  BSF    03.5
0700:  BSF    06.3
0701:  BCF    03.5
0702:  BTFSC  06.3
0703:  GOTO   757
....................       { 
....................          ID_GATEWAY[NUM]++; 
0704:  MOVLW  3C
0705:  BSF    03.6
0706:  ADDWF  10,W
0707:  MOVWF  04
0708:  BCF    03.7
0709:  INCF   00,F
....................          ID_GATEWAY[NUM] = ID_GATEWAY[NUM] % 10; 
070A:  MOVLW  3C
070B:  ADDWF  10,W
070C:  MOVWF  78
070D:  CLRF   7A
070E:  BTFSC  03.0
070F:  INCF   7A,F
0710:  MOVF   78,W
0711:  MOVWF  11
0712:  MOVF   7A,W
0713:  MOVWF  12
0714:  MOVLW  3C
0715:  ADDWF  10,W
0716:  MOVWF  04
0717:  BCF    03.7
0718:  MOVF   00,W
0719:  MOVWF  14
071A:  MOVLW  0A
071B:  MOVWF  15
071C:  BCF    03.6
071D:  CALL   547
071E:  MOVF   77,W
071F:  BSF    03.6
0720:  MOVWF  13
0721:  MOVF   11,W
0722:  MOVWF  04
0723:  BCF    03.7
0724:  BTFSC  12.0
0725:  BSF    03.7
0726:  MOVF   13,W
0727:  MOVWF  00
....................          ITOA (ID_GATEWAY[NUM], 10, TEMP_CHAR); 
0728:  MOVLW  3C
0729:  ADDWF  10,W
072A:  MOVWF  04
072B:  BCF    03.7
072C:  MOVF   00,W
072D:  MOVWF  11
072E:  CLRF   42
072F:  CLRF   41
0730:  CLRF   40
0731:  MOVF   11,W
0732:  MOVWF  3F
0733:  MOVLW  0A
0734:  MOVWF  43
0735:  CLRF   45
0736:  MOVLW  6F
0737:  MOVWF  44
0738:  BCF    03.6
0739:  CALL   40A
....................          LCD_GOTOXY (7 + NUM, 2); 
073A:  MOVLW  07
073B:  BSF    03.6
073C:  ADDWF  10,W
073D:  MOVWF  11
073E:  MOVWF  41
073F:  MOVLW  02
0740:  MOVWF  42
0741:  BCF    03.6
0742:  CALL   2F0
....................          DELAY_MS (10); 
0743:  MOVLW  0A
0744:  BSF    03.6
0745:  MOVWF  41
0746:  BCF    03.6
0747:  CALL   170
....................          PRINTF (LCD_PUTC, TEMP_CHAR); 
0748:  MOVLW  6F
0749:  MOVWF  04
074A:  BCF    03.7
074B:  CALL   52A
....................          DELAY_MS (300); 
074C:  MOVLW  02
074D:  BSF    03.6
074E:  MOVWF  11
074F:  MOVLW  96
0750:  MOVWF  41
0751:  BCF    03.6
0752:  CALL   170
0753:  BSF    03.6
0754:  DECFSZ 11,F
0755:  GOTO   74F
0756:  BCF    03.6
....................       } 
0757:  GOTO   6D2
....................    } 
.................... } 
....................  
.................... VOID BUTT_OKE() 
.................... { 
....................    TT_CONFIG_DONE = 0; 
*
0140:  BCF    03.6
0141:  BCF    4E.3
....................    TT_FUN = 0;//BREAK WHILE BUTT_FUN 
0142:  BCF    4E.4
....................    TT_STT = 0;// BREAK WHILE CHONID/NHAPID_GW 
0143:  BCF    4E.5
.................... } 
....................  
.................... VOID SELLECT_FUN() 
.................... { 
....................    TT_CONFIG_DONE = 0; 
*
05CF:  BCF    4E.3
....................  
....................    SWITCH (CONFIG_FUN) 
05D0:  MOVF   38,W
05D1:  BTFSC  03.2
05D2:  GOTO   5D7
05D3:  XORLW  01
05D4:  BTFSC  03.2
05D5:  GOTO   694
05D6:  GOTO   758
....................    { 
....................       CASE 0: 
....................       CHON_ID (); 
....................       BREAK; 
*
0693:  GOTO   758
....................  
....................       CASE 1:     
....................       NHAPID_GW (); 
....................       BREAK; 
....................    } 
.................... } 
....................  
.................... VOID BUTT_FUN() 
.................... { 
....................    TT_FUN = 1; 
*
055E:  BSF    4E.4
....................    LCD_GOTOXY (1, 1) ; 
055F:  MOVLW  01
0560:  BSF    03.6
0561:  MOVWF  41
0562:  MOVWF  42
0563:  BCF    03.6
0564:  CALL   2F0
....................    DELAY_MS (10); 
0565:  MOVLW  0A
0566:  BSF    03.6
0567:  MOVWF  41
0568:  BCF    03.6
0569:  CALL   170
....................    PRINTF (LCD_PUTC, "CONFIG:        "); 
056A:  MOVLW  BF
056B:  BSF    03.6
056C:  MOVWF  0D
056D:  MOVLW  00
056E:  MOVWF  0F
056F:  BCF    03.6
0570:  CALL   33E
....................  
....................    // HIEN THI LCD 
....................    LCD_GOTOXY (1, 2) ; 
0571:  MOVLW  01
0572:  BSF    03.6
0573:  MOVWF  41
0574:  MOVLW  02
0575:  MOVWF  42
0576:  BCF    03.6
0577:  CALL   2F0
....................    DELAY_MS (10); 
0578:  MOVLW  0A
0579:  BSF    03.6
057A:  MOVWF  41
057B:  BCF    03.6
057C:  CALL   170
....................    PRINTF (LCD_PUTC, "CASE:          ") ; 
057D:  MOVLW  C7
057E:  BSF    03.6
057F:  MOVWF  0D
0580:  MOVLW  00
0581:  MOVWF  0F
0582:  BCF    03.6
0583:  CALL   33E
....................  
....................    WHILE (TT_FUN) 
0584:  BTFSS  4E.4
0585:  GOTO   5CD
....................    { 
....................       IF (INPUT (BT2_PIN) == 0) //NEU NUT BAM DUOC BAM 
0586:  BSF    03.5
0587:  BSF    06.2
0588:  BCF    03.5
0589:  BTFSC  06.2
058A:  GOTO   5CC
....................       { 
....................          CONFIG_FUN ++; 
058B:  INCF   38,F
....................          CONFIG_FUN = CONFIG_FUN % 2; 
058C:  MOVLW  01
058D:  ANDWF  38,F
....................          DELAY_MS (300); 
058E:  MOVLW  02
058F:  BSF    03.6
0590:  MOVWF  10
0591:  MOVLW  96
0592:  MOVWF  41
0593:  BCF    03.6
0594:  CALL   170
0595:  BSF    03.6
0596:  DECFSZ 10,F
0597:  GOTO   591
....................          //HIEN THI 
....................          LCD_GOTOXY (6, 2) ; 
0598:  MOVLW  06
0599:  MOVWF  41
059A:  MOVLW  02
059B:  MOVWF  42
059C:  BCF    03.6
059D:  CALL   2F0
....................          ITOA (CONFIG_FUN, 10, TEMP_CHAR); 
059E:  BSF    03.6
059F:  CLRF   42
05A0:  CLRF   41
05A1:  CLRF   40
05A2:  BCF    03.6
05A3:  MOVF   38,W
05A4:  BSF    03.6
05A5:  MOVWF  3F
05A6:  MOVLW  0A
05A7:  MOVWF  43
05A8:  CLRF   45
05A9:  MOVLW  6F
05AA:  MOVWF  44
05AB:  BCF    03.6
05AC:  CALL   40A
....................          DELAY_MS (10); 
05AD:  MOVLW  0A
05AE:  BSF    03.6
05AF:  MOVWF  41
05B0:  BCF    03.6
05B1:  CALL   170
....................          PRINTF (LCD_PUTC, TEMP_CHAR); 
05B2:  MOVLW  6F
05B3:  MOVWF  04
05B4:  BCF    03.7
05B5:  CALL   52A
....................  
....................          SWITCH (CONFIG_FUN) 
05B6:  MOVF   38,W
05B7:  BTFSC  03.2
05B8:  GOTO   5BD
05B9:  XORLW  01
05BA:  BTFSC  03.2
05BB:  GOTO   5C5
05BC:  GOTO   5CC
....................          { 
....................             CASE 0: 
....................             PRINTF (LCD_PUTC, " - ID-NODE      "); 
05BD:  MOVLW  CF
05BE:  BSF    03.6
05BF:  MOVWF  0D
05C0:  MOVLW  00
05C1:  MOVWF  0F
05C2:  BCF    03.6
05C3:  CALL   33E
....................             BREAK; 
05C4:  GOTO   5CC
....................  
....................             CASE 1: 
....................             PRINTF (LCD_PUTC, " - ID-GW       "); 
05C5:  MOVLW  D8
05C6:  BSF    03.6
05C7:  MOVWF  0D
05C8:  MOVLW  00
05C9:  MOVWF  0F
05CA:  BCF    03.6
05CB:  CALL   33E
....................             BREAK;             
....................          } 
....................       } 
05CC:  GOTO   584
....................    } 
....................  
....................    ////// 
....................    IF (!TT_CONFIG_DONE) 
05CD:  BTFSC  4E.3
05CE:  GOTO   758
....................    { 
....................       SELLECT_FUN (); 
....................    } 
*
0758:  BCF    0A.3
0759:  BSF    0A.4
075A:  GOTO   354 (RETURN)
.................... } 
.................... VOID XULY_IDNODE_NHAP(){ 
....................    //*TEMP_CHAR3 = "\0"; 
....................    *ID_NODE_CHAR = "\0"; 
*
0891:  CLRF   7A
0892:  MOVLW  4F
0893:  MOVWF  3E
0894:  MOVF   7A,W
0895:  MOVWF  3F
0896:  MOVF   3E,W
0897:  MOVWF  04
0898:  BCF    03.7
0899:  BTFSC  3F.0
089A:  BSF    03.7
089B:  CLRF   00
....................    FOR (int j = 0; j < 4; j++) 
089C:  CLRF   3D
089D:  MOVF   3D,W
089E:  SUBLW  03
089F:  BTFSS  03.0
08A0:  GOTO   0CA
....................    { 
....................       ITOA (ID_NODE[j], 10, TEMP_CHAR); 
08A1:  MOVLW  42
08A2:  ADDWF  3D,W
08A3:  MOVWF  04
08A4:  BCF    03.7
08A5:  MOVF   00,W
08A6:  MOVWF  3E
08A7:  CLRF   42
08A8:  CLRF   41
08A9:  CLRF   40
08AA:  MOVF   3E,W
08AB:  MOVWF  3F
08AC:  MOVLW  0A
08AD:  MOVWF  43
08AE:  CLRF   45
08AF:  MOVLW  6F
08B0:  MOVWF  44
08B1:  BCF    0A.3
08B2:  BCF    03.6
08B3:  CALL   40A
08B4:  BSF    0A.3
....................       DELAY_MS (1); 
08B5:  MOVLW  01
08B6:  BSF    03.6
08B7:  MOVWF  41
08B8:  BCF    0A.3
08B9:  BCF    03.6
08BA:  CALL   170
08BB:  BSF    0A.3
....................       STRCAT (ID_NODE_CHAR, TEMP_CHAR); 
08BC:  BSF    03.6
08BD:  CLRF   3F
08BE:  MOVLW  4F
08BF:  MOVWF  3E
08C0:  CLRF   41
08C1:  MOVLW  6F
08C2:  MOVWF  40
08C3:  BCF    0A.3
08C4:  BCF    03.6
08C5:  CALL   75B
08C6:  BSF    0A.3
08C7:  BSF    03.6
08C8:  INCF   3D,F
08C9:  GOTO   09D
....................    }   
....................    //ID_NODE_CHAR = TEMP_CHAR3;    
....................    //STRCPY(ID_NODE_CHAR,TEMP_CHAR3); 
....................    //strcpy 
.................... } 
.................... VOID XULY_IDGW_NHAP(){ 
....................  
....................    *ID_GATEWAY_CHAR = "\0"; 
*
0855:  CLRF   7A
0856:  MOVLW  56
0857:  MOVWF  3E
0858:  MOVF   7A,W
0859:  MOVWF  3F
085A:  MOVF   3E,W
085B:  MOVWF  04
085C:  BCF    03.7
085D:  BTFSC  3F.0
085E:  BSF    03.7
085F:  CLRF   00
....................    FOR (int j = 0; j < 6; j++) 
0860:  CLRF   3D
0861:  MOVF   3D,W
0862:  SUBLW  05
0863:  BTFSS  03.0
0864:  GOTO   08E
....................    { 
....................       ITOA (ID_GATEWAY[j], 10, TEMP_CHAR); 
0865:  MOVLW  3C
0866:  ADDWF  3D,W
0867:  MOVWF  04
0868:  BCF    03.7
0869:  MOVF   00,W
086A:  MOVWF  3E
086B:  CLRF   42
086C:  CLRF   41
086D:  CLRF   40
086E:  MOVF   3E,W
086F:  MOVWF  3F
0870:  MOVLW  0A
0871:  MOVWF  43
0872:  CLRF   45
0873:  MOVLW  6F
0874:  MOVWF  44
0875:  BCF    0A.3
0876:  BCF    03.6
0877:  CALL   40A
0878:  BSF    0A.3
....................       DELAY_MS (1); 
0879:  MOVLW  01
087A:  BSF    03.6
087B:  MOVWF  41
087C:  BCF    0A.3
087D:  BCF    03.6
087E:  CALL   170
087F:  BSF    0A.3
....................       STRCAT (ID_GATEWAY_CHAR, TEMP_CHAR); 
0880:  BSF    03.6
0881:  CLRF   3F
0882:  MOVLW  56
0883:  MOVWF  3E
0884:  CLRF   41
0885:  MOVLW  6F
0886:  MOVWF  40
0887:  BCF    0A.3
0888:  BCF    03.6
0889:  CALL   75B
088A:  BSF    0A.3
088B:  BSF    03.6
088C:  INCF   3D,F
088D:  GOTO   061
....................    }   
.................... } 
....................  
....................  
.................... VOID CONFIG_DONE() 
.................... { 
....................    TT_FUN = 0; 
*
0800:  BCF    4E.4
....................    TT_STT = 0; 
0801:  BCF    4E.5
....................    CHAR *PACKAGE_CONFIG[]={"*", "LENGHT","CF", "ID_GW1234" ,"ID_NODE","#"}; 
0802:  MOVLW  2A
0803:  BSF    03.6
0804:  MOVWF  1C
0805:  CLRF   1D
0806:  MOVLW  4C
0807:  MOVWF  1E
0808:  MOVLW  45
0809:  MOVWF  1F
080A:  MOVLW  4E
080B:  MOVWF  20
080C:  MOVLW  47
080D:  MOVWF  21
080E:  MOVLW  48
080F:  MOVWF  22
0810:  MOVLW  54
0811:  MOVWF  23
0812:  CLRF   24
0813:  MOVLW  43
0814:  MOVWF  25
0815:  MOVLW  46
0816:  MOVWF  26
0817:  CLRF   27
0818:  MOVLW  49
0819:  MOVWF  28
081A:  MOVLW  44
081B:  MOVWF  29
081C:  MOVLW  5F
081D:  MOVWF  2A
081E:  MOVLW  47
081F:  MOVWF  2B
0820:  MOVLW  57
0821:  MOVWF  2C
0822:  MOVLW  31
0823:  MOVWF  2D
0824:  MOVLW  32
0825:  MOVWF  2E
0826:  MOVLW  33
0827:  MOVWF  2F
0828:  MOVLW  34
0829:  MOVWF  30
082A:  CLRF   31
082B:  MOVLW  49
082C:  MOVWF  32
082D:  MOVLW  44
082E:  MOVWF  33
082F:  MOVLW  5F
0830:  MOVWF  34
0831:  MOVLW  4E
0832:  MOVWF  35
0833:  MOVLW  4F
0834:  MOVWF  36
0835:  MOVLW  44
0836:  MOVWF  37
0837:  MOVLW  45
0838:  MOVWF  38
0839:  CLRF   39
083A:  MOVLW  23
083B:  MOVWF  3A
083C:  CLRF   3B
083D:  MOVLW  01
083E:  MOVWF  11
083F:  MOVLW  1C
0840:  MOVWF  10
0841:  MOVLW  01
0842:  MOVWF  13
0843:  MOVLW  1E
0844:  MOVWF  12
0845:  MOVLW  01
0846:  MOVWF  15
0847:  MOVLW  25
0848:  MOVWF  14
0849:  MOVLW  01
084A:  MOVWF  17
084B:  MOVLW  28
084C:  MOVWF  16
084D:  MOVLW  01
084E:  MOVWF  19
084F:  MOVLW  32
0850:  MOVWF  18
0851:  MOVLW  01
0852:  MOVWF  1B
0853:  MOVLW  3A
0854:  MOVWF  1A
....................    XULY_IDGW_NHAP(); 
....................    PACKAGE_CONFIG[3] = ID_GATEWAY_CHAR; 
*
088E:  CLRF   17
088F:  MOVLW  56
0890:  MOVWF  16
....................     
....................     
....................    XULY_IDNODE_NHAP(); 
....................  
....................    PACKAGE_CONFIG[4] = ID_NODE_CHAR;     
*
08CA:  CLRF   19
08CB:  MOVLW  4F
08CC:  MOVWF  18
....................       /*     
....................    LEN_PACKAGES = 0; 
....................    PACKAGE_CONFIG[1] = "12"; //DO DAI CUA LENGHT CO DO DAI = 2 
....................    FOR (int J = 0; J < 5; J++) 
....................    { 
....................       LEN_PACKAGES += strlen(PACKAGE_CONFIG[J]); 
....................    }    
....................    */ 
....................    LEN_PACKAGES = 20; //5 @ 
08CD:  MOVLW  14
08CE:  BCF    03.6
08CF:  MOVWF  46
....................    ITOA (LEN_PACKAGES, 10, TEMP_CHAR); 
08D0:  BSF    03.6
08D1:  CLRF   42
08D2:  CLRF   41
08D3:  CLRF   40
08D4:  BCF    03.6
08D5:  MOVF   46,W
08D6:  BSF    03.6
08D7:  MOVWF  3F
08D8:  MOVLW  0A
08D9:  MOVWF  43
08DA:  CLRF   45
08DB:  MOVLW  6F
08DC:  MOVWF  44
08DD:  BCF    0A.3
08DE:  BCF    03.6
08DF:  CALL   40A
08E0:  BSF    0A.3
....................     
....................    PACKAGE_CONFIG[1] = TEMP_CHAR; 
08E1:  BSF    03.6
08E2:  CLRF   13
08E3:  MOVLW  6F
08E4:  MOVWF  12
....................     
....................    FOR (INT J = 0; J < 6; J++) 
08E5:  CLRF   3C
08E6:  MOVF   3C,W
08E7:  SUBLW  05
08E8:  BTFSS  03.0
08E9:  GOTO   104
....................    { 
....................       PRINTF (PACKAGE_CONFIG[J]); 
08EA:  BCF    03.0
08EB:  RLF    3C,W
08EC:  ADDLW  10
08ED:  MOVWF  04
08EE:  BSF    03.7
08EF:  INCF   04,F
08F0:  MOVF   00,W
08F1:  MOVWF  3E
08F2:  DECF   04,F
08F3:  MOVF   00,W
08F4:  MOVWF  3D
08F5:  MOVWF  04
08F6:  BCF    03.7
08F7:  BTFSC  3E.0
08F8:  BSF    03.7
08F9:  BCF    0A.3
08FA:  BCF    03.6
08FB:  CALL   799
08FC:  BSF    0A.3
....................       PRINTF ("@"); 
08FD:  MOVLW  40
08FE:  BTFSS  0C.4
08FF:  GOTO   0FE
0900:  MOVWF  19
0901:  BSF    03.6
0902:  INCF   3C,F
0903:  GOTO   0E6
....................    } 
....................  
....................  
....................    LCD_GOTOXY (1, 1) ; 
0904:  MOVLW  01
0905:  MOVWF  41
0906:  MOVWF  42
0907:  BCF    0A.3
0908:  BCF    03.6
0909:  CALL   2F0
090A:  BSF    0A.3
....................    DELAY_MS (10); 
090B:  MOVLW  0A
090C:  BSF    03.6
090D:  MOVWF  41
090E:  BCF    0A.3
090F:  BCF    03.6
0910:  CALL   170
0911:  BSF    0A.3
....................    PRINTF (LCD_PUTC, "WAITING ....        ") ; 
0912:  MOVLW  E0
0913:  BSF    03.6
0914:  MOVWF  0D
0915:  MOVLW  00
0916:  MOVWF  0F
0917:  BCF    0A.3
0918:  BCF    03.6
0919:  CALL   33E
091A:  BSF    0A.3
....................    LCD_GOTOXY (1, 2) ; 
091B:  MOVLW  01
091C:  BSF    03.6
091D:  MOVWF  41
091E:  MOVLW  02
091F:  MOVWF  42
0920:  BCF    0A.3
0921:  BCF    03.6
0922:  CALL   2F0
0923:  BSF    0A.3
....................    DELAY_MS (10); 
0924:  MOVLW  0A
0925:  BSF    03.6
0926:  MOVWF  41
0927:  BCF    0A.3
0928:  BCF    03.6
0929:  CALL   170
092A:  BSF    0A.3
....................    PRINTF (LCD_PUTC, "WAITING ....        ") ;    
092B:  MOVLW  EB
092C:  BSF    03.6
092D:  MOVWF  0D
092E:  MOVLW  00
092F:  MOVWF  0F
0930:  BCF    0A.3
0931:  BCF    03.6
0932:  CALL   33E
0933:  BSF    0A.3
....................    TT_CONFIG_DONE = 0; 
0934:  BCF    4E.3
0935:  BCF    0A.3
0936:  BSF    0A.4
0937:  GOTO   35B (RETURN)
.................... } 
....................  
....................  
....................  VOID XACNHANCONFIG() 
....................  {    
....................    KYTU=0;          
*
0E60:  CLRF   3A
....................    LCD_GOTOXY (1, 1) ; 
0E61:  MOVLW  01
0E62:  BSF    03.6
0E63:  MOVWF  41
0E64:  MOVWF  42
0E65:  BCF    0A.3
0E66:  BCF    03.6
0E67:  CALL   2F0
0E68:  BSF    0A.3
....................    DELAY_MS (10); 
0E69:  MOVLW  0A
0E6A:  BSF    03.6
0E6B:  MOVWF  41
0E6C:  BCF    0A.3
0E6D:  BCF    03.6
0E6E:  CALL   170
0E6F:  BSF    0A.3
....................    TEMP_CHAR = "_"; 
0E70:  BSF    03.6
0E71:  CLRF   18
0E72:  CLRF   19
0E73:  MOVLW  6F
0E74:  MOVWF  04
0E75:  BCF    03.7
0E76:  MOVF   18,W
0E77:  ADDWF  04,F
0E78:  MOVF   19,W
0E79:  BCF    0A.3
0E7A:  BCF    03.6
0E7B:  CALL   05E
0E7C:  BSF    0A.3
0E7D:  MOVWF  00
0E7E:  IORLW  00
0E7F:  BTFSC  03.2
0E80:  GOTO   686
0E81:  BSF    03.6
0E82:  INCF   19,F
0E83:  INCF   18,F
0E84:  GOTO   673
0E85:  BCF    03.6
....................    CHAR * TOKEN; 
....................    TOKEN = STRTOK (KYTUCHAR2, TEMP_CHAR);    
0E86:  BSF    03.6
0E87:  CLRF   19
0E88:  MOVLW  D2
0E89:  MOVWF  18
0E8A:  CLRF   1B
0E8B:  MOVLW  6F
0E8C:  MOVWF  1A
0E8D:  BCF    03.6
0E8E:  CALL   138
0E8F:  MOVF   79,W
0E90:  BSF    03.6
0E91:  MOVWF  17
0E92:  MOVF   78,W
0E93:  MOVWF  16
....................     WHILE (TOKEN != NULL) 
0E94:  MOVF   16,F
0E95:  BTFSS  03.2
0E96:  GOTO   69A
0E97:  MOVF   17,F
0E98:  BTFSC  03.2
0E99:  GOTO   6E3
....................     {                 
....................        SWITCH(KYTU) 
0E9A:  BCF    03.6
0E9B:  MOVF   3A,W
0E9C:  BTFSC  03.2
0E9D:  GOTO   6A5
0E9E:  XORLW  01
0E9F:  BTFSC  03.2
0EA0:  GOTO   6BF
0EA1:  XORLW  03
0EA2:  BTFSC  03.2
0EA3:  GOTO   6C9
0EA4:  GOTO   6D2
....................        { 
....................          CASE 0: 
....................          DELAY_MS (1); 
0EA5:  MOVLW  01
0EA6:  BSF    03.6
0EA7:  MOVWF  41
0EA8:  BCF    0A.3
0EA9:  BCF    03.6
0EAA:  CALL   170
0EAB:  BSF    0A.3
....................          PRINTF (LCD_PUTC,TOKEN); 
0EAC:  BSF    03.6
0EAD:  MOVF   16,W
0EAE:  MOVWF  04
0EAF:  BCF    03.7
0EB0:  BTFSC  17.0
0EB1:  BSF    03.7
0EB2:  BCF    0A.3
0EB3:  BCF    03.6
0EB4:  CALL   52A
0EB5:  BSF    0A.3
....................          PRINTF (LCD_PUTC,"            "); 
0EB6:  MOVLW  F6
0EB7:  BSF    03.6
0EB8:  MOVWF  0D
0EB9:  MOVLW  00
0EBA:  MOVWF  0F
0EBB:  BCF    0A.3
0EBC:  BCF    03.6
0EBD:  CALL   33E
0EBE:  BSF    0A.3
....................          CASE 1:  
....................          SOLUONGTHIETBI_CONFIG = ATOI(TOKEN); 
0EBF:  BSF    03.6
0EC0:  MOVF   17,W
0EC1:  MOVWF  19
0EC2:  MOVF   16,W
0EC3:  MOVWF  18
0EC4:  BCF    03.6
0EC5:  CALL   229
0EC6:  MOVF   78,W
0EC7:  MOVWF  49
....................          BREAK;                      
0EC8:  GOTO   6D2
....................          CASE 2: 
....................          SOLUONGCAMBIEN_CONFIG = ATOI(TOKEN); 
0EC9:  BSF    03.6
0ECA:  MOVF   17,W
0ECB:  MOVWF  19
0ECC:  MOVF   16,W
0ECD:  MOVWF  18
0ECE:  BCF    03.6
0ECF:  CALL   229
0ED0:  MOVF   78,W
0ED1:  MOVWF  4A
....................          BREAK;               
....................        }  
....................       TOKEN = STRTOK(NULL, TEMP_CHAR); 
0ED2:  BSF    03.6
0ED3:  CLRF   19
0ED4:  CLRF   18
0ED5:  CLRF   1B
0ED6:  MOVLW  6F
0ED7:  MOVWF  1A
0ED8:  BCF    03.6
0ED9:  CALL   138
0EDA:  MOVF   79,W
0EDB:  BSF    03.6
0EDC:  MOVWF  17
0EDD:  MOVF   78,W
0EDE:  MOVWF  16
....................       KYTU++;         
0EDF:  BCF    03.6
0EE0:  INCF   3A,F
0EE1:  BSF    03.6
0EE2:  GOTO   694
....................     }           
....................    DELAY_MS (1);       
0EE3:  MOVLW  01
0EE4:  MOVWF  41
0EE5:  BCF    0A.3
0EE6:  BCF    03.6
0EE7:  CALL   170
0EE8:  BSF    0A.3
....................    LCD_GOTOXY (1, 2) ; 
0EE9:  MOVLW  01
0EEA:  BSF    03.6
0EEB:  MOVWF  41
0EEC:  MOVLW  02
0EED:  MOVWF  42
0EEE:  BCF    0A.3
0EEF:  BCF    03.6
0EF0:  CALL   2F0
0EF1:  BSF    0A.3
....................    DELAY_MS (10); 
0EF2:  MOVLW  0A
0EF3:  BSF    03.6
0EF4:  MOVWF  41
0EF5:  BCF    0A.3
0EF6:  BCF    03.6
0EF7:  CALL   170
0EF8:  BSF    0A.3
....................    PRINTF (LCD_PUTC,"TB: ");    
0EF9:  MOVLW  FD
0EFA:  BSF    03.6
0EFB:  MOVWF  0D
0EFC:  MOVLW  00
0EFD:  MOVWF  0F
0EFE:  BCF    0A.3
0EFF:  BCF    03.6
0F00:  CALL   33E
0F01:  BSF    0A.3
....................    ITOA (SOLUONGTHIETBI_CONFIG, 10, TEMP_CHAR);    
0F02:  BSF    03.6
0F03:  CLRF   42
0F04:  CLRF   41
0F05:  CLRF   40
0F06:  BCF    03.6
0F07:  MOVF   49,W
0F08:  BSF    03.6
0F09:  MOVWF  3F
0F0A:  MOVLW  0A
0F0B:  MOVWF  43
0F0C:  CLRF   45
0F0D:  MOVLW  6F
0F0E:  MOVWF  44
0F0F:  BCF    0A.3
0F10:  BCF    03.6
0F11:  CALL   40A
0F12:  BSF    0A.3
....................    PRINTF (LCD_PUTC,TEMP_CHAR);    
0F13:  MOVLW  6F
0F14:  MOVWF  04
0F15:  BCF    03.7
0F16:  BCF    0A.3
0F17:  CALL   52A
0F18:  BSF    0A.3
....................    PRINTF (LCD_PUTC,"    CB:");    
0F19:  MOVLW  00
0F1A:  BSF    03.6
0F1B:  MOVWF  0D
0F1C:  MOVLW  01
0F1D:  MOVWF  0F
0F1E:  BCF    0A.3
0F1F:  BCF    03.6
0F20:  CALL   33E
0F21:  BSF    0A.3
....................    ITOA (SOLUONGCAMBIEN_CONFIG, 10, TEMP_CHAR);    
0F22:  BSF    03.6
0F23:  CLRF   42
0F24:  CLRF   41
0F25:  CLRF   40
0F26:  BCF    03.6
0F27:  MOVF   4A,W
0F28:  BSF    03.6
0F29:  MOVWF  3F
0F2A:  MOVLW  0A
0F2B:  MOVWF  43
0F2C:  CLRF   45
0F2D:  MOVLW  6F
0F2E:  MOVWF  44
0F2F:  BCF    0A.3
0F30:  BCF    03.6
0F31:  CALL   40A
0F32:  BSF    0A.3
....................    PRINTF (LCD_PUTC,TEMP_CHAR);       
0F33:  MOVLW  6F
0F34:  MOVWF  04
0F35:  BCF    03.7
0F36:  BCF    0A.3
0F37:  CALL   52A
0F38:  BSF    0A.3
....................    TT_CONFIG_OKE_UART = 1; 
0F39:  BSF    4E.6
....................     
....................  }  
.................... //--------------------------------------------------------------------// 
....................  
.................... #INCLUDE <DIEU_KHIEN.C> 
.................... VOID READ_BTN_STATE() 
*
0F75:  BSF    03.6
0F76:  CLRF   10
0F77:  MOVLW  34
0F78:  MOVWF  11
.................... { 
....................     
....................    INT TB = 0; 
....................    INT ID_TB =52; 
....................    FOR (TB = 0; TB < SOLUONGTHIETBI_CONFIG; TB++) 
0F79:  CLRF   10
0F7A:  BCF    03.6
0F7B:  MOVF   49,W
0F7C:  BSF    03.6
0F7D:  SUBWF  10,W
0F7E:  BTFSC  03.0
0F7F:  GOTO   7BE
....................    {   IF (TB>3) ID_TB = 64; 
0F80:  MOVF   10,W
0F81:  SUBLW  03
0F82:  BTFSC  03.0
0F83:  GOTO   786
0F84:  MOVLW  40
0F85:  MOVWF  11
....................        IF (!INPUT (ID_TB + TB)) 
0F86:  MOVF   10,W
0F87:  ADDWF  11,W
0F88:  MOVWF  12
0F89:  MOVWF  19
0F8A:  MOVLW  01
0F8B:  MOVWF  1A
0F8C:  CLRF   1C
0F8D:  MOVLW  80
0F8E:  MOVWF  1B
0F8F:  BCF    0A.3
0F90:  BCF    03.6
0F91:  CALL   7DE
0F92:  BSF    0A.3
0F93:  BSF    03.6
0F94:  MOVF   12,W
0F95:  MOVWF  1C
0F96:  CLRF   1E
0F97:  CLRF   1D
0F98:  BCF    03.6
0F99:  CALL   352
0F9A:  BTFSC  78.0
0F9B:  GOTO   7BB
....................       {   
....................          DELAY_MS(200); 
0F9C:  MOVLW  C8
0F9D:  BSF    03.6
0F9E:  MOVWF  41
0F9F:  BCF    0A.3
0FA0:  BCF    03.6
0FA1:  CALL   170
0FA2:  BSF    0A.3
....................          TT_THIETBI_TEMP[TB] = ~TT_THIETBI_TEMP[TB];          
0FA3:  BSF    03.6
0FA4:  MOVF   10,W
0FA5:  MOVWF  1C
0FA6:  CLRF   1E
0FA7:  MOVLW  4D
0FA8:  MOVWF  1D
0FA9:  BCF    03.6
0FAA:  CALL   352
0FAB:  MOVLW  00
0FAC:  BTFSS  78.0
0FAD:  MOVLW  01
0FAE:  BSF    03.6
0FAF:  MOVWF  12
0FB0:  MOVF   10,W
0FB1:  MOVWF  19
0FB2:  MOVF   12,W
0FB3:  MOVWF  1A
0FB4:  CLRF   1C
0FB5:  MOVLW  4D
0FB6:  MOVWF  1B
0FB7:  BCF    0A.3
0FB8:  BCF    03.6
0FB9:  CALL   7DE
0FBA:  BSF    0A.3
....................       } 
0FBB:  BSF    03.6
0FBC:  INCF   10,F
0FBD:  GOTO   77A
....................    } 
0FBE:  BCF    03.6
0FBF:  BCF    0A.3
0FC0:  BSF    0A.4
0FC1:  GOTO   36F (RETURN)
.................... /* 
....................    FOR (TB = 0; TB < 4; TB++) 
....................    { 
....................  
....................       IF (!INPUT (68 + TB)) 
....................       { 
....................           DELAY_MS(200); 
....................           TT_THIETBI_TEMP[TB + 4] = ~TT_THIETBI_TEMP[TB + 4];            
....................       } 
....................    } 
.................... */ 
.................... } 
.................... INT BIN_TO_DEC() 
*
0BBD:  BSF    03.6
0BBE:  CLRF   19
0BBF:  MOVLW  01
0BC0:  MOVWF  1A
.................... { 
....................    INT8 DEC_VL = 0 ;  
....................    INT8 BASE = 1; 
....................    INT8 I; 
....................    FOR (I=0;I<8;I++) 
0BC1:  CLRF   1B
0BC2:  MOVF   1B,W
0BC3:  SUBLW  07
0BC4:  BTFSS  03.0
0BC5:  GOTO   3E1
....................    { 
....................    DEC_VL = DEC_VL+ BASE*TT_THIETBI_TEMP[I]; 
0BC6:  MOVF   1B,W
0BC7:  MOVWF  1C
0BC8:  CLRF   1E
0BC9:  MOVLW  4D
0BCA:  MOVWF  1D
0BCB:  BCF    03.6
0BCC:  CALL   352
0BCD:  MOVLW  00
0BCE:  BTFSC  78.0
0BCF:  MOVLW  01
0BD0:  BSF    03.6
0BD1:  MOVWF  1C
0BD2:  MOVF   1A,W
0BD3:  MOVWF  1F
0BD4:  MOVF   1C,W
0BD5:  MOVWF  20
0BD6:  BCF    0A.3
0BD7:  BCF    03.6
0BD8:  CALL   7B7
0BD9:  BSF    0A.3
0BDA:  MOVF   78,W
0BDB:  BSF    03.6
0BDC:  ADDWF  19,F
....................    BASE = BASE*2; 
0BDD:  BCF    03.0
0BDE:  RLF    1A,F
0BDF:  INCF   1B,F
0BE0:  GOTO   3C2
....................    } 
....................    RETURN DEC_VL; 
0BE1:  MOVF   19,W
0BE2:  MOVWF  78
....................  
.................... } 
....................   
....................  VOID XUAT_DIEU_KHIEN() 
....................  { 
....................    LENH_DIEU_KHIEN = BIN_TO_DEC(); 
0BE3:  MOVF   78,W
0BE4:  BCF    03.6
0BE5:  MOVWF  3B
....................    XUATTRANGTHAI (LENH_DIEU_KHIEN) ;   
0BE6:  MOVF   3B,W
0BE7:  BSF    03.6
0BE8:  MOVWF  19
....................    FOR (INT ST=0;ST<8;ST++){ 
*
0C0D:  BSF    03.6
0C0E:  CLRF   18
0C0F:  MOVF   18,W
0C10:  SUBLW  07
0C11:  BTFSS  03.0
0C12:  GOTO   44C
....................       TEMP_CHAR = "0"; 
0C13:  CLRF   19
0C14:  CLRF   1A
0C15:  MOVLW  6F
0C16:  MOVWF  04
0C17:  BCF    03.7
0C18:  MOVF   19,W
0C19:  ADDWF  04,F
0C1A:  MOVF   1A,W
0C1B:  BCF    0A.3
0C1C:  BCF    03.6
0C1D:  CALL   058
0C1E:  BSF    0A.3
0C1F:  MOVWF  00
0C20:  IORLW  00
0C21:  BTFSC  03.2
0C22:  GOTO   428
0C23:  BSF    03.6
0C24:  INCF   1A,F
0C25:  INCF   19,F
0C26:  GOTO   415
0C27:  BCF    03.6
....................       ITOA(TT_THIETBI_TEMP[ST],10,TEMP_CHAR); 
0C28:  BSF    03.6
0C29:  MOVF   18,W
0C2A:  MOVWF  1C
0C2B:  CLRF   1E
0C2C:  MOVLW  4D
0C2D:  MOVWF  1D
0C2E:  BCF    03.6
0C2F:  CALL   352
0C30:  MOVLW  00
0C31:  BTFSC  78.0
0C32:  MOVLW  01
0C33:  BSF    03.6
0C34:  MOVWF  19
0C35:  CLRF   42
0C36:  CLRF   41
0C37:  CLRF   40
0C38:  MOVF   19,W
0C39:  MOVWF  3F
0C3A:  MOVLW  0A
0C3B:  MOVWF  43
0C3C:  CLRF   45
0C3D:  MOVLW  6F
0C3E:  MOVWF  44
0C3F:  BCF    0A.3
0C40:  BCF    03.6
0C41:  CALL   40A
0C42:  BSF    0A.3
....................       PRINTF (LCD_PUTC, TEMP_CHAR); 
0C43:  MOVLW  6F
0C44:  MOVWF  04
0C45:  BCF    03.7
0C46:  BCF    0A.3
0C47:  CALL   52A
0C48:  BSF    0A.3
0C49:  BSF    03.6
0C4A:  INCF   18,F
0C4B:  GOTO   40F
....................    } 
....................    //CHAR *PACKAGE_CONFIG[]={"*", "LENGHT","CF", "ID_GW1234" ,"ID_NODE","#"}; 
....................    IF(LENH_DIEU_KHIEN<10) TEMP_CHAR ="22"; 
0C4C:  BCF    03.6
0C4D:  MOVF   3B,W
0C4E:  SUBLW  09
0C4F:  BTFSS  03.0
0C50:  GOTO   468
0C51:  BSF    03.6
0C52:  CLRF   19
0C53:  CLRF   1A
0C54:  MOVLW  6F
0C55:  MOVWF  04
0C56:  BCF    03.7
0C57:  MOVF   19,W
0C58:  ADDWF  04,F
0C59:  MOVF   1A,W
0C5A:  BCF    0A.3
0C5B:  BCF    03.6
0C5C:  CALL   064
0C5D:  BSF    0A.3
0C5E:  MOVWF  00
0C5F:  IORLW  00
0C60:  BTFSC  03.2
0C61:  GOTO   467
0C62:  BSF    03.6
0C63:  INCF   1A,F
0C64:  INCF   19,F
0C65:  GOTO   454
0C66:  BCF    03.6
0C67:  GOTO   49D
....................    ELSE IF(LENH_DIEU_KHIEN>=10 && LENH_DIEU_KHIEN <100) TEMP_CHAR ="23"; 
0C68:  MOVF   3B,W
0C69:  SUBLW  09
0C6A:  BTFSC  03.0
0C6B:  GOTO   487
0C6C:  MOVF   3B,W
0C6D:  SUBLW  63
0C6E:  BTFSS  03.0
0C6F:  GOTO   487
0C70:  BSF    03.6
0C71:  CLRF   19
0C72:  CLRF   1A
0C73:  MOVLW  6F
0C74:  MOVWF  04
0C75:  BCF    03.7
0C76:  MOVF   19,W
0C77:  ADDWF  04,F
0C78:  MOVF   1A,W
0C79:  BCF    0A.3
0C7A:  BCF    03.6
0C7B:  CALL   06B
0C7C:  BSF    0A.3
0C7D:  MOVWF  00
0C7E:  IORLW  00
0C7F:  BTFSC  03.2
0C80:  GOTO   486
0C81:  BSF    03.6
0C82:  INCF   1A,F
0C83:  INCF   19,F
0C84:  GOTO   473
0C85:  BCF    03.6
0C86:  GOTO   49D
....................    ELSE TEMP_CHAR ="24";     
0C87:  BSF    03.6
0C88:  CLRF   19
0C89:  CLRF   1A
0C8A:  MOVLW  6F
0C8B:  MOVWF  04
0C8C:  BCF    03.7
0C8D:  MOVF   19,W
0C8E:  ADDWF  04,F
0C8F:  MOVF   1A,W
0C90:  BCF    0A.3
0C91:  BCF    03.6
0C92:  CALL   072
0C93:  BSF    0A.3
0C94:  MOVWF  00
0C95:  IORLW  00
0C96:  BTFSC  03.2
0C97:  GOTO   49D
0C98:  BSF    03.6
0C99:  INCF   1A,F
0C9A:  INCF   19,F
0C9B:  GOTO   48A
0C9C:  BCF    03.6
....................    PRINTF ("*@"); 
0C9D:  MOVLW  2A
0C9E:  BTFSS  0C.4
0C9F:  GOTO   49E
0CA0:  MOVWF  19
0CA1:  MOVLW  40
0CA2:  BTFSS  0C.4
0CA3:  GOTO   4A2
0CA4:  MOVWF  19
....................    PRINTF (TEMP_CHAR); 
0CA5:  MOVLW  6F
0CA6:  MOVWF  04
0CA7:  BCF    03.7
0CA8:  BCF    0A.3
0CA9:  CALL   799
0CAA:  BSF    0A.3
....................    PRINTF ("@DK@"); 
0CAB:  MOVLW  04
0CAC:  BSF    03.6
0CAD:  MOVWF  0D
0CAE:  MOVLW  01
0CAF:  MOVWF  0F
0CB0:  BCF    03.6
0CB1:  CALL   36B
....................    PRINTF (ID_GATEWAY_CHAR); 
0CB2:  MOVLW  56
0CB3:  MOVWF  04
0CB4:  BCF    03.7
0CB5:  BCF    0A.3
0CB6:  CALL   799
0CB7:  BSF    0A.3
....................    PRINTF ("@"); 
0CB8:  MOVLW  40
0CB9:  BTFSS  0C.4
0CBA:  GOTO   4B9
0CBB:  MOVWF  19
....................    PRINTF (ID_NODE_CHAR); 
0CBC:  MOVLW  4F
0CBD:  MOVWF  04
0CBE:  BCF    03.7
0CBF:  BCF    0A.3
0CC0:  CALL   799
0CC1:  BSF    0A.3
....................    PRINTF ("@"); 
0CC2:  MOVLW  40
0CC3:  BTFSS  0C.4
0CC4:  GOTO   4C3
0CC5:  MOVWF  19
....................    ITOA(LENH_DIEU_KHIEN,10,TEMP_CHAR); 
0CC6:  BSF    03.6
0CC7:  CLRF   42
0CC8:  CLRF   41
0CC9:  CLRF   40
0CCA:  BCF    03.6
0CCB:  MOVF   3B,W
0CCC:  BSF    03.6
0CCD:  MOVWF  3F
0CCE:  MOVLW  0A
0CCF:  MOVWF  43
0CD0:  CLRF   45
0CD1:  MOVLW  6F
0CD2:  MOVWF  44
0CD3:  BCF    0A.3
0CD4:  BCF    03.6
0CD5:  CALL   40A
0CD6:  BSF    0A.3
....................    PRINTF (TEMP_CHAR); 
0CD7:  MOVLW  6F
0CD8:  MOVWF  04
0CD9:  BCF    03.7
0CDA:  BCF    0A.3
0CDB:  CALL   799
0CDC:  BSF    0A.3
....................    PRINTF ("@#"); 
0CDD:  MOVLW  40
0CDE:  BTFSS  0C.4
0CDF:  GOTO   4DE
0CE0:  MOVWF  19
0CE1:  MOVLW  23
0CE2:  BTFSS  0C.4
0CE3:  GOTO   4E2
0CE4:  MOVWF  19
....................     
....................     
....................    LCD_GOTOXY (1, 2) ; 
0CE5:  MOVLW  01
0CE6:  BSF    03.6
0CE7:  MOVWF  41
0CE8:  MOVLW  02
0CE9:  MOVWF  42
0CEA:  BCF    0A.3
0CEB:  BCF    03.6
0CEC:  CALL   2F0
0CED:  BSF    0A.3
....................    DELAY_MS (10); 
0CEE:  MOVLW  0A
0CEF:  BSF    03.6
0CF0:  MOVWF  41
0CF1:  BCF    0A.3
0CF2:  BCF    03.6
0CF3:  CALL   170
0CF4:  BSF    0A.3
....................    PRINTF (LCD_PUTC, "SW: ");     
0CF5:  MOVLW  07
0CF6:  BSF    03.6
0CF7:  MOVWF  0D
0CF8:  MOVLW  01
0CF9:  MOVWF  0F
0CFA:  BCF    0A.3
0CFB:  BCF    03.6
0CFC:  CALL   33E
0CFD:  BSF    0A.3
....................    FOR (ST=0;ST<8;ST++){ 
0CFE:  BSF    03.6
0CFF:  CLRF   18
0D00:  MOVF   18,W
0D01:  SUBLW  07
0D02:  BTFSS  03.0
0D03:  GOTO   53D
....................       TEMP_CHAR = "0"; 
0D04:  CLRF   19
0D05:  CLRF   1A
0D06:  MOVLW  6F
0D07:  MOVWF  04
0D08:  BCF    03.7
0D09:  MOVF   19,W
0D0A:  ADDWF  04,F
0D0B:  MOVF   1A,W
0D0C:  BCF    0A.3
0D0D:  BCF    03.6
0D0E:  CALL   058
0D0F:  BSF    0A.3
0D10:  MOVWF  00
0D11:  IORLW  00
0D12:  BTFSC  03.2
0D13:  GOTO   519
0D14:  BSF    03.6
0D15:  INCF   1A,F
0D16:  INCF   19,F
0D17:  GOTO   506
0D18:  BCF    03.6
....................       ITOA(TT_THIETBI_TEMP[ST],10,TEMP_CHAR); 
0D19:  BSF    03.6
0D1A:  MOVF   18,W
0D1B:  MOVWF  1C
0D1C:  CLRF   1E
0D1D:  MOVLW  4D
0D1E:  MOVWF  1D
0D1F:  BCF    03.6
0D20:  CALL   352
0D21:  MOVLW  00
0D22:  BTFSC  78.0
0D23:  MOVLW  01
0D24:  BSF    03.6
0D25:  MOVWF  19
0D26:  CLRF   42
0D27:  CLRF   41
0D28:  CLRF   40
0D29:  MOVF   19,W
0D2A:  MOVWF  3F
0D2B:  MOVLW  0A
0D2C:  MOVWF  43
0D2D:  CLRF   45
0D2E:  MOVLW  6F
0D2F:  MOVWF  44
0D30:  BCF    0A.3
0D31:  BCF    03.6
0D32:  CALL   40A
0D33:  BSF    0A.3
....................       PRINTF (LCD_PUTC, TEMP_CHAR); 
0D34:  MOVLW  6F
0D35:  MOVWF  04
0D36:  BCF    03.7
0D37:  BCF    0A.3
0D38:  CALL   52A
0D39:  BSF    0A.3
0D3A:  BSF    03.6
0D3B:  INCF   18,F
0D3C:  GOTO   500
....................    }    
0D3D:  BCF    03.6
0D3E:  RETURN
....................     
....................  } 
....................  VOID DIEUKHIENTHIETBI () 
*
0F3B:  BSF    03.6
0F3C:  CLRF   16
....................  { 
....................     INT MA_DEC = 0; 
....................     MA_DEC = ATOI (KYTUCHAR2); 
0F3D:  CLRF   19
0F3E:  MOVLW  D2
0F3F:  MOVWF  18
0F40:  BCF    03.6
0F41:  CALL   229
0F42:  MOVF   78,W
0F43:  BSF    03.6
0F44:  MOVWF  16
....................  
....................    UNSIGNED INT8   SB;    
....................    #BIT BSERI  = MA_DEC.0 
....................     
....................    FOR (SB=0;SB<8;SB++) 
0F45:  CLRF   17
0F46:  MOVF   17,W
0F47:  SUBLW  07
0F48:  BTFSS  03.0
0F49:  GOTO   75E
....................       {                                                     
....................          TT_THIETBI_TEMP[SB] = BSERI; 
0F4A:  MOVLW  00
0F4B:  BTFSC  16.0
0F4C:  MOVLW  01
0F4D:  MOVWF  18
0F4E:  MOVF   17,W
0F4F:  MOVWF  19
0F50:  MOVF   18,W
0F51:  MOVWF  1A
0F52:  CLRF   1C
0F53:  MOVLW  4D
0F54:  MOVWF  1B
0F55:  BCF    0A.3
0F56:  BCF    03.6
0F57:  CALL   7DE
0F58:  BSF    0A.3
....................          MA_DEC=MA_DEC>>1;  
0F59:  BCF    03.0
0F5A:  BSF    03.6
0F5B:  RRF    16,F
0F5C:  INCF   17,F
0F5D:  GOTO   746
....................      }     
....................     XUAT_DIEU_KHIEN(); 
0F5E:  BCF    03.6
0F5F:  CALL   3BD
....................  } 
....................  
....................  
.................... #INCLUDE <analog.C> 
....................  
....................   INT ADC_READ (INT KENH) 
....................  { 
....................     UNSIGNED INT8 ANALOG_PORT[] = {1,2,4,8,16,32,64};  
*
1010:  MOVLW  01
1011:  MOVWF  14
1012:  MOVLW  02
1013:  MOVWF  15
1014:  MOVLW  04
1015:  MOVWF  16
1016:  MOVLW  08
1017:  MOVWF  17
1018:  MOVLW  10
1019:  MOVWF  18
101A:  MOVLW  20
101B:  MOVWF  19
101C:  MOVLW  40
101D:  MOVWF  1A
....................     SETUP_ADC_PORTS (ANALOG_PORT[KENH]); 
101E:  MOVLW  14
101F:  ADDWF  13,W
1020:  MOVWF  04
1021:  BSF    03.7
1022:  MOVF   00,W
1023:  MOVWF  1C
1024:  MOVWF  1D
1025:  CLRF   1E
1026:  CLRF   1F
1027:  CLRF   20
1028:  MOVLW  89
1029:  MOVWF  04
102A:  BSF    03.7
102B:  MOVLW  C0
102C:  ANDWF  00,F
102D:  MOVF   1F,W
102E:  IORWF  00,F
102F:  MOVLW  9F
1030:  MOVWF  04
1031:  BCF    03.7
1032:  MOVLW  CF
1033:  ANDWF  00,F
1034:  MOVF   1E,W
1035:  IORWF  00,F
1036:  MOVLW  88
1037:  MOVWF  04
1038:  BSF    03.7
1039:  MOVF   1D,W
103A:  MOVWF  00
....................     DELAY_MS(3); 
103B:  MOVLW  03
103C:  MOVWF  41
103D:  BCF    0A.4
103E:  BCF    03.6
103F:  CALL   170
1040:  BSF    0A.4
....................     SET_ADC_CHANNEL (KENH); 
1041:  BSF    03.6
1042:  RLF    13,W
1043:  MOVWF  77
1044:  RLF    77,F
1045:  MOVLW  FC
1046:  ANDWF  77,F
1047:  BCF    03.6
1048:  MOVF   1F,W
1049:  ANDLW  C3
104A:  IORWF  77,W
104B:  MOVWF  1F
....................     DELAY_MS(3); 
104C:  MOVLW  03
104D:  BSF    03.6
104E:  MOVWF  41
104F:  BCF    0A.4
1050:  BCF    03.6
1051:  CALL   170
1052:  BSF    0A.4
....................     KQADC = 0; 
1053:  CLRF   33
1054:  CLRF   32
....................     FOR (INT I = 0; I < 100; I++) 
1055:  BSF    03.6
1056:  CLRF   1B
1057:  MOVF   1B,W
1058:  SUBLW  63
1059:  BTFSS  03.0
105A:  GOTO   071
....................     { 
....................        KQADC = KQADC + READ_ADC () ; 
105B:  BCF    03.6
105C:  BSF    1F.1
105D:  BTFSC  1F.1
105E:  GOTO   05D
105F:  BSF    03.5
1060:  MOVF   1E,W
1061:  BCF    03.5
1062:  ADDWF  32,F
1063:  MOVF   1E,W
1064:  BTFSC  03.0
1065:  INCFSZ 1E,W
1066:  ADDWF  33,F
....................        DELAY_MS (1); 
1067:  MOVLW  01
1068:  BSF    03.6
1069:  MOVWF  41
106A:  BCF    0A.4
106B:  BCF    03.6
106C:  CALL   170
106D:  BSF    0A.4
106E:  BSF    03.6
106F:  INCF   1B,F
1070:  GOTO   057
....................     } 
....................  
....................     KQADC = KQADC / (100 * 2.046); 
1071:  BCF    03.6
1072:  MOVF   33,W
1073:  BSF    03.6
1074:  MOVWF  1D
1075:  BCF    03.6
1076:  MOVF   32,W
1077:  BSF    03.6
1078:  MOVWF  1C
*
1095:  MOVF   7A,W
1096:  MOVWF  1F
1097:  MOVF   79,W
1098:  MOVWF  1E
1099:  MOVF   78,W
109A:  MOVWF  1D
109B:  MOVF   77,W
109C:  MOVWF  1C
109D:  MOVLW  9A
109E:  MOVWF  23
109F:  MOVLW  99
10A0:  MOVWF  22
10A1:  MOVLW  4C
10A2:  MOVWF  21
10A3:  MOVLW  86
10A4:  MOVWF  20
*
116E:  MOVF   7A,W
116F:  MOVWF  1F
1170:  MOVF   79,W
1171:  MOVWF  1E
1172:  MOVF   78,W
1173:  MOVWF  1D
1174:  MOVF   77,W
1175:  MOVWF  1C
*
1194:  MOVF   79,W
1195:  BCF    03.6
1196:  MOVWF  33
1197:  MOVF   78,W
1198:  MOVWF  32
....................     RETURN KQADC; 
1199:  MOVF   32,W
119A:  MOVWF  78
....................  } 
....................  
....................  
....................  VOID READ_ANALOG ( ) 
....................  { 
....................    FOR(INT K = 0; K<SOLUONGCAMBIEN_CONFIG; K++){ 
*
1000:  BSF    03.6
1001:  CLRF   10
1002:  BCF    03.6
1003:  MOVF   4A,W
1004:  BSF    03.6
1005:  SUBWF  10,W
1006:  BTFSC  03.0
1007:  GOTO   1A5
....................       KET_QUA_ANALOG[K] = ADC_READ (K);   
1008:  MOVLW  34
1009:  ADDWF  10,W
100A:  MOVWF  11
100B:  CLRF   12
100C:  BTFSC  03.0
100D:  INCF   12,F
100E:  MOVF   10,W
100F:  MOVWF  13
*
119B:  BSF    03.6
119C:  MOVF   11,W
119D:  MOVWF  04
119E:  BCF    03.7
119F:  BTFSC  12.0
11A0:  BSF    03.7
11A1:  MOVF   78,W
11A2:  MOVWF  00
11A3:  INCF   10,F
11A4:  GOTO   002
....................    } 
11A5:  BCF    03.6
11A6:  BCF    0A.3
11A7:  BSF    0A.4
11A8:  GOTO   37F (RETURN)
....................  } 
....................  
....................  VOID SEND_ANALOG_UART() 
....................  { 
....................    OUTPUT_TOGGLE(PIN_C4); 
11A9:  BCF    31.4
11AA:  MOVF   31,W
11AB:  BSF    03.5
11AC:  MOVWF  07
11AD:  MOVLW  10
11AE:  BCF    03.5
11AF:  XORWF  07,F
....................    //CHAR *PACKAGE_SS[]={"*", "26","SS", "IDGW12" ,"NODE","ZZ","AA","VV","CC","SS"}; 
....................    CHAR *PACKAGE_SS[]={"ZZ","AA","VV","CC","SS"};    
11B0:  MOVLW  5A
11B1:  BSF    03.6
11B2:  MOVWF  1A
11B3:  MOVWF  1B
11B4:  CLRF   1C
11B5:  MOVLW  41
11B6:  MOVWF  1D
11B7:  MOVWF  1E
11B8:  CLRF   1F
11B9:  MOVLW  56
11BA:  MOVWF  20
11BB:  MOVWF  21
11BC:  CLRF   22
11BD:  MOVLW  43
11BE:  MOVWF  23
11BF:  MOVWF  24
11C0:  CLRF   25
11C1:  MOVLW  53
11C2:  MOVWF  26
11C3:  MOVWF  27
11C4:  CLRF   28
11C5:  MOVLW  01
11C6:  MOVWF  11
11C7:  MOVLW  1A
11C8:  MOVWF  10
11C9:  MOVLW  01
11CA:  MOVWF  13
11CB:  MOVLW  1D
11CC:  MOVWF  12
11CD:  MOVLW  01
11CE:  MOVWF  15
11CF:  MOVLW  20
11D0:  MOVWF  14
11D1:  MOVLW  01
11D2:  MOVWF  17
11D3:  MOVLW  23
11D4:  MOVWF  16
11D5:  MOVLW  01
11D6:  MOVWF  19
11D7:  MOVLW  26
11D8:  MOVWF  18
....................    PACKAGE_SS[0] = ID_GATEWAY_CHAR; 
11D9:  CLRF   11
11DA:  MOVLW  56
11DB:  MOVWF  10
....................    PACKAGE_SS[1] = ID_NODE_CHAR; 
11DC:  CLRF   13
11DD:  MOVLW  4F
11DE:  MOVWF  12
....................    UNSIGNED INT8 DO_DAI =20; 
11DF:  MOVLW  14
11E0:  MOVWF  29
....................     
....................    FOR(INT I = 0; I<SOLUONGCAMBIEN_CONFIG; I++) 
11E1:  CLRF   2A
11E2:  BCF    03.6
11E3:  MOVF   4A,W
11E4:  BSF    03.6
11E5:  SUBWF  2A,W
11E6:  BTFSC  03.0
11E7:  GOTO   20D
....................    { 
....................       ITOA(KET_QUA_ANALOG[I],10,PACKAGE_SS[I]); 
11E8:  MOVLW  34
11E9:  ADDWF  2A,W
11EA:  MOVWF  04
11EB:  BCF    03.7
11EC:  MOVF   00,W
11ED:  MOVWF  2B
11EE:  BCF    03.0
11EF:  RLF    2A,W
11F0:  ADDLW  10
11F1:  MOVWF  04
11F2:  BSF    03.7
11F3:  INCF   04,F
11F4:  MOVF   00,W
11F5:  MOVWF  2D
11F6:  DECF   04,F
11F7:  MOVF   00,W
11F8:  MOVWF  2C
11F9:  CLRF   42
11FA:  CLRF   41
11FB:  CLRF   40
11FC:  MOVF   2B,W
11FD:  MOVWF  3F
11FE:  MOVLW  0A
11FF:  MOVWF  43
1200:  MOVF   2D,W
1201:  MOVWF  45
1202:  MOVF   2C,W
1203:  MOVWF  44
1204:  BCF    0A.4
1205:  BCF    03.6
1206:  CALL   40A
1207:  BSF    0A.4
....................       DO_DAI = DO_DAI + 3; 
1208:  MOVLW  03
1209:  BSF    03.6
120A:  ADDWF  29,F
120B:  INCF   2A,F
120C:  GOTO   1E2
....................    }       
....................    ITOA(DO_DAI,10,TEMP_CHAR2); 
120D:  CLRF   42
120E:  CLRF   41
120F:  CLRF   40
1210:  MOVF   29,W
1211:  MOVWF  3F
1212:  MOVLW  0A
1213:  MOVWF  43
1214:  CLRF   45
1215:  MOVLW  7B
1216:  MOVWF  44
1217:  BCF    0A.4
1218:  BCF    03.6
1219:  CALL   40A
121A:  BSF    0A.4
....................    PRINTF ("*@");    
121B:  MOVLW  2A
121C:  BTFSS  0C.4
121D:  GOTO   21C
121E:  MOVWF  19
121F:  MOVLW  40
1220:  BTFSS  0C.4
1221:  GOTO   220
1222:  MOVWF  19
....................    PRINTF (TEMP_CHAR2); 
1223:  MOVLW  7B
1224:  MOVWF  04
1225:  BCF    03.7
1226:  BCF    0A.4
1227:  CALL   799
1228:  BSF    0A.4
....................    PRINTF ("@SS@");    
1229:  MOVLW  0A
122A:  BSF    03.6
122B:  MOVWF  0D
122C:  MOVLW  01
122D:  MOVWF  0F
122E:  BCF    0A.4
122F:  BSF    0A.3
1230:  BCF    03.6
1231:  CALL   36B
1232:  BSF    0A.4
1233:  BCF    0A.3
....................    PRINTF (ID_GATEWAY_CHAR); 
1234:  MOVLW  56
1235:  MOVWF  04
1236:  BCF    03.7
1237:  BCF    0A.4
1238:  CALL   799
1239:  BSF    0A.4
....................    PRINTF ("@"); 
123A:  MOVLW  40
123B:  BTFSS  0C.4
123C:  GOTO   23B
123D:  MOVWF  19
....................    PRINTF (ID_NODE_CHAR); 
123E:  MOVLW  4F
123F:  MOVWF  04
1240:  BCF    03.7
1241:  BCF    0A.4
1242:  CALL   799
1243:  BSF    0A.4
....................    PRINTF ("@");    
1244:  MOVLW  40
1245:  BTFSS  0C.4
1246:  GOTO   245
1247:  MOVWF  19
....................    FOR ( I = 0; I < SOLUONGCAMBIEN_CONFIG; I++) 
1248:  BSF    03.6
1249:  CLRF   2A
124A:  BCF    03.6
124B:  MOVF   4A,W
124C:  BSF    03.6
124D:  SUBWF  2A,W
124E:  BTFSC  03.0
124F:  GOTO   26A
....................    { 
....................       PRINTF (PACKAGE_SS[I]); 
1250:  BCF    03.0
1251:  RLF    2A,W
1252:  ADDLW  10
1253:  MOVWF  04
1254:  BSF    03.7
1255:  INCF   04,F
1256:  MOVF   00,W
1257:  MOVWF  2C
1258:  DECF   04,F
1259:  MOVF   00,W
125A:  MOVWF  2B
125B:  MOVWF  04
125C:  BCF    03.7
125D:  BTFSC  2C.0
125E:  BSF    03.7
125F:  BCF    0A.4
1260:  BCF    03.6
1261:  CALL   799
1262:  BSF    0A.4
....................       PRINTF ("@"); 
1263:  MOVLW  40
1264:  BTFSS  0C.4
1265:  GOTO   264
1266:  MOVWF  19
1267:  BSF    03.6
1268:  INCF   2A,F
1269:  GOTO   24A
....................    } 
....................    PRINTF ("#"); 
126A:  MOVLW  23
126B:  BCF    03.6
126C:  BTFSS  0C.4
126D:  GOTO   26C
126E:  MOVWF  19
....................    OUTPUT_TOGGLE(PIN_C4); 
126F:  BCF    31.4
1270:  MOVF   31,W
1271:  BSF    03.5
1272:  MOVWF  07
1273:  MOVLW  10
1274:  BCF    03.5
1275:  XORWF  07,F
1276:  BCF    0A.3
1277:  BSF    0A.4
1278:  GOTO   384 (RETURN)
....................     
....................  } 
....................   
....................   
....................   
....................   
....................  /* 
....................  INT ADC_READ (INT KENH) 
....................  { 
....................     UNSIGNED INT8 ANALOG_PORT[] = {1, 2, 4, 8, 16, 32, 64}; 
....................     SETUP_ADC_PORTS (ANALOG_PORT[KENH]); 
....................     DELAY_MS (3) ; 
....................     SET_ADC_CHANNEL (KENH); 
....................     DELAY_MS (3) ; 
....................     KQADC = 0; 
....................     FOR (INT I = 0; I < 100; I++) 
....................     { 
....................        KQADC = KQADC + READ_ADC () ; 
....................        DELAY_MS (1); 
....................     } 
....................  
....................     KQADC = KQADC / (100 * 2.046); 
....................     RETURN KQADC; 
....................  } 
....................  
....................  VOID READ_ANALOG () 
....................  { 
....................     FOR (INT K = 0; K < SOLUONGCAMBIEN_CONFIG; K++) 
....................     { 
....................        KET_QUA_ANALOG[K] = ADC_READ (K); 
....................     } 
....................  } 
....................  
....................  VOID SEND_ANALOG_UART () 
....................  { 
....................     OUTPUT_TOGGLE (PIN_C4) ; 
....................     //CHAR * PACKAGE_SS[] ={" * ", "26", "SS", "IDGW12", "NODE", "ZZ", "AA", "VV", "CC", "SS"}; 
....................     CHAR * PACKAGE_SS[] ={"IDGW12", "NODE", "ZZ", "AA", "VV", "CC", "SS"}; 
....................     PACKAGE_SS[0] = ID_GATEWAY_CHAR; 
....................     PACKAGE_SS[1] = ID_NODE_CHAR; 
....................     UNSIGNED INT8 DO_DAI = 20; 
....................      
....................     FOR (INT I = 0; I < SOLUONGCAMBIEN_CONFIG; I++) 
....................     { 
....................        ITOA (KET_QUA_ANALOG[I], 10, PACKAGE_SS[2 + I]) ; 
....................        DO_DAI = DO_DAI + 3; 
....................     } 
....................  
....................     ITOA (DO_DAI, 10, TEMP_CHAR2) ; 
....................     PRINTF (" * @"); 
....................     PRINTF (TEMP_CHAR2); 
....................     PRINTF ("@SS@"); 
....................     FOR (I = 0; I < 2 + SOLUONGCAMBIEN_CONFIG; I++) 
....................     { 
....................        PRINTF (PACKAGE_SS[I]); 
....................        PRINTF ("@"); 
....................     } 
....................  
....................     PRINTF ("#"); 
....................     OUTPUT_TOGGLE (PIN_C4) ; 
....................  } 
....................  
.................... */ 
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
.................... VOID QUET_PHIM() 
*
010D:  BSF    03.6
010E:  CLRF   64
.................... { 
....................    INT BDT = 0; 
....................    WHILE (!INPUT (BT1_PIN)) //NEU NUT BAM DUOC BAM 
010F:  BSF    03.5
0110:  BCF    03.6
0111:  BSF    06.1
0112:  BCF    03.5
0113:  BTFSC  06.1
0114:  GOTO   12A
....................    { 
....................       IF (TMR1IF) 
0115:  BTFSS  0C.0
0116:  GOTO   127
....................       { 
....................          OUTPUT_TOGGLE (PIN_C4); 
0117:  BCF    31.4
0118:  MOVF   31,W
0119:  BSF    03.5
011A:  MOVWF  07
011B:  MOVLW  10
011C:  BCF    03.5
011D:  XORWF  07,F
....................          TMR1IF = 0; SET_TIMER1 (3036); BDT++; 
011E:  BCF    0C.0
011F:  CLRF   0E
0120:  MOVLW  0B
0121:  MOVWF  0F
0122:  MOVLW  DC
0123:  MOVWF  0E
0124:  BSF    03.6
0125:  INCF   64,F
0126:  BCF    03.6
....................       } 
0127:  BSF    03.6
0128:  GOTO   10F
0129:  BCF    03.6
....................    } 
....................  
....................    IF (BDT > 20) 
012A:  BSF    03.6
012B:  MOVF   64,W
012C:  SUBLW  14
012D:  BTFSC  03.0
012E:  GOTO   138
....................    { 
....................       //CONFIG NODE 
....................       TT_CONFIG = ~TT_CONFIG; // VAO TRANG THAI CONFIG 
012F:  MOVLW  02
0130:  BCF    03.6
0131:  XORWF  4E,F
....................       TT_CONTROL = ~TT_CONTROL; 
0132:  MOVLW  04
0133:  XORWF  4E,F
....................       //CONFIG_DONE (); 
....................       TT_CONFIG_DONE = 1; 
0134:  BSF    4E.3
....................       TT_FUN = 0; 
0135:  BCF    4E.4
....................    } 
0136:  GOTO   14F
0137:  BSF    03.6
....................  
....................    ELSE IF (BDT > 1&&BDT < 20) 
0138:  MOVF   64,W
0139:  SUBLW  01
013A:  BTFSC  03.0
013B:  GOTO   146
013C:  MOVF   64,W
013D:  SUBLW  13
013E:  BTFSS  03.0
013F:  GOTO   146
....................    { 
....................       BUTT_OKE (); //OKE 
....................    } 
*
0144:  GOTO   14F
0145:  BSF    03.6
....................  
....................    ELSE 
....................    {             
....................       //TMR1IF = 0; SET_TIMER1 (0);       
....................       TT_SW = 1; 
0146:  BCF    03.6
0147:  BSF    4E.7
....................       OUTPUT_TOGGLE (PIN_C4); 
0148:  BCF    31.4
0149:  MOVF   31,W
014A:  BSF    03.5
014B:  MOVWF  07
014C:  MOVLW  10
014D:  BCF    03.5
014E:  XORWF  07,F
....................       //READ_BTN_STATE () ;       
....................    } 
.................... } 
....................  
.................... #INT_EXT 
....................  
....................  VOID NGAT_NGOAI  () 
....................  { 
....................     QUET_PHIM (); 
....................  } 
....................  
014F:  BCF    0B.1
0150:  BCF    0A.3
0151:  BCF    0A.4
0152:  GOTO   031
....................  #INT_RDA 
....................  VOID NGAT  () 
....................  { 
....................     KYTUCHAR[VT] = GETCH (); 
0153:  MOVLW  A0
0154:  ADDWF  39,W
0155:  MOVWF  04
0156:  BCF    03.7
0157:  BTFSS  0C.5
0158:  GOTO   157
0159:  MOVF   1A,W
015A:  MOVWF  00
....................  
....................     IF (KYTUCHAR[VT] == '.') 
015B:  MOVLW  A0
015C:  ADDWF  39,W
015D:  MOVWF  04
015E:  BCF    03.7
015F:  MOVF   00,W
0160:  SUBLW  2E
0161:  BTFSS  03.2
0162:  GOTO   16B
....................     { 
....................        KYTUCHAR[VT] = '\0'; 
0163:  MOVLW  A0
0164:  ADDWF  39,W
0165:  MOVWF  04
0166:  BCF    03.7
0167:  CLRF   00
....................        VT = 0; 
0168:  CLRF   39
....................        TTNHAN = 1; 
0169:  BSF    4E.0
....................     } 
016A:  GOTO   16C
....................  
....................     ELSE 
....................     VT++; 
016B:  INCF   39,F
016C:  BCF    0C.5
016D:  BCF    0A.3
016E:  BCF    0A.4
016F:  GOTO   031
....................  } 
....................  
....................  VOID XU_LY_UART () 
*
0D3F:  MOVLW  2A
0D40:  BSF    03.6
0D41:  MOVWF  10
....................  { 
....................     //ID_NODE_NHAN = KYTU[1] - 48; 
....................     //ID_DEVICE_NHAN = KYTU[2] - 48 + 64; 
....................     //TT_DEVICE_NHAN = KYTU[3] - 48; // - 48 ASCII -- > S?. + 64 -- > PORT_D (D0 = 64) 
....................     /* TINH DO DAI*/ 
....................     CHAR CH = '*'; 
....................     CHAR * RET; 
....................     * ID_NODE_NHAN = '\0'; 
0D42:  CLRF   7A
0D43:  MOVLW  5F
0D44:  MOVWF  04
0D45:  BCF    03.7
0D46:  BTFSC  7A.0
0D47:  BSF    03.7
0D48:  CLRF   00
....................     * ID_GW_NHAN = '\0'; 
0D49:  CLRF   7A
0D4A:  MOVLW  66
0D4B:  MOVWF  04
0D4C:  BCF    03.7
0D4D:  BTFSC  7A.0
0D4E:  BSF    03.7
0D4F:  CLRF   00
....................     KYTUCHAR2 = ""; 
0D50:  CLRF   16
0D51:  CLRF   17
0D52:  MOVLW  D2
0D53:  MOVWF  04
0D54:  BCF    03.7
0D55:  MOVF   16,W
0D56:  ADDWF  04,F
0D57:  MOVF   17,W
0D58:  BCF    0A.3
0D59:  BCF    03.6
0D5A:  CALL   07F
0D5B:  BSF    0A.3
0D5C:  MOVWF  00
0D5D:  IORLW  00
0D5E:  BTFSC  03.2
0D5F:  GOTO   565
0D60:  BSF    03.6
0D61:  INCF   17,F
0D62:  INCF   16,F
0D63:  GOTO   552
0D64:  BCF    03.6
....................     UNSIGNED INT8 LEN_RET; 
....................     RET = STRCHR (KYTUCHAR, CH); 
0D65:  BSF    03.6
0D66:  CLRF   17
0D67:  MOVLW  A0
0D68:  MOVWF  16
0D69:  MOVF   10,W
0D6A:  MOVWF  18
*
0D8C:  MOVF   79,W
0D8D:  MOVWF  12
0D8E:  MOVF   78,W
0D8F:  MOVWF  11
....................     LEN_RET = STRLEN (RET); 
0D90:  MOVF   12,W
0D91:  MOVWF  17
0D92:  MOVF   11,W
0D93:  MOVWF  16
*
0DB1:  MOVF   78,W
0DB2:  MOVWF  13
....................  
....................     /* LAY TOKEN DAU TIEN */ 
....................     KYTU = 0; 
0DB3:  BCF    03.6
0DB4:  CLRF   3A
....................     TEMP_CHAR = "#"; 
0DB5:  BSF    03.6
0DB6:  CLRF   16
0DB7:  CLRF   17
0DB8:  MOVLW  6F
0DB9:  MOVWF  04
0DBA:  BCF    03.7
0DBB:  MOVF   16,W
0DBC:  ADDWF  04,F
0DBD:  MOVF   17,W
0DBE:  BCF    0A.3
0DBF:  BCF    03.6
0DC0:  CALL   079
0DC1:  BSF    0A.3
0DC2:  MOVWF  00
0DC3:  IORLW  00
0DC4:  BTFSC  03.2
0DC5:  GOTO   5CB
0DC6:  BSF    03.6
0DC7:  INCF   17,F
0DC8:  INCF   16,F
0DC9:  GOTO   5B8
0DCA:  BCF    03.6
....................     CHAR * TOKEN; 
....................     TOKEN = STRTOK (KYTUCHAR, TEMP_CHAR); 
0DCB:  BSF    03.6
0DCC:  CLRF   19
0DCD:  MOVLW  A0
0DCE:  MOVWF  18
0DCF:  CLRF   1B
0DD0:  MOVLW  6F
0DD1:  MOVWF  1A
0DD2:  BCF    03.6
0DD3:  CALL   138
0DD4:  MOVF   79,W
0DD5:  BSF    03.6
0DD6:  MOVWF  15
0DD7:  MOVF   78,W
0DD8:  MOVWF  14
....................  
....................     /* DUYET QUA CAC TOKEN CON LAI */ 
....................     WHILE (TOKEN != NULL) 
0DD9:  MOVF   14,F
0DDA:  BTFSS  03.2
0DDB:  GOTO   5DF
0DDC:  MOVF   15,F
0DDD:  BTFSC  03.2
0DDE:  GOTO   632
....................     { 
....................        SWITCH (KYTU) 
0DDF:  BCF    03.6
0DE0:  MOVF   3A,W
0DE1:  ADDLW  FA
0DE2:  BTFSC  03.0
0DE3:  GOTO   621
0DE4:  ADDLW  06
0DE5:  GOTO   76B
....................        { 
....................           CASE 0: 
....................           BREAK; 
0DE6:  GOTO   621
....................  
....................           CASE 1: 
....................           STRCAT (ID_GW_NHAN, TOKEN); 
0DE7:  BSF    03.6
0DE8:  CLRF   3F
0DE9:  MOVLW  66
0DEA:  MOVWF  3E
0DEB:  MOVF   15,W
0DEC:  MOVWF  41
0DED:  MOVF   14,W
0DEE:  MOVWF  40
0DEF:  BCF    0A.3
0DF0:  BCF    03.6
0DF1:  CALL   75B
0DF2:  BSF    0A.3
....................           BREAK; 
0DF3:  GOTO   621
....................  
....................           CASE 2: 
....................           STRCAT (ID_NODE_NHAN, TOKEN); 
0DF4:  BSF    03.6
0DF5:  CLRF   3F
0DF6:  MOVLW  5F
0DF7:  MOVWF  3E
0DF8:  MOVF   15,W
0DF9:  MOVWF  41
0DFA:  MOVF   14,W
0DFB:  MOVWF  40
0DFC:  BCF    0A.3
0DFD:  BCF    03.6
0DFE:  CALL   75B
0DFF:  BSF    0A.3
....................           BREAK; 
0E00:  GOTO   621
....................  
....................           CASE 3: 
....................           LENHDIEUKHIEN = ATOI (TOKEN); 
0E01:  BSF    03.6
0E02:  MOVF   15,W
0E03:  MOVWF  19
0E04:  MOVF   14,W
0E05:  MOVWF  18
0E06:  BCF    03.6
0E07:  CALL   229
0E08:  MOVF   78,W
0E09:  MOVWF  47
....................           BREAK; 
0E0A:  GOTO   621
....................  
....................           CASE 4: 
....................           DODAI_DATA_NHAN = ATOI (TOKEN); 
0E0B:  BSF    03.6
0E0C:  MOVF   15,W
0E0D:  MOVWF  19
0E0E:  MOVF   14,W
0E0F:  MOVWF  18
0E10:  BCF    03.6
0E11:  CALL   229
0E12:  MOVF   78,W
0E13:  MOVWF  48
....................           BREAK; 
0E14:  GOTO   621
....................  
....................           CASE 5: 
....................           STRCAT (KYTUCHAR2, TOKEN); 
0E15:  BSF    03.6
0E16:  CLRF   3F
0E17:  MOVLW  D2
0E18:  MOVWF  3E
0E19:  MOVF   15,W
0E1A:  MOVWF  41
0E1B:  MOVF   14,W
0E1C:  MOVWF  40
0E1D:  BCF    0A.3
0E1E:  BCF    03.6
0E1F:  CALL   75B
0E20:  BSF    0A.3
....................           BREAK; 
....................        } 
....................  
....................        TOKEN = STRTOK (NULL, TEMP_CHAR); 
0E21:  BSF    03.6
0E22:  CLRF   19
0E23:  CLRF   18
0E24:  CLRF   1B
0E25:  MOVLW  6F
0E26:  MOVWF  1A
0E27:  BCF    03.6
0E28:  CALL   138
0E29:  MOVF   79,W
0E2A:  BSF    03.6
0E2B:  MOVWF  15
0E2C:  MOVF   78,W
0E2D:  MOVWF  14
....................        KYTU++; 
0E2E:  BCF    03.6
0E2F:  INCF   3A,F
0E30:  BSF    03.6
0E31:  GOTO   5D9
....................     } 
....................  
....................     /* SO SANH ID returns - 1 IF s1 < s2, 0 if s1 = s2, 1 if s1 > s2 */ 
....................     SOSANH_IDGW = STRCMP (ID_GW_NHAN, ID_GATEWAY_CHAR); 
0E32:  CLRF   17
0E33:  MOVLW  66
0E34:  MOVWF  16
0E35:  CLRF   19
0E36:  MOVLW  56
0E37:  MOVWF  18
0E38:  BCF    03.6
0E39:  CALL   30C
0E3A:  MOVF   78,W
0E3B:  MOVWF  4C
....................     SOSANH_IDNODE = STRCMP (ID_NODE_NHAN, ID_NODE_CHAR); 
0E3C:  BSF    03.6
0E3D:  CLRF   17
0E3E:  MOVLW  5F
0E3F:  MOVWF  16
0E40:  CLRF   19
0E41:  MOVLW  4F
0E42:  MOVWF  18
0E43:  BCF    03.6
0E44:  CALL   30C
0E45:  MOVF   78,W
0E46:  MOVWF  4B
....................      
....................     IF (SOSANH_IDGW == 0&&SOSANH_IDNODE == 0&&LEN_RET == DODAI_DATA_NHAN) 
0E47:  MOVF   4C,F
0E48:  BTFSS  03.2
0E49:  GOTO   761
0E4A:  MOVF   4B,F
0E4B:  BTFSS  03.2
0E4C:  GOTO   761
0E4D:  MOVF   48,W
0E4E:  BSF    03.6
0E4F:  SUBWF  13,W
0E50:  BTFSC  03.2
0E51:  GOTO   654
0E52:  BCF    03.6
0E53:  GOTO   761
....................     { 
....................        SWITCH (LENHDIEUKHIEN) 
0E54:  BCF    03.6
0E55:  MOVF   47,W
0E56:  BTFSC  03.2
0E57:  GOTO   65F
0E58:  XORLW  01
0E59:  BTFSC  03.2
0E5A:  GOTO   660
0E5B:  XORLW  03
0E5C:  BTFSC  03.2
0E5D:  GOTO   73B
0E5E:  GOTO   760
....................        { 
....................           CASE 0: 
....................           BREAK; 
0E5F:  GOTO   760
....................  
....................           CASE 1: 
....................           XACNHANCONFIG () ; 
....................           BREAK; 
*
0F3A:  GOTO   760
....................  
....................           CASE 2: 
....................           DIEUKHIENTHIETBI () ; 
....................           BREAK; 
....................        } 
....................     } 
*
0F60:  GOTO   768
....................  
....................     ELSE 
....................     { 
....................        DELAY_MS (10); 
0F61:  MOVLW  0A
0F62:  BSF    03.6
0F63:  MOVWF  41
0F64:  BCF    0A.3
0F65:  BCF    03.6
0F66:  CALL   170
0F67:  BSF    0A.3
....................  
....................        /* DATA RCV SAI ID NODE, ID GW HOAC LA SAI DO DAI*/ 
....................     } 
0F68:  BCF    0A.3
0F69:  BSF    0A.4
0F6A:  GOTO   366 (RETURN)
....................  
....................  } 
....................  
....................  VOID MAIN () 
*
1279:  MOVF   03,W
127A:  ANDLW  1F
127B:  MOVWF  03
127C:  BSF    03.5
127D:  BSF    03.6
127E:  BSF    07.3
127F:  MOVLW  08
1280:  BCF    03.6
1281:  MOVWF  19
1282:  MOVLW  02
1283:  MOVWF  1A
1284:  MOVLW  A6
1285:  MOVWF  18
1286:  MOVLW  90
1287:  BCF    03.5
1288:  MOVWF  18
1289:  MOVLW  FF
128A:  MOVWF  31
128B:  CLRF   38
128C:  CLRF   39
128D:  CLRF   3A
128E:  CLRF   3B
128F:  CLRF   46
1290:  CLRF   47
1291:  CLRF   48
1292:  CLRF   49
1293:  MOVLW  03
1294:  MOVWF  4A
1295:  CLRF   4B
1296:  CLRF   4C
1297:  BCF    4E.0
1298:  BCF    4E.1
1299:  BCF    4E.2
129A:  BCF    4E.3
129B:  BCF    4E.4
129C:  BCF    4E.5
129D:  BCF    4E.6
129E:  BCF    4E.7
129F:  BSF    03.5
12A0:  BSF    03.6
12A1:  MOVF   09,W
12A2:  ANDLW  C0
12A3:  MOVWF  09
12A4:  BCF    03.6
12A5:  BCF    1F.4
12A6:  BCF    1F.5
12A7:  MOVLW  00
12A8:  BSF    03.6
12A9:  MOVWF  08
12AA:  BCF    03.5
12AB:  CLRF   07
12AC:  CLRF   08
12AD:  CLRF   09
12AE:  BCF    03.7
....................  { 
....................     SET_TRIS_D (0XF0); 
*
1322:  MOVLW  F0
1323:  MOVWF  08
....................     SET_TRIS_B (0XFF); 
1324:  MOVLW  FF
1325:  MOVWF  06
....................     SET_TRIS_E (0); 
1326:  BCF    09.0
1327:  BCF    09.1
1328:  BCF    09.2
1329:  BCF    09.3
....................     SET_TRIS_C (0X80); 
132A:  MOVLW  80
132B:  MOVWF  07
132C:  BCF    03.5
132D:  MOVWF  31
....................     SETUP_ADC (ADC_CLOCK_DIV_8); 
132E:  BSF    1F.6
132F:  BCF    1F.7
1330:  BSF    03.5
1331:  BSF    1F.7
1332:  BCF    03.5
1333:  BSF    1F.0
....................     ENABLE_INTERRUPTS (INT_TIMER0); 
1334:  BSF    0B.5
....................     ENABLE_INTERRUPTS (INT_EXT); //CHO PHEP NGAT NGOAI 
1335:  BSF    0B.4
....................     ENABLE_INTERRUPTS (INT_EXT_H2L); //NGAT XAY RA KHI CO XUNG TU CAO XUONG THAP 
1336:  BSF    0B.4
1337:  BSF    03.5
1338:  BCF    01.6
....................     ENABLE_INTERRUPTS (INT_RDA); 
1339:  BSF    0C.5
....................     ENABLE_INTERRUPTS (GLOBAL); 
133A:  MOVLW  C0
133B:  BCF    03.5
133C:  IORWF  0B,F
....................      
....................     SETUP_TIMER_1 (T1_INTERNAL|T1_DIV_BY_8); 
133D:  MOVLW  35
133E:  MOVWF  10
....................     //SET_TIMER1 (0); 
....................     SET_TIMER1 (3036); 
133F:  CLRF   0E
1340:  MOVLW  0B
1341:  MOVWF  0F
1342:  MOVLW  DC
1343:  MOVWF  0E
....................     TMR1IF = 0; 
1344:  BCF    0C.0
....................     LCD_INIT (); // KHOI TAO LCD 
1345:  BCF    0A.4
1346:  GOTO   28A
1347:  BSF    0A.4
....................     TT_CONFIG = 0; 
1348:  BCF    4E.1
....................     TT_CONFIG_DONE = 0; 
1349:  BCF    4E.3
....................     TT_CONTROL = 1; 
134A:  BSF    4E.2
....................     OUTPUT_HIGH (PIN_D3) ; 
134B:  BSF    03.5
134C:  BCF    08.3
134D:  BCF    03.5
134E:  BSF    08.3
....................     TTNHAN = 0; 
134F:  BCF    4E.0
....................  
....................  
....................      
....................     WHILE (TRUE) 
....................     { 
....................        IF (TT_CONFIG)   {BUTT_FUN (); } // GOI HAM CHON LENH (SWITCH CASE) 
1350:  BTFSS  4E.1
1351:  GOTO   356
1352:  BCF    0A.4
1353:  GOTO   55E
1354:  BSF    0A.4
1355:  GOTO   392
....................        ELSE IF (TT_CONFIG_DONE) { CONFIG_DONE (); } 
1356:  BTFSS  4E.3
1357:  GOTO   35E
1358:  BCF    0A.4
1359:  BSF    0A.3
135A:  GOTO   000
135B:  BSF    0A.4
135C:  BCF    0A.3
135D:  GOTO   392
....................        ELSE 
....................        { 
....................           WHILE (!TT_CONFIG) 
135E:  BTFSC  4E.1
135F:  GOTO   392
....................           { 
....................              IF (TTNHAN == 1) 
1360:  BTFSS  4E.0
1361:  GOTO   368
....................              { 
....................                 TTNHAN = 0; 
1362:  BCF    4E.0
....................                 XU_LY_UART () ; 
1363:  BCF    0A.4
1364:  BSF    0A.3
1365:  GOTO   53F
1366:  BSF    0A.4
1367:  BCF    0A.3
....................              } 
....................              IF (TT_CONFIG_OKE_UART == 1) 
1368:  BTFSS  4E.6
1369:  GOTO   391
....................              { 
....................                  
....................                IF (TT_SW) 
136A:  BTFSS  4E.7
136B:  GOTO   377
....................                { 
....................                   READ_BTN_STATE(); 
136C:  BCF    0A.4
136D:  BSF    0A.3
136E:  GOTO   775
136F:  BSF    0A.4
1370:  BCF    0A.3
....................                   TT_SW = 0;              
1371:  BCF    4E.7
....................                   XUAT_DIEU_KHIEN();               
1372:  BCF    0A.4
1373:  BSF    0A.3
1374:  CALL   3BD
1375:  BSF    0A.4
1376:  BCF    0A.3
....................                }                 
....................                 DELAY_MS (100) ; 
1377:  MOVLW  64
1378:  BSF    03.6
1379:  MOVWF  41
137A:  BCF    0A.4
137B:  BCF    03.6
137C:  CALL   170
137D:  BSF    0A.4
....................                 READ_ANALOG () ; 
137E:  GOTO   000
....................  
....................                 IF (KET_QUA_ANALOG[0] > 28) 
137F:  MOVF   34,W
1380:  SUBLW  1C
1381:  BTFSC  03.0
1382:  GOTO   391
....................                 { 
....................                    SEND_ANALOG_UART () ; 
1383:  GOTO   1A9
....................                    DELAY_MS (2000) ; 
1384:  MOVLW  08
1385:  BSF    03.6
1386:  MOVWF  10
1387:  MOVLW  FA
1388:  MOVWF  41
1389:  BCF    0A.4
138A:  BCF    03.6
138B:  CALL   170
138C:  BSF    0A.4
138D:  BSF    03.6
138E:  DECFSZ 10,F
138F:  GOTO   387
1390:  BCF    03.6
....................                 } 
....................              } 
1391:  GOTO   35E
....................           } 
....................        } 
1392:  GOTO   350
....................     } 
....................  } 
....................  
1393:  SLEEP

Configuration Fuses:
   Word  1: 2FE2   HS NOWDT PUT MCLR NOPROTECT NOCPD BROWNOUT IESO FCMEN NOLVP NODEBUG
   Word  2: 3FFF   BORV40 NOWRT
