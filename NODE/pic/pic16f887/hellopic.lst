CCS PCM C Compiler, Version 5.015, 5967               27-Oct-21 21:08

               Filename:   E:\DATN\NODE\pic\pic16f887\hellopic.lst

               ROM used:   3325 words (41%)
                           Largest free fragment is 2048
               RAM used:   142 (39%) at main() level
                           194 (53%) worst case
               Stack used: 7 locations (6 in main + 1 for interrupts)
               Stack size: 8

*
0000:  MOVLW  0B
0001:  MOVWF  0A
0002:  GOTO   354
0003:  NOP
0004:  MOVWF  7F
0005:  SWAPF  03,W
0006:  CLRF   03
0007:  MOVWF  21
0008:  MOVF   0A,W
0009:  MOVWF  20
000A:  CLRF   0A
000B:  MOVF   04,W
000C:  MOVWF  22
000D:  MOVF   77,W
000E:  MOVWF  23
000F:  MOVF   78,W
0010:  MOVWF  24
0011:  MOVF   79,W
0012:  MOVWF  25
0013:  MOVF   7A,W
0014:  MOVWF  26
0015:  BSF    03.6
0016:  MOVF   0D,W
0017:  BCF    03.6
0018:  MOVWF  27
0019:  BSF    03.6
001A:  MOVF   0F,W
001B:  BCF    03.6
001C:  MOVWF  28
001D:  BSF    03.6
001E:  MOVF   0C,W
001F:  BCF    03.6
0020:  MOVWF  29
0021:  BSF    03.6
0022:  MOVF   0E,W
0023:  BCF    03.6
0024:  MOVWF  2A
0025:  BCF    03.7
0026:  BCF    03.5
0027:  BTFSS  0B.4
0028:  GOTO   02B
0029:  BTFSC  0B.1
002A:  GOTO   052
002B:  MOVLW  8C
002C:  MOVWF  04
002D:  BTFSS  00.5
002E:  GOTO   031
002F:  BTFSC  0C.5
0030:  GOTO   055
0031:  MOVF   22,W
0032:  MOVWF  04
0033:  MOVF   23,W
0034:  MOVWF  77
0035:  MOVF   24,W
0036:  MOVWF  78
0037:  MOVF   25,W
0038:  MOVWF  79
0039:  MOVF   26,W
003A:  MOVWF  7A
003B:  MOVF   27,W
003C:  BSF    03.6
003D:  MOVWF  0D
003E:  BCF    03.6
003F:  MOVF   28,W
0040:  BSF    03.6
0041:  MOVWF  0F
0042:  BCF    03.6
0043:  MOVF   29,W
0044:  BSF    03.6
0045:  MOVWF  0C
0046:  BCF    03.6
0047:  MOVF   2A,W
0048:  BSF    03.6
0049:  MOVWF  0E
004A:  BCF    03.6
004B:  MOVF   20,W
004C:  MOVWF  0A
004D:  SWAPF  21,W
004E:  MOVWF  03
004F:  SWAPF  7F,F
0050:  SWAPF  7F,W
0051:  RETFIE
0052:  BCF    0A.3
0053:  BCF    0A.4
0054:  GOTO   0C9
0055:  BCF    0A.3
0056:  BCF    0A.4
0057:  GOTO   0FA
....................  
.................... #INCLUDE <thuvien.c> 
.................... #INCLUDE <16F887.H> 
.................... //////////// Standard Header file for the PIC16F887 device //////////////// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2013 Custom Computer Services          //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... #device PIC16F887 
0058:  BCF    0A.0
0059:  BCF    0A.1
005A:  BCF    0A.2
005B:  ADDWF  02,F
005C:  RETLW  30
005D:  RETLW  00
005E:  BCF    0A.0
005F:  BCF    0A.1
0060:  BCF    0A.2
0061:  ADDWF  02,F
0062:  RETLW  5F
0063:  RETLW  00
0064:  DATA CE,27
0065:  DATA C4,22
0066:  DATA 3A,10
0067:  DATA 00,00
0068:  DATA 30,18
0069:  DATA 30,18
006A:  DATA 00,01
006B:  DATA 20,10
006C:  DATA 20,10
006D:  DATA 20,10
006E:  DATA 5F,10
006F:  DATA 20,10
0070:  DATA 20,10
0071:  DATA 20,10
0072:  DATA 20,10
0073:  DATA 20,10
0074:  DATA 20,10
0075:  DATA 20,00
0076:  DATA 20,10
0077:  DATA 20,10
0078:  DATA 5F,10
0079:  DATA 20,10
007A:  DATA 20,00
007B:  DATA 49,22
007C:  DATA DF,23
007D:  DATA 57,1D
007E:  DATA 00,01
007F:  DATA 30,18
0080:  DATA 30,18
0081:  DATA 30,18
0082:  DATA 00,01
0083:  DATA 20,10
0084:  DATA 20,10
0085:  DATA 20,10
0086:  DATA 5F,10
0087:  DATA 20,10
0088:  DATA 20,10
0089:  DATA 20,10
008A:  DATA 20,10
008B:  DATA 20,10
008C:  DATA 20,10
008D:  DATA 20,10
008E:  DATA 20,00
008F:  DATA 20,10
0090:  DATA 20,10
0091:  DATA 5F,10
0092:  DATA 20,10
0093:  DATA 20,00
0094:  DATA C3,27
0095:  DATA 4E,23
0096:  DATA C9,23
0097:  DATA 3A,10
0098:  DATA 20,10
0099:  DATA 20,10
009A:  DATA 20,10
009B:  DATA 20,00
009C:  DATA C3,20
009D:  DATA D3,22
009E:  DATA 3A,10
009F:  DATA 20,10
00A0:  DATA 20,10
00A1:  DATA 20,10
00A2:  DATA 20,10
00A3:  DATA 20,00
00A4:  DATA A0,16
00A5:  DATA A0,24
00A6:  DATA C4,16
00A7:  DATA CE,27
00A8:  DATA C4,22
00A9:  DATA 20,10
00AA:  DATA 20,10
00AB:  DATA 20,10
00AC:  DATA 00,01
00AD:  DATA A0,16
00AE:  DATA A0,24
00AF:  DATA C4,16
00B0:  DATA C7,2B
00B1:  DATA 20,10
00B2:  DATA 20,10
00B3:  DATA 20,10
00B4:  DATA 20,00
00B5:  DATA C3,27
00B6:  DATA 4E,23
00B7:  DATA C9,23
00B8:  DATA 20,22
00B9:  DATA 4F,27
00BA:  DATA 45,10
00BB:  DATA 20,10
00BC:  DATA 20,10
00BD:  DATA 20,10
00BE:  DATA 20,00
00BF:  DATA C3,27
00C0:  DATA 4E,23
00C1:  DATA C9,23
00C2:  DATA 20,22
00C3:  DATA 4F,27
00C4:  DATA 45,10
00C5:  DATA 20,10
00C6:  DATA 20,10
00C7:  DATA 20,10
00C8:  DATA 20,00
*
02D6:  MOVF   0B,W
02D7:  BSF    03.5
02D8:  MOVWF  55
02D9:  BCF    03.5
02DA:  BCF    0B.7
02DB:  BSF    03.5
02DC:  BSF    03.6
02DD:  BSF    0C.7
02DE:  BSF    0C.0
02DF:  NOP
02E0:  NOP
02E1:  BCF    03.6
02E2:  BTFSS  55.7
02E3:  GOTO   2E7
02E4:  BCF    03.5
02E5:  BSF    0B.7
02E6:  BSF    03.5
02E7:  BCF    03.5
02E8:  BSF    03.6
02E9:  MOVF   0C,W
02EA:  ANDLW  7F
02EB:  BTFSC  03.2
02EC:  GOTO   348
02ED:  BSF    03.5
02EE:  BCF    03.6
02EF:  MOVWF  55
02F0:  BCF    03.5
02F1:  BSF    03.6
02F2:  MOVF   0D,W
02F3:  BSF    03.5
02F4:  BCF    03.6
02F5:  MOVWF  56
02F6:  BCF    03.5
02F7:  BSF    03.6
02F8:  MOVF   0F,W
02F9:  BSF    03.5
02FA:  BCF    03.6
02FB:  MOVWF  57
02FC:  MOVF   55,W
02FD:  MOVWF  58
02FE:  BCF    03.5
02FF:  CALL   29C
0300:  BSF    03.5
0301:  MOVF   56,W
0302:  BCF    03.5
0303:  BSF    03.6
0304:  MOVWF  0D
0305:  BSF    03.5
0306:  BCF    03.6
0307:  MOVF   57,W
0308:  BCF    03.5
0309:  BSF    03.6
030A:  MOVWF  0F
030B:  BCF    03.6
030C:  MOVF   0B,W
030D:  BSF    03.5
030E:  MOVWF  58
030F:  BCF    03.5
0310:  BCF    0B.7
0311:  BSF    03.5
0312:  BSF    03.6
0313:  BSF    0C.7
0314:  BSF    0C.0
0315:  NOP
0316:  NOP
0317:  BCF    03.6
0318:  BTFSS  58.7
0319:  GOTO   31D
031A:  BCF    03.5
031B:  BSF    0B.7
031C:  BSF    03.5
031D:  BCF    03.5
031E:  BSF    03.6
031F:  RLF    0C,W
0320:  RLF    0E,W
0321:  ANDLW  7F
0322:  BTFSC  03.2
0323:  GOTO   348
0324:  BSF    03.5
0325:  BCF    03.6
0326:  MOVWF  55
0327:  BCF    03.5
0328:  BSF    03.6
0329:  MOVF   0D,W
032A:  BSF    03.5
032B:  BCF    03.6
032C:  MOVWF  56
032D:  BCF    03.5
032E:  BSF    03.6
032F:  MOVF   0F,W
0330:  BSF    03.5
0331:  BCF    03.6
0332:  MOVWF  57
0333:  MOVF   55,W
0334:  MOVWF  58
0335:  BCF    03.5
0336:  CALL   29C
0337:  BSF    03.5
0338:  MOVF   56,W
0339:  BCF    03.5
033A:  BSF    03.6
033B:  MOVWF  0D
033C:  BSF    03.5
033D:  BCF    03.6
033E:  MOVF   57,W
033F:  BCF    03.5
0340:  BSF    03.6
0341:  MOVWF  0F
0342:  INCF   0D,F
0343:  BTFSC  03.2
0344:  INCF   0F,F
0345:  BCF    03.6
0346:  GOTO   2D6
0347:  BSF    03.6
0348:  BCF    03.6
0349:  RETURN
034A:  BTFSC  03.1
034B:  GOTO   34F
034C:  MOVLW  20
034D:  MOVWF  04
034E:  BSF    03.7
034F:  BSF    03.6
0350:  MOVF   1B,W
0351:  XORWF  1F,W
0352:  ANDLW  80
0353:  MOVWF  25
0354:  BTFSS  1B.7
0355:  GOTO   361
0356:  COMF   18,F
0357:  COMF   19,F
0358:  COMF   1A,F
0359:  COMF   1B,F
035A:  INCF   18,F
035B:  BTFSC  03.2
035C:  INCF   19,F
035D:  BTFSC  03.2
035E:  INCF   1A,F
035F:  BTFSC  03.2
0360:  INCF   1B,F
0361:  BTFSS  1F.7
0362:  GOTO   36E
0363:  COMF   1C,F
0364:  COMF   1D,F
0365:  COMF   1E,F
0366:  COMF   1F,F
0367:  INCF   1C,F
0368:  BTFSC  03.2
0369:  INCF   1D,F
036A:  BTFSC  03.2
036B:  INCF   1E,F
036C:  BTFSC  03.2
036D:  INCF   1F,F
036E:  CLRF   77
036F:  CLRF   78
0370:  CLRF   79
0371:  CLRF   7A
0372:  CLRF   20
0373:  CLRF   21
0374:  CLRF   22
0375:  CLRF   23
0376:  MOVF   1F,W
0377:  IORWF  1E,W
0378:  IORWF  1D,W
0379:  IORWF  1C,W
037A:  BTFSC  03.2
037B:  GOTO   3AC
037C:  MOVLW  20
037D:  MOVWF  24
037E:  BCF    03.0
037F:  RLF    18,F
0380:  RLF    19,F
0381:  RLF    1A,F
0382:  RLF    1B,F
0383:  RLF    20,F
0384:  RLF    21,F
0385:  RLF    22,F
0386:  RLF    23,F
0387:  MOVF   1F,W
0388:  SUBWF  23,W
0389:  BTFSS  03.2
038A:  GOTO   395
038B:  MOVF   1E,W
038C:  SUBWF  22,W
038D:  BTFSS  03.2
038E:  GOTO   395
038F:  MOVF   1D,W
0390:  SUBWF  21,W
0391:  BTFSS  03.2
0392:  GOTO   395
0393:  MOVF   1C,W
0394:  SUBWF  20,W
0395:  BTFSS  03.0
0396:  GOTO   3A6
0397:  MOVF   1C,W
0398:  SUBWF  20,F
0399:  MOVF   1D,W
039A:  BTFSS  03.0
039B:  INCFSZ 1D,W
039C:  SUBWF  21,F
039D:  MOVF   1E,W
039E:  BTFSS  03.0
039F:  INCFSZ 1E,W
03A0:  SUBWF  22,F
03A1:  MOVF   1F,W
03A2:  BTFSS  03.0
03A3:  INCFSZ 1F,W
03A4:  SUBWF  23,F
03A5:  BSF    03.0
03A6:  RLF    77,F
03A7:  RLF    78,F
03A8:  RLF    79,F
03A9:  RLF    7A,F
03AA:  DECFSZ 24,F
03AB:  GOTO   37E
03AC:  BTFSS  25.7
03AD:  GOTO   3B9
03AE:  COMF   77,F
03AF:  COMF   78,F
03B0:  COMF   79,F
03B1:  COMF   7A,F
03B2:  INCF   77,F
03B3:  BTFSC  03.2
03B4:  INCF   78,F
03B5:  BTFSC  03.2
03B6:  INCF   79,F
03B7:  BTFSC  03.2
03B8:  INCF   7A,F
03B9:  MOVF   20,W
03BA:  MOVWF  00
03BB:  INCF   04,F
03BC:  MOVF   21,W
03BD:  MOVWF  00
03BE:  INCF   04,F
03BF:  MOVF   22,W
03C0:  MOVWF  00
03C1:  INCF   04,F
03C2:  MOVF   23,W
03C3:  MOVWF  00
03C4:  BCF    03.6
03C5:  RETURN
*
03ED:  MOVLW  20
03EE:  MOVWF  1C
03EF:  CLRF   18
03F0:  CLRF   19
03F1:  CLRF   1A
03F2:  CLRF   1B
03F3:  MOVF   13,W
03F4:  MOVWF  7A
03F5:  MOVF   12,W
03F6:  MOVWF  79
03F7:  MOVF   11,W
03F8:  MOVWF  78
03F9:  MOVF   10,W
03FA:  MOVWF  77
03FB:  BCF    03.0
03FC:  BTFSS  77.0
03FD:  GOTO   40C
03FE:  MOVF   14,W
03FF:  ADDWF  18,F
0400:  MOVF   15,W
0401:  BTFSC  03.0
0402:  INCFSZ 15,W
0403:  ADDWF  19,F
0404:  MOVF   16,W
0405:  BTFSC  03.0
0406:  INCFSZ 16,W
0407:  ADDWF  1A,F
0408:  MOVF   17,W
0409:  BTFSC  03.0
040A:  INCFSZ 17,W
040B:  ADDWF  1B,F
040C:  RRF    1B,F
040D:  RRF    1A,F
040E:  RRF    19,F
040F:  RRF    18,F
0410:  RRF    7A,F
0411:  RRF    79,F
0412:  RRF    78,F
0413:  RRF    77,F
0414:  DECFSZ 1C,F
0415:  GOTO   3FB
*
0528:  MOVF   00,F
0529:  BTFSC  03.2
052A:  GOTO   544
052B:  BSF    03.5
052C:  CLRF   56
052D:  MOVF   04,W
052E:  MOVWF  55
052F:  BCF    56.0
0530:  BTFSC  03.7
0531:  BSF    56.0
0532:  MOVF   00,W
0533:  MOVWF  58
0534:  BCF    03.5
0535:  CALL   29C
0536:  BSF    03.5
0537:  MOVF   55,W
0538:  MOVWF  04
0539:  BCF    03.7
053A:  BTFSC  56.0
053B:  BSF    03.7
053C:  INCF   04,F
053D:  BTFSS  03.2
053E:  GOTO   542
053F:  BCF    03.5
0540:  INCF   05,F
0541:  BSF    03.5
0542:  BCF    03.5
0543:  GOTO   528
0544:  RETURN
0545:  BSF    03.5
0546:  MOVF   59,W
0547:  CLRF   78
0548:  SUBWF  58,W
0549:  BTFSC  03.0
054A:  GOTO   54E
054B:  MOVF   58,W
054C:  MOVWF  77
054D:  GOTO   55A
054E:  CLRF   77
054F:  MOVLW  08
0550:  MOVWF  5A
0551:  RLF    58,F
0552:  RLF    77,F
0553:  MOVF   59,W
0554:  SUBWF  77,W
0555:  BTFSC  03.0
0556:  MOVWF  77
0557:  RLF    78,F
0558:  DECFSZ 5A,F
0559:  GOTO   551
055A:  BCF    03.5
055B:  RETURN
*
07C4:  BSF    03.5
07C5:  MOVF   54,W
07C6:  ANDLW  07
07C7:  MOVWF  77
07C8:  RRF    54,W
07C9:  MOVWF  78
07CA:  RRF    78,F
07CB:  RRF    78,F
07CC:  MOVLW  1F
07CD:  ANDWF  78,F
07CE:  MOVF   78,W
07CF:  ADDWF  56,W
07D0:  MOVWF  04
07D1:  BCF    03.7
07D2:  BTFSC  57.0
07D3:  BSF    03.7
07D4:  CLRF   78
07D5:  INCF   78,F
07D6:  INCF   77,F
07D7:  GOTO   7D9
07D8:  RLF    78,F
07D9:  DECFSZ 77,F
07DA:  GOTO   7D8
07DB:  MOVF   55,F
07DC:  BTFSC  03.2
07DD:  GOTO   7E1
07DE:  MOVF   78,W
07DF:  IORWF  00,F
07E0:  GOTO   7E4
07E1:  COMF   78,F
07E2:  MOVF   78,W
07E3:  ANDWF  00,F
07E4:  BCF    03.5
07E5:  RETURN
*
090A:  MOVF   00,F
090B:  BTFSC  03.2
090C:  GOTO   125
090D:  CLRF   58
090E:  MOVF   04,W
090F:  MOVWF  57
0910:  BCF    58.0
0911:  BTFSC  03.7
0912:  BSF    58.0
0913:  MOVF   00,W
0914:  BCF    03.5
0915:  BTFSS  0C.4
0916:  GOTO   115
0917:  MOVWF  19
0918:  BSF    03.5
0919:  MOVF   57,W
091A:  MOVWF  04
091B:  BCF    03.7
091C:  BTFSC  58.0
091D:  BSF    03.7
091E:  INCF   04,F
091F:  BTFSS  03.2
0920:  GOTO   124
0921:  BCF    03.5
0922:  INCF   05,F
0923:  BSF    03.5
0924:  GOTO   10A
*
0AC1:  CLRF   77
0AC2:  CLRF   78
0AC3:  MOVF   5B,W
0AC4:  BCF    03.0
0AC5:  BTFSC  5C.0
0AC6:  ADDWF  77,F
0AC7:  RRF    77,F
0AC8:  RRF    78,F
0AC9:  BTFSC  5C.1
0ACA:  ADDWF  77,F
0ACB:  RRF    77,F
0ACC:  RRF    78,F
0ACD:  BTFSC  5C.2
0ACE:  ADDWF  77,F
0ACF:  RRF    77,F
0AD0:  RRF    78,F
0AD1:  BTFSC  5C.3
0AD2:  ADDWF  77,F
0AD3:  RRF    77,F
0AD4:  RRF    78,F
0AD5:  BTFSC  5C.4
0AD6:  ADDWF  77,F
0AD7:  RRF    77,F
0AD8:  RRF    78,F
0AD9:  BTFSC  5C.5
0ADA:  ADDWF  77,F
0ADB:  RRF    77,F
0ADC:  RRF    78,F
0ADD:  BTFSC  5C.6
0ADE:  ADDWF  77,F
0ADF:  RRF    77,F
0AE0:  RRF    78,F
0AE1:  BTFSC  5C.7
0AE2:  ADDWF  77,F
0AE3:  RRF    77,F
0AE4:  RRF    78,F
*
0D0F:  BSF    0A.0
0D10:  BCF    0A.1
0D11:  BSF    0A.2
0D12:  ADDWF  02,F
0D13:  GOTO   4B0
0D14:  GOTO   4B1
0D15:  GOTO   4BB
0D16:  GOTO   4C6
....................  
.................... #list 
....................  
.................... #DEVICE ADC=10 
.................... #INCLUDE <STRING.H> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
*
0759:  BSF    03.5
075A:  MOVF   57,W
075B:  MOVWF  5B
075C:  MOVF   56,W
075D:  MOVWF  5A
075E:  MOVF   5B,W
075F:  MOVWF  7A
0760:  MOVF   5A,W
0761:  MOVWF  04
0762:  BCF    03.7
0763:  BTFSC  7A.0
0764:  BSF    03.7
0765:  MOVF   00,F
0766:  BTFSC  03.2
0767:  GOTO   76C
0768:  INCF   5A,F
0769:  BTFSC  03.2
076A:  INCF   5B,F
076B:  GOTO   75E
....................    while(*s2 != '\0') 
076C:  MOVF   59,W
076D:  MOVWF  7A
076E:  MOVF   58,W
076F:  MOVWF  04
0770:  BCF    03.7
0771:  BTFSC  7A.0
0772:  BSF    03.7
0773:  MOVF   00,F
0774:  BTFSC  03.2
0775:  GOTO   78B
....................    { 
....................       *s = *s2; 
0776:  MOVF   58,W
0777:  MOVWF  04
0778:  BCF    03.7
0779:  BTFSC  59.0
077A:  BSF    03.7
077B:  MOVF   00,W
077C:  MOVWF  5E
077D:  MOVF   5A,W
077E:  MOVWF  04
077F:  BCF    03.7
0780:  BTFSC  5B.0
0781:  BSF    03.7
0782:  MOVF   5E,W
0783:  MOVWF  00
....................       ++s; 
0784:  INCF   5A,F
0785:  BTFSC  03.2
0786:  INCF   5B,F
....................       ++s2; 
0787:  INCF   58,F
0788:  BTFSC  03.2
0789:  INCF   59,F
078A:  GOTO   76C
....................    } 
....................  
....................    *s = '\0'; 
078B:  MOVF   5A,W
078C:  MOVWF  04
078D:  BCF    03.7
078E:  BTFSC  5B.0
078F:  BSF    03.7
0790:  CLRF   00
....................    return(s1); 
0791:  MOVF   56,W
0792:  MOVWF  78
0793:  MOVF   57,W
0794:  MOVWF  79
0795:  BCF    03.5
0796:  RETURN
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
*
09ED:  MOVF   5D,W
09EE:  MOVWF  61
09EF:  MOVF   5C,W
09F0:  MOVWF  60
09F1:  MOVF   61,W
09F2:  MOVWF  7A
09F3:  MOVF   60,W
09F4:  MOVWF  04
09F5:  BCF    03.7
09F6:  BTFSC  7A.0
09F7:  BSF    03.7
09F8:  MOVF   00,F
09F9:  BTFSC  03.2
09FA:  GOTO   22A
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
09FB:  MOVF   5F,W
09FC:  MOVWF  63
09FD:  MOVF   5E,W
09FE:  MOVWF  62
09FF:  MOVF   63,W
0A00:  MOVWF  7A
0A01:  MOVF   62,W
0A02:  MOVWF  04
0A03:  BCF    03.7
0A04:  BTFSC  7A.0
0A05:  BSF    03.7
0A06:  MOVF   00,F
0A07:  BTFSC  03.2
0A08:  GOTO   226
....................          if (*sc1 == *sc2) 
0A09:  MOVF   61,W
0A0A:  MOVWF  7A
0A0B:  MOVF   60,W
0A0C:  MOVWF  04
0A0D:  BCF    03.7
0A0E:  BTFSC  7A.0
0A0F:  BSF    03.7
0A10:  MOVF   00,W
0A11:  MOVWF  64
0A12:  MOVF   63,W
0A13:  MOVWF  7A
0A14:  MOVF   62,W
0A15:  MOVWF  04
0A16:  BCF    03.7
0A17:  BTFSC  7A.0
0A18:  BSF    03.7
0A19:  MOVF   00,W
0A1A:  SUBWF  64,W
0A1B:  BTFSS  03.2
0A1C:  GOTO   222
....................             return(sc1); 
0A1D:  MOVF   60,W
0A1E:  MOVWF  78
0A1F:  MOVF   61,W
0A20:  MOVWF  79
0A21:  GOTO   22D
0A22:  INCF   62,F
0A23:  BTFSC  03.2
0A24:  INCF   63,F
0A25:  GOTO   1FF
0A26:  INCF   60,F
0A27:  BTFSC  03.2
0A28:  INCF   61,F
0A29:  GOTO   1F1
....................    return(0); 
0A2A:  MOVLW  00
0A2B:  MOVWF  78
0A2C:  MOVWF  79
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
*
097A:  MOVF   5D,W
097B:  MOVWF  61
097C:  MOVF   5C,W
097D:  MOVWF  60
097E:  MOVF   61,W
097F:  MOVWF  7A
0980:  MOVF   60,W
0981:  MOVWF  04
0982:  BCF    03.7
0983:  BTFSC  7A.0
0984:  BSF    03.7
0985:  MOVF   00,F
0986:  BTFSC  03.2
0987:  GOTO   1BF
....................       for (sc2 = s2; ; sc2++) 
0988:  MOVF   5F,W
0989:  MOVWF  63
098A:  MOVF   5E,W
098B:  MOVWF  62
....................     if (*sc2 == '\0') 
098C:  MOVF   63,W
098D:  MOVWF  7A
098E:  MOVF   62,W
098F:  MOVWF  04
0990:  BCF    03.7
0991:  BTFSC  7A.0
0992:  BSF    03.7
0993:  MOVF   00,F
0994:  BTFSS  03.2
0995:  GOTO   1A3
....................        return(sc1 - s1); 
0996:  MOVF   5C,W
0997:  SUBWF  60,W
0998:  MOVWF  77
0999:  MOVF   61,W
099A:  MOVWF  7A
099B:  MOVF   5D,W
099C:  BTFSS  03.0
099D:  INCFSZ 5D,W
099E:  SUBWF  7A,F
099F:  MOVF   77,W
09A0:  MOVWF  78
09A1:  GOTO   1CA
09A2:  GOTO   1B7
....................          else if (*sc1 == *sc2) 
09A3:  MOVF   61,W
09A4:  MOVWF  7A
09A5:  MOVF   60,W
09A6:  MOVWF  04
09A7:  BCF    03.7
09A8:  BTFSC  7A.0
09A9:  BSF    03.7
09AA:  MOVF   00,W
09AB:  MOVWF  64
09AC:  MOVF   63,W
09AD:  MOVWF  7A
09AE:  MOVF   62,W
09AF:  MOVWF  04
09B0:  BCF    03.7
09B1:  BTFSC  7A.0
09B2:  BSF    03.7
09B3:  MOVF   00,W
09B4:  SUBWF  64,W
09B5:  BTFSC  03.2
....................             break; 
09B6:  GOTO   1BB
09B7:  INCF   62,F
09B8:  BTFSC  03.2
09B9:  INCF   63,F
09BA:  GOTO   18C
09BB:  INCF   60,F
09BC:  BTFSC  03.2
09BD:  INCF   61,F
09BE:  GOTO   17E
....................    return(sc1 - s1); 
09BF:  MOVF   5C,W
09C0:  SUBWF  60,W
09C1:  MOVWF  77
09C2:  MOVF   61,W
09C3:  MOVWF  7A
09C4:  MOVF   5D,W
09C5:  BTFSS  03.0
09C6:  INCFSZ 5D,W
09C7:  SUBWF  7A,F
09C8:  MOVF   77,W
09C9:  MOVWF  78
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
*
0B80:  BCF    03.6
0B81:  CLRF   2B
0B82:  CLRF   2C
....................  
....................    beg = (s1)? s1: save; 
*
0961:  BSF    03.5
0962:  MOVF   54,W
0963:  IORWF  55,W
0964:  BTFSC  03.2
0965:  GOTO   16A
0966:  MOVF   55,W
0967:  MOVWF  7A
0968:  MOVF   54,W
0969:  GOTO   16F
096A:  BCF    03.5
096B:  MOVF   2C,W
096C:  MOVWF  7A
096D:  MOVF   2B,W
096E:  BSF    03.5
096F:  MOVWF  58
0970:  MOVF   7A,W
0971:  MOVWF  59
....................    beg += strspn(beg, s2); 
0972:  MOVF   59,W
0973:  MOVWF  5D
0974:  MOVF   58,W
0975:  MOVWF  5C
0976:  MOVF   57,W
0977:  MOVWF  5F
0978:  MOVF   56,W
0979:  MOVWF  5E
*
09CA:  MOVF   78,W
09CB:  ADDWF  58,F
09CC:  BTFSC  03.0
09CD:  INCF   59,F
....................    if (*beg == '\0') 
09CE:  MOVF   59,W
09CF:  MOVWF  7A
09D0:  MOVF   58,W
09D1:  MOVWF  04
09D2:  BCF    03.7
09D3:  BTFSC  7A.0
09D4:  BSF    03.7
09D5:  MOVF   00,F
09D6:  BTFSS  03.2
09D7:  GOTO   1E5
....................    { 
....................       *save = ' '; 
09D8:  BCF    03.5
09D9:  MOVF   2B,W
09DA:  MOVWF  04
09DB:  BCF    03.7
09DC:  BTFSC  2C.0
09DD:  BSF    03.7
09DE:  MOVLW  20
09DF:  MOVWF  00
....................       return(0); 
09E0:  MOVLW  00
09E1:  MOVWF  78
09E2:  MOVWF  79
09E3:  GOTO   251
09E4:  BSF    03.5
....................    } 
....................    end = strpbrk(beg, s2); 
09E5:  MOVF   59,W
09E6:  MOVWF  5D
09E7:  MOVF   58,W
09E8:  MOVWF  5C
09E9:  MOVF   57,W
09EA:  MOVWF  5F
09EB:  MOVF   56,W
09EC:  MOVWF  5E
*
0A2D:  MOVF   79,W
0A2E:  MOVWF  5B
0A2F:  MOVF   78,W
0A30:  MOVWF  5A
....................    if (*end != '\0') 
0A31:  MOVF   5B,W
0A32:  MOVWF  7A
0A33:  MOVF   5A,W
0A34:  MOVWF  04
0A35:  BCF    03.7
0A36:  BTFSC  7A.0
0A37:  BSF    03.7
0A38:  MOVF   00,F
0A39:  BTFSC  03.2
0A3A:  GOTO   244
....................    { 
....................       *end = '\0'; 
0A3B:  MOVF   5A,W
0A3C:  MOVWF  04
0A3D:  BCF    03.7
0A3E:  BTFSC  5B.0
0A3F:  BSF    03.7
0A40:  CLRF   00
....................       end++; 
0A41:  INCF   5A,F
0A42:  BTFSC  03.2
0A43:  INCF   5B,F
....................    } 
....................    save = end; 
0A44:  MOVF   5B,W
0A45:  BCF    03.5
0A46:  MOVWF  2C
0A47:  BSF    03.5
0A48:  MOVF   5A,W
0A49:  BCF    03.5
0A4A:  MOVWF  2B
....................    return(beg); 
0A4B:  BSF    03.5
0A4C:  MOVF   58,W
0A4D:  MOVWF  78
0A4E:  MOVF   59,W
0A4F:  MOVWF  79
0A50:  BCF    03.5
0A51:  RETURN
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
*
08BA:  MOVF   58,W
08BB:  MOVWF  5A
08BC:  MOVF   57,W
08BD:  MOVWF  59
08BE:  MOVF   5A,W
08BF:  MOVWF  7A
08C0:  MOVF   59,W
08C1:  MOVWF  04
08C2:  BCF    03.7
08C3:  BTFSC  7A.0
08C4:  BSF    03.7
08C5:  MOVF   00,F
08C6:  BTFSC  03.2
08C7:  GOTO   0CC
08C8:  INCF   59,F
08C9:  BTFSC  03.2
08CA:  INCF   5A,F
08CB:  GOTO   0BE
....................    return(sc - s); 
08CC:  MOVF   57,W
08CD:  SUBWF  59,W
08CE:  MOVWF  77
08CF:  MOVF   5A,W
08D0:  MOVWF  7A
08D1:  MOVF   58,W
08D2:  BTFSS  03.0
08D3:  INCFSZ 58,W
08D4:  SUBWF  7A,F
08D5:  MOVF   77,W
08D6:  MOVWF  78
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #INCLUDE <STDLIB.H> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... /* Standart template: float strtof(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... float strtof(char *s,char *endptr); 
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s,char *endptr); 
.................... float64 strtod(char *s,char *endptr); 
.................... #else 
.................... //provided for compatibility 
.................... #define strtof48(s, e) strtof(s, e) 
.................... #define strtod(s, e) strtof(s, e) 
.................... #endif 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof(s)   strtof(s, 0) 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof48(s) strtof48(s, 0) 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof64(s) strtod(s, 0) 
.................... #endif 
....................  
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float atoe(char * s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s); 
.................... #endif 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... unsigned int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................  
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
*
0A52:  BSF    03.5
0A53:  CLRF   59
....................    sign = 0; 
0A54:  CLRF   57
....................    base = 10; 
0A55:  MOVLW  0A
0A56:  MOVWF  58
....................    result = 0; 
0A57:  CLRF   56
....................  
....................    if (!s) 
0A58:  MOVF   54,W
0A59:  IORWF  55,W
0A5A:  BTFSS  03.2
0A5B:  GOTO   25F
....................       return 0; 
0A5C:  MOVLW  00
0A5D:  MOVWF  78
0A5E:  GOTO   352
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
0A5F:  MOVF   59,W
0A60:  INCF   59,F
0A61:  ADDWF  54,W
0A62:  MOVWF  04
0A63:  BCF    03.7
0A64:  BTFSC  55.0
0A65:  BSF    03.7
0A66:  MOVF   00,W
0A67:  MOVWF  5A
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
0A68:  MOVF   5A,W
0A69:  SUBLW  2D
0A6A:  BTFSS  03.2
0A6B:  GOTO   278
....................    { 
....................       sign = 1;         // Set the sign to negative 
0A6C:  MOVLW  01
0A6D:  MOVWF  57
....................       c = s[index++]; 
0A6E:  MOVF   59,W
0A6F:  INCF   59,F
0A70:  ADDWF  54,W
0A71:  MOVWF  04
0A72:  BCF    03.7
0A73:  BTFSC  55.0
0A74:  BSF    03.7
0A75:  MOVF   00,W
0A76:  MOVWF  5A
....................    } 
0A77:  GOTO   285
....................    else if (c == '+') 
0A78:  MOVF   5A,W
0A79:  SUBLW  2B
0A7A:  BTFSS  03.2
0A7B:  GOTO   285
....................    { 
....................       c = s[index++]; 
0A7C:  MOVF   59,W
0A7D:  INCF   59,F
0A7E:  ADDWF  54,W
0A7F:  MOVWF  04
0A80:  BCF    03.7
0A81:  BTFSC  55.0
0A82:  BSF    03.7
0A83:  MOVF   00,W
0A84:  MOVWF  5A
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
0A85:  MOVF   5A,W
0A86:  SUBLW  2F
0A87:  BTFSC  03.0
0A88:  GOTO   348
0A89:  MOVF   5A,W
0A8A:  SUBLW  39
0A8B:  BTFSS  03.0
0A8C:  GOTO   348
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
0A8D:  MOVF   5A,W
0A8E:  SUBLW  30
0A8F:  BTFSS  03.2
0A90:  GOTO   2B1
0A91:  MOVF   59,W
0A92:  ADDWF  54,W
0A93:  MOVWF  04
0A94:  BCF    03.7
0A95:  BTFSC  55.0
0A96:  BSF    03.7
0A97:  MOVF   00,W
0A98:  SUBLW  78
0A99:  BTFSC  03.2
0A9A:  GOTO   2A5
0A9B:  MOVF   59,W
0A9C:  ADDWF  54,W
0A9D:  MOVWF  04
0A9E:  BCF    03.7
0A9F:  BTFSC  55.0
0AA0:  BSF    03.7
0AA1:  MOVF   00,W
0AA2:  SUBLW  58
0AA3:  BTFSS  03.2
0AA4:  GOTO   2B1
....................       { 
....................          base = 16; 
0AA5:  MOVLW  10
0AA6:  MOVWF  58
....................          index++; 
0AA7:  INCF   59,F
....................          c = s[index++]; 
0AA8:  MOVF   59,W
0AA9:  INCF   59,F
0AAA:  ADDWF  54,W
0AAB:  MOVWF  04
0AAC:  BCF    03.7
0AAD:  BTFSC  55.0
0AAE:  BSF    03.7
0AAF:  MOVF   00,W
0AB0:  MOVWF  5A
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
0AB1:  MOVF   58,W
0AB2:  SUBLW  0A
0AB3:  BTFSS  03.2
0AB4:  GOTO   2F6
....................       { 
....................          while (c >= '0' && c <= '9') 
0AB5:  MOVF   5A,W
0AB6:  SUBLW  2F
0AB7:  BTFSC  03.0
0AB8:  GOTO   2F5
0AB9:  MOVF   5A,W
0ABA:  SUBLW  39
0ABB:  BTFSS  03.0
0ABC:  GOTO   2F5
....................          { 
....................             result = 10*result + (c - '0'); 
0ABD:  MOVLW  0A
0ABE:  MOVWF  5B
0ABF:  MOVF   56,W
0AC0:  MOVWF  5C
*
0AE5:  MOVF   78,W
0AE6:  MOVWF  5B
0AE7:  MOVLW  30
0AE8:  SUBWF  5A,W
0AE9:  ADDWF  5B,W
0AEA:  MOVWF  56
....................             c = s[index++]; 
0AEB:  MOVF   59,W
0AEC:  INCF   59,F
0AED:  ADDWF  54,W
0AEE:  MOVWF  04
0AEF:  BCF    03.7
0AF0:  BTFSC  55.0
0AF1:  BSF    03.7
0AF2:  MOVF   00,W
0AF3:  MOVWF  5A
0AF4:  GOTO   2B5
....................          } 
....................       } 
0AF5:  GOTO   348
....................       else if (base == 16)    // The number is a hexa number 
0AF6:  MOVF   58,W
0AF7:  SUBLW  10
0AF8:  BTFSS  03.2
0AF9:  GOTO   348
....................       { 
....................          c = toupper(c); 
0AFA:  MOVF   5A,W
0AFB:  SUBLW  60
0AFC:  BTFSC  03.0
0AFD:  GOTO   305
0AFE:  MOVF   5A,W
0AFF:  SUBLW  7A
0B00:  BTFSS  03.0
0B01:  GOTO   305
0B02:  MOVF   5A,W
0B03:  ANDLW  DF
0B04:  GOTO   306
0B05:  MOVF   5A,W
0B06:  MOVWF  5A
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
0B07:  MOVF   5A,W
0B08:  SUBLW  2F
0B09:  BTFSC  03.0
0B0A:  GOTO   30F
0B0B:  MOVF   5A,W
0B0C:  SUBLW  39
0B0D:  BTFSC  03.0
0B0E:  GOTO   317
0B0F:  MOVF   5A,W
0B10:  SUBLW  40
0B11:  BTFSC  03.0
0B12:  GOTO   348
0B13:  MOVF   5A,W
0B14:  SUBLW  46
0B15:  BTFSS  03.0
0B16:  GOTO   348
....................          { 
....................             if (c >= '0' && c <= '9') 
0B17:  MOVF   5A,W
0B18:  SUBLW  2F
0B19:  BTFSC  03.0
0B1A:  GOTO   328
0B1B:  MOVF   5A,W
0B1C:  SUBLW  39
0B1D:  BTFSS  03.0
0B1E:  GOTO   328
....................                result = (result << 4) + (c - '0'); 
0B1F:  SWAPF  56,W
0B20:  MOVWF  5B
0B21:  MOVLW  F0
0B22:  ANDWF  5B,F
0B23:  MOVLW  30
0B24:  SUBWF  5A,W
0B25:  ADDWF  5B,W
0B26:  MOVWF  56
0B27:  GOTO   331
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
0B28:  SWAPF  56,W
0B29:  MOVWF  5B
0B2A:  MOVLW  F0
0B2B:  ANDWF  5B,F
0B2C:  MOVLW  41
0B2D:  SUBWF  5A,W
0B2E:  ADDLW  0A
0B2F:  ADDWF  5B,W
0B30:  MOVWF  56
....................  
....................             c = s[index++]; 
0B31:  MOVF   59,W
0B32:  INCF   59,F
0B33:  ADDWF  54,W
0B34:  MOVWF  04
0B35:  BCF    03.7
0B36:  BTFSC  55.0
0B37:  BSF    03.7
0B38:  MOVF   00,W
0B39:  MOVWF  5A
....................             c = toupper(c); 
0B3A:  MOVF   5A,W
0B3B:  SUBLW  60
0B3C:  BTFSC  03.0
0B3D:  GOTO   345
0B3E:  MOVF   5A,W
0B3F:  SUBLW  7A
0B40:  BTFSS  03.0
0B41:  GOTO   345
0B42:  MOVF   5A,W
0B43:  ANDLW  DF
0B44:  GOTO   346
0B45:  MOVF   5A,W
0B46:  MOVWF  5A
0B47:  GOTO   307
....................          } 
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
0B48:  DECFSZ 57,W
0B49:  GOTO   350
0B4A:  MOVF   58,W
0B4B:  SUBLW  0A
0B4C:  BTFSS  03.2
0B4D:  GOTO   350
....................        result = -result; 
0B4E:  COMF   56,F
0B4F:  INCF   56,F
....................  
....................    return(result); 
0B50:  MOVF   56,W
0B51:  MOVWF  78
0B52:  BCF    03.5
0B53:  RETURN
.................... } 
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
*
03C6:  BSF    03.5
03C7:  CLRF   61
03C8:  CLRF   60
03C9:  CLRF   5F
03CA:  MOVLW  01
03CB:  MOVWF  5E
03CC:  CLRF   63
03CD:  CLRF   64
.................... { 
....................      unsigned int32 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
03CE:  BTFSS  5A.7
03CF:  GOTO   420
....................          sign=1;        // Check for negative number 
03D0:  MOVLW  01
03D1:  MOVWF  63
....................          num*=-1; 
03D2:  MOVF   5A,W
03D3:  BCF    03.5
03D4:  BSF    03.6
03D5:  MOVWF  13
03D6:  BSF    03.5
03D7:  BCF    03.6
03D8:  MOVF   59,W
03D9:  BCF    03.5
03DA:  BSF    03.6
03DB:  MOVWF  12
03DC:  BSF    03.5
03DD:  BCF    03.6
03DE:  MOVF   58,W
03DF:  BCF    03.5
03E0:  BSF    03.6
03E1:  MOVWF  11
03E2:  BSF    03.5
03E3:  BCF    03.6
03E4:  MOVF   57,W
03E5:  BCF    03.5
03E6:  BSF    03.6
03E7:  MOVWF  10
03E8:  MOVLW  FF
03E9:  MOVWF  17
03EA:  MOVWF  16
03EB:  MOVWF  15
03EC:  MOVWF  14
*
0416:  MOVF   7A,W
0417:  BSF    03.5
0418:  BCF    03.6
0419:  MOVWF  5A
041A:  MOVF   79,W
041B:  MOVWF  59
041C:  MOVF   78,W
041D:  MOVWF  58
041E:  MOVF   77,W
041F:  MOVWF  57
....................      } 
....................  
....................      while(temp>0) { 
0420:  MOVF   5E,F
0421:  BTFSS  03.2
0422:  GOTO   42C
0423:  MOVF   5F,F
0424:  BTFSS  03.2
0425:  GOTO   42C
0426:  MOVF   60,F
0427:  BTFSS  03.2
0428:  GOTO   42C
0429:  MOVF   61,F
042A:  BTFSC  03.2
042B:  GOTO   4D2
....................          temp=(num/base); 
042C:  BCF    03.1
042D:  MOVF   5A,W
042E:  BCF    03.5
042F:  BSF    03.6
0430:  MOVWF  1B
0431:  BSF    03.5
0432:  BCF    03.6
0433:  MOVF   59,W
0434:  BCF    03.5
0435:  BSF    03.6
0436:  MOVWF  1A
0437:  BSF    03.5
0438:  BCF    03.6
0439:  MOVF   58,W
043A:  BCF    03.5
043B:  BSF    03.6
043C:  MOVWF  19
043D:  BSF    03.5
043E:  BCF    03.6
043F:  MOVF   57,W
0440:  BCF    03.5
0441:  BSF    03.6
0442:  MOVWF  18
0443:  CLRF   1F
0444:  CLRF   1E
0445:  CLRF   1D
0446:  BSF    03.5
0447:  BCF    03.6
0448:  MOVF   5B,W
0449:  BCF    03.5
044A:  BSF    03.6
044B:  MOVWF  1C
044C:  BCF    03.6
044D:  CALL   34A
044E:  MOVF   7A,W
044F:  BSF    03.5
0450:  MOVWF  61
0451:  MOVF   79,W
0452:  MOVWF  60
0453:  MOVF   78,W
0454:  MOVWF  5F
0455:  MOVF   77,W
0456:  MOVWF  5E
....................          s[cnt]=(num%base)+'0';    // Conversion 
0457:  MOVF   64,W
0458:  ADDWF  5C,W
0459:  MOVWF  78
045A:  MOVF   5D,W
045B:  MOVWF  7A
045C:  BTFSC  03.0
045D:  INCF   7A,F
045E:  MOVF   78,W
045F:  BCF    03.5
0460:  BSF    03.6
0461:  MOVWF  10
0462:  MOVF   7A,W
0463:  MOVWF  11
0464:  CLRF   13
0465:  MOVF   04,W
0466:  MOVWF  12
0467:  BCF    13.0
0468:  BTFSC  03.7
0469:  BSF    13.0
046A:  BSF    03.1
046B:  MOVLW  14
046C:  MOVWF  04
046D:  BSF    03.7
046E:  BSF    03.5
046F:  BCF    03.6
0470:  MOVF   5A,W
0471:  BCF    03.5
0472:  BSF    03.6
0473:  MOVWF  1B
0474:  BSF    03.5
0475:  BCF    03.6
0476:  MOVF   59,W
0477:  BCF    03.5
0478:  BSF    03.6
0479:  MOVWF  1A
047A:  BSF    03.5
047B:  BCF    03.6
047C:  MOVF   58,W
047D:  BCF    03.5
047E:  BSF    03.6
047F:  MOVWF  19
0480:  BSF    03.5
0481:  BCF    03.6
0482:  MOVF   57,W
0483:  BCF    03.5
0484:  BSF    03.6
0485:  MOVWF  18
0486:  CLRF   1F
0487:  CLRF   1E
0488:  CLRF   1D
0489:  BSF    03.5
048A:  BCF    03.6
048B:  MOVF   5B,W
048C:  BCF    03.5
048D:  BSF    03.6
048E:  MOVWF  1C
048F:  BCF    03.6
0490:  CALL   34A
0491:  BSF    03.6
0492:  MOVF   12,W
0493:  MOVWF  04
0494:  BCF    03.7
0495:  BTFSC  13.0
0496:  BSF    03.7
0497:  MOVLW  30
0498:  ADDWF  14,W
0499:  MOVWF  77
049A:  MOVF   15,W
049B:  MOVWF  78
049C:  MOVLW  00
049D:  BTFSC  03.0
049E:  MOVLW  01
049F:  ADDWF  78,F
04A0:  MOVF   16,W
04A1:  MOVWF  79
04A2:  MOVLW  00
04A3:  BTFSC  03.0
04A4:  MOVLW  01
04A5:  ADDWF  79,F
04A6:  MOVF   17,W
04A7:  MOVWF  7A
04A8:  MOVLW  00
04A9:  BTFSC  03.0
04AA:  MOVLW  01
04AB:  ADDWF  7A,F
04AC:  MOVF   10,W
04AD:  MOVWF  04
04AE:  BCF    03.7
04AF:  BTFSC  11.0
04B0:  BSF    03.7
04B1:  MOVF   77,W
04B2:  MOVWF  00
....................  
....................          if(s[cnt]>0x39) 
04B3:  BSF    03.5
04B4:  BCF    03.6
04B5:  MOVF   64,W
04B6:  ADDWF  5C,W
04B7:  MOVWF  04
04B8:  BCF    03.7
04B9:  BTFSC  5D.0
04BA:  BSF    03.7
04BB:  MOVF   00,W
04BC:  SUBLW  39
04BD:  BTFSC  03.0
04BE:  GOTO   4C8
....................             s[cnt]+=0x7; 
04BF:  MOVF   64,W
04C0:  ADDWF  5C,W
04C1:  MOVWF  04
04C2:  BCF    03.7
04C3:  BTFSC  5D.0
04C4:  BSF    03.7
04C5:  MOVLW  07
04C6:  ADDWF  00,W
04C7:  MOVWF  00
....................  
....................          cnt++; 
04C8:  INCF   64,F
....................          num=temp; 
04C9:  MOVF   61,W
04CA:  MOVWF  5A
04CB:  MOVF   60,W
04CC:  MOVWF  59
04CD:  MOVF   5F,W
04CE:  MOVWF  58
04CF:  MOVF   5E,W
04D0:  MOVWF  57
04D1:  GOTO   420
....................      } 
....................  
....................      if(sign==1) { 
04D2:  DECFSZ 63,W
04D3:  GOTO   4DD
....................          s[cnt]=0x2D;      // Negative sign 
04D4:  MOVF   64,W
04D5:  ADDWF  5C,W
04D6:  MOVWF  04
04D7:  BCF    03.7
04D8:  BTFSC  5D.0
04D9:  BSF    03.7
04DA:  MOVLW  2D
04DB:  MOVWF  00
....................          cnt++; 
04DC:  INCF   64,F
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
04DD:  CLRF   62
04DE:  BCF    03.0
04DF:  RRF    64,W
04E0:  SUBWF  62,W
04E1:  BTFSC  03.0
04E2:  GOTO   51B
....................  
....................          c=s[i]; 
04E3:  MOVF   62,W
04E4:  ADDWF  5C,W
04E5:  MOVWF  04
04E6:  BCF    03.7
04E7:  BTFSC  5D.0
04E8:  BSF    03.7
04E9:  MOVF   00,W
04EA:  MOVWF  65
....................          s[i]=s[cnt-i-1];        // Reverse the number 
04EB:  MOVF   62,W
04EC:  ADDWF  5C,W
04ED:  MOVWF  78
04EE:  MOVF   5D,W
04EF:  MOVWF  7A
04F0:  BTFSC  03.0
04F1:  INCF   7A,F
04F2:  MOVF   78,W
04F3:  BCF    03.5
04F4:  BSF    03.6
04F5:  MOVWF  10
04F6:  MOVF   7A,W
04F7:  MOVWF  11
04F8:  BSF    03.5
04F9:  BCF    03.6
04FA:  MOVF   62,W
04FB:  SUBWF  64,W
04FC:  ADDLW  FF
04FD:  ADDWF  5C,W
04FE:  MOVWF  04
04FF:  BCF    03.7
0500:  BTFSC  5D.0
0501:  BSF    03.7
0502:  MOVF   00,W
0503:  BCF    03.5
0504:  BSF    03.6
0505:  MOVWF  12
0506:  MOVF   10,W
0507:  MOVWF  04
0508:  BCF    03.7
0509:  BTFSC  11.0
050A:  BSF    03.7
050B:  MOVF   12,W
050C:  MOVWF  00
....................          s[cnt-i-1]=c; 
050D:  BSF    03.5
050E:  BCF    03.6
050F:  MOVF   62,W
0510:  SUBWF  64,W
0511:  ADDLW  FF
0512:  ADDWF  5C,W
0513:  MOVWF  04
0514:  BCF    03.7
0515:  BTFSC  5D.0
0516:  BSF    03.7
0517:  MOVF   65,W
0518:  MOVWF  00
0519:  INCF   62,F
051A:  GOTO   4DE
....................      } 
....................      s[cnt]='\0';     // End the string 
051B:  MOVF   64,W
051C:  ADDWF  5C,W
051D:  MOVWF  04
051E:  BCF    03.7
051F:  BTFSC  5D.0
0520:  BSF    03.7
0521:  CLRF   00
....................      return s; 
0522:  MOVF   5C,W
0523:  MOVWF  78
0524:  MOVF   5D,W
0525:  MOVWF  79
0526:  BCF    03.5
0527:  RETURN
.................... } 
....................  
.................... #if defined(__PCD__) 
....................  
.................... char * itoa(signed int48 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int48 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... char * itoa(signed int64 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int64 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................       
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1;         
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................              
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #endif 
....................  
.................... float strtof(char *s, char *endptr) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s, char *endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float48)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float48)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s, char *endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float64)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float64)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtoulGO; 
....................  
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................    { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... int8 mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #if !defined(__PCD__) 
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2);  
.................... #else  
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2);  
.................... #endif 
....................  
....................  
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    unsigned int8 t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=1; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = 0; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
.................... #INCLUDE <STDIO.H> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDIO 
.................... #define _STDIO 
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #ifndef getc 
.................... #define getc getch 
.................... #define getchar getch 
.................... #define puts(s) {printf(s); putchar(13); putchar(10);} 
.................... #define putc putchar 
.................... #endif 
.................... /* maps error number to an error message. Writes a sequence of characters to 
.................... stderr stream thus: if s is not null then string pointed to by s follwed by 
.................... a colon (:) and a space and the appropriate error message returned by strerror 
.................... function with argument errno 
....................  
.................... Returns: no value 
.................... */ 
....................  
.................... #ifdef _ERRNO 
.................... void perror(char *s) 
.................... { 
....................   if(s) 
....................   fprintf(STDERR,"%s: ",s); 
....................   fprintf(STDERR,"%s\r\n",strerror(errno)); 
.................... } 
.................... #endif 
.................... #endif 
....................  
.................... #FUSES NOWDT, PUT, HS 
.................... #USE DELAY(CLOCK=20M) 
*
0117:  MOVLW  D9
0118:  MOVWF  04
0119:  BCF    03.7
011A:  MOVF   00,W
011B:  BTFSC  03.2
011C:  GOTO   12A
011D:  MOVLW  06
011E:  MOVWF  78
011F:  CLRF   77
0120:  DECFSZ 77,F
0121:  GOTO   120
0122:  DECFSZ 78,F
0123:  GOTO   11F
0124:  MOVLW  7B
0125:  MOVWF  77
0126:  DECFSZ 77,F
0127:  GOTO   126
0128:  DECFSZ 00,F
0129:  GOTO   11D
012A:  RETURN
.................... #USE RS232(BAUD=9600,XMIT=PIN_C6,RCV=PIN_C7) 
.................... #DEFINE BT1_PIN PIN_B1 
.................... #DEFINE BT2_PIN PIN_B2 
.................... #DEFINE BT3_PIN PIN_B3 
.................... #DEFINE LCD_ENABLE_PIN  PIN_E0                                    
.................... #DEFINE LCD_RS_PIN      PIN_E1                                 
.................... #DEFINE LCD_RW_PIN      PIN_E2   
.................... #DEFINE LCD_DATA4       PIN_C0                                
.................... #DEFINE LCD_DATA5       PIN_C1                                  
.................... #DEFINE LCD_DATA6       PIN_C2                                    
.................... #DEFINE LCD_DATA7       PIN_C3   
.................... #INCLUDE <LCD.C> 
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... ////                             LCD.C                                     //// 
.................... ////                 Driver for common LCD modules                         //// 
.................... ////                                                                       //// 
.................... ////  lcd_init()   Must be called before any other function.               //// 
.................... ////                                                                       //// 
.................... ////  lcd_putc(c)  Will display c on the next position of the LCD.         //// 
.................... ////                 \a  Set cursor position to upper left                 //// 
.................... ////                 \f  Clear display, set cursor to upper left           //// 
.................... ////                 \n  Go to start of second line                        //// 
.................... ////                 \b  Move back one position                            //// 
.................... ////              If LCD_EXTENDED_NEWLINE is defined, the \n character     //// 
.................... ////              will erase all remanining characters on the current      //// 
.................... ////              line, and move the cursor to the beginning of the next   //// 
.................... ////              line.                                                    //// 
.................... ////              If LCD_EXTENDED_NEWLINE is defined, the \r character     //// 
.................... ////              will move the cursor to the start of the current         //// 
.................... ////              line.                                                    //// 
.................... ////                                                                       //// 
.................... ////  lcd_gotoxy(x,y) Set write position on LCD (upper left is 1,1)        //// 
.................... ////                                                                       //// 
.................... ////  lcd_getc(x,y)   Returns character at position x,y on LCD             //// 
.................... ////                                                                       //// 
.................... ////  lcd_cursor_on(int1 on)   Turn the cursor on (on=TRUE) or off         //// 
.................... ////              (on=FALSE).                                              //// 
.................... ////                                                                       //// 
.................... ////  lcd_set_cgram_char(w, *p)   Write a custom character to the CGRAM.   //// 
.................... ////                                                                       //// 
.................... ////                                                                       //// 
.................... ////  CONFIGURATION                                                        //// 
.................... ////  The LCD can be configured in one of two ways: a.) port access or     //// 
.................... ////  b.) pin access.  Port access requires the entire 7 bit interface     //// 
.................... ////  connected to one GPIO port, and the data bits (D4:D7 of the LCD)     //// 
.................... ////  connected to sequential pins on the GPIO.  Pin access                //// 
.................... ////  has no requirements, all 7 bits of the control interface can         //// 
.................... ////  can be connected to any GPIO using several ports.                    //// 
.................... ////                                                                       //// 
.................... ////  To use port access, #define LCD_DATA_PORT to the SFR location of     //// 
.................... ////  of the GPIO port that holds the interface, -AND- edit LCD_PIN_MAP    //// 
.................... ////  of this file to configure the pin order.  If you are using a         //// 
.................... ////  baseline PIC (PCB), then LCD_OUTPUT_MAP and LCD_INPUT_MAP also must  //// 
.................... ////  be defined.                                                          //// 
.................... ////                                                                       //// 
.................... ////  Example of port access:                                              //// 
.................... ////     #define LCD_DATA_PORT getenv("SFR:PORTD")                         //// 
.................... ////                                                                       //// 
.................... ////  To use pin access, the following pins must be defined:               //// 
.................... ////     LCD_ENABLE_PIN                                                    //// 
.................... ////     LCD_RS_PIN                                                        //// 
.................... ////     LCD_RW_PIN                                                        //// 
.................... ////     LCD_DATA4                                                         //// 
.................... ////     LCD_DATA5                                                         //// 
.................... ////     LCD_DATA6                                                         //// 
.................... ////     LCD_DATA7                                                         //// 
.................... ////                                                                       //// 
.................... ////  Example of pin access:                                               //// 
.................... ////     #define LCD_ENABLE_PIN  PIN_E0                                    //// 
.................... ////     #define LCD_RS_PIN      PIN_E1                                    //// 
.................... ////     #define LCD_RW_PIN      PIN_E2                                    //// 
.................... ////     #define LCD_DATA4       PIN_D4                                    //// 
.................... ////     #define LCD_DATA5       PIN_D5                                    //// 
.................... ////     #define LCD_DATA6       PIN_D6                                    //// 
.................... ////     #define LCD_DATA7       PIN_D7                                    //// 
.................... ////                                                                       //// 
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2010 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef __LCD_C__ 
.................... #define __LCD_C__ 
....................  
.................... // define the pinout. 
.................... // only required if port access is being used. 
.................... typedef struct   
.................... {                            // This structure is overlayed 
....................    int1 enable;           // on to an I/O port to gain 
....................    int1 rs;               // access to the LCD pins. 
....................    int1 rw;               // The bits are allocated from 
....................    int1 unused;           // low order up.  ENABLE will 
....................    unsigned int     data : 4;         // be LSB pin of that port. 
....................   #if defined(__PCD__)       // The port used will be LCD_DATA_PORT. 
....................    unsigned int    reserved: 8; 
....................   #endif 
.................... } LCD_PIN_MAP; 
....................  
.................... // this is to improve compatability with previous LCD drivers that accepted 
.................... // a define labeled 'use_portb_lcd' that configured the LCD onto port B. 
.................... #if ((defined(use_portb_lcd)) && (use_portb_lcd==TRUE)) 
....................  #define LCD_DATA_PORT getenv("SFR:PORTB") 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
....................    // these definitions only need to be modified for baseline PICs. 
....................    // all other PICs use LCD_PIN_MAP or individual LCD_xxx pin definitions. 
.................... /*                                    EN, RS,   RW,   UNUSED,  DATA  */ 
....................  const LCD_PIN_MAP LCD_OUTPUT_MAP =  {0,  0,    0,    0,       0}; 
....................  const LCD_PIN_MAP LCD_INPUT_MAP =   {0,  0,    0,    0,       0xF}; 
.................... #endif 
....................  
.................... ////////////////////// END CONFIGURATION /////////////////////////////////// 
....................  
.................... #ifndef LCD_ENABLE_PIN 
....................    #define lcd_output_enable(x) lcdlat.enable=x 
....................    #define lcd_enable_tris()   lcdtris.enable=0 
.................... #else 
....................    #define lcd_output_enable(x) output_bit(LCD_ENABLE_PIN, x) 
....................    #define lcd_enable_tris()  output_drive(LCD_ENABLE_PIN) 
.................... #endif 
....................  
.................... #ifndef LCD_RS_PIN 
....................    #define lcd_output_rs(x) lcdlat.rs=x 
....................    #define lcd_rs_tris()   lcdtris.rs=0 
.................... #else 
....................    #define lcd_output_rs(x) output_bit(LCD_RS_PIN, x) 
....................    #define lcd_rs_tris()  output_drive(LCD_RS_PIN) 
.................... #endif 
....................  
.................... #ifndef LCD_RW_PIN 
....................    #define lcd_output_rw(x) lcdlat.rw=x 
....................    #define lcd_rw_tris()   lcdtris.rw=0 
.................... #else 
....................    #define lcd_output_rw(x) output_bit(LCD_RW_PIN, x) 
....................    #define lcd_rw_tris()  output_drive(LCD_RW_PIN) 
.................... #endif 
....................  
.................... // original version of this library incorrectly labeled LCD_DATA0 as LCD_DATA4, 
.................... // LCD_DATA1 as LCD_DATA5, and so on.  this block of code makes the driver 
.................... // compatible with any code written for the original library 
.................... #if (defined(LCD_DATA0) && defined(LCD_DATA1) && defined(LCD_DATA2) && defined(LCD_DATA3) && !defined(LCD_DATA4) && !defined(LCD_DATA5) && !defined(LCD_DATA6) && !defined(LCD_DATA7)) 
....................    #define  LCD_DATA4    LCD_DATA0 
....................    #define  LCD_DATA5    LCD_DATA1 
....................    #define  LCD_DATA6    LCD_DATA2 
....................    #define  LCD_DATA7    LCD_DATA3 
.................... #endif 
....................  
.................... #ifndef LCD_DATA4 
.................... #ifndef LCD_DATA_PORT 
....................    #if defined(__PCB__) 
....................       #define LCD_DATA_PORT      0x06     //portb 
....................       #define set_tris_lcd(x)   set_tris_b(x) 
....................    #else 
....................      #if defined(PIN_D0) 
....................       #define LCD_DATA_PORT      getenv("SFR:PORTD")     //portd 
....................      #else 
....................       #define LCD_DATA_PORT      getenv("SFR:PORTB")     //portb 
....................      #endif 
....................    #endif    
.................... #endif 
....................  
.................... #if defined(__PCB__) 
....................    LCD_PIN_MAP lcd, lcdlat; 
....................    #byte lcd = LCD_DATA_PORT 
....................    #byte lcdlat = LCD_DATA_PORT 
.................... #elif defined(__PCM__) 
....................    LCD_PIN_MAP lcd, lcdlat, lcdtris; 
....................    #byte lcd = LCD_DATA_PORT 
....................    #byte lcdlat = LCD_DATA_PORT 
....................    #byte lcdtris = LCD_DATA_PORT+0x80 
.................... #elif defined(__PCH__) 
....................    LCD_PIN_MAP lcd, lcdlat, lcdtris; 
....................    #byte lcd = LCD_DATA_PORT 
....................    #byte lcdlat = LCD_DATA_PORT+9 
....................    #byte lcdtris = LCD_DATA_PORT+0x12 
.................... #elif defined(__PCD__) 
....................    LCD_PIN_MAP lcd, lcdlat, lcdtris; 
....................    #word lcd = LCD_DATA_PORT 
....................    #word lcdlat = LCD_DATA_PORT+2 
....................    #word lcdtris = LCD_DATA_PORT-0x02 
.................... #endif 
.................... #endif   //LCD_DATA4 not defined 
....................  
.................... #ifndef LCD_TYPE 
....................    #define LCD_TYPE 2           // 0=5x7, 1=5x10, 2=2 lines 
.................... #endif 
....................  
.................... #ifndef LCD_LINE_TWO 
....................    #define LCD_LINE_TWO 0x40    // LCD RAM address for the second line 
.................... #endif 
....................  
.................... #ifndef LCD_LINE_LENGTH 
....................    #define LCD_LINE_LENGTH 20 
.................... #endif 
....................  
.................... unsigned int8 lcd_read_nibble(void); 
....................  
.................... unsigned int8 lcd_read_byte(void) 
.................... { 
....................    unsigned int8 low,high; 
....................  
....................  #if defined(__PCB__) 
....................    set_tris_lcd(LCD_INPUT_MAP); 
....................  #else 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    output_float(LCD_DATA4); 
*
01B8:  BSF    07.0
....................    output_float(LCD_DATA5); 
01B9:  BSF    07.1
....................    output_float(LCD_DATA6); 
01BA:  BSF    07.2
....................    output_float(LCD_DATA7); 
01BB:  BSF    07.3
....................   #else 
....................    lcdtris.data = 0xF; 
....................   #endif 
....................  #endif 
....................          
....................    lcd_output_rw(1); 
01BC:  BCF    03.5
01BD:  BSF    09.2
01BE:  BSF    03.5
01BF:  BCF    09.2
....................    delay_cycles(1); 
01C0:  NOP
....................    lcd_output_enable(1); 
01C1:  BCF    03.5
01C2:  BSF    09.0
01C3:  BSF    03.5
01C4:  BCF    09.0
....................    delay_cycles(1); 
01C5:  NOP
....................    high = lcd_read_nibble(); 
01C6:  BCF    03.5
01C7:  CALL   16D
01C8:  MOVF   78,W
01C9:  BSF    03.5
01CA:  MOVWF  60
....................        
....................    lcd_output_enable(0); 
01CB:  BCF    03.5
01CC:  BCF    09.0
01CD:  BSF    03.5
01CE:  BCF    09.0
....................    delay_cycles(1); 
01CF:  NOP
....................    lcd_output_enable(1); 
01D0:  BCF    03.5
01D1:  BSF    09.0
01D2:  BSF    03.5
01D3:  BCF    09.0
....................    delay_us(1); 
01D4:  GOTO   1D5
01D5:  GOTO   1D6
01D6:  NOP
....................    low = lcd_read_nibble(); 
01D7:  BCF    03.5
01D8:  CALL   16D
01D9:  MOVF   78,W
01DA:  BSF    03.5
01DB:  MOVWF  5F
....................        
....................    lcd_output_enable(0); 
01DC:  BCF    03.5
01DD:  BCF    09.0
01DE:  BSF    03.5
01DF:  BCF    09.0
....................  
....................  #if defined(__PCB__) 
....................    set_tris_lcd(LCD_OUTPUT_MAP); 
....................  #else 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    output_drive(LCD_DATA4); 
01E0:  BCF    03.5
01E1:  BCF    31.0
01E2:  MOVF   31,W
01E3:  BSF    03.5
01E4:  MOVWF  07
....................    output_drive(LCD_DATA5); 
01E5:  BCF    03.5
01E6:  BCF    31.1
01E7:  MOVF   31,W
01E8:  BSF    03.5
01E9:  MOVWF  07
....................    output_drive(LCD_DATA6); 
01EA:  BCF    03.5
01EB:  BCF    31.2
01EC:  MOVF   31,W
01ED:  BSF    03.5
01EE:  MOVWF  07
....................    output_drive(LCD_DATA7); 
01EF:  BCF    03.5
01F0:  BCF    31.3
01F1:  MOVF   31,W
01F2:  BSF    03.5
01F3:  MOVWF  07
....................   #else 
....................    lcdtris.data = 0x0; 
....................   #endif 
....................  #endif 
....................  
....................    return( (high<<4) | low); 
01F4:  SWAPF  60,W
01F5:  MOVWF  77
01F6:  MOVLW  F0
01F7:  ANDWF  77,F
01F8:  MOVF   77,W
01F9:  IORWF  5F,W
01FA:  MOVWF  78
.................... } 
....................  
.................... unsigned int8 lcd_read_nibble(void) 
.................... { 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
*
016D:  BSF    03.5
016E:  CLRF   61
....................    unsigned int8 n = 0x00; 
....................  
....................    /* Read the data port */ 
....................    n |= input(LCD_DATA4); 
016F:  BCF    03.5
0170:  BSF    31.0
0171:  MOVF   31,W
0172:  BSF    03.5
0173:  MOVWF  07
0174:  MOVLW  00
0175:  BCF    03.5
0176:  BTFSC  07.0
0177:  MOVLW  01
0178:  BSF    03.5
0179:  IORWF  61,F
....................    n |= input(LCD_DATA5) << 1; 
017A:  BCF    03.5
017B:  BSF    31.1
017C:  MOVF   31,W
017D:  BSF    03.5
017E:  MOVWF  07
017F:  MOVLW  00
0180:  BCF    03.5
0181:  BTFSC  07.1
0182:  MOVLW  01
0183:  MOVWF  77
0184:  BCF    03.0
0185:  RLF    77,F
0186:  MOVF   77,W
0187:  BSF    03.5
0188:  IORWF  61,F
....................    n |= input(LCD_DATA6) << 2; 
0189:  BCF    03.5
018A:  BSF    31.2
018B:  MOVF   31,W
018C:  BSF    03.5
018D:  MOVWF  07
018E:  MOVLW  00
018F:  BCF    03.5
0190:  BTFSC  07.2
0191:  MOVLW  01
0192:  MOVWF  77
0193:  RLF    77,F
0194:  RLF    77,F
0195:  MOVLW  FC
0196:  ANDWF  77,F
0197:  MOVF   77,W
0198:  BSF    03.5
0199:  IORWF  61,F
....................    n |= input(LCD_DATA7) << 3; 
019A:  BCF    03.5
019B:  BSF    31.3
019C:  MOVF   31,W
019D:  BSF    03.5
019E:  MOVWF  07
019F:  MOVLW  00
01A0:  BCF    03.5
01A1:  BTFSC  07.3
01A2:  MOVLW  01
01A3:  MOVWF  77
01A4:  RLF    77,F
01A5:  RLF    77,F
01A6:  RLF    77,F
01A7:  MOVLW  F8
01A8:  ANDWF  77,F
01A9:  MOVF   77,W
01AA:  BSF    03.5
01AB:  IORWF  61,F
....................     
....................    return(n); 
01AC:  MOVF   61,W
01AD:  MOVWF  78
....................   #else 
01AE:  BCF    03.5
01AF:  RETURN
....................    return(lcd.data); 
....................   #endif 
.................... } 
....................  
.................... void lcd_send_nibble(unsigned int8 n) 
.................... { 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    /* Write to the data port */ 
....................    output_bit(LCD_DATA4, bit_test(n, 0)); 
*
012B:  BSF    03.5
012C:  BTFSC  60.0
012D:  GOTO   132
012E:  BCF    03.5
012F:  BCF    07.0
0130:  GOTO   134
0131:  BSF    03.5
0132:  BCF    03.5
0133:  BSF    07.0
0134:  BCF    31.0
0135:  MOVF   31,W
0136:  BSF    03.5
0137:  MOVWF  07
....................    output_bit(LCD_DATA5, bit_test(n, 1)); 
0138:  BTFSC  60.1
0139:  GOTO   13E
013A:  BCF    03.5
013B:  BCF    07.1
013C:  GOTO   140
013D:  BSF    03.5
013E:  BCF    03.5
013F:  BSF    07.1
0140:  BCF    31.1
0141:  MOVF   31,W
0142:  BSF    03.5
0143:  MOVWF  07
....................    output_bit(LCD_DATA6, bit_test(n, 2)); 
0144:  BTFSC  60.2
0145:  GOTO   14A
0146:  BCF    03.5
0147:  BCF    07.2
0148:  GOTO   14C
0149:  BSF    03.5
014A:  BCF    03.5
014B:  BSF    07.2
014C:  BCF    31.2
014D:  MOVF   31,W
014E:  BSF    03.5
014F:  MOVWF  07
....................    output_bit(LCD_DATA7, bit_test(n, 3)); 
0150:  BTFSC  60.3
0151:  GOTO   156
0152:  BCF    03.5
0153:  BCF    07.3
0154:  GOTO   158
0155:  BSF    03.5
0156:  BCF    03.5
0157:  BSF    07.3
0158:  BCF    31.3
0159:  MOVF   31,W
015A:  BSF    03.5
015B:  MOVWF  07
....................   #else       
....................    lcdlat.data = n; 
....................   #endif 
....................        
....................    delay_cycles(1); 
015C:  NOP
....................    lcd_output_enable(1); 
015D:  BCF    03.5
015E:  BSF    09.0
015F:  BSF    03.5
0160:  BCF    09.0
....................    delay_us(2); 
0161:  MOVLW  02
0162:  MOVWF  77
0163:  DECFSZ 77,F
0164:  GOTO   163
0165:  GOTO   166
0166:  NOP
....................    lcd_output_enable(0); 
0167:  BCF    03.5
0168:  BCF    09.0
0169:  BSF    03.5
016A:  BCF    09.0
016B:  BCF    03.5
016C:  RETURN
.................... } 
....................  
.................... void lcd_send_byte(unsigned int8 address, unsigned int8 n) 
.................... { 
....................   #if defined(__PCB__) 
....................    set_tris_lcd(LCD_OUTPUT_MAP); 
....................   #else 
....................    lcd_enable_tris(); 
*
01B0:  BSF    03.5
01B1:  BCF    09.0
....................    lcd_rs_tris(); 
01B2:  BCF    09.1
....................    lcd_rw_tris(); 
01B3:  BCF    09.2
....................   #endif 
....................  
....................    lcd_output_rs(0); 
01B4:  BCF    03.5
01B5:  BCF    09.1
01B6:  BSF    03.5
01B7:  BCF    09.1
....................    while ( bit_test(lcd_read_byte(),7) ) ; 
*
01FB:  MOVF   78,W
01FC:  MOVWF  5F
01FD:  BTFSC  5F.7
01FE:  GOTO   1B8
....................    lcd_output_rs(address); 
01FF:  MOVF   5D,F
0200:  BTFSS  03.2
0201:  GOTO   206
0202:  BCF    03.5
0203:  BCF    09.1
0204:  GOTO   208
0205:  BSF    03.5
0206:  BCF    03.5
0207:  BSF    09.1
0208:  BSF    03.5
0209:  BCF    09.1
....................    delay_cycles(1); 
020A:  NOP
....................    lcd_output_rw(0); 
020B:  BCF    03.5
020C:  BCF    09.2
020D:  BSF    03.5
020E:  BCF    09.2
....................    delay_cycles(1); 
020F:  NOP
....................    lcd_output_enable(0); 
0210:  BCF    03.5
0211:  BCF    09.0
0212:  BSF    03.5
0213:  BCF    09.0
....................    lcd_send_nibble(n >> 4); 
0214:  SWAPF  5E,W
0215:  MOVWF  5F
0216:  MOVLW  0F
0217:  ANDWF  5F,F
0218:  MOVF   5F,W
0219:  MOVWF  60
021A:  BCF    03.5
021B:  CALL   12B
....................    lcd_send_nibble(n & 0xf); 
021C:  BSF    03.5
021D:  MOVF   5E,W
021E:  ANDLW  0F
021F:  MOVWF  5F
0220:  MOVWF  60
0221:  BCF    03.5
0222:  CALL   12B
0223:  RETURN
.................... } 
....................  
.................... #if defined(LCD_EXTENDED_NEWLINE) 
.................... unsigned int8 g_LcdX, g_LcdY; 
.................... #endif 
....................  
.................... void lcd_init(void)  
.................... { 
....................    unsigned int8 i; 
....................    unsigned int8 LCD_INIT_STRING[4] = {0x20 | (LCD_TYPE << 2), 0xc, 1, 6}; 
0224:  MOVLW  28
0225:  BSF    03.5
0226:  MOVWF  55
0227:  MOVLW  0C
0228:  MOVWF  56
0229:  MOVLW  01
022A:  MOVWF  57
022B:  MOVLW  06
022C:  MOVWF  58
....................                              // These bytes need to be sent to the LCD 
....................                              // to start it up. 
....................     
....................  
....................    lcd_output_enable(0); 
022D:  BCF    03.5
022E:  BCF    09.0
022F:  BSF    03.5
0230:  BCF    09.0
....................    lcd_output_rs(0); 
0231:  BCF    03.5
0232:  BCF    09.1
0233:  BSF    03.5
0234:  BCF    09.1
....................    lcd_output_rw(0); 
0235:  BCF    03.5
0236:  BCF    09.2
0237:  BSF    03.5
0238:  BCF    09.2
....................  
....................  #if defined(__PCB__) 
....................    set_tris_lcd(LCD_OUTPUT_MAP); 
....................  #else 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    output_drive(LCD_DATA4); 
0239:  BCF    03.5
023A:  BCF    31.0
023B:  MOVF   31,W
023C:  BSF    03.5
023D:  MOVWF  07
....................    output_drive(LCD_DATA5); 
023E:  BCF    03.5
023F:  BCF    31.1
0240:  MOVF   31,W
0241:  BSF    03.5
0242:  MOVWF  07
....................    output_drive(LCD_DATA6); 
0243:  BCF    03.5
0244:  BCF    31.2
0245:  MOVF   31,W
0246:  BSF    03.5
0247:  MOVWF  07
....................    output_drive(LCD_DATA7); 
0248:  BCF    03.5
0249:  BCF    31.3
024A:  MOVF   31,W
024B:  BSF    03.5
024C:  MOVWF  07
....................   #else 
....................    lcdtris.data = 0x0; 
....................   #endif 
....................    lcd_enable_tris(); 
024D:  BCF    09.0
....................    lcd_rs_tris(); 
024E:  BCF    09.1
....................    lcd_rw_tris(); 
024F:  BCF    09.2
....................  #endif 
....................      
....................    delay_ms(15); 
0250:  MOVLW  0F
0251:  MOVWF  59
0252:  BCF    03.5
0253:  CALL   117
....................    for(i=1;i<=3;++i) 
0254:  MOVLW  01
0255:  BSF    03.5
0256:  MOVWF  54
0257:  MOVF   54,W
0258:  SUBLW  03
0259:  BTFSS  03.0
025A:  GOTO   267
....................    { 
....................        lcd_send_nibble(3); 
025B:  MOVLW  03
025C:  MOVWF  60
025D:  BCF    03.5
025E:  CALL   12B
....................        delay_ms(5); 
025F:  MOVLW  05
0260:  BSF    03.5
0261:  MOVWF  59
0262:  BCF    03.5
0263:  CALL   117
0264:  BSF    03.5
0265:  INCF   54,F
0266:  GOTO   257
....................    } 
....................     
....................    lcd_send_nibble(2); 
0267:  MOVLW  02
0268:  MOVWF  60
0269:  BCF    03.5
026A:  CALL   12B
....................    delay_ms(5); 
026B:  MOVLW  05
026C:  BSF    03.5
026D:  MOVWF  59
026E:  BCF    03.5
026F:  CALL   117
....................    for(i=0;i<=3;++i) 
0270:  BSF    03.5
0271:  CLRF   54
0272:  MOVF   54,W
0273:  SUBLW  03
0274:  BTFSS  03.0
0275:  GOTO   284
....................       lcd_send_byte(0,LCD_INIT_STRING[i]); 
0276:  MOVLW  D5
0277:  ADDWF  54,W
0278:  MOVWF  04
0279:  BCF    03.7
027A:  MOVF   00,W
027B:  MOVWF  59
027C:  CLRF   5D
027D:  MOVF   59,W
027E:  MOVWF  5E
027F:  BCF    03.5
0280:  CALL   1B0
....................  
....................   #if defined(LCD_EXTENDED_NEWLINE) 
0281:  BSF    03.5
0282:  INCF   54,F
0283:  GOTO   272
0284:  BCF    03.5
0285:  BSF    0A.3
0286:  BCF    0A.4
0287:  GOTO   443 (RETURN)
....................    g_LcdX = 0; 
....................    g_LcdY = 0; 
....................   #endif 
.................... } 
....................  
.................... void lcd_gotoxy(unsigned int8 x, unsigned int8 y) 
.................... { 
....................    unsigned int8 address; 
....................     
....................    if(y!=1) 
0288:  BSF    03.5
0289:  DECFSZ 5A,W
028A:  GOTO   28C
028B:  GOTO   28F
....................       address=LCD_LINE_TWO; 
028C:  MOVLW  40
028D:  MOVWF  5B
028E:  GOTO   290
....................    else 
....................       address=0; 
028F:  CLRF   5B
....................       
....................    address+=x-1; 
0290:  MOVLW  01
0291:  SUBWF  59,W
0292:  ADDWF  5B,F
....................    lcd_send_byte(0,0x80|address); 
0293:  MOVF   5B,W
0294:  IORLW  80
0295:  MOVWF  5C
0296:  CLRF   5D
0297:  MOVF   5C,W
0298:  MOVWF  5E
0299:  BCF    03.5
029A:  CALL   1B0
....................  
....................   #if defined(LCD_EXTENDED_NEWLINE) 
029B:  RETURN
....................    g_LcdX = x - 1; 
....................    g_LcdY = y - 1; 
....................   #endif 
.................... } 
....................  
.................... void lcd_putc(char c) 
.................... { 
....................    switch (c) 
029C:  BSF    03.5
029D:  MOVF   58,W
029E:  XORLW  07
029F:  BCF    03.5
02A0:  BTFSC  03.2
02A1:  GOTO   2AC
02A2:  XORLW  0B
02A3:  BTFSC  03.2
02A4:  GOTO   2B3
02A5:  XORLW  06
02A6:  BTFSC  03.2
02A7:  GOTO   2BF
02A8:  XORLW  02
02A9:  BTFSC  03.2
02AA:  GOTO   2C7
02AB:  GOTO   2CE
....................    { 
....................       case '\a'   :  lcd_gotoxy(1,1);     break; 
02AC:  MOVLW  01
02AD:  BSF    03.5
02AE:  MOVWF  59
02AF:  MOVWF  5A
02B0:  BCF    03.5
02B1:  CALL   288
02B2:  GOTO   2D5
....................  
....................       case '\f'   :  lcd_send_byte(0,1); 
02B3:  BSF    03.5
02B4:  CLRF   5D
02B5:  MOVLW  01
02B6:  MOVWF  5E
02B7:  BCF    03.5
02B8:  CALL   1B0
....................                      delay_ms(2); 
02B9:  MOVLW  02
02BA:  BSF    03.5
02BB:  MOVWF  59
02BC:  BCF    03.5
02BD:  CALL   117
....................                     #if defined(LCD_EXTENDED_NEWLINE) 
....................                      g_LcdX = 0; 
....................                      g_LcdY = 0; 
....................                     #endif 
....................                      break; 
02BE:  GOTO   2D5
....................  
....................      #if defined(LCD_EXTENDED_NEWLINE) 
....................       case '\r'   :  lcd_gotoxy(1, g_LcdY+1);   break; 
....................       case '\n'   : 
....................          while (g_LcdX++ < LCD_LINE_LENGTH) 
....................          { 
....................             lcd_send_byte(1, ' '); 
....................          } 
....................          lcd_gotoxy(1, g_LcdY+2); 
....................          break; 
....................      #else 
....................       case '\n'   : lcd_gotoxy(1,2);        break; 
02BF:  MOVLW  01
02C0:  BSF    03.5
02C1:  MOVWF  59
02C2:  MOVLW  02
02C3:  MOVWF  5A
02C4:  BCF    03.5
02C5:  CALL   288
02C6:  GOTO   2D5
....................      #endif 
....................       
....................       case '\b'   : lcd_send_byte(0,0x10);  break; 
02C7:  BSF    03.5
02C8:  CLRF   5D
02C9:  MOVLW  10
02CA:  MOVWF  5E
02CB:  BCF    03.5
02CC:  CALL   1B0
02CD:  GOTO   2D5
....................       
....................      #if defined(LCD_EXTENDED_NEWLINE) 
....................       default     :  
....................          if (g_LcdX < LCD_LINE_LENGTH) 
....................          { 
....................             lcd_send_byte(1, c); 
....................             g_LcdX++; 
....................          } 
....................          break; 
....................      #else 
....................       default     : lcd_send_byte(1,c);     break; 
02CE:  MOVLW  01
02CF:  BSF    03.5
02D0:  MOVWF  5D
02D1:  MOVF   58,W
02D2:  MOVWF  5E
02D3:  BCF    03.5
02D4:  CALL   1B0
....................      #endif 
....................    } 
02D5:  RETURN
.................... } 
....................   
.................... char lcd_getc(unsigned int8 x, unsigned int8 y) 
.................... { 
....................    char value; 
....................  
....................    lcd_gotoxy(x,y); 
....................    while ( bit_test(lcd_read_byte(),7) ); // wait until busy flag is low 
....................    lcd_output_rs(1); 
....................    value = lcd_read_byte(); 
....................    lcd_output_rs(0); 
....................     
....................    return(value); 
.................... } 
....................  
.................... // write a custom character to the ram 
.................... // which is 0-7 and specifies which character array we are modifying. 
.................... // ptr points to an array of 8 bytes, where each byte is the next row of 
.................... //    pixels.  only bits 0-4 are used.  the last row is the cursor row, and 
.................... //    usually you will want to leave this byte 0x00. 
.................... void lcd_set_cgram_char(unsigned int8 which, unsigned int8 *ptr) 
.................... { 
....................    unsigned int i; 
....................  
....................    which <<= 3; 
....................    which &= 0x38; 
....................  
....................    lcd_send_byte(0, 0x40 | which);  //set cgram address 
....................  
....................    for(i=0; i<8; i++) 
....................    { 
....................       lcd_send_byte(1, *ptr++); 
....................    } 
....................    
....................    #if defined(LCD_EXTENDED_NEWLINE) 
....................     lcd_gotoxy(g_LcdX+1, g_LcdY+1);  //set ddram address 
....................    #endif 
.................... } 
....................  
.................... void lcd_cursor_on(int1 on) 
.................... { 
....................    if (on) 
....................    { 
....................       lcd_send_byte(0,0x0F);           //turn LCD cursor ON 
....................    } 
....................    else 
....................    { 
....................       lcd_send_byte(0,0x0C);           //turn LCD cursor OFF 
....................    } 
.................... } 
....................  
.................... #endif 
....................  
.................... #BIT TMR1IF = 0x0C.0 //bit thu 0 (TMR1IF) cua PIR1 
....................  
.................... #INCLUDE <khaibaobien.c> // VARIABLE. 
.................... UNSIGNED INT16 KQADC,AN0, AN1; 
.................... UNSIGNED INT8 CONFIG_FUN=0; 
.................... UNSIGNED INT8 VT=0, KYTU=0;// KYTU[30],  
.................... UNSIGNED INT8 ID_NODE_NHAN, ID_DEVICE_NHAN, TT_DEVICE_NHAN; 
.................... UNSIGNED INT8 ID_GATEWAY[6] = {5,7,3,5,4,5}; 
*
0B83:  MOVLW  05
0B84:  MOVWF  3E
0B85:  MOVLW  07
0B86:  MOVWF  3F
0B87:  MOVLW  03
0B88:  MOVWF  40
0B89:  MOVLW  05
0B8A:  MOVWF  41
0B8B:  MOVLW  04
0B8C:  MOVWF  42
0B8D:  MOVLW  05
0B8E:  MOVWF  43
.................... UNSIGNED INT8 ID_NODE[4] = {0,0,0,0}; 
0B8F:  CLRF   44
0B90:  CLRF   45
0B91:  CLRF   46
0B92:  CLRF   47
.................... UNSIGNED INT8 LEN_PACKAGES = 0; 
.................... INT1 TTNHAN = 0, TT_CONFIG=0, TT_CONTROL=0,TT_CONFIG_DONE=0, TT_FUN=0, TT_STT=0; 
....................  
.................... CHAR *ID_NODE_CHAR[]= "0000"; 
0B93:  MOVLW  30
0B94:  MOVWF  4C
0B95:  MOVWF  4D
0B96:  MOVWF  4E
0B97:  MOVWF  4F
0B98:  CLRF   50
0B99:  CLRF   4B
0B9A:  MOVLW  4C
0B9B:  MOVWF  4A
.................... CHAR *ID_GATEWAY_CHAR[]= "000000"; 
0B9C:  MOVLW  30
0B9D:  MOVWF  53
0B9E:  MOVWF  54
0B9F:  MOVWF  55
0BA0:  MOVWF  56
0BA1:  MOVWF  57
0BA2:  MOVWF  58
0BA3:  CLRF   59
0BA4:  CLRF   52
0BA5:  MOVLW  53
0BA6:  MOVWF  51
.................... CHAR KYTUCHAR[20]="HIHI"; 
0BA7:  MOVLW  48
0BA8:  MOVWF  5A
0BA9:  MOVLW  49
0BAA:  MOVWF  5B
0BAB:  MOVLW  48
0BAC:  MOVWF  5C
0BAD:  MOVLW  49
0BAE:  MOVWF  5D
0BAF:  CLRF   5E
.................... //CHAR *DATA_NHANDUOC[]={"IDGW","IDNODE","COMMAN","DATA"}; 
.................... CHAR *PACKAGE_CONFIG[]={"*", "LENGHT","C_F", "ID_GW1234" ,"ID_NODE","#"}; 
0BB0:  MOVLW  2A
0BB1:  BSF    03.5
0BB2:  MOVWF  2C
0BB3:  CLRF   2D
0BB4:  MOVLW  4C
0BB5:  MOVWF  2E
0BB6:  MOVLW  45
0BB7:  MOVWF  2F
0BB8:  MOVLW  4E
0BB9:  MOVWF  30
0BBA:  MOVLW  47
0BBB:  MOVWF  31
0BBC:  MOVLW  48
0BBD:  MOVWF  32
0BBE:  MOVLW  54
0BBF:  MOVWF  33
0BC0:  CLRF   34
0BC1:  MOVLW  43
0BC2:  MOVWF  35
0BC3:  MOVLW  5F
0BC4:  MOVWF  36
0BC5:  MOVLW  46
0BC6:  MOVWF  37
0BC7:  CLRF   38
0BC8:  MOVLW  49
0BC9:  MOVWF  39
0BCA:  MOVLW  44
0BCB:  MOVWF  3A
0BCC:  MOVLW  5F
0BCD:  MOVWF  3B
0BCE:  MOVLW  47
0BCF:  MOVWF  3C
0BD0:  MOVLW  57
0BD1:  MOVWF  3D
0BD2:  MOVLW  31
0BD3:  MOVWF  3E
0BD4:  MOVLW  32
0BD5:  MOVWF  3F
0BD6:  MOVLW  33
0BD7:  MOVWF  40
0BD8:  MOVLW  34
0BD9:  MOVWF  41
0BDA:  CLRF   42
0BDB:  MOVLW  49
0BDC:  MOVWF  43
0BDD:  MOVLW  44
0BDE:  MOVWF  44
0BDF:  MOVLW  5F
0BE0:  MOVWF  45
0BE1:  MOVLW  4E
0BE2:  MOVWF  46
0BE3:  MOVLW  4F
0BE4:  MOVWF  47
0BE5:  MOVLW  44
0BE6:  MOVWF  48
0BE7:  MOVLW  45
0BE8:  MOVWF  49
0BE9:  CLRF   4A
0BEA:  MOVLW  23
0BEB:  MOVWF  4B
0BEC:  CLRF   4C
0BED:  CLRF   21
0BEE:  MOVLW  AC
0BEF:  MOVWF  20
0BF0:  CLRF   23
0BF1:  MOVLW  AE
0BF2:  MOVWF  22
0BF3:  CLRF   25
0BF4:  MOVLW  B5
0BF5:  MOVWF  24
0BF6:  CLRF   27
0BF7:  MOVLW  B9
0BF8:  MOVWF  26
0BF9:  CLRF   29
0BFA:  MOVLW  C3
0BFB:  MOVWF  28
0BFC:  CLRF   2B
0BFD:  MOVLW  CB
0BFE:  MOVWF  2A
.................... CHAR *TEMP_CHAR[]="00"; 
0BFF:  MOVLW  30
0C00:  MOVWF  70
0C01:  MOVWF  71
0C02:  CLRF   72
0C03:  BCF    03.5
0C04:  CLRF   6F
0C05:  MOVLW  70
0C06:  MOVWF  6E
.................... //CHAR *TEMP_CHAR2[]="00000000";  
.................... CHAR *TEMP_CHAR3[]="0000";  
0C07:  MOVLW  30
0C08:  BSF    03.5
0C09:  MOVWF  4D
0C0A:  MOVWF  4E
0C0B:  MOVWF  4F
0C0C:  MOVWF  50
0C0D:  CLRF   51
0C0E:  CLRF   74
0C0F:  MOVLW  CD
0C10:  MOVWF  73
....................  
....................  
....................  
.................... //#INCLUDE <CONFIG_NODE.C> // CU HINH NODE. 
.................... #INCLUDE <config_1.C> // CU HINH NODE. 
....................  
.................... //--------------------------------------------------------------------// 
.................... VOID CHON_ID() 
.................... { 
....................    // TT_CONFIG_DONE; 
....................    TT_CONFIG_DONE = 0; 
*
05D5:  BCF    49.3
....................    TT_STT = 1; 
05D6:  BSF    49.5
....................    UNSIGNED INT8 NUM = 0; 
05D7:  BSF    03.5
05D8:  CLRF   54
....................    TEMP_CHAR = "0"; 
05D9:  CLRF   55
05DA:  CLRF   56
05DB:  MOVLW  6E
05DC:  MOVWF  04
05DD:  BCF    03.7
05DE:  MOVF   55,W
05DF:  ADDWF  04,F
05E0:  MOVF   56,W
05E1:  BCF    03.5
05E2:  CALL   058
05E3:  MOVWF  00
05E4:  IORLW  00
05E5:  BTFSC  03.2
05E6:  GOTO   5EC
05E7:  BSF    03.5
05E8:  INCF   56,F
05E9:  INCF   55,F
05EA:  GOTO   5DB
05EB:  BCF    03.5
....................    LCD_GOTOXY (1, 2) ; 
05EC:  MOVLW  01
05ED:  BSF    03.5
05EE:  MOVWF  59
05EF:  MOVLW  02
05F0:  MOVWF  5A
05F1:  BCF    03.5
05F2:  CALL   288
....................    DELAY_MS (10); 
05F3:  MOVLW  0A
05F4:  BSF    03.5
05F5:  MOVWF  59
05F6:  BCF    03.5
05F7:  CALL   117
....................    PRINTF (LCD_PUTC, "NODE: "); 
05F8:  MOVLW  64
05F9:  BSF    03.6
05FA:  MOVWF  0D
05FB:  MOVLW  00
05FC:  MOVWF  0F
05FD:  BCF    03.6
05FE:  CALL   2D6
....................    PRINTF (LCD_PUTC, "0000"); 
05FF:  MOVLW  68
0600:  BSF    03.6
0601:  MOVWF  0D
0602:  MOVLW  00
0603:  MOVWF  0F
0604:  BCF    03.6
0605:  CALL   2D6
....................    LCD_GOTOXY (1, 1) ; 
0606:  MOVLW  01
0607:  BSF    03.5
0608:  MOVWF  59
0609:  MOVWF  5A
060A:  BCF    03.5
060B:  CALL   288
....................    PRINTF (LCD_PUTC, "      _              ");//6 SPACE PHIA TRUOC "_" 
060C:  MOVLW  6B
060D:  BSF    03.6
060E:  MOVWF  0D
060F:  MOVLW  00
0610:  MOVWF  0F
0611:  BCF    03.6
0612:  CALL   2D6
....................    //ID_GW = "1234";     
....................  
....................    WHILE (TT_STT) 
0613:  BTFSS  49.5
0614:  GOTO   691
....................    { 
....................       IF (!INPUT (BT2_PIN)) //NEU NUT BAM DUOC BAM 
0615:  BSF    03.5
0616:  BSF    06.2
0617:  BCF    03.5
0618:  BTFSC  06.2
0619:  GOTO   638
....................       { 
....................           
....................          NUM++; 
061A:  BSF    03.5
061B:  INCF   54,F
....................          NUM = NUM % 4; 
061C:  MOVLW  03
061D:  ANDWF  54,F
....................          LCD_GOTOXY (3 + NUM, 1); 
061E:  ADDWF  54,W
061F:  MOVWF  55
0620:  MOVWF  59
0621:  MOVLW  01
0622:  MOVWF  5A
0623:  BCF    03.5
0624:  CALL   288
....................          PRINTF (LCD_PUTC, "    _    ");//4SPACE 
0625:  MOVLW  76
0626:  BSF    03.6
0627:  MOVWF  0D
0628:  MOVLW  00
0629:  MOVWF  0F
062A:  BCF    03.6
062B:  CALL   2D6
....................          DELAY_MS (300);  
062C:  MOVLW  02
062D:  BSF    03.5
062E:  MOVWF  55
062F:  MOVLW  96
0630:  MOVWF  59
0631:  BCF    03.5
0632:  CALL   117
0633:  BSF    03.5
0634:  DECFSZ 55,F
0635:  GOTO   62F
....................       } 
0636:  GOTO   68F
0637:  BCF    03.5
....................  
....................       ELSE IF (!INPUT (BT3_PIN)) 
0638:  BSF    03.5
0639:  BSF    06.3
063A:  BCF    03.5
063B:  BTFSC  06.3
063C:  GOTO   690
....................       { 
....................          ID_NODE[NUM]++; 
063D:  MOVLW  44
063E:  BSF    03.5
063F:  ADDWF  54,W
0640:  MOVWF  04
0641:  BCF    03.7
0642:  INCF   00,F
....................          ID_NODE[NUM] = ID_NODE[NUM] % 10; 
0643:  MOVLW  44
0644:  ADDWF  54,W
0645:  MOVWF  78
0646:  CLRF   7A
0647:  BTFSC  03.0
0648:  INCF   7A,F
0649:  MOVF   78,W
064A:  MOVWF  55
064B:  MOVF   7A,W
064C:  MOVWF  56
064D:  MOVLW  44
064E:  ADDWF  54,W
064F:  MOVWF  04
0650:  BCF    03.7
0651:  MOVF   00,W
0652:  MOVWF  58
0653:  MOVLW  0A
0654:  MOVWF  59
0655:  BCF    03.5
0656:  CALL   545
0657:  MOVF   77,W
0658:  BSF    03.5
0659:  MOVWF  57
065A:  MOVF   55,W
065B:  MOVWF  04
065C:  BCF    03.7
065D:  BTFSC  56.0
065E:  BSF    03.7
065F:  MOVF   57,W
0660:  MOVWF  00
....................          ITOA (ID_NODE[NUM], 10, TEMP_CHAR); 
0661:  MOVLW  44
0662:  ADDWF  54,W
0663:  MOVWF  04
0664:  BCF    03.7
0665:  MOVF   00,W
0666:  MOVWF  55
0667:  CLRF   5A
0668:  CLRF   59
0669:  CLRF   58
066A:  MOVF   55,W
066B:  MOVWF  57
066C:  MOVLW  0A
066D:  MOVWF  5B
066E:  CLRF   5D
066F:  MOVLW  6E
0670:  MOVWF  5C
0671:  BCF    03.5
0672:  CALL   3C6
....................          LCD_GOTOXY (7 + NUM, 2); 
0673:  MOVLW  07
0674:  BSF    03.5
0675:  ADDWF  54,W
0676:  MOVWF  55
0677:  MOVWF  59
0678:  MOVLW  02
0679:  MOVWF  5A
067A:  BCF    03.5
067B:  CALL   288
....................          DELAY_MS (10); 
067C:  MOVLW  0A
067D:  BSF    03.5
067E:  MOVWF  59
067F:  BCF    03.5
0680:  CALL   117
....................          PRINTF (LCD_PUTC, TEMP_CHAR); 
0681:  MOVLW  6E
0682:  MOVWF  04
0683:  BCF    03.7
0684:  CALL   528
....................          DELAY_MS (300); 
0685:  MOVLW  02
0686:  BSF    03.5
0687:  MOVWF  55
0688:  MOVLW  96
0689:  MOVWF  59
068A:  BCF    03.5
068B:  CALL   117
068C:  BSF    03.5
068D:  DECFSZ 55,F
068E:  GOTO   688
068F:  BCF    03.5
....................       } 
0690:  GOTO   613
....................    } 
.................... } 
....................  
.................... VOID NHAPID_GW() 
*
0692:  BSF    03.5
0693:  CLRF   54
.................... { 
....................    UNSIGNED INT8 NUM = 0; 
....................    TEMP_CHAR = "0"; 
0694:  CLRF   55
0695:  CLRF   56
0696:  MOVLW  6E
0697:  MOVWF  04
0698:  BCF    03.7
0699:  MOVF   55,W
069A:  ADDWF  04,F
069B:  MOVF   56,W
069C:  BCF    03.5
069D:  CALL   058
069E:  MOVWF  00
069F:  IORLW  00
06A0:  BTFSC  03.2
06A1:  GOTO   6A7
06A2:  BSF    03.5
06A3:  INCF   56,F
06A4:  INCF   55,F
06A5:  GOTO   696
06A6:  BCF    03.5
....................    TT_CONFIG_DONE = 0; 
06A7:  BCF    49.3
....................    TT_STT = 1; 
06A8:  BSF    49.5
....................    LCD_GOTOXY (1, 2) ; 
06A9:  MOVLW  01
06AA:  BSF    03.5
06AB:  MOVWF  59
06AC:  MOVLW  02
06AD:  MOVWF  5A
06AE:  BCF    03.5
06AF:  CALL   288
....................    DELAY_MS (10); 
06B0:  MOVLW  0A
06B1:  BSF    03.5
06B2:  MOVWF  59
06B3:  BCF    03.5
06B4:  CALL   117
....................    PRINTF (LCD_PUTC, "ID_GW:"); 
06B5:  MOVLW  7B
06B6:  BSF    03.6
06B7:  MOVWF  0D
06B8:  MOVLW  00
06B9:  MOVWF  0F
06BA:  BCF    03.6
06BB:  CALL   2D6
....................    PRINTF (LCD_PUTC, "000000"); 
06BC:  MOVLW  7F
06BD:  BSF    03.6
06BE:  MOVWF  0D
06BF:  MOVLW  00
06C0:  MOVWF  0F
06C1:  BCF    03.6
06C2:  CALL   2D6
....................    LCD_GOTOXY (1, 1) ; 
06C3:  MOVLW  01
06C4:  BSF    03.5
06C5:  MOVWF  59
06C6:  MOVWF  5A
06C7:  BCF    03.5
06C8:  CALL   288
....................    PRINTF (LCD_PUTC, "      _                ");//6 SPACE PHIA TRUOC "_" 
06C9:  MOVLW  83
06CA:  BSF    03.6
06CB:  MOVWF  0D
06CC:  MOVLW  00
06CD:  MOVWF  0F
06CE:  BCF    03.6
06CF:  CALL   2D6
....................    //ID_GW = "1234";     
....................  
....................    WHILE (TT_STT) 
06D0:  BTFSS  49.5
06D1:  GOTO   756
....................    { 
....................       IF (!INPUT (BT2_PIN)) //NEU NUT BAM DUOC BAM 
06D2:  BSF    03.5
06D3:  BSF    06.2
06D4:  BCF    03.5
06D5:  BTFSC  06.2
06D6:  GOTO   6FD
....................       { 
....................           
....................          NUM++; 
06D7:  BSF    03.5
06D8:  INCF   54,F
....................          NUM = NUM % 6; 
06D9:  MOVF   54,W
06DA:  MOVWF  58
06DB:  MOVLW  06
06DC:  MOVWF  59
06DD:  BCF    03.5
06DE:  CALL   545
06DF:  MOVF   77,W
06E0:  BSF    03.5
06E1:  MOVWF  54
....................          LCD_GOTOXY (3 + NUM, 1); 
06E2:  MOVLW  03
06E3:  ADDWF  54,W
06E4:  MOVWF  55
06E5:  MOVWF  59
06E6:  MOVLW  01
06E7:  MOVWF  5A
06E8:  BCF    03.5
06E9:  CALL   288
....................          PRINTF (LCD_PUTC, "    _    ");//4SPACE 
06EA:  MOVLW  8F
06EB:  BSF    03.6
06EC:  MOVWF  0D
06ED:  MOVLW  00
06EE:  MOVWF  0F
06EF:  BCF    03.6
06F0:  CALL   2D6
....................          DELAY_MS (300);  
06F1:  MOVLW  02
06F2:  BSF    03.5
06F3:  MOVWF  55
06F4:  MOVLW  96
06F5:  MOVWF  59
06F6:  BCF    03.5
06F7:  CALL   117
06F8:  BSF    03.5
06F9:  DECFSZ 55,F
06FA:  GOTO   6F4
....................       } 
06FB:  GOTO   754
06FC:  BCF    03.5
....................  
....................       ELSE IF (!INPUT (BT3_PIN)) 
06FD:  BSF    03.5
06FE:  BSF    06.3
06FF:  BCF    03.5
0700:  BTFSC  06.3
0701:  GOTO   755
....................       { 
....................          ID_GATEWAY[NUM]++; 
0702:  MOVLW  3E
0703:  BSF    03.5
0704:  ADDWF  54,W
0705:  MOVWF  04
0706:  BCF    03.7
0707:  INCF   00,F
....................          ID_GATEWAY[NUM] = ID_GATEWAY[NUM] % 10; 
0708:  MOVLW  3E
0709:  ADDWF  54,W
070A:  MOVWF  78
070B:  CLRF   7A
070C:  BTFSC  03.0
070D:  INCF   7A,F
070E:  MOVF   78,W
070F:  MOVWF  55
0710:  MOVF   7A,W
0711:  MOVWF  56
0712:  MOVLW  3E
0713:  ADDWF  54,W
0714:  MOVWF  04
0715:  BCF    03.7
0716:  MOVF   00,W
0717:  MOVWF  58
0718:  MOVLW  0A
0719:  MOVWF  59
071A:  BCF    03.5
071B:  CALL   545
071C:  MOVF   77,W
071D:  BSF    03.5
071E:  MOVWF  57
071F:  MOVF   55,W
0720:  MOVWF  04
0721:  BCF    03.7
0722:  BTFSC  56.0
0723:  BSF    03.7
0724:  MOVF   57,W
0725:  MOVWF  00
....................          ITOA (ID_GATEWAY[NUM], 10, TEMP_CHAR); 
0726:  MOVLW  3E
0727:  ADDWF  54,W
0728:  MOVWF  04
0729:  BCF    03.7
072A:  MOVF   00,W
072B:  MOVWF  55
072C:  CLRF   5A
072D:  CLRF   59
072E:  CLRF   58
072F:  MOVF   55,W
0730:  MOVWF  57
0731:  MOVLW  0A
0732:  MOVWF  5B
0733:  CLRF   5D
0734:  MOVLW  6E
0735:  MOVWF  5C
0736:  BCF    03.5
0737:  CALL   3C6
....................          LCD_GOTOXY (7 + NUM, 2); 
0738:  MOVLW  07
0739:  BSF    03.5
073A:  ADDWF  54,W
073B:  MOVWF  55
073C:  MOVWF  59
073D:  MOVLW  02
073E:  MOVWF  5A
073F:  BCF    03.5
0740:  CALL   288
....................          DELAY_MS (10); 
0741:  MOVLW  0A
0742:  BSF    03.5
0743:  MOVWF  59
0744:  BCF    03.5
0745:  CALL   117
....................          PRINTF (LCD_PUTC, TEMP_CHAR); 
0746:  MOVLW  6E
0747:  MOVWF  04
0748:  BCF    03.7
0749:  CALL   528
....................          DELAY_MS (300); 
074A:  MOVLW  02
074B:  BSF    03.5
074C:  MOVWF  55
074D:  MOVLW  96
074E:  MOVWF  59
074F:  BCF    03.5
0750:  CALL   117
0751:  BSF    03.5
0752:  DECFSZ 55,F
0753:  GOTO   74D
0754:  BCF    03.5
....................       } 
0755:  GOTO   6D0
....................    } 
.................... } 
....................  
.................... VOID BUTT_OKE() 
.................... { 
....................    TT_CONFIG_DONE = 0; 
*
00F2:  BCF    03.6
00F3:  BCF    49.3
....................    TT_FUN = 0;//BREAK WHILE BUTT_FUN 
00F4:  BCF    49.4
....................    TT_STT = 0;// BREAK WHILE CHONID/NHAPID_GW 
00F5:  BCF    49.5
.................... } 
....................  
.................... VOID SELLECT_FUN() 
.................... { 
....................    TT_CONFIG_DONE = 0; 
*
05CD:  BCF    49.3
....................  
....................    SWITCH (CONFIG_FUN) 
05CE:  MOVF   38,W
05CF:  BTFSC  03.2
05D0:  GOTO   5D5
05D1:  XORLW  01
05D2:  BTFSC  03.2
05D3:  GOTO   692
05D4:  GOTO   756
....................    { 
....................       CASE 0: 
....................       CHON_ID (); 
....................       BREAK; 
*
0691:  GOTO   756
....................  
....................       CASE 1:     
....................       NHAPID_GW (); 
....................       BREAK; 
....................    } 
.................... } 
....................  
.................... VOID BUTT_FUN() 
.................... { 
....................    TT_FUN = 1; 
*
055C:  BSF    49.4
....................    LCD_GOTOXY (1, 1) ; 
055D:  MOVLW  01
055E:  BSF    03.5
055F:  MOVWF  59
0560:  MOVWF  5A
0561:  BCF    03.5
0562:  CALL   288
....................    DELAY_MS (10); 
0563:  MOVLW  0A
0564:  BSF    03.5
0565:  MOVWF  59
0566:  BCF    03.5
0567:  CALL   117
....................    PRINTF (LCD_PUTC, "CONFIG:        "); 
0568:  MOVLW  94
0569:  BSF    03.6
056A:  MOVWF  0D
056B:  MOVLW  00
056C:  MOVWF  0F
056D:  BCF    03.6
056E:  CALL   2D6
....................  
....................    // HIEN THI LCD 
....................    LCD_GOTOXY (1, 2) ; 
056F:  MOVLW  01
0570:  BSF    03.5
0571:  MOVWF  59
0572:  MOVLW  02
0573:  MOVWF  5A
0574:  BCF    03.5
0575:  CALL   288
....................    DELAY_MS (10); 
0576:  MOVLW  0A
0577:  BSF    03.5
0578:  MOVWF  59
0579:  BCF    03.5
057A:  CALL   117
....................    PRINTF (LCD_PUTC, "CASE:          ") ; 
057B:  MOVLW  9C
057C:  BSF    03.6
057D:  MOVWF  0D
057E:  MOVLW  00
057F:  MOVWF  0F
0580:  BCF    03.6
0581:  CALL   2D6
....................  
....................    WHILE (TT_FUN) 
0582:  BTFSS  49.4
0583:  GOTO   5CB
....................    { 
....................       IF (INPUT (BT2_PIN) == 0) //NEU NUT BAM DUOC BAM 
0584:  BSF    03.5
0585:  BSF    06.2
0586:  BCF    03.5
0587:  BTFSC  06.2
0588:  GOTO   5CA
....................       { 
....................          CONFIG_FUN ++; 
0589:  INCF   38,F
....................          CONFIG_FUN = CONFIG_FUN % 2; 
058A:  MOVLW  01
058B:  ANDWF  38,F
....................          DELAY_MS (300); 
058C:  MOVLW  02
058D:  BSF    03.5
058E:  MOVWF  54
058F:  MOVLW  96
0590:  MOVWF  59
0591:  BCF    03.5
0592:  CALL   117
0593:  BSF    03.5
0594:  DECFSZ 54,F
0595:  GOTO   58F
....................          //HIEN THI 
....................          LCD_GOTOXY (6, 2) ; 
0596:  MOVLW  06
0597:  MOVWF  59
0598:  MOVLW  02
0599:  MOVWF  5A
059A:  BCF    03.5
059B:  CALL   288
....................          ITOA (CONFIG_FUN, 10, TEMP_CHAR); 
059C:  BSF    03.5
059D:  CLRF   5A
059E:  CLRF   59
059F:  CLRF   58
05A0:  BCF    03.5
05A1:  MOVF   38,W
05A2:  BSF    03.5
05A3:  MOVWF  57
05A4:  MOVLW  0A
05A5:  MOVWF  5B
05A6:  CLRF   5D
05A7:  MOVLW  6E
05A8:  MOVWF  5C
05A9:  BCF    03.5
05AA:  CALL   3C6
....................          DELAY_MS (10); 
05AB:  MOVLW  0A
05AC:  BSF    03.5
05AD:  MOVWF  59
05AE:  BCF    03.5
05AF:  CALL   117
....................          PRINTF (LCD_PUTC, TEMP_CHAR); 
05B0:  MOVLW  6E
05B1:  MOVWF  04
05B2:  BCF    03.7
05B3:  CALL   528
....................  
....................          SWITCH (CONFIG_FUN) 
05B4:  MOVF   38,W
05B5:  BTFSC  03.2
05B6:  GOTO   5BB
05B7:  XORLW  01
05B8:  BTFSC  03.2
05B9:  GOTO   5C3
05BA:  GOTO   5CA
....................          { 
....................             CASE 0: 
....................             PRINTF (LCD_PUTC, " - ID-NODE      "); 
05BB:  MOVLW  A4
05BC:  BSF    03.6
05BD:  MOVWF  0D
05BE:  MOVLW  00
05BF:  MOVWF  0F
05C0:  BCF    03.6
05C1:  CALL   2D6
....................             BREAK; 
05C2:  GOTO   5CA
....................  
....................             CASE 1: 
....................             PRINTF (LCD_PUTC, " - ID-GW       "); 
05C3:  MOVLW  AD
05C4:  BSF    03.6
05C5:  MOVWF  0D
05C6:  MOVLW  00
05C7:  MOVWF  0F
05C8:  BCF    03.6
05C9:  CALL   2D6
....................             BREAK;             
....................          } 
....................       } 
05CA:  GOTO   582
....................    } 
....................  
....................    ////// 
....................    IF (!TT_CONFIG_DONE) 
05CB:  BTFSC  49.3
05CC:  GOTO   756
....................    { 
....................       SELLECT_FUN (); 
....................    } 
*
0756:  BSF    0A.3
0757:  BCF    0A.4
0758:  GOTO   450 (RETURN)
.................... } 
.................... VOID XULY_IDNODE_NHAP(){ 
....................    *TEMP_CHAR3 = "\0"; 
*
083F:  CLRF   7A
0840:  MOVLW  73
0841:  MOVWF  56
0842:  MOVF   7A,W
0843:  MOVWF  57
0844:  MOVF   56,W
0845:  MOVWF  04
0846:  BCF    03.7
0847:  BTFSC  57.0
0848:  BSF    03.7
0849:  CLRF   00
....................    *ID_NODE_CHAR = "\0"; 
084A:  CLRF   7A
084B:  MOVLW  4A
084C:  MOVWF  56
084D:  MOVF   7A,W
084E:  MOVWF  57
084F:  MOVF   56,W
0850:  MOVWF  04
0851:  BCF    03.7
0852:  BTFSC  57.0
0853:  BSF    03.7
0854:  CLRF   00
....................    FOR (int j = 0; j < 4; j++) 
0855:  CLRF   55
0856:  MOVF   55,W
0857:  SUBLW  03
0858:  BTFSS  03.0
0859:  GOTO   083
....................    { 
....................       ITOA (ID_NODE[j], 10, TEMP_CHAR); 
085A:  MOVLW  44
085B:  ADDWF  55,W
085C:  MOVWF  04
085D:  BCF    03.7
085E:  MOVF   00,W
085F:  MOVWF  56
0860:  CLRF   5A
0861:  CLRF   59
0862:  CLRF   58
0863:  MOVF   56,W
0864:  MOVWF  57
0865:  MOVLW  0A
0866:  MOVWF  5B
0867:  CLRF   5D
0868:  MOVLW  6E
0869:  MOVWF  5C
086A:  BCF    0A.3
086B:  BCF    03.5
086C:  CALL   3C6
086D:  BSF    0A.3
....................       DELAY_MS (1); 
086E:  MOVLW  01
086F:  BSF    03.5
0870:  MOVWF  59
0871:  BCF    0A.3
0872:  BCF    03.5
0873:  CALL   117
0874:  BSF    0A.3
....................       STRCAT (TEMP_CHAR3, TEMP_CHAR); 
0875:  BSF    03.5
0876:  CLRF   57
0877:  MOVLW  73
0878:  MOVWF  56
0879:  CLRF   59
087A:  MOVLW  6E
087B:  MOVWF  58
087C:  BCF    0A.3
087D:  BCF    03.5
087E:  CALL   759
087F:  BSF    0A.3
0880:  BSF    03.5
0881:  INCF   55,F
0882:  GOTO   056
....................    }   
....................    //ID_NODE_CHAR = TEMP_CHAR3;    
....................    STRCPY(ID_NODE_CHAR,TEMP_CHAR3); 
0883:  CLRF   59
0884:  MOVLW  73
0885:  MOVWF  58
0886:  CLRF   57
0887:  MOVLW  4A
0888:  MOVWF  56
0889:  MOVF   58,W
088A:  MOVWF  04
088B:  BCF    03.7
088C:  BTFSC  59.0
088D:  BSF    03.7
088E:  MOVF   00,W
088F:  MOVWF  5A
0890:  MOVF   56,W
0891:  MOVWF  04
0892:  BCF    03.7
0893:  BTFSC  57.0
0894:  BSF    03.7
0895:  MOVF   5A,W
0896:  MOVWF  00
0897:  MOVF   00,F
0898:  BTFSC  03.2
0899:  GOTO   09D
089A:  INCF   56,F
089B:  INCF   58,F
089C:  GOTO   089
....................    //strcpy 
.................... } 
.................... VOID XULY_IDGW_NHAP(){ 
....................  
....................    *ID_GATEWAY_CHAR = "\0"; 
*
0802:  CLRF   7A
0803:  MOVLW  51
0804:  BSF    03.5
0805:  MOVWF  56
0806:  MOVF   7A,W
0807:  MOVWF  57
0808:  MOVF   56,W
0809:  MOVWF  04
080A:  BCF    03.7
080B:  BTFSC  57.0
080C:  BSF    03.7
080D:  CLRF   00
....................    FOR (int j = 0; j < 6; j++) 
080E:  CLRF   55
080F:  MOVF   55,W
0810:  SUBLW  05
0811:  BTFSS  03.0
0812:  GOTO   03C
....................    { 
....................       ITOA (ID_GATEWAY[j], 10, TEMP_CHAR); 
0813:  MOVLW  3E
0814:  ADDWF  55,W
0815:  MOVWF  04
0816:  BCF    03.7
0817:  MOVF   00,W
0818:  MOVWF  56
0819:  CLRF   5A
081A:  CLRF   59
081B:  CLRF   58
081C:  MOVF   56,W
081D:  MOVWF  57
081E:  MOVLW  0A
081F:  MOVWF  5B
0820:  CLRF   5D
0821:  MOVLW  6E
0822:  MOVWF  5C
0823:  BCF    0A.3
0824:  BCF    03.5
0825:  CALL   3C6
0826:  BSF    0A.3
....................       DELAY_MS (1); 
0827:  MOVLW  01
0828:  BSF    03.5
0829:  MOVWF  59
082A:  BCF    0A.3
082B:  BCF    03.5
082C:  CALL   117
082D:  BSF    0A.3
....................       STRCAT (ID_GATEWAY_CHAR, TEMP_CHAR); 
082E:  BSF    03.5
082F:  CLRF   57
0830:  MOVLW  51
0831:  MOVWF  56
0832:  CLRF   59
0833:  MOVLW  6E
0834:  MOVWF  58
0835:  BCF    0A.3
0836:  BCF    03.5
0837:  CALL   759
0838:  BSF    0A.3
0839:  BSF    03.5
083A:  INCF   55,F
083B:  GOTO   00F
....................    }   
....................     //STRCPY(ID_GATEWAY_CHAR,TEMP_CHAR2); 
.................... } 
....................  
....................  
.................... VOID CONFIG_DONE() 
.................... { 
....................    TT_FUN = 0; 
*
0800:  BCF    49.4
....................    TT_STT = 0;    
0801:  BCF    49.5
....................    XULY_IDGW_NHAP(); 
....................    PACKAGE_CONFIG[3] = ID_GATEWAY_CHAR; 
*
083C:  CLRF   27
083D:  MOVLW  51
083E:  MOVWF  26
....................     
....................    XULY_IDNODE_NHAP(); 
....................    PACKAGE_CONFIG[4] = ID_NODE_CHAR;          
*
089D:  CLRF   29
089E:  MOVLW  4A
089F:  MOVWF  28
....................    LEN_PACKAGES = 0; 
08A0:  BCF    03.5
08A1:  CLRF   48
....................    PACKAGE_CONFIG[1] = "__"; //DO DAI CUA LENGHT CO DO DAI = 2 
08A2:  MOVLW  5F
08A3:  BSF    03.5
08A4:  MOVWF  22
08A5:  MOVWF  23
....................    FOR (int J = 0; J < 6; J++) 
08A6:  CLRF   54
08A7:  MOVF   54,W
08A8:  SUBLW  05
08A9:  BTFSS  03.0
08AA:  GOTO   0DD
....................    { 
....................       LEN_PACKAGES += strlen(PACKAGE_CONFIG[J]); 
08AB:  BCF    03.0
08AC:  RLF    54,W
08AD:  ADDLW  A0
08AE:  MOVWF  04
08AF:  BCF    03.7
08B0:  INCF   04,F
08B1:  MOVF   00,W
08B2:  MOVWF  56
08B3:  DECF   04,F
08B4:  MOVF   00,W
08B5:  MOVWF  55
08B6:  MOVF   56,W
08B7:  MOVWF  58
08B8:  MOVF   55,W
08B9:  MOVWF  57
*
08D7:  MOVF   78,W
08D8:  BCF    03.5
08D9:  ADDWF  48,F
08DA:  BSF    03.5
08DB:  INCF   54,F
08DC:  GOTO   0A7
....................    }    
....................    LEN_PACKAGES = LEN_PACKAGES+5; //5 @ 
08DD:  MOVLW  05
08DE:  BCF    03.5
08DF:  ADDWF  48,F
....................    ITOA (LEN_PACKAGES, 10, TEMP_CHAR); 
08E0:  BSF    03.5
08E1:  CLRF   5A
08E2:  CLRF   59
08E3:  CLRF   58
08E4:  BCF    03.5
08E5:  MOVF   48,W
08E6:  BSF    03.5
08E7:  MOVWF  57
08E8:  MOVLW  0A
08E9:  MOVWF  5B
08EA:  CLRF   5D
08EB:  MOVLW  6E
08EC:  MOVWF  5C
08ED:  BCF    0A.3
08EE:  BCF    03.5
08EF:  CALL   3C6
08F0:  BSF    0A.3
....................    PACKAGE_CONFIG[1] = TEMP_CHAR; 
08F1:  BSF    03.5
08F2:  CLRF   23
08F3:  MOVLW  6E
08F4:  MOVWF  22
....................     
....................    FOR ( J = 0; J < 6; J++) 
08F5:  CLRF   54
08F6:  MOVF   54,W
08F7:  SUBLW  05
08F8:  BTFSS  03.0
08F9:  GOTO   12D
....................    { 
....................       PRINTF (PACKAGE_CONFIG[J]); 
08FA:  BCF    03.0
08FB:  RLF    54,W
08FC:  ADDLW  A0
08FD:  MOVWF  04
08FE:  BCF    03.7
08FF:  INCF   04,F
0900:  MOVF   00,W
0901:  MOVWF  56
0902:  DECF   04,F
0903:  MOVF   00,W
0904:  MOVWF  55
0905:  MOVF   55,W
0906:  MOVWF  04
0907:  BCF    03.7
0908:  BTFSC  56.0
0909:  BSF    03.7
....................       PRINTF ("@"); 
*
0925:  MOVLW  40
0926:  BCF    03.5
0927:  BTFSS  0C.4
0928:  GOTO   127
0929:  MOVWF  19
092A:  BSF    03.5
092B:  INCF   54,F
092C:  GOTO   0F6
....................    } 
....................  
....................  
....................    LCD_GOTOXY (1, 1) ; 
092D:  MOVLW  01
092E:  MOVWF  59
092F:  MOVWF  5A
0930:  BCF    0A.3
0931:  BCF    03.5
0932:  CALL   288
0933:  BSF    0A.3
....................    DELAY_MS (10); 
0934:  MOVLW  0A
0935:  BSF    03.5
0936:  MOVWF  59
0937:  BCF    0A.3
0938:  BCF    03.5
0939:  CALL   117
093A:  BSF    0A.3
....................    PRINTF (LCD_PUTC, "CONFIG DONE        ") ; 
093B:  MOVLW  B5
093C:  BSF    03.6
093D:  MOVWF  0D
093E:  MOVLW  00
093F:  MOVWF  0F
0940:  BCF    0A.3
0941:  BCF    03.6
0942:  CALL   2D6
0943:  BSF    0A.3
....................    LCD_GOTOXY (1, 2) ; 
0944:  MOVLW  01
0945:  BSF    03.5
0946:  MOVWF  59
0947:  MOVLW  02
0948:  MOVWF  5A
0949:  BCF    0A.3
094A:  BCF    03.5
094B:  CALL   288
094C:  BSF    0A.3
....................    DELAY_MS (10); 
094D:  MOVLW  0A
094E:  BSF    03.5
094F:  MOVWF  59
0950:  BCF    0A.3
0951:  BCF    03.5
0952:  CALL   117
0953:  BSF    0A.3
....................    PRINTF (LCD_PUTC, "CONFIG DONE        ") ; 
0954:  MOVLW  BF
0955:  BSF    03.6
0956:  MOVWF  0D
0957:  MOVLW  00
0958:  MOVWF  0F
0959:  BCF    0A.3
095A:  BCF    03.6
095B:  CALL   2D6
095C:  BSF    0A.3
....................  
....................    TT_CONFIG_DONE = 0; 
095D:  BCF    49.3
095E:  BSF    0A.3
095F:  BCF    0A.4
0960:  GOTO   455 (RETURN)
.................... } 
....................  
.................... //--------------------------------------------------------------------// 
....................  
....................  
....................  
....................  
....................  
.................... VOID QUET_PHIM() 
*
00C9:  BSF    03.6
00CA:  CLRF   26
.................... { 
....................    INT BDT = 0; 
....................  
....................    WHILE (!INPUT (BT1_PIN)) //NEU NUT BAM DUOC BAM 
00CB:  BSF    03.5
00CC:  BCF    03.6
00CD:  BSF    06.1
00CE:  BCF    03.5
00CF:  BTFSC  06.1
00D0:  GOTO   0E4
....................    { 
....................       IF (TMR1IF) 
00D1:  BTFSS  0C.0
00D2:  GOTO   0E1
....................       { 
....................          OUTPUT_TOGGLE (PIN_D2); 
00D3:  BSF    03.5
00D4:  BCF    08.2
00D5:  MOVLW  04
00D6:  BCF    03.5
00D7:  XORWF  08,F
....................          TMR1IF = 0; SET_TIMER1 (3036); BDT++; 
00D8:  BCF    0C.0
00D9:  CLRF   0E
00DA:  MOVLW  0B
00DB:  MOVWF  0F
00DC:  MOVLW  DC
00DD:  MOVWF  0E
00DE:  BSF    03.6
00DF:  INCF   26,F
00E0:  BCF    03.6
....................       } 
00E1:  BSF    03.6
00E2:  GOTO   0CB
00E3:  BCF    03.6
....................    } 
....................  
....................    IF (BDT > 20) 
00E4:  BSF    03.6
00E5:  MOVF   26,W
00E6:  SUBLW  14
00E7:  BTFSC  03.0
00E8:  GOTO   0F2
....................    { 
....................       //CONFIG NODE 
....................       TT_CONFIG = ~TT_CONFIG; // VAO TRANG THAI CONFIG 
00E9:  MOVLW  02
00EA:  BCF    03.6
00EB:  XORWF  49,F
....................       TT_CONTROL = ~TT_CONTROL; 
00EC:  MOVLW  04
00ED:  XORWF  49,F
....................       //CONFIG_DONE (); 
....................       TT_CONFIG_DONE = 1; 
00EE:  BSF    49.3
....................       TT_FUN = 0; 
00EF:  BCF    49.4
....................    } 
00F0:  GOTO   0F6
00F1:  BSF    03.6
....................  
....................    ELSE 
....................    { 
....................       BUTT_OKE (); //OKE 
....................    } 
.................... } 
....................  
.................... #INT_EXT 
....................  
....................  VOID NGAT_NGOAI () 
....................  { 
....................     QUET_PHIM (); 
....................  } 
....................  
*
00F6:  BCF    0B.1
00F7:  BCF    0A.3
00F8:  BCF    0A.4
00F9:  GOTO   031
....................  #INT_RDA 
....................  VOID NGAT () 
....................  { 
....................     KYTUCHAR[VT] = GETCH (); 
00FA:  MOVLW  5A
00FB:  ADDWF  39,W
00FC:  MOVWF  04
00FD:  BCF    03.7
00FE:  BTFSS  0C.5
00FF:  GOTO   0FE
0100:  MOVF   1A,W
0101:  MOVWF  00
....................  
....................     IF (KYTUCHAR[VT] == '.') 
0102:  MOVLW  5A
0103:  ADDWF  39,W
0104:  MOVWF  04
0105:  BCF    03.7
0106:  MOVF   00,W
0107:  SUBLW  2E
0108:  BTFSS  03.2
0109:  GOTO   112
....................     { 
....................        KYTUCHAR[VT] = '\0'; 
010A:  MOVLW  5A
010B:  ADDWF  39,W
010C:  MOVWF  04
010D:  BCF    03.7
010E:  CLRF   00
....................        VT = 0; 
010F:  CLRF   39
....................        TTNHAN = 1; 
0110:  BSF    49.0
....................     } 
0111:  GOTO   113
....................  
....................     ELSE 
....................     VT++; 
0112:  INCF   39,F
0113:  BCF    0C.5
0114:  BCF    0A.3
0115:  BCF    0A.4
0116:  GOTO   031
....................  } 
....................  
....................  VOID XUATLCD  () 
....................  { 
....................     LCD_GOTOXY (1, 1) ; 
*
07AD:  MOVLW  01
07AE:  BSF    03.5
07AF:  MOVWF  59
07B0:  MOVWF  5A
07B1:  BCF    03.5
07B2:  CALL   288
....................     DELAY_MS (10); 
07B3:  MOVLW  0A
07B4:  BSF    03.5
07B5:  MOVWF  59
07B6:  BCF    03.5
07B7:  CALL   117
....................     PRINTF (LCD_PUTC, KYTUCHAR); 
07B8:  MOVLW  5A
07B9:  MOVWF  04
07BA:  BCF    03.7
07BB:  CALL   528
....................     DELAY_MS (1); 
07BC:  MOVLW  01
07BD:  BSF    03.5
07BE:  MOVWF  59
07BF:  BCF    03.5
07C0:  CALL   117
07C1:  BSF    0A.3
07C2:  BCF    0A.4
07C3:  GOTO   475 (RETURN)
....................  } 
....................  
....................  INT ADC_READ (INT KENH) 
....................  { 
....................     SET_ADC_CHANNEL (KENH); 
....................     KQADC = 0; 
....................     FOR (INT I = 0; I < 100; I++) 
....................     { 
....................        KQADC = KQADC + READ_ADC () ; 
....................        DELAY_MS (1); 
....................     } 
....................  
....................     KQADC = KQADC / (100 * 2.046); 
....................     RETURN KQADC; 
....................  } 
....................  
....................  VOID CHUONG_TRINH_CON () 
....................  { 
....................     FOR (INT I = 0; I <= 30; I++) 
*
0797:  BSF    03.5
0798:  CLRF   54
0799:  MOVF   54,W
079A:  SUBLW  1E
079B:  BTFSS  03.0
079C:  GOTO   7A9
....................     { 
....................        OUTPUT_TOGGLE (PIN_D1); 
079D:  BCF    08.1
079E:  MOVLW  02
079F:  BCF    03.5
07A0:  XORWF  08,F
....................        DELAY_MS (100); 
07A1:  MOVLW  64
07A2:  BSF    03.5
07A3:  MOVWF  59
07A4:  BCF    03.5
07A5:  CALL   117
07A6:  BSF    03.5
07A7:  INCF   54,F
07A8:  GOTO   799
....................     } 
07A9:  BCF    03.5
07AA:  BSF    0A.3
07AB:  BCF    0A.4
07AC:  GOTO   45A (RETURN)
....................  } 
....................  
....................  VOID MAIN  () 
*
0B54:  MOVF   03,W
0B55:  ANDLW  1F
0B56:  MOVWF  03
0B57:  BSF    03.5
0B58:  BSF    03.6
0B59:  BSF    07.3
0B5A:  MOVLW  08
0B5B:  BCF    03.6
0B5C:  MOVWF  19
0B5D:  MOVLW  02
0B5E:  MOVWF  1A
0B5F:  MOVLW  A6
0B60:  MOVWF  18
0B61:  MOVLW  90
0B62:  BCF    03.5
0B63:  MOVWF  18
0B64:  MOVLW  FF
0B65:  MOVWF  31
0B66:  CLRF   38
0B67:  CLRF   39
0B68:  CLRF   3A
0B69:  CLRF   48
0B6A:  BCF    49.0
0B6B:  BCF    49.1
0B6C:  BCF    49.2
0B6D:  BCF    49.3
0B6E:  BCF    49.4
0B6F:  BCF    49.5
0B70:  BSF    03.5
0B71:  BSF    03.6
0B72:  MOVF   09,W
0B73:  ANDLW  C0
0B74:  MOVWF  09
0B75:  BCF    03.6
0B76:  BCF    1F.4
0B77:  BCF    1F.5
0B78:  MOVLW  00
0B79:  BSF    03.6
0B7A:  MOVWF  08
0B7B:  BCF    03.5
0B7C:  CLRF   07
0B7D:  CLRF   08
0B7E:  CLRF   09
0B7F:  BCF    03.7
....................  { 
....................     SET_TRIS_D (0X00); 
*
0C11:  MOVLW  00
0C12:  MOVWF  08
....................     SET_TRIS_B (0XFF); 
0C13:  MOVLW  FF
0C14:  MOVWF  06
....................     SET_TRIS_E (0); 
0C15:  BCF    09.0
0C16:  BCF    09.1
0C17:  BCF    09.2
0C18:  BCF    09.3
....................     SET_TRIS_C (0X80); 
0C19:  MOVLW  80
0C1A:  MOVWF  07
0C1B:  BCF    03.5
0C1C:  MOVWF  31
....................     SETUP_ADC (ADC_CLOCK_DIV_8); 
0C1D:  BSF    1F.6
0C1E:  BCF    1F.7
0C1F:  BSF    03.5
0C20:  BSF    1F.7
0C21:  BCF    03.5
0C22:  BSF    1F.0
....................     SETUP_ADC_PORTS (SAN0); 
0C23:  BSF    03.5
0C24:  BSF    03.6
0C25:  MOVF   09,W
0C26:  ANDLW  C0
0C27:  MOVWF  09
0C28:  BCF    03.6
0C29:  BCF    1F.4
0C2A:  BCF    1F.5
0C2B:  MOVLW  01
0C2C:  BSF    03.6
0C2D:  MOVWF  08
....................     ENABLE_INTERRUPTS (INT_TIMER0); 
0C2E:  BCF    03.5
0C2F:  BCF    03.6
0C30:  BSF    0B.5
....................     ENABLE_INTERRUPTS (INT_EXT); //CHO PHEP NGAT NGOAI 
0C31:  BSF    0B.4
....................     ENABLE_INTERRUPTS (INT_EXT_H2L); //NGAT XAY RA KHI CO XUNG TU CAO XUONG THAP 
0C32:  BSF    0B.4
0C33:  BSF    03.5
0C34:  BCF    01.6
....................     ENABLE_INTERRUPTS (INT_RDA); 
0C35:  BSF    0C.5
....................     ENABLE_INTERRUPTS (GLOBAL); 
0C36:  MOVLW  C0
0C37:  BCF    03.5
0C38:  IORWF  0B,F
....................      
....................     SETUP_TIMER_1 (T1_INTERNAL|T1_DIV_BY_8); 
0C39:  MOVLW  35
0C3A:  MOVWF  10
....................     //SET_TIMER1 (0); 
....................     SET_TIMER1 (3036); 
0C3B:  CLRF   0E
0C3C:  MOVLW  0B
0C3D:  MOVWF  0F
0C3E:  MOVLW  DC
0C3F:  MOVWF  0E
....................     TMR1IF = 0; 
0C40:  BCF    0C.0
....................     LCD_INIT (); // KHOI TAO LCD 
0C41:  BCF    0A.3
0C42:  GOTO   224
0C43:  BSF    0A.3
....................  
....................     TT_CONFIG = 0; 
0C44:  BCF    49.1
....................     TT_CONFIG_DONE = 0; 
0C45:  BCF    49.3
....................     TT_CONTROL = 1; 
0C46:  BSF    49.2
....................     OUTPUT_D (0X00); 
0C47:  BSF    03.5
0C48:  CLRF   08
0C49:  BCF    03.5
0C4A:  CLRF   08
....................     TTNHAN = 0; 
0C4B:  BCF    49.0
....................      
....................      
....................      
....................     WHILE (TRUE) 
....................     { 
....................        //AN1 = ADC_READ (1) ; 
....................        //AN0 = ADC_READ (0) ; 
....................  
....................        IF (TT_CONFIG) 
0C4C:  BTFSS  49.1
0C4D:  GOTO   452
....................        { 
....................           BUTT_FUN (); // GOI HAM CHON LENH (SWITCH CASE) 
0C4E:  BCF    0A.3
0C4F:  GOTO   55C
0C50:  BSF    0A.3
....................        } 
0C51:  GOTO   50D
....................  
....................        ELSE IF (TT_CONFIG_DONE) 
0C52:  BTFSS  49.3
0C53:  GOTO   456
....................        { 
....................           CONFIG_DONE (); 
0C54:  GOTO   000
....................        } 
0C55:  GOTO   50D
....................  
....................         
....................        ELSE 
....................        { 
....................           WHILE (!TT_CONFIG) 
0C56:  BTFSC  49.1
0C57:  GOTO   50D
....................           { 
....................              CHUONG_TRINH_CON (); 
0C58:  BCF    0A.3
0C59:  GOTO   797
0C5A:  BSF    0A.3
....................  
....................              IF (AN0 > 26) 
0C5B:  MOVF   35,F
0C5C:  BTFSS  03.2
0C5D:  GOTO   462
0C5E:  MOVF   34,W
0C5F:  SUBLW  1A
0C60:  BTFSC  03.0
0C61:  GOTO   46F
....................              { 
....................  
....................                  
....................                 DELAY_MS (1000); 
0C62:  MOVLW  04
0C63:  BSF    03.5
0C64:  MOVWF  54
0C65:  MOVLW  FA
0C66:  MOVWF  59
0C67:  BCF    0A.3
0C68:  BCF    03.5
0C69:  CALL   117
0C6A:  BSF    0A.3
0C6B:  BSF    03.5
0C6C:  DECFSZ 54,F
0C6D:  GOTO   465
0C6E:  BCF    03.5
....................              } 
....................  
....................               
....................              IF (TTNHAN == 1) 
0C6F:  BTFSS  49.0
0C70:  GOTO   50C
....................              { 
....................                 TTNHAN = 0; 
0C71:  BCF    49.0
....................                 KYTU = 0; 
0C72:  CLRF   3A
....................                 //TEMP_CHAR = 'K'; 
....................                 //ID_NODE_NHAN = KYTU[1] - 48; 
....................                 //ID_DEVICE_NHAN = KYTU[2] - 48 + 64; 
....................                 //TT_DEVICE_NHAN = KYTU[3] - 48; // - 48 ASCII -- > S?. + 64 -- > PORT_D (D0 = 64) 
....................                 XUATLCD (); 
0C73:  BCF    0A.3
0C74:  GOTO   7AD
0C75:  BSF    0A.3
....................                  
....................                 /* LAY TOKEN DAU TIEN */ 
....................                 TEMP_CHAR = "_"; 
0C76:  BSF    03.5
0C77:  CLRF   54
0C78:  CLRF   55
0C79:  MOVLW  6E
0C7A:  MOVWF  04
0C7B:  BCF    03.7
0C7C:  MOVF   54,W
0C7D:  ADDWF  04,F
0C7E:  MOVF   55,W
0C7F:  BCF    0A.3
0C80:  BCF    03.5
0C81:  CALL   05E
0C82:  BSF    0A.3
0C83:  MOVWF  00
0C84:  IORLW  00
0C85:  BTFSC  03.2
0C86:  GOTO   48C
0C87:  BSF    03.5
0C88:  INCF   55,F
0C89:  INCF   54,F
0C8A:  GOTO   479
0C8B:  BCF    03.5
....................                 CHAR * TOKEN; 
....................                 TOKEN = STRTOK (KYTUCHAR, TEMP_CHAR); 
0C8C:  BSF    03.5
0C8D:  CLRF   55
0C8E:  MOVLW  5A
0C8F:  MOVWF  54
0C90:  CLRF   57
0C91:  MOVLW  6E
0C92:  MOVWF  56
0C93:  BCF    03.5
0C94:  CALL   161
0C95:  MOVF   79,W
0C96:  BSF    03.5
0C97:  MOVWF  53
0C98:  MOVF   78,W
0C99:  MOVWF  52
....................                  
....................                 /* DUYET QUA CAC TOKEN CON LAI */ 
....................                  
....................                 LCD_GOTOXY (1, 2) ; 
0C9A:  MOVLW  01
0C9B:  MOVWF  59
0C9C:  MOVLW  02
0C9D:  MOVWF  5A
0C9E:  BCF    0A.3
0C9F:  BCF    03.5
0CA0:  CALL   288
0CA1:  BSF    0A.3
....................                 WHILE (TOKEN != NULL) 
0CA2:  BSF    03.5
0CA3:  MOVF   52,F
0CA4:  BTFSS  03.2
0CA5:  GOTO   4A9
0CA6:  MOVF   53,F
0CA7:  BTFSC  03.2
0CA8:  GOTO   4E7
....................                 {                 
....................                    SWITCH(KYTU) 
0CA9:  BCF    03.5
0CAA:  MOVF   3A,W
0CAB:  ADDLW  FC
0CAC:  BTFSC  03.0
0CAD:  GOTO   4CF
0CAE:  ADDLW  04
0CAF:  GOTO   50F
....................                    { 
....................                      CASE 0: 
....................                      BREAK; 
0CB0:  GOTO   4CF
....................                      CASE 1: 
....................                      ID_NODE_NHAN = ATOI(TOKEN);   
0CB1:  BSF    03.5
0CB2:  MOVF   53,W
0CB3:  MOVWF  55
0CB4:  MOVF   52,W
0CB5:  MOVWF  54
0CB6:  BCF    03.5
0CB7:  CALL   252
0CB8:  MOVF   78,W
0CB9:  MOVWF  3B
....................                      BREAK; 
0CBA:  GOTO   4CF
....................                 
....................                      CASE 2: 
....................                      ID_DEVICE_NHAN =  ATOI(TOKEN) + 64 ; 
0CBB:  BSF    03.5
0CBC:  MOVF   53,W
0CBD:  MOVWF  55
0CBE:  MOVF   52,W
0CBF:  MOVWF  54
0CC0:  BCF    03.5
0CC1:  CALL   252
0CC2:  MOVLW  40
0CC3:  ADDWF  78,W
0CC4:  MOVWF  3C
....................                      BREAK; 
0CC5:  GOTO   4CF
....................                 
....................                      CASE 3: 
....................                      TT_DEVICE_NHAN =  ATOI(TOKEN);                  
0CC6:  BSF    03.5
0CC7:  MOVF   53,W
0CC8:  MOVWF  55
0CC9:  MOVF   52,W
0CCA:  MOVWF  54
0CCB:  BCF    03.5
0CCC:  CALL   252
0CCD:  MOVF   78,W
0CCE:  MOVWF  3D
....................                      BREAK; 
....................                 
....................                     
....................                    } 
....................                   //PRINTF (LCD_PUTC, TOKEN);    
....................                   DELAY_MS (1);                       
0CCF:  MOVLW  01
0CD0:  BSF    03.5
0CD1:  MOVWF  59
0CD2:  BCF    0A.3
0CD3:  BCF    03.5
0CD4:  CALL   117
0CD5:  BSF    0A.3
....................                   TOKEN = STRTOK(NULL, TEMP_CHAR); 
0CD6:  BSF    03.5
0CD7:  CLRF   55
0CD8:  CLRF   54
0CD9:  CLRF   57
0CDA:  MOVLW  6E
0CDB:  MOVWF  56
0CDC:  BCF    03.5
0CDD:  CALL   161
0CDE:  MOVF   79,W
0CDF:  BSF    03.5
0CE0:  MOVWF  53
0CE1:  MOVF   78,W
0CE2:  MOVWF  52
....................                   KYTU++;      
0CE3:  BCF    03.5
0CE4:  INCF   3A,F
0CE5:  GOTO   4A2
0CE6:  BSF    03.5
....................                  
....................                 } 
....................                 IF (ID_NODE_NHAN == ID_NODE) 
0CE7:  BCF    03.5
0CE8:  MOVF   3B,W
0CE9:  SUBLW  44
0CEA:  BTFSS  03.2
0CEB:  GOTO   50C
0CEC:  XORLW  00
0CED:  BTFSS  03.2
0CEE:  GOTO   50C
....................                 { 
....................                    OUTPUT_BIT (ID_DEVICE_NHAN, TT_DEVICE_NHAN); 
0CEF:  MOVF   3D,F
0CF0:  BTFSS  03.2
0CF1:  GOTO   4F4
0CF2:  MOVLW  00
0CF3:  GOTO   4F5
0CF4:  MOVLW  01
0CF5:  MOVWF  77
0CF6:  MOVF   3C,W
0CF7:  BSF    03.5
0CF8:  MOVWF  54
0CF9:  MOVF   77,W
0CFA:  MOVWF  55
0CFB:  CLRF   57
0CFC:  CLRF   56
0CFD:  BCF    0A.3
0CFE:  BCF    03.5
0CFF:  CALL   7C4
0D00:  BSF    0A.3
0D01:  MOVF   3C,W
0D02:  BSF    03.5
0D03:  MOVWF  54
0D04:  CLRF   55
0D05:  CLRF   57
0D06:  MOVLW  80
0D07:  MOVWF  56
0D08:  BCF    0A.3
0D09:  BCF    03.5
0D0A:  CALL   7C4
0D0B:  BSF    0A.3
....................                 } 
....................              } 
0D0C:  GOTO   456
....................           } 
....................        } 
0D0D:  GOTO   44C
....................     } 
....................  } 
....................  
0D0E:  SLEEP

Configuration Fuses:
   Word  1: 2FE2   HS NOWDT PUT MCLR NOPROTECT NOCPD BROWNOUT IESO FCMEN NOLVP NODEBUG
   Word  2: 3FFF   BORV40 NOWRT
