CCS PCM C Compiler, Version 5.015, 5967               08-Nov-21 23:59

               Filename:   E:\DATN_V2\NODE\pic\pic16f887\hellopic.lst

               ROM used:   4782 words (58%)
                           Largest free fragment is 2048
               RAM used:   174 (47%) at main() level
                           259 (70%) worst case
               Stack used: 8 locations (7 in main + 1 for interrupts)
               Stack size: 8

*
0000:  MOVLW  11
0001:  MOVWF  0A
0002:  GOTO   1A9
0003:  NOP
0004:  MOVWF  7F
0005:  SWAPF  03,W
0006:  CLRF   03
0007:  MOVWF  21
0008:  MOVF   0A,W
0009:  MOVWF  20
000A:  CLRF   0A
000B:  MOVF   04,W
000C:  MOVWF  22
000D:  MOVF   77,W
000E:  MOVWF  23
000F:  MOVF   78,W
0010:  MOVWF  24
0011:  MOVF   79,W
0012:  MOVWF  25
0013:  MOVF   7A,W
0014:  MOVWF  26
0015:  BSF    03.6
0016:  MOVF   0D,W
0017:  BCF    03.6
0018:  MOVWF  27
0019:  BSF    03.6
001A:  MOVF   0F,W
001B:  BCF    03.6
001C:  MOVWF  28
001D:  BSF    03.6
001E:  MOVF   0C,W
001F:  BCF    03.6
0020:  MOVWF  29
0021:  BSF    03.6
0022:  MOVF   0E,W
0023:  BCF    03.6
0024:  MOVWF  2A
0025:  BCF    03.7
0026:  BCF    03.5
0027:  BTFSS  0B.4
0028:  GOTO   02B
0029:  BTFSC  0B.1
002A:  GOTO   052
002B:  MOVLW  8C
002C:  MOVWF  04
002D:  BTFSS  00.5
002E:  GOTO   031
002F:  BTFSC  0C.5
0030:  GOTO   055
0031:  MOVF   22,W
0032:  MOVWF  04
0033:  MOVF   23,W
0034:  MOVWF  77
0035:  MOVF   24,W
0036:  MOVWF  78
0037:  MOVF   25,W
0038:  MOVWF  79
0039:  MOVF   26,W
003A:  MOVWF  7A
003B:  MOVF   27,W
003C:  BSF    03.6
003D:  MOVWF  0D
003E:  BCF    03.6
003F:  MOVF   28,W
0040:  BSF    03.6
0041:  MOVWF  0F
0042:  BCF    03.6
0043:  MOVF   29,W
0044:  BSF    03.6
0045:  MOVWF  0C
0046:  BCF    03.6
0047:  MOVF   2A,W
0048:  BSF    03.6
0049:  MOVWF  0E
004A:  BCF    03.6
004B:  MOVF   20,W
004C:  MOVWF  0A
004D:  SWAPF  21,W
004E:  MOVWF  03
004F:  SWAPF  7F,F
0050:  SWAPF  7F,W
0051:  RETFIE
0052:  BCF    0A.3
0053:  BCF    0A.4
0054:  GOTO   0F2
0055:  BCF    0A.3
0056:  BCF    0A.4
0057:  GOTO   138
....................  
.................... #INCLUDE <thuvien.c> 
.................... #INCLUDE <16F887.H> 
.................... //////////// Standard Header file for the PIC16F887 device //////////////// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2013 Custom Computer Services          //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... #device PIC16F887 
0058:  BCF    0A.0
0059:  BCF    0A.1
005A:  BCF    0A.2
005B:  ADDWF  02,F
005C:  RETLW  30
005D:  RETLW  00
005E:  BCF    0A.0
005F:  BCF    0A.1
0060:  BCF    0A.2
0061:  ADDWF  02,F
0062:  RETLW  5F
0063:  RETLW  00
0064:  BCF    0A.0
0065:  BCF    0A.1
0066:  BCF    0A.2
0067:  ADDWF  02,F
0068:  RETLW  23
0069:  RETLW  00
006A:  BCF    0A.0
006B:  BCF    0A.1
006C:  BCF    0A.2
006D:  ADDWF  02,F
006E:  RETLW  00
006F:  DATA CE,27
0070:  DATA C4,22
0071:  DATA 3A,10
0072:  DATA 00,00
0073:  DATA 30,18
0074:  DATA 30,18
0075:  DATA 20,10
0076:  DATA 20,10
0077:  DATA 20,10
0078:  DATA 20,10
0079:  DATA 20,10
007A:  DATA 00,01
007B:  DATA 20,10
007C:  DATA 20,10
007D:  DATA 20,10
007E:  DATA 5F,10
007F:  DATA 20,10
0080:  DATA 20,10
0081:  DATA 20,10
0082:  DATA 20,10
0083:  DATA 20,10
0084:  DATA 20,10
0085:  DATA 20,00
0086:  DATA 20,10
0087:  DATA 20,10
0088:  DATA 5F,10
0089:  DATA 20,10
008A:  DATA 20,00
008B:  DATA 49,22
008C:  DATA DF,23
008D:  DATA 57,1D
008E:  DATA 00,01
008F:  DATA 30,18
0090:  DATA 30,18
0091:  DATA 30,18
0092:  DATA 20,10
0093:  DATA 20,10
0094:  DATA 20,10
0095:  DATA 20,10
0096:  DATA 00,01
0097:  DATA 20,10
0098:  DATA 20,10
0099:  DATA 20,10
009A:  DATA 5F,10
009B:  DATA 20,10
009C:  DATA 20,10
009D:  DATA 20,10
009E:  DATA 20,10
009F:  DATA 20,10
00A0:  DATA 20,10
00A1:  DATA 20,10
00A2:  DATA 20,00
00A3:  DATA 20,10
00A4:  DATA 20,10
00A5:  DATA 5F,10
00A6:  DATA 20,10
00A7:  DATA 20,10
00A8:  DATA 20,10
00A9:  DATA 20,00
00AA:  DATA C3,27
00AB:  DATA 4E,23
00AC:  DATA C9,23
00AD:  DATA 3A,10
00AE:  DATA 20,10
00AF:  DATA 20,10
00B0:  DATA 20,10
00B1:  DATA 20,00
00B2:  DATA C3,20
00B3:  DATA D3,22
00B4:  DATA 3A,10
00B5:  DATA 20,10
00B6:  DATA 20,10
00B7:  DATA 20,10
00B8:  DATA 20,10
00B9:  DATA 20,00
00BA:  DATA A0,16
00BB:  DATA A0,24
00BC:  DATA C4,16
00BD:  DATA CE,27
00BE:  DATA C4,22
00BF:  DATA 20,10
00C0:  DATA 20,10
00C1:  DATA 20,10
00C2:  DATA 00,01
00C3:  DATA A0,16
00C4:  DATA A0,24
00C5:  DATA C4,16
00C6:  DATA C7,2B
00C7:  DATA 20,10
00C8:  DATA 20,10
00C9:  DATA 20,10
00CA:  DATA 20,00
00CB:  DATA D7,20
00CC:  DATA 49,2A
00CD:  DATA 49,27
00CE:  DATA 47,10
00CF:  DATA 2E,17
00D0:  DATA 2E,17
00D1:  DATA 20,10
00D2:  DATA 20,10
00D3:  DATA 20,10
00D4:  DATA 20,10
00D5:  DATA 00,01
00D6:  DATA D7,20
00D7:  DATA 49,2A
00D8:  DATA 49,27
00D9:  DATA 47,10
00DA:  DATA 2E,17
00DB:  DATA 2E,17
00DC:  DATA 20,10
00DD:  DATA 20,10
00DE:  DATA 20,10
00DF:  DATA 20,10
00E0:  DATA 00,00
00E1:  DATA 20,10
00E2:  DATA 20,10
00E3:  DATA 20,10
00E4:  DATA 20,10
00E5:  DATA 20,10
00E6:  DATA 20,10
00E7:  DATA 00,01
00E8:  DATA 54,21
00E9:  DATA 3A,10
00EA:  DATA 00,01
00EB:  DATA 20,10
00EC:  DATA 20,10
00ED:  DATA 43,21
00EE:  DATA 3A,00
00EF:  DATA D3,2B
00F0:  DATA 3A,10
00F1:  DATA 00,01
*
0155:  DATA 20,15
0156:  DATA 20,20
0157:  DATA 00,00
0158:  DATA C0,29
0159:  DATA 53,20
015A:  DATA 00,01
*
0329:  MOVF   0B,W
032A:  BSF    03.6
032B:  MOVWF  3D
032C:  BCF    03.6
032D:  BCF    0B.7
032E:  BSF    03.5
032F:  BSF    03.6
0330:  BSF    0C.7
0331:  BSF    0C.0
0332:  NOP
0333:  NOP
0334:  BCF    03.5
0335:  BTFSS  3D.7
0336:  GOTO   33A
0337:  BCF    03.6
0338:  BSF    0B.7
0339:  BSF    03.6
033A:  MOVF   0C,W
033B:  ANDLW  7F
033C:  BTFSC  03.2
033D:  GOTO   377
033E:  MOVWF  3D
033F:  MOVF   0D,W
0340:  MOVWF  3E
0341:  MOVF   0F,W
0342:  MOVWF  3F
0343:  MOVF   3D,W
0344:  MOVWF  40
0345:  BCF    03.6
0346:  CALL   2EF
0347:  BSF    03.6
0348:  MOVF   3E,W
0349:  MOVWF  0D
034A:  MOVF   3F,W
034B:  MOVWF  0F
034C:  BCF    03.6
034D:  MOVF   0B,W
034E:  BSF    03.6
034F:  MOVWF  40
0350:  BCF    03.6
0351:  BCF    0B.7
0352:  BSF    03.5
0353:  BSF    03.6
0354:  BSF    0C.7
0355:  BSF    0C.0
0356:  NOP
0357:  NOP
0358:  BCF    03.5
0359:  BTFSS  40.7
035A:  GOTO   35E
035B:  BCF    03.6
035C:  BSF    0B.7
035D:  BSF    03.6
035E:  RLF    0C,W
035F:  RLF    0E,W
0360:  ANDLW  7F
0361:  BTFSC  03.2
0362:  GOTO   377
0363:  MOVWF  3D
0364:  MOVF   0D,W
0365:  MOVWF  3E
0366:  MOVF   0F,W
0367:  MOVWF  3F
0368:  MOVF   3D,W
0369:  MOVWF  40
036A:  BCF    03.6
036B:  CALL   2EF
036C:  BSF    03.6
036D:  MOVF   3E,W
036E:  MOVWF  0D
036F:  MOVF   3F,W
0370:  MOVWF  0F
0371:  INCF   0D,F
0372:  BTFSC  03.2
0373:  INCF   0F,F
0374:  BCF    03.6
0375:  GOTO   329
0376:  BSF    03.6
0377:  BCF    03.6
0378:  RETURN
0379:  BTFSC  03.1
037A:  GOTO   37E
037B:  MOVLW  5E
037C:  MOVWF  04
037D:  BSF    03.7
037E:  BSF    03.6
037F:  MOVF   59,W
0380:  XORWF  5D,W
0381:  ANDLW  80
0382:  MOVWF  63
0383:  BTFSS  59.7
0384:  GOTO   390
0385:  COMF   56,F
0386:  COMF   57,F
0387:  COMF   58,F
0388:  COMF   59,F
0389:  INCF   56,F
038A:  BTFSC  03.2
038B:  INCF   57,F
038C:  BTFSC  03.2
038D:  INCF   58,F
038E:  BTFSC  03.2
038F:  INCF   59,F
0390:  BTFSS  5D.7
0391:  GOTO   39D
0392:  COMF   5A,F
0393:  COMF   5B,F
0394:  COMF   5C,F
0395:  COMF   5D,F
0396:  INCF   5A,F
0397:  BTFSC  03.2
0398:  INCF   5B,F
0399:  BTFSC  03.2
039A:  INCF   5C,F
039B:  BTFSC  03.2
039C:  INCF   5D,F
039D:  CLRF   77
039E:  CLRF   78
039F:  CLRF   79
03A0:  CLRF   7A
03A1:  CLRF   5E
03A2:  CLRF   5F
03A3:  CLRF   60
03A4:  CLRF   61
03A5:  MOVF   5D,W
03A6:  IORWF  5C,W
03A7:  IORWF  5B,W
03A8:  IORWF  5A,W
03A9:  BTFSC  03.2
03AA:  GOTO   3DB
03AB:  MOVLW  20
03AC:  MOVWF  62
03AD:  BCF    03.0
03AE:  RLF    56,F
03AF:  RLF    57,F
03B0:  RLF    58,F
03B1:  RLF    59,F
03B2:  RLF    5E,F
03B3:  RLF    5F,F
03B4:  RLF    60,F
03B5:  RLF    61,F
03B6:  MOVF   5D,W
03B7:  SUBWF  61,W
03B8:  BTFSS  03.2
03B9:  GOTO   3C4
03BA:  MOVF   5C,W
03BB:  SUBWF  60,W
03BC:  BTFSS  03.2
03BD:  GOTO   3C4
03BE:  MOVF   5B,W
03BF:  SUBWF  5F,W
03C0:  BTFSS  03.2
03C1:  GOTO   3C4
03C2:  MOVF   5A,W
03C3:  SUBWF  5E,W
03C4:  BTFSS  03.0
03C5:  GOTO   3D5
03C6:  MOVF   5A,W
03C7:  SUBWF  5E,F
03C8:  MOVF   5B,W
03C9:  BTFSS  03.0
03CA:  INCFSZ 5B,W
03CB:  SUBWF  5F,F
03CC:  MOVF   5C,W
03CD:  BTFSS  03.0
03CE:  INCFSZ 5C,W
03CF:  SUBWF  60,F
03D0:  MOVF   5D,W
03D1:  BTFSS  03.0
03D2:  INCFSZ 5D,W
03D3:  SUBWF  61,F
03D4:  BSF    03.0
03D5:  RLF    77,F
03D6:  RLF    78,F
03D7:  RLF    79,F
03D8:  RLF    7A,F
03D9:  DECFSZ 62,F
03DA:  GOTO   3AD
03DB:  BTFSS  63.7
03DC:  GOTO   3E8
03DD:  COMF   77,F
03DE:  COMF   78,F
03DF:  COMF   79,F
03E0:  COMF   7A,F
03E1:  INCF   77,F
03E2:  BTFSC  03.2
03E3:  INCF   78,F
03E4:  BTFSC  03.2
03E5:  INCF   79,F
03E6:  BTFSC  03.2
03E7:  INCF   7A,F
03E8:  MOVF   5E,W
03E9:  MOVWF  00
03EA:  INCF   04,F
03EB:  MOVF   5F,W
03EC:  MOVWF  00
03ED:  INCF   04,F
03EE:  MOVF   60,W
03EF:  MOVWF  00
03F0:  INCF   04,F
03F1:  MOVF   61,W
03F2:  MOVWF  00
03F3:  BCF    03.6
03F4:  RETURN
*
040E:  MOVLW  20
040F:  MOVWF  5A
0410:  CLRF   56
0411:  CLRF   57
0412:  CLRF   58
0413:  CLRF   59
0414:  MOVF   51,W
0415:  MOVWF  7A
0416:  MOVF   50,W
0417:  MOVWF  79
0418:  MOVF   4F,W
0419:  MOVWF  78
041A:  MOVF   4E,W
041B:  MOVWF  77
041C:  BCF    03.0
041D:  BTFSS  77.0
041E:  GOTO   42D
041F:  MOVF   52,W
0420:  ADDWF  56,F
0421:  MOVF   53,W
0422:  BTFSC  03.0
0423:  INCFSZ 53,W
0424:  ADDWF  57,F
0425:  MOVF   54,W
0426:  BTFSC  03.0
0427:  INCFSZ 54,W
0428:  ADDWF  58,F
0429:  MOVF   55,W
042A:  BTFSC  03.0
042B:  INCFSZ 55,W
042C:  ADDWF  59,F
042D:  RRF    59,F
042E:  RRF    58,F
042F:  RRF    57,F
0430:  RRF    56,F
0431:  RRF    7A,F
0432:  RRF    79,F
0433:  RRF    78,F
0434:  RRF    77,F
0435:  DECFSZ 5A,F
0436:  GOTO   41C
*
0515:  MOVF   00,F
0516:  BTFSC  03.2
0517:  GOTO   531
0518:  BSF    03.6
0519:  CLRF   1A
051A:  MOVF   04,W
051B:  MOVWF  19
051C:  BCF    1A.0
051D:  BTFSC  03.7
051E:  BSF    1A.0
051F:  MOVF   00,W
0520:  MOVWF  40
0521:  BCF    03.6
0522:  CALL   2EF
0523:  BSF    03.6
0524:  MOVF   19,W
0525:  MOVWF  04
0526:  BCF    03.7
0527:  BTFSC  1A.0
0528:  BSF    03.7
0529:  INCF   04,F
052A:  BTFSS  03.2
052B:  GOTO   52F
052C:  BCF    03.6
052D:  INCF   05,F
052E:  BSF    03.6
052F:  BCF    03.6
0530:  GOTO   515
0531:  RETURN
0532:  BSF    03.6
0533:  MOVF   15,W
0534:  CLRF   78
0535:  SUBWF  14,W
0536:  BTFSC  03.0
0537:  GOTO   53B
0538:  MOVF   14,W
0539:  MOVWF  77
053A:  GOTO   547
053B:  CLRF   77
053C:  MOVLW  08
053D:  MOVWF  16
053E:  RLF    14,F
053F:  RLF    77,F
0540:  MOVF   15,W
0541:  SUBWF  77,W
0542:  BTFSC  03.0
0543:  MOVWF  77
0544:  RLF    78,F
0545:  DECFSZ 16,F
0546:  GOTO   53E
0547:  BCF    03.6
0548:  RETURN
*
0784:  MOVF   00,F
0785:  BTFSC  03.2
0786:  GOTO   7A1
0787:  BSF    03.6
0788:  CLRF   40
0789:  MOVF   04,W
078A:  MOVWF  3F
078B:  BCF    40.0
078C:  BTFSC  03.7
078D:  BSF    40.0
078E:  MOVF   00,W
078F:  BCF    03.6
0790:  BTFSS  0C.4
0791:  GOTO   790
0792:  MOVWF  19
0793:  BSF    03.6
0794:  MOVF   3F,W
0795:  MOVWF  04
0796:  BCF    03.7
0797:  BTFSC  40.0
0798:  BSF    03.7
0799:  INCF   04,F
079A:  BTFSS  03.2
079B:  GOTO   79F
079C:  BCF    03.6
079D:  INCF   05,F
079E:  BSF    03.6
079F:  BCF    03.6
07A0:  GOTO   784
07A1:  RETURN
07A2:  CLRF   77
07A3:  CLRF   78
07A4:  BSF    03.6
07A5:  MOVF   1F,W
07A6:  BCF    03.0
07A7:  BTFSC  20.0
07A8:  ADDWF  77,F
07A9:  RRF    77,F
07AA:  RRF    78,F
07AB:  BTFSC  20.1
07AC:  ADDWF  77,F
07AD:  RRF    77,F
07AE:  RRF    78,F
07AF:  BTFSC  20.2
07B0:  ADDWF  77,F
07B1:  RRF    77,F
07B2:  RRF    78,F
07B3:  BTFSC  20.3
07B4:  ADDWF  77,F
07B5:  RRF    77,F
07B6:  RRF    78,F
07B7:  BTFSC  20.4
07B8:  ADDWF  77,F
07B9:  RRF    77,F
07BA:  RRF    78,F
07BB:  BTFSC  20.5
07BC:  ADDWF  77,F
07BD:  RRF    77,F
07BE:  RRF    78,F
07BF:  BTFSC  20.6
07C0:  ADDWF  77,F
07C1:  RRF    77,F
07C2:  RRF    78,F
07C3:  BTFSC  20.7
07C4:  ADDWF  77,F
07C5:  RRF    77,F
07C6:  RRF    78,F
07C7:  BCF    03.6
07C8:  RETURN
07C9:  BSF    03.6
07CA:  MOVF   19,W
07CB:  ANDLW  07
07CC:  MOVWF  77
07CD:  RRF    19,W
07CE:  MOVWF  78
07CF:  RRF    78,F
07D0:  RRF    78,F
07D1:  MOVLW  1F
07D2:  ANDWF  78,F
07D3:  MOVF   78,W
07D4:  ADDWF  1B,W
07D5:  MOVWF  04
07D6:  BCF    03.7
07D7:  BTFSC  1C.0
07D8:  BSF    03.7
07D9:  CLRF   78
07DA:  INCF   78,F
07DB:  INCF   77,F
07DC:  GOTO   7DE
07DD:  RLF    78,F
07DE:  DECFSZ 77,F
07DF:  GOTO   7DD
07E0:  MOVF   1A,F
07E1:  BTFSC  03.2
07E2:  GOTO   7E6
07E3:  MOVF   78,W
07E4:  IORWF  00,F
07E5:  GOTO   7E9
07E6:  COMF   78,F
07E7:  MOVF   78,W
07E8:  ANDWF  00,F
07E9:  BCF    03.6
07EA:  RETURN
*
0B52:  BSF    03.6
0B53:  MOVF   1C,W
0B54:  ANDLW  07
0B55:  MOVWF  77
0B56:  RRF    1C,W
0B57:  MOVWF  78
0B58:  RRF    78,F
0B59:  RRF    78,F
0B5A:  MOVLW  1F
0B5B:  ANDWF  78,F
0B5C:  MOVF   78,W
0B5D:  ADDWF  1D,W
0B5E:  MOVWF  04
0B5F:  BCF    03.7
0B60:  BTFSC  1E.0
0B61:  BSF    03.7
0B62:  MOVF   00,W
0B63:  MOVWF  78
0B64:  INCF   77,F
0B65:  GOTO   367
0B66:  RRF    78,F
0B67:  DECFSZ 77,F
0B68:  GOTO   366
0B69:  BCF    03.6
0B6A:  RETURN
*
0E41:  BCF    0A.0
0E42:  BSF    0A.1
0E43:  BSF    0A.2
0E44:  ADDWF  02,F
0E45:  GOTO   4BC
0E46:  GOTO   4BD
0E47:  GOTO   4CA
0E48:  GOTO   4D7
0E49:  GOTO   4E1
0E4A:  GOTO   4EB
*
0ECF:  MOVF   0B,W
0ED0:  BSF    03.6
0ED1:  MOVWF  3B
0ED2:  BCF    03.6
0ED3:  BCF    0B.7
0ED4:  BSF    03.5
0ED5:  BSF    03.6
0ED6:  BSF    0C.7
0ED7:  BSF    0C.0
0ED8:  NOP
0ED9:  NOP
0EDA:  BCF    03.5
0EDB:  BTFSS  3B.7
0EDC:  GOTO   6E0
0EDD:  BCF    03.6
0EDE:  BSF    0B.7
0EDF:  BSF    03.6
0EE0:  MOVF   0C,W
0EE1:  ANDLW  7F
0EE2:  BTFSC  03.2
0EE3:  GOTO   71F
0EE4:  MOVWF  3B
0EE5:  MOVF   0D,W
0EE6:  MOVWF  3C
0EE7:  MOVF   0F,W
0EE8:  MOVWF  3D
0EE9:  MOVF   3B,W
0EEA:  BCF    03.6
0EEB:  BTFSS  0C.4
0EEC:  GOTO   6EB
0EED:  MOVWF  19
0EEE:  BSF    03.6
0EEF:  MOVF   3C,W
0EF0:  MOVWF  0D
0EF1:  MOVF   3D,W
0EF2:  MOVWF  0F
0EF3:  BCF    03.6
0EF4:  MOVF   0B,W
0EF5:  BSF    03.6
0EF6:  MOVWF  3E
0EF7:  BCF    03.6
0EF8:  BCF    0B.7
0EF9:  BSF    03.5
0EFA:  BSF    03.6
0EFB:  BSF    0C.7
0EFC:  BSF    0C.0
0EFD:  NOP
0EFE:  NOP
0EFF:  BCF    03.5
0F00:  BTFSS  3E.7
0F01:  GOTO   705
0F02:  BCF    03.6
0F03:  BSF    0B.7
0F04:  BSF    03.6
0F05:  RLF    0C,W
0F06:  RLF    0E,W
0F07:  ANDLW  7F
0F08:  BTFSC  03.2
0F09:  GOTO   71F
0F0A:  MOVWF  3B
0F0B:  MOVF   0D,W
0F0C:  MOVWF  3C
0F0D:  MOVF   0F,W
0F0E:  MOVWF  3D
0F0F:  MOVF   3B,W
0F10:  BCF    03.6
0F11:  BTFSS  0C.4
0F12:  GOTO   711
0F13:  MOVWF  19
0F14:  BSF    03.6
0F15:  MOVF   3C,W
0F16:  MOVWF  0D
0F17:  MOVF   3D,W
0F18:  MOVWF  0F
0F19:  INCF   0D,F
0F1A:  BTFSC  03.2
0F1B:  INCF   0F,F
0F1C:  BCF    03.6
0F1D:  GOTO   6CF
0F1E:  BSF    03.6
0F1F:  BCF    03.6
0F20:  RETURN
*
1079:  MOVLW  8E
107A:  MOVWF  77
107B:  MOVF   1D,W
107C:  MOVWF  78
107D:  MOVF   1C,W
107E:  MOVWF  79
107F:  CLRF   7A
1080:  MOVF   78,F
1081:  BTFSS  03.2
1082:  GOTO   08D
1083:  MOVF   79,W
1084:  MOVWF  78
1085:  CLRF   79
1086:  MOVLW  08
1087:  SUBWF  77,F
1088:  MOVF   78,F
1089:  BTFSS  03.2
108A:  GOTO   08D
108B:  CLRF   77
108C:  GOTO   095
108D:  BCF    03.0
108E:  BTFSC  78.7
108F:  GOTO   094
1090:  RLF    79,F
1091:  RLF    78,F
1092:  DECF   77,F
1093:  GOTO   08D
1094:  BCF    78.7
*
10A5:  MOVF   1C,W
10A6:  BTFSC  03.2
10A7:  GOTO   16A
10A8:  MOVWF  28
10A9:  MOVF   20,W
10AA:  BTFSC  03.2
10AB:  GOTO   16A
10AC:  SUBWF  28,F
10AD:  BTFSS  03.0
10AE:  GOTO   0B4
10AF:  MOVLW  7F
10B0:  ADDWF  28,F
10B1:  BTFSC  03.0
10B2:  GOTO   16A
10B3:  GOTO   0BA
10B4:  MOVLW  81
10B5:  SUBWF  28,F
10B6:  BTFSS  03.0
10B7:  GOTO   16A
10B8:  BTFSC  03.2
10B9:  GOTO   16A
10BA:  MOVF   28,W
10BB:  MOVWF  77
10BC:  CLRF   78
10BD:  CLRF   79
10BE:  CLRF   7A
10BF:  CLRF   27
10C0:  MOVF   1D,W
10C1:  MOVWF  26
10C2:  BSF    26.7
10C3:  MOVF   1E,W
10C4:  MOVWF  25
10C5:  MOVF   1F,W
10C6:  MOVWF  24
10C7:  MOVLW  19
10C8:  MOVWF  28
10C9:  MOVF   23,W
10CA:  SUBWF  24,F
10CB:  BTFSC  03.0
10CC:  GOTO   0DD
10CD:  MOVLW  01
10CE:  SUBWF  25,F
10CF:  BTFSC  03.0
10D0:  GOTO   0DD
10D1:  SUBWF  26,F
10D2:  BTFSC  03.0
10D3:  GOTO   0DD
10D4:  SUBWF  27,F
10D5:  BTFSC  03.0
10D6:  GOTO   0DD
10D7:  INCF   27,F
10D8:  INCF   26,F
10D9:  INCF   25,F
10DA:  MOVF   23,W
10DB:  ADDWF  24,F
10DC:  GOTO   10F
10DD:  MOVF   22,W
10DE:  SUBWF  25,F
10DF:  BTFSC  03.0
10E0:  GOTO   0F8
10E1:  MOVLW  01
10E2:  SUBWF  26,F
10E3:  BTFSC  03.0
10E4:  GOTO   0F8
10E5:  SUBWF  27,F
10E6:  BTFSC  03.0
10E7:  GOTO   0F8
10E8:  INCF   27,F
10E9:  INCF   26,F
10EA:  MOVF   22,W
10EB:  ADDWF  25,F
10EC:  MOVF   23,W
10ED:  ADDWF  24,F
10EE:  BTFSS  03.0
10EF:  GOTO   10F
10F0:  INCF   25,F
10F1:  BTFSS  03.2
10F2:  GOTO   10F
10F3:  INCF   26,F
10F4:  BTFSS  03.2
10F5:  GOTO   10F
10F6:  INCF   27,F
10F7:  GOTO   10F
10F8:  MOVF   21,W
10F9:  IORLW  80
10FA:  SUBWF  26,F
10FB:  BTFSC  03.0
10FC:  GOTO   10E
10FD:  MOVLW  01
10FE:  SUBWF  27,F
10FF:  BTFSC  03.0
1100:  GOTO   10E
1101:  INCF   27,F
1102:  MOVF   21,W
1103:  IORLW  80
1104:  ADDWF  26,F
1105:  MOVF   22,W
1106:  ADDWF  25,F
1107:  BTFSS  03.0
1108:  GOTO   0EC
1109:  INCF   26,F
110A:  BTFSS  03.2
110B:  GOTO   0EC
110C:  INCF   27,F
110D:  GOTO   0EC
110E:  BSF    7A.0
110F:  DECFSZ 28,F
1110:  GOTO   112
1111:  GOTO   11D
1112:  BCF    03.0
1113:  RLF    24,F
1114:  RLF    25,F
1115:  RLF    26,F
1116:  RLF    27,F
1117:  BCF    03.0
1118:  RLF    7A,F
1119:  RLF    79,F
111A:  RLF    78,F
111B:  RLF    29,F
111C:  GOTO   0C9
111D:  BTFSS  29.0
111E:  GOTO   125
111F:  BCF    03.0
1120:  RRF    78,F
1121:  RRF    79,F
1122:  RRF    7A,F
1123:  RRF    29,F
1124:  GOTO   128
1125:  DECF   77,F
1126:  BTFSC  03.2
1127:  GOTO   16A
1128:  BTFSC  29.7
1129:  GOTO   151
112A:  BCF    03.0
112B:  RLF    24,F
112C:  RLF    25,F
112D:  RLF    26,F
112E:  RLF    27,F
112F:  MOVF   23,W
1130:  SUBWF  24,F
1131:  BTFSC  03.0
1132:  GOTO   13D
1133:  MOVLW  01
1134:  SUBWF  25,F
1135:  BTFSC  03.0
1136:  GOTO   13D
1137:  SUBWF  26,F
1138:  BTFSC  03.0
1139:  GOTO   13D
113A:  SUBWF  27,F
113B:  BTFSS  03.0
113C:  GOTO   160
113D:  MOVF   22,W
113E:  SUBWF  25,F
113F:  BTFSC  03.0
1140:  GOTO   148
1141:  MOVLW  01
1142:  SUBWF  26,F
1143:  BTFSC  03.0
1144:  GOTO   148
1145:  SUBWF  27,F
1146:  BTFSS  03.0
1147:  GOTO   160
1148:  MOVF   21,W
1149:  IORLW  80
114A:  SUBWF  26,F
114B:  BTFSC  03.0
114C:  GOTO   151
114D:  MOVLW  01
114E:  SUBWF  27,F
114F:  BTFSS  03.0
1150:  GOTO   160
1151:  INCF   7A,F
1152:  BTFSS  03.2
1153:  GOTO   160
1154:  INCF   79,F
1155:  BTFSS  03.2
1156:  GOTO   160
1157:  INCF   78,F
1158:  BTFSS  03.2
1159:  GOTO   160
115A:  INCF   77,F
115B:  BTFSC  03.2
115C:  GOTO   16A
115D:  RRF    78,F
115E:  RRF    79,F
115F:  RRF    7A,F
1160:  MOVF   1D,W
1161:  MOVWF  28
1162:  MOVF   21,W
1163:  XORWF  28,F
1164:  BTFSS  28.7
1165:  GOTO   168
1166:  BSF    78.7
1167:  GOTO   16E
1168:  BCF    78.7
1169:  GOTO   16E
116A:  CLRF   77
116B:  CLRF   78
116C:  CLRF   79
116D:  CLRF   7A
*
1176:  MOVLW  8E
1177:  MOVWF  77
1178:  MOVF   1C,W
1179:  SUBWF  77,F
117A:  MOVF   1D,W
117B:  MOVWF  79
117C:  MOVF   1E,W
117D:  MOVWF  78
117E:  BSF    79.7
117F:  MOVF   77,F
1180:  BTFSC  03.2
1181:  GOTO   18D
1182:  BCF    03.0
1183:  MOVF   79,F
1184:  BTFSS  03.2
1185:  GOTO   189
1186:  MOVF   78,F
1187:  BTFSC  03.2
1188:  GOTO   18D
1189:  RRF    79,F
118A:  RRF    78,F
118B:  DECFSZ 77,F
118C:  GOTO   182
118D:  BTFSS  1D.7
118E:  GOTO   194
118F:  COMF   78,F
1190:  COMF   79,F
1191:  INCF   78,F
1192:  BTFSC  03.2
1193:  INCF   79,F
....................  
.................... #list 
....................  
.................... #DEVICE ADC=10 
.................... #INCLUDE <STRING.H> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
*
0746:  BSF    03.6
0747:  MOVF   3F,W
0748:  MOVWF  43
0749:  MOVF   3E,W
074A:  MOVWF  42
074B:  MOVF   43,W
074C:  MOVWF  7A
074D:  MOVF   42,W
074E:  MOVWF  04
074F:  BCF    03.7
0750:  BTFSC  7A.0
0751:  BSF    03.7
0752:  MOVF   00,F
0753:  BTFSC  03.2
0754:  GOTO   759
0755:  INCF   42,F
0756:  BTFSC  03.2
0757:  INCF   43,F
0758:  GOTO   74B
....................    while(*s2 != '\0') 
0759:  MOVF   41,W
075A:  MOVWF  7A
075B:  MOVF   40,W
075C:  MOVWF  04
075D:  BCF    03.7
075E:  BTFSC  7A.0
075F:  BSF    03.7
0760:  MOVF   00,F
0761:  BTFSC  03.2
0762:  GOTO   778
....................    { 
....................       *s = *s2; 
0763:  MOVF   40,W
0764:  MOVWF  04
0765:  BCF    03.7
0766:  BTFSC  41.0
0767:  BSF    03.7
0768:  MOVF   00,W
0769:  MOVWF  46
076A:  MOVF   42,W
076B:  MOVWF  04
076C:  BCF    03.7
076D:  BTFSC  43.0
076E:  BSF    03.7
076F:  MOVF   46,W
0770:  MOVWF  00
....................       ++s; 
0771:  INCF   42,F
0772:  BTFSC  03.2
0773:  INCF   43,F
....................       ++s2; 
0774:  INCF   40,F
0775:  BTFSC  03.2
0776:  INCF   41,F
0777:  GOTO   759
....................    } 
....................  
....................    *s = '\0'; 
0778:  MOVF   42,W
0779:  MOVWF  04
077A:  BCF    03.7
077B:  BTFSC  43.0
077C:  BSF    03.7
077D:  CLRF   00
....................    return(s1); 
077E:  MOVF   3E,W
077F:  MOVWF  78
0780:  MOVF   3F,W
0781:  MOVWF  79
0782:  BCF    03.6
0783:  RETURN
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
*
0B0C:  BSF    03.6
0B0D:  MOVF   17,W
0B0E:  MOVWF  7A
0B0F:  MOVF   16,W
0B10:  MOVWF  04
0B11:  BCF    03.7
0B12:  BTFSC  7A.0
0B13:  BSF    03.7
0B14:  MOVF   00,W
0B15:  MOVWF  1A
0B16:  MOVF   19,W
0B17:  MOVWF  7A
0B18:  MOVF   18,W
0B19:  MOVWF  04
0B1A:  BCF    03.7
0B1B:  BTFSC  7A.0
0B1C:  BSF    03.7
0B1D:  MOVF   00,W
0B1E:  SUBWF  1A,W
0B1F:  BTFSS  03.2
0B20:  GOTO   338
....................       if (*s1 == '\0') 
0B21:  MOVF   17,W
0B22:  MOVWF  7A
0B23:  MOVF   16,W
0B24:  MOVWF  04
0B25:  BCF    03.7
0B26:  BTFSC  7A.0
0B27:  BSF    03.7
0B28:  MOVF   00,F
0B29:  BTFSS  03.2
0B2A:  GOTO   32E
....................          return(0); 
0B2B:  MOVLW  00
0B2C:  MOVWF  78
0B2D:  GOTO   350
0B2E:  MOVF   17,W
0B2F:  MOVWF  7A
0B30:  MOVF   16,W
0B31:  INCF   16,F
0B32:  BTFSC  03.2
0B33:  INCF   17,F
0B34:  INCF   18,F
0B35:  BTFSC  03.2
0B36:  INCF   19,F
0B37:  GOTO   30D
....................    return((*s1 < *s2) ? -1: 1); 
0B38:  MOVF   17,W
0B39:  MOVWF  7A
0B3A:  MOVF   16,W
0B3B:  MOVWF  04
0B3C:  BCF    03.7
0B3D:  BTFSC  17.0
0B3E:  BSF    03.7
0B3F:  MOVF   00,W
0B40:  MOVWF  1A
0B41:  MOVF   19,W
0B42:  MOVWF  7A
0B43:  MOVF   18,W
0B44:  MOVWF  04
0B45:  BCF    03.7
0B46:  BTFSC  19.0
0B47:  BSF    03.7
0B48:  MOVF   00,W
0B49:  SUBWF  1A,W
0B4A:  BTFSC  03.0
0B4B:  GOTO   34E
0B4C:  MOVLW  FF
0B4D:  GOTO   34F
0B4E:  MOVLW  01
0B4F:  MOVWF  78
0B50:  BCF    03.6
0B51:  RETURN
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
*
0C41:  MOVF   17,W
0C42:  MOVWF  7A
0C43:  MOVF   16,W
0C44:  MOVWF  04
0C45:  BCF    03.7
0C46:  BTFSC  7A.0
0C47:  BSF    03.7
0C48:  MOVF   18,W
0C49:  SUBWF  00,W
0C4A:  BTFSC  03.2
0C4B:  GOTO   45E
....................       if (*s == '\0') 
0C4C:  MOVF   17,W
0C4D:  MOVWF  7A
0C4E:  MOVF   16,W
0C4F:  MOVWF  04
0C50:  BCF    03.7
0C51:  BTFSC  7A.0
0C52:  BSF    03.7
0C53:  MOVF   00,F
0C54:  BTFSS  03.2
0C55:  GOTO   45A
....................          return(0); 
0C56:  MOVLW  00
0C57:  MOVWF  78
0C58:  MOVWF  79
0C59:  GOTO   462
0C5A:  INCF   16,F
0C5B:  BTFSC  03.2
0C5C:  INCF   17,F
0C5D:  GOTO   441
....................    return(s); 
0C5E:  MOVF   16,W
0C5F:  MOVWF  78
0C60:  MOVF   17,W
0C61:  MOVWF  79
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
*
09C4:  MOVF   21,W
09C5:  MOVWF  25
09C6:  MOVF   20,W
09C7:  MOVWF  24
09C8:  MOVF   25,W
09C9:  MOVWF  7A
09CA:  MOVF   24,W
09CB:  MOVWF  04
09CC:  BCF    03.7
09CD:  BTFSC  7A.0
09CE:  BSF    03.7
09CF:  MOVF   00,F
09D0:  BTFSC  03.2
09D1:  GOTO   201
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
09D2:  MOVF   23,W
09D3:  MOVWF  27
09D4:  MOVF   22,W
09D5:  MOVWF  26
09D6:  MOVF   27,W
09D7:  MOVWF  7A
09D8:  MOVF   26,W
09D9:  MOVWF  04
09DA:  BCF    03.7
09DB:  BTFSC  7A.0
09DC:  BSF    03.7
09DD:  MOVF   00,F
09DE:  BTFSC  03.2
09DF:  GOTO   1FD
....................          if (*sc1 == *sc2) 
09E0:  MOVF   25,W
09E1:  MOVWF  7A
09E2:  MOVF   24,W
09E3:  MOVWF  04
09E4:  BCF    03.7
09E5:  BTFSC  7A.0
09E6:  BSF    03.7
09E7:  MOVF   00,W
09E8:  MOVWF  28
09E9:  MOVF   27,W
09EA:  MOVWF  7A
09EB:  MOVF   26,W
09EC:  MOVWF  04
09ED:  BCF    03.7
09EE:  BTFSC  7A.0
09EF:  BSF    03.7
09F0:  MOVF   00,W
09F1:  SUBWF  28,W
09F2:  BTFSS  03.2
09F3:  GOTO   1F9
....................             return(sc1); 
09F4:  MOVF   24,W
09F5:  MOVWF  78
09F6:  MOVF   25,W
09F7:  MOVWF  79
09F8:  GOTO   204
09F9:  INCF   26,F
09FA:  BTFSC  03.2
09FB:  INCF   27,F
09FC:  GOTO   1D6
09FD:  INCF   24,F
09FE:  BTFSC  03.2
09FF:  INCF   25,F
0A00:  GOTO   1C8
....................    return(0); 
0A01:  MOVLW  00
0A02:  MOVWF  78
0A03:  MOVWF  79
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
*
0951:  MOVF   21,W
0952:  MOVWF  25
0953:  MOVF   20,W
0954:  MOVWF  24
0955:  MOVF   25,W
0956:  MOVWF  7A
0957:  MOVF   24,W
0958:  MOVWF  04
0959:  BCF    03.7
095A:  BTFSC  7A.0
095B:  BSF    03.7
095C:  MOVF   00,F
095D:  BTFSC  03.2
095E:  GOTO   196
....................       for (sc2 = s2; ; sc2++) 
095F:  MOVF   23,W
0960:  MOVWF  27
0961:  MOVF   22,W
0962:  MOVWF  26
....................     if (*sc2 == '\0') 
0963:  MOVF   27,W
0964:  MOVWF  7A
0965:  MOVF   26,W
0966:  MOVWF  04
0967:  BCF    03.7
0968:  BTFSC  7A.0
0969:  BSF    03.7
096A:  MOVF   00,F
096B:  BTFSS  03.2
096C:  GOTO   17A
....................        return(sc1 - s1); 
096D:  MOVF   20,W
096E:  SUBWF  24,W
096F:  MOVWF  77
0970:  MOVF   25,W
0971:  MOVWF  7A
0972:  MOVF   21,W
0973:  BTFSS  03.0
0974:  INCFSZ 21,W
0975:  SUBWF  7A,F
0976:  MOVF   77,W
0977:  MOVWF  78
0978:  GOTO   1A1
0979:  GOTO   18E
....................          else if (*sc1 == *sc2) 
097A:  MOVF   25,W
097B:  MOVWF  7A
097C:  MOVF   24,W
097D:  MOVWF  04
097E:  BCF    03.7
097F:  BTFSC  7A.0
0980:  BSF    03.7
0981:  MOVF   00,W
0982:  MOVWF  28
0983:  MOVF   27,W
0984:  MOVWF  7A
0985:  MOVF   26,W
0986:  MOVWF  04
0987:  BCF    03.7
0988:  BTFSC  7A.0
0989:  BSF    03.7
098A:  MOVF   00,W
098B:  SUBWF  28,W
098C:  BTFSC  03.2
....................             break; 
098D:  GOTO   192
098E:  INCF   26,F
098F:  BTFSC  03.2
0990:  INCF   27,F
0991:  GOTO   163
0992:  INCF   24,F
0993:  BTFSC  03.2
0994:  INCF   25,F
0995:  GOTO   155
....................    return(sc1 - s1); 
0996:  MOVF   20,W
0997:  SUBWF  24,W
0998:  MOVWF  77
0999:  MOVF   25,W
099A:  MOVWF  7A
099B:  MOVF   21,W
099C:  BTFSS  03.0
099D:  INCFSZ 21,W
099E:  SUBWF  7A,F
099F:  MOVF   77,W
09A0:  MOVWF  78
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
*
11DF:  BCF    03.6
11E0:  CLRF   2B
11E1:  CLRF   2C
....................  
....................    beg = (s1)? s1: save; 
*
0938:  BSF    03.6
0939:  MOVF   18,W
093A:  IORWF  19,W
093B:  BTFSC  03.2
093C:  GOTO   141
093D:  MOVF   19,W
093E:  MOVWF  7A
093F:  MOVF   18,W
0940:  GOTO   146
0941:  BCF    03.6
0942:  MOVF   2C,W
0943:  MOVWF  7A
0944:  MOVF   2B,W
0945:  BSF    03.6
0946:  MOVWF  1C
0947:  MOVF   7A,W
0948:  MOVWF  1D
....................    beg += strspn(beg, s2); 
0949:  MOVF   1D,W
094A:  MOVWF  21
094B:  MOVF   1C,W
094C:  MOVWF  20
094D:  MOVF   1B,W
094E:  MOVWF  23
094F:  MOVF   1A,W
0950:  MOVWF  22
*
09A1:  MOVF   78,W
09A2:  ADDWF  1C,F
09A3:  BTFSC  03.0
09A4:  INCF   1D,F
....................    if (*beg == '\0') 
09A5:  MOVF   1D,W
09A6:  MOVWF  7A
09A7:  MOVF   1C,W
09A8:  MOVWF  04
09A9:  BCF    03.7
09AA:  BTFSC  7A.0
09AB:  BSF    03.7
09AC:  MOVF   00,F
09AD:  BTFSS  03.2
09AE:  GOTO   1BC
....................    { 
....................       *save = ' '; 
09AF:  BCF    03.6
09B0:  MOVF   2B,W
09B1:  MOVWF  04
09B2:  BCF    03.7
09B3:  BTFSC  2C.0
09B4:  BSF    03.7
09B5:  MOVLW  20
09B6:  MOVWF  00
....................       return(0); 
09B7:  MOVLW  00
09B8:  MOVWF  78
09B9:  MOVWF  79
09BA:  GOTO   228
09BB:  BSF    03.6
....................    } 
....................    end = strpbrk(beg, s2); 
09BC:  MOVF   1D,W
09BD:  MOVWF  21
09BE:  MOVF   1C,W
09BF:  MOVWF  20
09C0:  MOVF   1B,W
09C1:  MOVWF  23
09C2:  MOVF   1A,W
09C3:  MOVWF  22
*
0A04:  MOVF   79,W
0A05:  MOVWF  1F
0A06:  MOVF   78,W
0A07:  MOVWF  1E
....................    if (*end != '\0') 
0A08:  MOVF   1F,W
0A09:  MOVWF  7A
0A0A:  MOVF   1E,W
0A0B:  MOVWF  04
0A0C:  BCF    03.7
0A0D:  BTFSC  7A.0
0A0E:  BSF    03.7
0A0F:  MOVF   00,F
0A10:  BTFSC  03.2
0A11:  GOTO   21B
....................    { 
....................       *end = '\0'; 
0A12:  MOVF   1E,W
0A13:  MOVWF  04
0A14:  BCF    03.7
0A15:  BTFSC  1F.0
0A16:  BSF    03.7
0A17:  CLRF   00
....................       end++; 
0A18:  INCF   1E,F
0A19:  BTFSC  03.2
0A1A:  INCF   1F,F
....................    } 
....................    save = end; 
0A1B:  MOVF   1F,W
0A1C:  BCF    03.6
0A1D:  MOVWF  2C
0A1E:  BSF    03.6
0A1F:  MOVF   1E,W
0A20:  BCF    03.6
0A21:  MOVWF  2B
....................    return(beg); 
0A22:  BSF    03.6
0A23:  MOVF   1C,W
0A24:  MOVWF  78
0A25:  MOVF   1D,W
0A26:  MOVWF  79
0A27:  BCF    03.6
0A28:  RETURN
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
*
0C6A:  MOVF   17,W
0C6B:  MOVWF  19
0C6C:  MOVF   16,W
0C6D:  MOVWF  18
0C6E:  MOVF   19,W
0C6F:  MOVWF  7A
0C70:  MOVF   18,W
0C71:  MOVWF  04
0C72:  BCF    03.7
0C73:  BTFSC  7A.0
0C74:  BSF    03.7
0C75:  MOVF   00,F
0C76:  BTFSC  03.2
0C77:  GOTO   47C
0C78:  INCF   18,F
0C79:  BTFSC  03.2
0C7A:  INCF   19,F
0C7B:  GOTO   46E
....................    return(sc - s); 
0C7C:  MOVF   16,W
0C7D:  SUBWF  18,W
0C7E:  MOVWF  77
0C7F:  MOVF   19,W
0C80:  MOVWF  7A
0C81:  MOVF   17,W
0C82:  BTFSS  03.0
0C83:  INCFSZ 17,W
0C84:  SUBWF  7A,F
0C85:  MOVF   77,W
0C86:  MOVWF  78
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #INCLUDE <STDLIB.H> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... /* Standart template: float strtof(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... float strtof(char *s,char *endptr); 
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s,char *endptr); 
.................... float64 strtod(char *s,char *endptr); 
.................... #else 
.................... //provided for compatibility 
.................... #define strtof48(s, e) strtof(s, e) 
.................... #define strtod(s, e) strtof(s, e) 
.................... #endif 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof(s)   strtof(s, 0) 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof48(s) strtof48(s, 0) 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof64(s) strtod(s, 0) 
.................... #endif 
....................  
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float atoe(char * s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s); 
.................... #endif 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... unsigned int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................  
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
*
0A29:  BSF    03.6
0A2A:  CLRF   1D
....................    sign = 0; 
0A2B:  CLRF   1B
....................    base = 10; 
0A2C:  MOVLW  0A
0A2D:  MOVWF  1C
....................    result = 0; 
0A2E:  CLRF   1A
....................  
....................    if (!s) 
0A2F:  MOVF   18,W
0A30:  IORWF  19,W
0A31:  BTFSS  03.2
0A32:  GOTO   236
....................       return 0; 
0A33:  MOVLW  00
0A34:  MOVWF  78
0A35:  GOTO   30A
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
0A36:  MOVF   1D,W
0A37:  INCF   1D,F
0A38:  ADDWF  18,W
0A39:  MOVWF  04
0A3A:  BCF    03.7
0A3B:  BTFSC  19.0
0A3C:  BSF    03.7
0A3D:  MOVF   00,W
0A3E:  MOVWF  1E
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
0A3F:  MOVF   1E,W
0A40:  SUBLW  2D
0A41:  BTFSS  03.2
0A42:  GOTO   24F
....................    { 
....................       sign = 1;         // Set the sign to negative 
0A43:  MOVLW  01
0A44:  MOVWF  1B
....................       c = s[index++]; 
0A45:  MOVF   1D,W
0A46:  INCF   1D,F
0A47:  ADDWF  18,W
0A48:  MOVWF  04
0A49:  BCF    03.7
0A4A:  BTFSC  19.0
0A4B:  BSF    03.7
0A4C:  MOVF   00,W
0A4D:  MOVWF  1E
....................    } 
0A4E:  GOTO   25C
....................    else if (c == '+') 
0A4F:  MOVF   1E,W
0A50:  SUBLW  2B
0A51:  BTFSS  03.2
0A52:  GOTO   25C
....................    { 
....................       c = s[index++]; 
0A53:  MOVF   1D,W
0A54:  INCF   1D,F
0A55:  ADDWF  18,W
0A56:  MOVWF  04
0A57:  BCF    03.7
0A58:  BTFSC  19.0
0A59:  BSF    03.7
0A5A:  MOVF   00,W
0A5B:  MOVWF  1E
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
0A5C:  MOVF   1E,W
0A5D:  SUBLW  2F
0A5E:  BTFSC  03.0
0A5F:  GOTO   300
0A60:  MOVF   1E,W
0A61:  SUBLW  39
0A62:  BTFSS  03.0
0A63:  GOTO   300
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
0A64:  MOVF   1E,W
0A65:  SUBLW  30
0A66:  BTFSS  03.2
0A67:  GOTO   288
0A68:  MOVF   1D,W
0A69:  ADDWF  18,W
0A6A:  MOVWF  04
0A6B:  BCF    03.7
0A6C:  BTFSC  19.0
0A6D:  BSF    03.7
0A6E:  MOVF   00,W
0A6F:  SUBLW  78
0A70:  BTFSC  03.2
0A71:  GOTO   27C
0A72:  MOVF   1D,W
0A73:  ADDWF  18,W
0A74:  MOVWF  04
0A75:  BCF    03.7
0A76:  BTFSC  19.0
0A77:  BSF    03.7
0A78:  MOVF   00,W
0A79:  SUBLW  58
0A7A:  BTFSS  03.2
0A7B:  GOTO   288
....................       { 
....................          base = 16; 
0A7C:  MOVLW  10
0A7D:  MOVWF  1C
....................          index++; 
0A7E:  INCF   1D,F
....................          c = s[index++]; 
0A7F:  MOVF   1D,W
0A80:  INCF   1D,F
0A81:  ADDWF  18,W
0A82:  MOVWF  04
0A83:  BCF    03.7
0A84:  BTFSC  19.0
0A85:  BSF    03.7
0A86:  MOVF   00,W
0A87:  MOVWF  1E
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
0A88:  MOVF   1C,W
0A89:  SUBLW  0A
0A8A:  BTFSS  03.2
0A8B:  GOTO   2AE
....................       { 
....................          while (c >= '0' && c <= '9') 
0A8C:  MOVF   1E,W
0A8D:  SUBLW  2F
0A8E:  BTFSC  03.0
0A8F:  GOTO   2AD
0A90:  MOVF   1E,W
0A91:  SUBLW  39
0A92:  BTFSS  03.0
0A93:  GOTO   2AD
....................          { 
....................             result = 10*result + (c - '0'); 
0A94:  MOVLW  0A
0A95:  MOVWF  1F
0A96:  MOVF   1A,W
0A97:  MOVWF  20
0A98:  BCF    0A.3
0A99:  BCF    03.6
0A9A:  CALL   7A2
0A9B:  BSF    0A.3
0A9C:  MOVF   78,W
0A9D:  BSF    03.6
0A9E:  MOVWF  1F
0A9F:  MOVLW  30
0AA0:  SUBWF  1E,W
0AA1:  ADDWF  1F,W
0AA2:  MOVWF  1A
....................             c = s[index++]; 
0AA3:  MOVF   1D,W
0AA4:  INCF   1D,F
0AA5:  ADDWF  18,W
0AA6:  MOVWF  04
0AA7:  BCF    03.7
0AA8:  BTFSC  19.0
0AA9:  BSF    03.7
0AAA:  MOVF   00,W
0AAB:  MOVWF  1E
0AAC:  GOTO   28C
....................          } 
....................       } 
0AAD:  GOTO   300
....................       else if (base == 16)    // The number is a hexa number 
0AAE:  MOVF   1C,W
0AAF:  SUBLW  10
0AB0:  BTFSS  03.2
0AB1:  GOTO   300
....................       { 
....................          c = toupper(c); 
0AB2:  MOVF   1E,W
0AB3:  SUBLW  60
0AB4:  BTFSC  03.0
0AB5:  GOTO   2BD
0AB6:  MOVF   1E,W
0AB7:  SUBLW  7A
0AB8:  BTFSS  03.0
0AB9:  GOTO   2BD
0ABA:  MOVF   1E,W
0ABB:  ANDLW  DF
0ABC:  GOTO   2BE
0ABD:  MOVF   1E,W
0ABE:  MOVWF  1E
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
0ABF:  MOVF   1E,W
0AC0:  SUBLW  2F
0AC1:  BTFSC  03.0
0AC2:  GOTO   2C7
0AC3:  MOVF   1E,W
0AC4:  SUBLW  39
0AC5:  BTFSC  03.0
0AC6:  GOTO   2CF
0AC7:  MOVF   1E,W
0AC8:  SUBLW  40
0AC9:  BTFSC  03.0
0ACA:  GOTO   300
0ACB:  MOVF   1E,W
0ACC:  SUBLW  46
0ACD:  BTFSS  03.0
0ACE:  GOTO   300
....................          { 
....................             if (c >= '0' && c <= '9') 
0ACF:  MOVF   1E,W
0AD0:  SUBLW  2F
0AD1:  BTFSC  03.0
0AD2:  GOTO   2E0
0AD3:  MOVF   1E,W
0AD4:  SUBLW  39
0AD5:  BTFSS  03.0
0AD6:  GOTO   2E0
....................                result = (result << 4) + (c - '0'); 
0AD7:  SWAPF  1A,W
0AD8:  MOVWF  1F
0AD9:  MOVLW  F0
0ADA:  ANDWF  1F,F
0ADB:  MOVLW  30
0ADC:  SUBWF  1E,W
0ADD:  ADDWF  1F,W
0ADE:  MOVWF  1A
0ADF:  GOTO   2E9
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
0AE0:  SWAPF  1A,W
0AE1:  MOVWF  1F
0AE2:  MOVLW  F0
0AE3:  ANDWF  1F,F
0AE4:  MOVLW  41
0AE5:  SUBWF  1E,W
0AE6:  ADDLW  0A
0AE7:  ADDWF  1F,W
0AE8:  MOVWF  1A
....................  
....................             c = s[index++]; 
0AE9:  MOVF   1D,W
0AEA:  INCF   1D,F
0AEB:  ADDWF  18,W
0AEC:  MOVWF  04
0AED:  BCF    03.7
0AEE:  BTFSC  19.0
0AEF:  BSF    03.7
0AF0:  MOVF   00,W
0AF1:  MOVWF  1E
....................             c = toupper(c); 
0AF2:  MOVF   1E,W
0AF3:  SUBLW  60
0AF4:  BTFSC  03.0
0AF5:  GOTO   2FD
0AF6:  MOVF   1E,W
0AF7:  SUBLW  7A
0AF8:  BTFSS  03.0
0AF9:  GOTO   2FD
0AFA:  MOVF   1E,W
0AFB:  ANDLW  DF
0AFC:  GOTO   2FE
0AFD:  MOVF   1E,W
0AFE:  MOVWF  1E
0AFF:  GOTO   2BF
....................          } 
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
0B00:  DECFSZ 1B,W
0B01:  GOTO   308
0B02:  MOVF   1C,W
0B03:  SUBLW  0A
0B04:  BTFSS  03.2
0B05:  GOTO   308
....................        result = -result; 
0B06:  COMF   1A,F
0B07:  INCF   1A,F
....................  
....................    return(result); 
0B08:  MOVF   1A,W
0B09:  MOVWF  78
0B0A:  BCF    03.6
0B0B:  RETURN
.................... } 
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
*
03F5:  BSF    03.6
03F6:  CLRF   49
03F7:  CLRF   48
03F8:  CLRF   47
03F9:  MOVLW  01
03FA:  MOVWF  46
03FB:  CLRF   4B
03FC:  CLRF   4C
.................... { 
....................      unsigned int32 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
03FD:  BTFSS  42.7
03FE:  GOTO   43F
....................          sign=1;        // Check for negative number 
03FF:  MOVLW  01
0400:  MOVWF  4B
....................          num*=-1; 
0401:  MOVF   42,W
0402:  MOVWF  51
0403:  MOVF   41,W
0404:  MOVWF  50
0405:  MOVF   40,W
0406:  MOVWF  4F
0407:  MOVF   3F,W
0408:  MOVWF  4E
0409:  MOVLW  FF
040A:  MOVWF  55
040B:  MOVWF  54
040C:  MOVWF  53
040D:  MOVWF  52
*
0437:  MOVF   7A,W
0438:  MOVWF  42
0439:  MOVF   79,W
043A:  MOVWF  41
043B:  MOVF   78,W
043C:  MOVWF  40
043D:  MOVF   77,W
043E:  MOVWF  3F
....................      } 
....................  
....................      while(temp>0) { 
043F:  MOVF   46,F
0440:  BTFSS  03.2
0441:  GOTO   44B
0442:  MOVF   47,F
0443:  BTFSS  03.2
0444:  GOTO   44B
0445:  MOVF   48,F
0446:  BTFSS  03.2
0447:  GOTO   44B
0448:  MOVF   49,F
0449:  BTFSC  03.2
044A:  GOTO   4C7
....................          temp=(num/base); 
044B:  BCF    03.1
044C:  MOVF   42,W
044D:  MOVWF  59
044E:  MOVF   41,W
044F:  MOVWF  58
0450:  MOVF   40,W
0451:  MOVWF  57
0452:  MOVF   3F,W
0453:  MOVWF  56
0454:  CLRF   5D
0455:  CLRF   5C
0456:  CLRF   5B
0457:  MOVF   43,W
0458:  MOVWF  5A
0459:  BCF    03.6
045A:  CALL   379
045B:  MOVF   7A,W
045C:  BSF    03.6
045D:  MOVWF  49
045E:  MOVF   79,W
045F:  MOVWF  48
0460:  MOVF   78,W
0461:  MOVWF  47
0462:  MOVF   77,W
0463:  MOVWF  46
....................          s[cnt]=(num%base)+'0';    // Conversion 
0464:  MOVF   4C,W
0465:  ADDWF  44,W
0466:  MOVWF  78
0467:  MOVF   45,W
0468:  MOVWF  7A
0469:  BTFSC  03.0
046A:  INCF   7A,F
046B:  MOVF   78,W
046C:  MOVWF  4E
046D:  MOVF   7A,W
046E:  MOVWF  4F
046F:  CLRF   51
0470:  MOVF   04,W
0471:  MOVWF  50
0472:  BCF    51.0
0473:  BTFSC  03.7
0474:  BSF    51.0
0475:  BSF    03.1
0476:  MOVLW  52
0477:  MOVWF  04
0478:  BSF    03.7
0479:  MOVF   42,W
047A:  MOVWF  59
047B:  MOVF   41,W
047C:  MOVWF  58
047D:  MOVF   40,W
047E:  MOVWF  57
047F:  MOVF   3F,W
0480:  MOVWF  56
0481:  CLRF   5D
0482:  CLRF   5C
0483:  CLRF   5B
0484:  MOVF   43,W
0485:  MOVWF  5A
0486:  BCF    03.6
0487:  CALL   379
0488:  BSF    03.6
0489:  MOVF   50,W
048A:  MOVWF  04
048B:  BCF    03.7
048C:  BTFSC  51.0
048D:  BSF    03.7
048E:  MOVLW  30
048F:  ADDWF  52,W
0490:  MOVWF  77
0491:  MOVF   53,W
0492:  MOVWF  78
0493:  MOVLW  00
0494:  BTFSC  03.0
0495:  MOVLW  01
0496:  ADDWF  78,F
0497:  MOVF   54,W
0498:  MOVWF  79
0499:  MOVLW  00
049A:  BTFSC  03.0
049B:  MOVLW  01
049C:  ADDWF  79,F
049D:  MOVF   55,W
049E:  MOVWF  7A
049F:  MOVLW  00
04A0:  BTFSC  03.0
04A1:  MOVLW  01
04A2:  ADDWF  7A,F
04A3:  MOVF   4E,W
04A4:  MOVWF  04
04A5:  BCF    03.7
04A6:  BTFSC  4F.0
04A7:  BSF    03.7
04A8:  MOVF   77,W
04A9:  MOVWF  00
....................  
....................          if(s[cnt]>0x39) 
04AA:  MOVF   4C,W
04AB:  ADDWF  44,W
04AC:  MOVWF  04
04AD:  BCF    03.7
04AE:  BTFSC  45.0
04AF:  BSF    03.7
04B0:  MOVF   00,W
04B1:  SUBLW  39
04B2:  BTFSC  03.0
04B3:  GOTO   4BD
....................             s[cnt]+=0x7; 
04B4:  MOVF   4C,W
04B5:  ADDWF  44,W
04B6:  MOVWF  04
04B7:  BCF    03.7
04B8:  BTFSC  45.0
04B9:  BSF    03.7
04BA:  MOVLW  07
04BB:  ADDWF  00,W
04BC:  MOVWF  00
....................  
....................          cnt++; 
04BD:  INCF   4C,F
....................          num=temp; 
04BE:  MOVF   49,W
04BF:  MOVWF  42
04C0:  MOVF   48,W
04C1:  MOVWF  41
04C2:  MOVF   47,W
04C3:  MOVWF  40
04C4:  MOVF   46,W
04C5:  MOVWF  3F
04C6:  GOTO   43F
....................      } 
....................  
....................      if(sign==1) { 
04C7:  DECFSZ 4B,W
04C8:  GOTO   4D2
....................          s[cnt]=0x2D;      // Negative sign 
04C9:  MOVF   4C,W
04CA:  ADDWF  44,W
04CB:  MOVWF  04
04CC:  BCF    03.7
04CD:  BTFSC  45.0
04CE:  BSF    03.7
04CF:  MOVLW  2D
04D0:  MOVWF  00
....................          cnt++; 
04D1:  INCF   4C,F
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
04D2:  CLRF   4A
04D3:  BCF    03.0
04D4:  RRF    4C,W
04D5:  SUBWF  4A,W
04D6:  BTFSC  03.0
04D7:  GOTO   508
....................  
....................          c=s[i]; 
04D8:  MOVF   4A,W
04D9:  ADDWF  44,W
04DA:  MOVWF  04
04DB:  BCF    03.7
04DC:  BTFSC  45.0
04DD:  BSF    03.7
04DE:  MOVF   00,W
04DF:  MOVWF  4D
....................          s[i]=s[cnt-i-1];        // Reverse the number 
04E0:  MOVF   4A,W
04E1:  ADDWF  44,W
04E2:  MOVWF  78
04E3:  MOVF   45,W
04E4:  MOVWF  7A
04E5:  BTFSC  03.0
04E6:  INCF   7A,F
04E7:  MOVF   78,W
04E8:  MOVWF  4E
04E9:  MOVF   7A,W
04EA:  MOVWF  4F
04EB:  MOVF   4A,W
04EC:  SUBWF  4C,W
04ED:  ADDLW  FF
04EE:  ADDWF  44,W
04EF:  MOVWF  04
04F0:  BCF    03.7
04F1:  BTFSC  45.0
04F2:  BSF    03.7
04F3:  MOVF   00,W
04F4:  MOVWF  50
04F5:  MOVF   4E,W
04F6:  MOVWF  04
04F7:  BCF    03.7
04F8:  BTFSC  4F.0
04F9:  BSF    03.7
04FA:  MOVF   50,W
04FB:  MOVWF  00
....................          s[cnt-i-1]=c; 
04FC:  MOVF   4A,W
04FD:  SUBWF  4C,W
04FE:  ADDLW  FF
04FF:  ADDWF  44,W
0500:  MOVWF  04
0501:  BCF    03.7
0502:  BTFSC  45.0
0503:  BSF    03.7
0504:  MOVF   4D,W
0505:  MOVWF  00
0506:  INCF   4A,F
0507:  GOTO   4D3
....................      } 
....................      s[cnt]='\0';     // End the string 
0508:  MOVF   4C,W
0509:  ADDWF  44,W
050A:  MOVWF  04
050B:  BCF    03.7
050C:  BTFSC  45.0
050D:  BSF    03.7
050E:  CLRF   00
....................      return s; 
050F:  MOVF   44,W
0510:  MOVWF  78
0511:  MOVF   45,W
0512:  MOVWF  79
0513:  BCF    03.6
0514:  RETURN
.................... } 
....................  
.................... #if defined(__PCD__) 
....................  
.................... char * itoa(signed int48 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int48 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... char * itoa(signed int64 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int64 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................       
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1;         
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................              
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #endif 
....................  
.................... float strtof(char *s, char *endptr) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s, char *endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float48)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float48)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s, char *endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float64)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float64)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtoulGO; 
....................  
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................    { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... int8 mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #if !defined(__PCD__) 
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2);  
.................... #else  
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2);  
.................... #endif 
....................  
....................  
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    unsigned int8 t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=1; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = 0; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
.................... #INCLUDE <STDIO.H> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDIO 
.................... #define _STDIO 
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #ifndef getc 
.................... #define getc getch 
.................... #define getchar getch 
.................... #define puts(s) {printf(s); putchar(13); putchar(10);} 
.................... #define putc putchar 
.................... #endif 
.................... /* maps error number to an error message. Writes a sequence of characters to 
.................... stderr stream thus: if s is not null then string pointed to by s follwed by 
.................... a colon (:) and a space and the appropriate error message returned by strerror 
.................... function with argument errno 
....................  
.................... Returns: no value 
.................... */ 
....................  
.................... #ifdef _ERRNO 
.................... void perror(char *s) 
.................... { 
....................   if(s) 
....................   fprintf(STDERR,"%s: ",s); 
....................   fprintf(STDERR,"%s\r\n",strerror(errno)); 
.................... } 
.................... #endif 
.................... #endif 
....................  
.................... #INCLUDE <MATH.H> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2011 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                    //// 
.................... //// History:                                                           //// 
.................... ////  * 9/20/2001 :  Improvments are made to sin/cos code.              //// 
.................... ////                 The code now is small, much faster,                //// 
.................... ////                 and more accurate.                                 //// 
.................... ////  * 2/21/2007 :  Compiler handles & operator differently and does   //// 
.................... ////                 not return generic (int8 *) so type cast is done   //// 
.................... ////  * 6/19/2010 :  Divisions by constants converted to multiplication //// 
.................... ////                 by its inverse to improve computation speed        //// 
.................... ////  * 1/21/2011 :  Constants used for double precision math updated   //// 
.................... ////                 Updated routines include 64 bit versions of cos,   //// 
.................... ////                 asin,atan,exp,log and dependant functions          //// 
.................... ////  * 1/31/2011 :  Optimized current 32-bit float routines for cos    //// 
.................... ////                 and log function                                   //// 
.................... ////  * 6/13/2011 :  Fixed PCD overload CEIL_FLOOR functions for values //// 
.................... ////                 greater then 10000000 and less then -10000000      //// 
.................... ////                                                                    //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef MATH_H 
.................... #define MATH_H 
....................  
.................... #ifdef PI 
.................... #undef  PI 
.................... #endif 
.................... #define PI     3.1415926535897932 
....................  
....................  
.................... #define SQRT2  1.4142135623730950 
....................  
.................... //float const ps[4] = {5.9304945, 21.125224, 8.9403076, 0.29730279}; 
.................... //float const qs[4] = {1.0000000, 15.035723, 17.764134, 2.4934718}; 
....................  
.................... ///////////////////////////// Round Functions ////////////////////////////// 
....................  
.................... float32 CEIL_FLOOR(float32 x, unsigned int8 n) 
.................... { 
....................    float32 y, res; 
....................    unsigned int16 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................       res = (float32)(unsigned int16)y; 
....................  
....................  else if (y < 10000000.0) 
....................    {  
....................       l = (unsigned int16)(y*0.000030517578125); 
....................       y = 32768.0*(y*0.000030517578125 - (float32)l); 
....................       res = 32768.0*(float32)l; 
....................       res += (float32)(unsigned int16)y; 
....................    } 
....................  
....................  else 
....................   res = y; 
....................  
....................  y = y - (float32)(unsigned int16)y; 
....................  
....................  if (s) 
....................   res = -res; 
....................  
....................  if (y != 0) 
....................  { 
....................   if (s == 1 && n == 0) 
....................    res -= 1.0; 
....................  
....................   if (s == 0 && n == 1) 
....................    res += 1.0; 
....................  } 
....................  if (x == 0) 
....................     res = 0; 
....................  
....................  return (res); 
.................... } 
....................  
.................... // Overloaded Functions to take care for new Data types in PCD 
.................... // Overloaded function CEIL_FLOOR() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 CEIL_FLOOR(float48 x, unsigned int8 n) 
.................... { 
....................    float48 y, res; 
....................    unsigned int32 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................       res = (float48)(unsigned int16)y; 
....................  
....................    else if (y < 549755813888.0) 
....................    { 
....................       l = (unsigned int32)(y*0.000030517578125); 
....................       y = 32768.0*(y*0.000030517578125 - (float48)l); 
....................       res = 32768.0*(float48)l; 
....................       res += (float48)(unsigned int16)y; 
....................    } 
....................    else 
....................    {   
....................       res = y; 
....................       y = 0.0; 
....................    } 
....................     
....................    if(y != 0) 
....................       y = y - (float48)(unsigned int16)y; 
....................  
....................    if (s) 
....................       res = -res; 
....................  
....................    if (y != 0) 
....................    { 
....................       if (s == 1 && n == 0) 
....................          res -= 1.0; 
....................  
....................       if (s == 0 && n == 1) 
....................          res += 1.0; 
....................    } 
....................    if (x == 0) 
....................       res = 0; 
....................  
....................    return (res); 
.................... } 
....................  
....................  
.................... // Overloaded function CEIL_FLOOR() for data type - Float64 
.................... float64 CEIL_FLOOR(float64 x, unsigned int8 n) 
.................... { 
....................    float64 y, res; 
....................    int64 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................       res = (float64)(unsigned int16)y; 
....................    else if (y < 4503599627370496.0) 
....................    { 
....................       l = (int64)(y*0.000030517578125); 
....................       y = 32768.0*(y*0.000030517578125 - (float64)l); 
....................       res = 32768.0*(float64)l; 
....................       res += (float64)(unsigned int16)y; 
....................    } 
....................    else 
....................    { 
....................       res = y; 
....................       y = 0.0; 
....................    } 
....................     
....................    if(y != 0) 
....................       y = y - (float64)(unsigned int16)y; 
....................  
....................    if (s) 
....................       res = -res; 
....................  
....................    if (y != 0) 
....................    { 
....................       if (s == 1 && n == 0) 
....................          res -= 1.0; 
....................  
....................       if (s == 0 && n == 1) 
....................          res += 1.0; 
....................    } 
....................     
....................    if (x == 0) 
....................       res = 0; 
....................  
....................    return (res); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float floor(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : rounds down the number x. 
.................... // Date : N/A 
.................... // 
.................... float32 floor(float32 x) 
.................... { 
....................    return CEIL_FLOOR(x,0); 
.................... } 
.................... // Following 2 functions are overloaded functions of floor() for PCD 
.................... // Overloaded function floor() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 floor(float48 x) 
.................... { 
....................    return CEIL_FLOOR(x, 0); 
.................... } 
....................  
.................... // Overloaded function floor() for data type - Float64 
.................... float64 floor(float64 x) 
.................... { 
....................    return CEIL_FLOOR(x, 0); 
.................... } 
.................... #endif 
....................  
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float ceil(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : rounds up the number x. 
.................... // Date : N/A 
.................... // 
.................... float32 ceil(float32 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
.................... // Following 2 functions are overloaded functions of ceil() for PCD 
.................... // Overloaded function ceil() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 ceil(float48 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
....................  
.................... // Overloaded function ceil() for data type - Float64 
.................... float64 ceil(float64 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
.................... #endif 
....................  
....................  //////////////////////////////////////////////////////////////////////////// 
.................... //   float fabs(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the absolute value of floating point number x 
.................... // Returns : returns the absolute value of x 
.................... // Date : N/A 
.................... // 
.................... #define fabs abs 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float fmod(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the floating point remainder of x/y 
.................... // Returns : returns the value of x= i*y, for some integer i such that, if y 
.................... // is non zero, the result has the same isgn of x na dmagnitude less than the 
.................... // magnitude of y. If y is zero then a domain error occurs. 
.................... // Date : N/A 
.................... // 
....................  
.................... float fmod(float32 x,float32 y) 
.................... { 
....................    float32 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... //Overloaded function for fmod() for PCD 
.................... // Overloaded function fmod() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 fmod(float48 x,float48 y) 
.................... { 
....................    float48 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... // Overloaded function fmod() for data type - Float64 
.................... float64 fmod(float64 x,float64 y) 
.................... { 
....................    float64 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... #endif 
.................... //////////////////// Exponential and logarithmic functions //////////////////// 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float exp(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (e^x) 
.................... // Date : N/A 
.................... // 
.................... #define LN2 0.6931471805599453 
.................... #define LN2_INV 1.4426950408889634073 
....................  
.................... float const pe[6] = {0.000207455774, 0.00127100575, 0.00965065093, 
....................                      0.0554965651,  0.240227138,  0.693147172}; 
....................  
....................  
.................... float32 exp(float32 x) 
.................... { 
....................    float32 y, res, r; 
....................    #if defined(__PCD__) 
....................    int8 data1; 
....................    #endif 
....................    signed int8 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 88.722838) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    n = (signed int16)(x*LN2_INV); 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
.................... #if !defined(__PCD__) 
....................    *((unsigned int8 *)(&res)) = n + 0x7F; 
.................... #endif 
....................  
.................... #if defined(__PCD__)  // Takes care of IEEE format for PCD 
....................    data1 = n+0x7F; 
....................    if(bit_test(data1,0)) 
....................    bit_set(*(((unsigned int8 *)(&res)+2)),7); 
....................    rotate_right(&data1,1); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&res)+3)) = data1; 
.................... #endif 
....................  
....................    y = y*LN2_INV - (float32)n; 
....................  
....................    r = pe[0]*y + pe[1]; 
....................    r = r*y + pe[2]; 
....................    r = r*y + pe[3]; 
....................    r = r*y + pe[4]; 
....................    r = r*y + pe[5]; 
....................  
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
....................  
....................  
.................... //Overloaded function for exp() for PCD 
.................... // Overloaded function exp() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 exp(float48 x) 
.................... { 
....................    float48 y, res, r; 
....................    int8 data1; 
....................    signed int8 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 88.722838) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    n = (signed int16)(x*LN2_INV); 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
....................  
....................    data1 = n+0x7F; 
....................    if(bit_test(data1,0)) 
....................    bit_set(*(((unsigned int8 *)(&res)+4)),7); 
....................    rotate_right(&data1,1); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&res)+5)) = data1; 
....................  
....................    y = y*LN2_INV - (float48)n; 
....................  
....................    r = pe[0]*y + pe[1]; 
....................    r = r*y + pe[2]; 
....................    r = r*y + pe[3]; 
....................    r = r*y + pe[4]; 
....................    r = r*y + pe[5]; 
....................  
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function exp() for data type - Float64 
.................... float64 const pe_64[12] ={9.30741400474913e-011,-4.28655416283316e-011, 
....................                           8.71486547014137e-009,9.84458531538385e-008, 
....................                           1.32588296983536e-006,1.52489283823016e-005, 
....................                           0.000154037598423921,0.00133335487036216, 
....................                           0.00961812936407326,0.0555041086222122, 
....................                           0.240226506962827,0.693147180559823}; 
....................  
.................... float64 exp(float64 x) 
.................... { 
....................    float64 y, res, r; 
....................    unsigned int16 data1, data2; 
....................    unsigned int16 *p; 
....................    signed int16 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 709.7827128) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x*LN2_INV; 
....................    n = (signed int16)y; 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
....................  
.................... #if !defined(__PCD__) 
....................    *((unsigned int16 *)(&res)) = n + 0x7F; 
.................... #endif 
....................    p= (((unsigned int16 *)(&res))+3); 
....................    data1 = *p; 
....................    data2 = *p;    
....................    data1 = n + 0x3FF; 
....................    data1 = data1 <<4; 
....................    if(bit_test(data2,15)) 
....................    bit_set(data1,15); 
....................    data2 = data2 & 0x000F; 
....................    data1 ^= data2; 
....................  
....................    *(((unsigned int16 *)(&res)+3)) = data1; 
....................  
....................  
....................    y = y*LN2_INV - (float64)n; 
....................  
....................    r = pe_64[0]*y + pe_64[1]; 
....................    r = r*y + pe_64[2]; 
....................    r = r*y + pe_64[3]; 
....................    r = r*y + pe_64[4]; 
....................    r = r*y + pe_64[5]; 
....................    r = r*y + pe_64[6]; 
....................    r = r*y + pe_64[7]; 
....................    r = r*y + pe_64[8]; 
....................    r = r*y + pe_64[9]; 
....................    r = r*y + pe_64[10]; 
....................    r = r*y + pe_64[11]; 
....................     
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
.................... #ENDIF 
....................  
....................  
.................... /************************************************************/ 
....................  
.................... float32 const pl[4] = {-1.080310025160955, 1.999999947089217}; 
.................... float32 const ql[4] = {0.091284365719509, -0.873491916557671}; 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float log(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the the natural log of x 
.................... // Date : N/A 
.................... // 
.................... float32 log(float32 x) 
.................... { 
....................    float32 y, res, r, y2; 
....................    #if defined(__PCD__) 
....................    unsigned int8  data1,data2; 
....................    #endif 
....................    signed int8 n; 
....................    #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
.................... #if !defined(__PCD__) 
....................     *((unsigned int8 *)(&y)) = 0x7E;  
.................... #endif 
....................  
.................... #if defined(__PCD__) // Takes care of IEEE format 
....................    data2 = *(((unsigned int8 *)(&y))+3); 
....................    *(((unsigned int8 *)(&y))+3) = 0x3F; 
....................    data1 = *(((unsigned int8 *)(&y))+2); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&y))+2) = data1; 
....................    if(bit_test(data2,7)) 
....................      bit_set(*(((unsigned int8 *)(&y))+3),7); 
.................... #endif 
....................  
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl[0]*y2 + pl[1]; 
....................  
....................       r = ql[0]*y2 + ql[1]; 
....................       r = r*y2 + 1.0; 
....................  
....................       res = y*res/r; 
.................... #if !defined(__PCD__) 
....................       n = *((unsigned int8 *)(&x)) - 0x7E; 
.................... #endif 
.................... #if defined(__PCD__)  
....................     data1 = *(((unsigned int8 *)(&x)+3)); 
....................     rotate_left(&data1,1); 
....................     data2 = *(((unsigned int8 *)(&x)+2)); 
....................     if(bit_test (data2,7)) 
....................       bit_set(data1,0); 
....................     n = data1 - 0x7E; 
.................... #endif 
....................  
....................       if (n<0)  
....................          r = -(float32)-n; 
....................       else 
....................          r = (float32)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................       res = 0.0; 
....................  
....................    return(res); 
.................... } 
....................  
.................... //Overloaded function for log() for PCD 
.................... // Overloaded function log() for data type - Float48 
.................... #if defined(__PCD__) 
.................... // Overloaded function log() for data type - float64 
.................... float64 const pl_64[4] = {-0.145694052150681, 1.365485300000370, 
....................                           -3.120535668274329, 2.000000000000000}; 
....................  
.................... float64 const ql_64[4] = {0.006047500465908, -0.208298281937234, 
....................                           1.113943039156721, -1.893601167470470}; 
....................  
.................... float48 log(float48 x) 
.................... { 
....................    float48 y, res, r, y2; 
....................    unsigned int8  data1,data2; 
....................    signed int8 n; 
.................... #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
.................... #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
....................  
.................... #if !defined(__PCD__) 
....................       *((unsigned int8 *)(&y)) = 0x7E;  
.................... #endif 
....................       data2 = *(((unsigned int8 *)(&y))+5); 
....................       *(((unsigned int8 *)(&y))+5) = 0x3F; 
....................       data1 = *(((unsigned int8 *)(&y))+4); 
....................       bit_clear(data1,7); 
....................       *(((unsigned int8 *)(&y))+4) = data1; 
....................  
....................       if(bit_test(data2,7)) 
....................       bit_set(*(((unsigned int8 *)(&y))+4),7); 
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl_64[0]*y2 + pl_64[1]; 
....................       res = res*y2 + pl_64[2]; 
....................       res = res*y2 + pl_64[3]; 
....................  
....................       r = ql_64[0]*y2 + ql_64[1]; 
....................       r = r*y2 + ql_64[2]; 
....................       r = r*y2 + ql_64[3]; 
....................       r = r*y2 + 1.0;  
....................       res = y*res/r; 
....................  
....................       data1 = *(((unsigned int8 *)(&x)+5)); 
....................       rotate_left(&data1,1); 
....................       data2 = *(((unsigned int8 *)(&x)+4)); 
....................       if(bit_test (data2,7)) 
....................       bit_set(data1,0); 
....................        
....................       n = data1 - 0x7E; 
....................  
....................       if (n<0) 
....................       r = -(float48)-n; 
....................       else 
....................       r = (float48)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................    res = 0.0; 
....................  
....................    return(res); 
.................... } 
....................  
.................... float64 log(float64 x) 
.................... { 
....................    float64 y, res, r, y2; 
....................    unsigned int16  data1,data2; 
....................    unsigned int16 *p; 
....................    signed int16 n; 
....................    #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
....................    #if !defined(__PCD__) 
....................        *((unsigned int8 *)(&y)) = 0x7E;  
....................    #endif 
....................       p= (((unsigned int16 *)(&y))+3); 
....................       data1 = *p; 
....................       data2 = *p; 
....................       data1 = 0x3FE; 
....................       data1 = data1 <<4; 
....................       if(bit_test (data2,15)) 
....................          bit_set(data1,15); 
....................       data2 = data2 & 0x000F; 
....................       data1 ^=data2; 
....................  
....................       *p = data1; 
....................  
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl_64[0]*y2 + pl_64[1]; 
....................       res = res*y2 + pl_64[2]; 
....................       res = res*y2 + pl_64[3]; 
....................  
....................       r = ql_64[0]*y2 + ql_64[1]; 
....................       r = r*y2 + ql_64[2]; 
....................       r = r*y2 + ql_64[3]; 
....................       r = r*y2 + 1.0; 
....................  
....................       res = y*res/r; 
....................   
....................       p= (((unsigned int16 *)(&x))+3); 
....................       data1 = *p; 
....................       bit_clear(data1,15); 
....................       data1 = data1 >>4;     
....................       n = data1 - 0x3FE; 
....................  
....................  
....................       if (n<0) 
....................          r = -(float64)-n; 
....................       else 
....................          r = (float64)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................       res = 0.0; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
....................  
.................... #define LN10 2.3025850929940456 
.................... #define LN10_INV 0.4342944819032518276 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float log10(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the the log base 10 of x 
.................... // Date : N/A 
.................... // 
.................... float32 log10(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = log(x); 
....................    r = r*LN10_INV; 
....................    return(r); 
.................... } 
....................  
.................... //Overloaded functions for log10() for PCD 
.................... // Overloaded function log10() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 log10(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = log(x); 
....................    r = r*LN10_INV; 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function log10() for data type - Float64 
.................... float64 log10(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = log(x); 
....................    r = r*LN10_INV; 
....................    return(r); 
.................... } 
.................... #endif 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float modf(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description :breaks the argument value int integral and fractional parts, 
.................... // ach of which have the same sign as the argument.  It stores the integral part 
.................... // as a float in the object pointed to by the iptr 
.................... // Returns : returns the signed fractional part of value. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 modf(float32 value,float32 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... //Overloaded functions for modf() for PCD 
.................... // Overloaded function modf() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 modf(float48 value,float48 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... // Overloaded function modf() for data type - Float64 
.................... float64 modf(float64 value,float64 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float pwr(float x,float y) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (x^y) 
.................... // Date : N/A 
.................... // Note : 0 is returned when the function will generate an imaginary number 
.................... // 
.................... float32 pwr(float32 x,float32 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... //Overloaded functions for pwr() for PCD 
.................... // Overloaded function pwr() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 pwr(float48 x,float48 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... // Overloaded function pwr() for data type - Float64 
.................... float64 pwr(float64 x,float64 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////// Power functions //////////////////// 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float pow(float x,float y) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (x^y) 
.................... // Date : N/A 
.................... // Note : 0 is returned when the function will generate an imaginary number 
.................... // 
.................... float32 pow(float32 x,float32 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... //Overloaded functions for pow() for PCD 
.................... // Overloaded function for pow() data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 pow(float48 x,float48 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
....................  
.................... // Overloaded function pow() for data type - Float64 
.................... float64 pow(float64 x,float64 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sqrt(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the square root of x 
.................... // Date : N/A 
.................... // 
.................... float32 sqrt(float32 x) 
.................... { 
....................    float32 y, res; 
....................    #if defined(__PCD__) 
....................    unsigned int16 data1,data2; 
....................    #endif 
....................    unsigned int8 *p; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................     
....................    #if !defined(__PCD__) 
....................     p=&y; 
....................    (*p)=(unsigned int8)((((unsigned int16)(*p)) + 127) >> 1); 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     p = (((unsigned int8 *)(&y))+3); 
....................     data1 = *(((unsigned int8 *)(&y))+3); 
....................     data2 = *(((unsigned int8 *)(&y))+2); 
....................     rotate_left(&data1,1);     
....................     if(bit_test(data2,7))     
....................        bit_set(data1,0);     
....................     data1 = ((data1+127) >>1); 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+3) = data1; 
....................     *(((unsigned int8 *)(&y))+2) = data2; 
....................      
....................   #endif 
....................  
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................  
....................       #if !defined(__PCD__) 
....................      (*p)--; 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     data1 = *(((unsigned int8 *)(&y))+3); 
....................     data2 = *(((unsigned int8 *)(&y))+2); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................        bit_set(data1,0);     
....................     data1--; 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+3) = data1; 
....................     *(((unsigned int8 *)(&y))+2) = data2; 
....................      
....................   #endif 
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
.................... //Overloaded functions for sqrt() for PCD 
.................... // Overloaded function sqrt() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sqrt(float48 x) 
.................... { 
....................    float48 y, res; 
....................    unsigned int16 data1,data2; 
....................    unsigned int8 *p; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................     
....................    #if !defined(__PCD__) 
....................     p=&y; 
....................    (*p)=(unsigned int8)((((unsigned int16)(*p)) + 127) >> 1); 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     p = (((unsigned int8 *)(&y))+5); 
....................     data1 = *(((unsigned int8 *)(&y))+5); 
....................     data2 = *(((unsigned int8 *)(&y))+4); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................        bit_set(data1,0);     
....................     data1 = ((data1+127) >>1); 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+5) = data1; 
....................     *(((unsigned int8 *)(&y))+4) = data2; 
....................      
....................   #endif 
....................  
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................  
....................       #if !defined(__PCD__) 
....................      (*p)--; 
....................    #endif 
....................     
....................     data1 = *(((unsigned int8 *)(&y))+5); 
....................     data2 = *(((unsigned int8 *)(&y))+4); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................        bit_set(data1,0);     
....................     data1--; 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+5) = data1; 
....................     *(((unsigned int8 *)(&y))+4) = data2; 
....................      
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function sqrt() for data type - Float64 
.................... float64 sqrt(float64 x) 
.................... { 
....................    float64 y, res; 
....................    unsigned int16 *p; 
....................    unsigned int16 temp1,temp2; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................    p= (((unsigned int16 *)(&y))+3); 
....................    temp1 = *p; 
....................    temp2 = *p; 
....................    bit_clear(temp1,15); 
....................    temp1 = (temp1>>4)+1023; 
....................    temp1 = temp1 >> 1; 
....................    temp1 = (temp1<<4) & 0xFFF0; 
....................    if(bit_test(temp2,15)) 
....................       bit_set(temp1,15); 
....................    temp2 = temp2 & 0x000F; 
....................    temp1 ^= temp2; 
....................     
....................    (*p) = temp1; 
....................     
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................      temp1 = *p; 
....................      temp2 = *p; 
....................      bit_clear(temp1,15); 
....................      temp1 = (temp1>>4); 
....................      temp1--; 
....................      temp1 = (temp1<<4) & 0xFFF0; 
....................      if(bit_test(temp2,15)) 
....................         bit_set(temp1,15); 
....................      temp2 = temp2 & 0x000F; 
....................      temp1 ^= temp2; 
....................      (*p) = temp1; 
....................  
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... ////////////////////////////// Trig Functions ////////////////////////////// 
.................... #ifdef PI_DIV_BY_TWO_INV 
.................... #undef PI_DIV_BY_TWO_INV 
.................... #endif 
.................... #define PI_DIV_BY_TWO_INV 0.63661977236758134 
.................... #ifdef PI_DIV_BY_TWO 
.................... #undef PI_DIV_BY_TWO 
.................... #endif 
.................... #define PI_DIV_BY_TWO   1.5707963267948966 
.................... #ifdef TWOBYPI 
.................... #undef TWOBYPI 
.................... #endif 
.................... #define TWOBYPI          0.6366197723675813 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float cos(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the cosine value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 cos(float32 x) 
.................... { 
....................    float32 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float32 frac; 
....................    float32 p[5] = {                    //by the series definition for cosine 
....................       -0.49999999456337096,            // sum ( ( (-1)^n * x^2n )/(2n)! ) 
....................        0.04166663896921267, 
....................       -0.00138883894522527, 
....................        0.00002476138231734, 
....................       -0.00000026070414770 
....................       //-0.00000000001147, 
....................       // 0.00000000000005 
....................    }; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant 
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 1.0; 
....................    t = t * t; 
....................    for (i = 0; i <= 4; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
....................  
.................... //Overloaded functions for cos() for PCD 
.................... // Overloaded function cos() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 cos(float48 x) 
.................... { 
....................    float48 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float48 frac; 
....................    float48 p[6] = {                    //by the series definition for cosine 
....................       -0.5,                            // sum ( ( (-1)^n * x^2n )/(2n)! ) 
....................        0.04166666666667, 
....................       -0.00138888888889, 
....................        0.00002480158730, 
....................       -0.00000027557319, 
....................        0.00000000208767, 
....................       //-0.00000000001147, 
....................       // 0.00000000000005 
....................    }; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant 
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 0.999999999781; 
....................    t = t * t; 
....................    for (i = 0; i <= 5; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
.................... // Overloaded function cos() for data type - Float64 
.................... float64 cos(float64 x) 
.................... { 
....................    float64 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float64 frac; 
....................    float64 p_64[9] = {               //by the series definition for cosine 
....................      -0.49999999999998740,           // sum ( ( (-1)^n * x^2n )/(2n)! )              
....................       0.04166666666656518, 
....................      -0.00138888888851691, 
....................       0.00002480158658490, 
....................      -0.00000027557239796, 
....................       0.00000000208715031, 
....................      -0.00000000001126577, 
....................       0.00000000000000427, 
....................       0.00000000000000372}; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant 
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 1.0; 
....................    t = t * t; 
....................    for (i = 0; i <= 8; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p_64[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sin(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the sine value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 sin(float32 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
....................  
.................... //Overloaded functions for sin() for PCD 
.................... // Overloaded function sin() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sin(float48 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
....................  
.................... // Overloaded function sin() for data type - Float48 
.................... float64 sin(float64 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float tan(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the tangent value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 tan(float32 x) 
.................... { 
....................    float32 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
.................... //Overloaded functions for tan() for PCD 
.................... // Overloaded function tan() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 tan(float48 x) 
.................... { 
....................    float48 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
....................  
.................... // Overloaded function tan() for data type - Float48 
.................... float64 tan(float64 x) 
.................... { 
....................    float64 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
.................... #endif 
....................  
.................... float32 const pas[3] = {0.49559947, -4.6145309, 5.6036290}; 
.................... float32 const qas[3] = {1.0000000,  -5.5484666, 5.6036290}; 
....................  
.................... float32 ASIN_COS(float32 x, unsigned int8 n) 
.................... { 
....................    float32 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)*0.5); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas[0]*y2 + pas[1]; 
....................    res = res*y2 + pas[2]; 
....................  
....................    r = qas[0]*y2 + qas[1]; 
....................    r = r*y2 + qas[2]; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
....................  
....................  
.................... //Overloaded functions for ASIN_COS() for PCD 
.................... // Overloaded function ASIN_COS() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 ASIN_COS(float48 x, unsigned int8 n) 
.................... { 
....................    float48 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)*0.5); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas[0]*y2 + pas[1]; 
....................    res = res*y2 + pas[2]; 
....................  
....................    r = qas[0]*y2 + qas[1]; 
....................    r = r*y2 + qas[2]; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function ASIN_COS() for data type - Float64 
.................... double pas_64[5]={1.000000000000000,-2.069938587724477,1.421444580548907, 
....................                  -0.360690137621842,0.024929451660228}; 
....................  
.................... double qas_64[5]={-2.236605254391134,1.719212122946451,-0.524122954476133, 
....................                    0.052808872045749,-0.000662536036570}; 
....................                     
.................... float64 ASIN_COS(float64 x, unsigned int8 n) 
.................... { 
....................    float64 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)*0.5); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas_64[4]*y2 + pas_64[3]; 
....................    res = res*y2 + pas_64[2]; 
....................    res = res*y2 + pas_64[1]; 
....................    res = res*y2 + pas_64[0]; 
....................  
....................    r = qas_64[4]*y2 + qas_64[3]; 
....................    r = r*y2 + qas_64[2]; 
....................    r = r*y2 + qas_64[1]; 
....................    r = r*y2 + qas_64[0]; 
....................    r = r*y2 + 1.0; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float asin(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arcsine value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 asin(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
.................... //Overloaded functions for asin() for PCD 
.................... // Overloaded function asin() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 asin(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function asin() for data type - Float64 
.................... float64 asin(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float acos(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arccosine value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 acos(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
.................... //Overloaded functions for acos() for PCD 
.................... // Overloaded function acos() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 acos(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function acos() for data type - Float64 
.................... float64 acos(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
.................... #endif 
....................  
.................... float32 const pat[4] = {0.17630401, 5.6710795, 22.376096, 19.818457}; 
.................... float32 const qat[4] = {1.0000000,  11.368190, 28.982246, 19.818457}; 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float atan(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arctangent value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 atan(float32 x) 
.................... { 
....................    float32 y, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................  
....................    res = pat[0]*y*y + pat[1]; 
....................    res = res*y*y + pat[2]; 
....................    res = res*y*y + pat[3]; 
....................  
....................    r = qat[0]*y*y + qat[1]; 
....................    r = r*y*y + qat[2]; 
....................    r = r*y*y + qat[3]; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
.................... //Overloaded functions for atan() for PCD 
.................... // Overloaded function atan() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 atan(float48 x) 
.................... { 
....................    float48 y, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................  
....................    res = pat[0]*y*y + pat[1]; 
....................    res = res*y*y + pat[2]; 
....................    res = res*y*y + pat[3]; 
....................  
....................    r = qat[0]*y*y + qat[1]; 
....................    r = r*y*y + qat[2]; 
....................    r = r*y*y + qat[3]; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
....................  
.................... float64 pat_64[6]={0.999999999999999,2.249923645595566,1.771541617806449, 
....................                    0.579678874003185,0.072162702162882,0.002281100141660}; 
....................  
.................... float64 qat_64[6]={2.583256978928510,2.432627277466967,1.016760379885393, 
....................                    0.182482977188688,0.011155377971690,0.000100013019160}; 
.................... // Overloaded function atan() for data type - Float64 
.................... float64 atan(float64 x) 
.................... { 
....................    float64 y,y2, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................    y2 = y*y; 
....................    res = pat_64[5]*y2 + pat_64[4]; 
....................    res = res*y2 + pat_64[3]; 
....................    res = res*y2 + pat_64[2]; 
....................    res = res*y2 + pat_64[1]; 
....................    res = res*y2 + pat_64[0]; 
....................  
....................    r = qat_64[5]*y2 + qat_64[4]; 
....................    r = r*y2 + qat_64[3]; 
....................    r = r*y2 + qat_64[2]; 
....................    r = r*y2 + qat_64[1]; 
....................    r = r*y2 + qat_64[0]; 
....................    r = r*y2 + 1.0; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... ///////////////////////////////////////////////////////////////////////////// 
.................... //   float atan2(float y, float x) 
.................... ///////////////////////////////////////////////////////////////////////////// 
.................... // Description :computes the principal value of arc tangent of y/x, using the 
.................... // signs of both the arguments to determine the quadrant of the return value 
.................... // Returns : returns the arc tangent of y/x. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 atan2(float32 y,float32 x) 
.................... { 
....................    float32 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
....................  
.................... //Overloaded functions for atan2() for PCD 
.................... // Overloaded function atan2() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 atan2(float48 y,float48 x) 
.................... { 
....................    float48 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
....................  
.................... // Overloaded function atan2() for data type - Float64 
.................... float64 atan2(float64 y,float64 x) 
.................... { 
....................    float64 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////// Hyperbolic functions //////////////////// 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float cosh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic cosine value of x 
.................... // Returns : returns the hyperbolic cosine value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 cosh(float32 x) 
.................... { 
....................    return ((exp(x)+exp(-x))*0.5); 
.................... } 
.................... //Overloaded functions for cosh() for PCD 
.................... // Overloaded function cosh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 cosh(float48 x) 
.................... { 
....................    return ((exp(x)+exp(-x))*0.5); 
.................... } 
....................  
.................... // Overloaded function cosh() for data type - Float64 
.................... float64 cosh(float64 x) 
.................... { 
....................    return ((exp(x)+exp(-x))*0.5); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sinh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic sine value of x 
.................... // Returns : returns the hyperbolic sine value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 sinh(float32 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))*0.5); 
.................... } 
.................... //Overloaded functions for sinh() for PCD 
.................... // Overloaded function sinh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sinh(float48 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))*0.5); 
.................... } 
....................  
.................... // Overloaded function sinh() for data type - Float48 
.................... float64 sinh(float64 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))*0.5); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float tanh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic tangent value of x 
.................... // Returns : returns the hyperbolic tangent value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 tanh(float32 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
.................... //Overloaded functions for tanh() for PCD 
.................... // Overloaded function tanh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 tanh(float48 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
....................  
.................... // Overloaded function tanh() for data type - Float64 
.................... float64 tanh(float64 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float frexp(float x, signed int *exp) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : breaks a floating point number into a normalized fraction and an integral 
.................... // power of 2. It stores the integer in the signed int object pointed to by exp. 
.................... // Returns : returns the value x, such that x is a double with magnitude in the interval 
.................... // [1/2,1) or zero, and value equals x times 2 raised to the power *exp.If value is zero, 
.................... // both parts of the result are zero. 
.................... // Date : N/A 
.................... // 
....................  
.................... #define LOG2 .30102999566398119521 
.................... #define LOG2_INV 3.32192809488736234787 
.................... float32 frexp(float32 x, signed int8 *exp) 
.................... { 
....................    float32 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)*LOG2_INV)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
....................  
.................... //Overloaded functions for frexp() for PCD 
.................... // Overloaded function frexp() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 frexp(float48 x, signed int8 *exp) 
.................... { 
....................    float48 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)*LOG2_INV)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
....................  
.................... // Overloaded function frexp() for data type - Float64 
.................... float64 frexp(float64 x, signed int8 *exp) 
.................... { 
....................    float64 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)*LOG2_INV)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
.................... #endif 
....................  
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... //   float ldexp(float x, signed int *exp) 
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... // Description : multiplies a floating point number by an integral power of 2. 
.................... // Returns : returns the value of x times 2 raised to the power exp. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 ldexp(float32 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... //Overloaded functions for ldexp() for PCD 
.................... // Overloaded function ldexp() for data type - Float48 
....................  
.................... #if defined(__PCD__) 
.................... float48 ldexp(float48 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... // Overloaded function ldexp() for data type - Float64 
.................... float64 ldexp(float64 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... #endif 
....................  
.................... #endif 
....................  
.................... #INCLUDE <xuatbyte74595.c> 
....................  
.................... #DEFINE      DS               PIN_D1 
.................... #DEFINE      SH_CP            PIN_D0   
.................... #DEFINE      STCP             PIN_D2 
.................... VOID XUATTRANGTHAI(UNSIGNED INT8 BYTEXUAT) 
.................... { 
....................    UNSIGNED INT8   SB;    
....................    #BIT BSERI  = BYTEXUAT.7 
....................     
....................    FOR (SB=0;SB<8;SB++) 
*
0B97:  CLRF   1A
0B98:  MOVF   1A,W
0B99:  SUBLW  07
0B9A:  BTFSS  03.0
0B9B:  GOTO   3B2
....................       {                                                  
....................          OUTPUT_BIT(DS,BSERI);     
0B9C:  BTFSC  19.7
0B9D:  GOTO   3A2
0B9E:  BCF    03.6
0B9F:  BCF    08.1
0BA0:  GOTO   3A4
0BA1:  BSF    03.6
0BA2:  BCF    03.6
0BA3:  BSF    08.1
0BA4:  BSF    03.5
0BA5:  BCF    08.1
....................          OUTPUT_LOW(SH_CP); OUTPUT_HIGH(SH_CP); 
0BA6:  BCF    08.0
0BA7:  BCF    03.5
0BA8:  BCF    08.0
0BA9:  BSF    03.5
0BAA:  BCF    08.0
0BAB:  BCF    03.5
0BAC:  BSF    08.0
....................          BYTEXUAT=BYTEXUAT<<1; //10010010->00100100   
0BAD:  BCF    03.0
0BAE:  BSF    03.6
0BAF:  RLF    19,F
0BB0:  INCF   1A,F
0BB1:  GOTO   398
....................      } 
....................       OUTPUT_LOW(STCP); OUTPUT_HIGH(STCP); 
0BB2:  BSF    03.5
0BB3:  BCF    03.6
0BB4:  BCF    08.2
0BB5:  BCF    03.5
0BB6:  BCF    08.2
0BB7:  BSF    03.5
0BB8:  BCF    08.2
0BB9:  BCF    03.5
0BBA:  BSF    08.2
.................... } 
....................  
....................  
.................... #FUSES NOWDT, PUT, HS 
.................... #USE DELAY(CLOCK=20M) 
*
015B:  MOVLW  41
015C:  MOVWF  04
015D:  BSF    03.7
015E:  MOVF   00,W
015F:  BTFSC  03.2
0160:  GOTO   16E
0161:  MOVLW  06
0162:  MOVWF  78
0163:  CLRF   77
0164:  DECFSZ 77,F
0165:  GOTO   164
0166:  DECFSZ 78,F
0167:  GOTO   163
0168:  MOVLW  7B
0169:  MOVWF  77
016A:  DECFSZ 77,F
016B:  GOTO   16A
016C:  DECFSZ 00,F
016D:  GOTO   161
016E:  RETURN
.................... #USE RS232(BAUD=9600,XMIT=PIN_C6,RCV=PIN_C7) 
.................... #DEFINE BT1_PIN PIN_B1 
.................... #DEFINE BT2_PIN PIN_B2 
.................... #DEFINE BT3_PIN PIN_B3 
.................... #DEFINE LCD_ENABLE_PIN  PIN_E0                                    
.................... #DEFINE LCD_RS_PIN      PIN_E1                                 
.................... #DEFINE LCD_RW_PIN      PIN_E2   
.................... #DEFINE LCD_DATA4       PIN_C0                                
.................... #DEFINE LCD_DATA5       PIN_C1                                  
.................... #DEFINE LCD_DATA6       PIN_C2                                    
.................... #DEFINE LCD_DATA7       PIN_C3   
.................... #INCLUDE <LCD.C> 
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... ////                             LCD.C                                     //// 
.................... ////                 Driver for common LCD modules                         //// 
.................... ////                                                                       //// 
.................... ////  lcd_init()   Must be called before any other function.               //// 
.................... ////                                                                       //// 
.................... ////  lcd_putc(c)  Will display c on the next position of the LCD.         //// 
.................... ////                 \a  Set cursor position to upper left                 //// 
.................... ////                 \f  Clear display, set cursor to upper left           //// 
.................... ////                 \n  Go to start of second line                        //// 
.................... ////                 \b  Move back one position                            //// 
.................... ////              If LCD_EXTENDED_NEWLINE is defined, the \n character     //// 
.................... ////              will erase all remanining characters on the current      //// 
.................... ////              line, and move the cursor to the beginning of the next   //// 
.................... ////              line.                                                    //// 
.................... ////              If LCD_EXTENDED_NEWLINE is defined, the \r character     //// 
.................... ////              will move the cursor to the start of the current         //// 
.................... ////              line.                                                    //// 
.................... ////                                                                       //// 
.................... ////  lcd_gotoxy(x,y) Set write position on LCD (upper left is 1,1)        //// 
.................... ////                                                                       //// 
.................... ////  lcd_getc(x,y)   Returns character at position x,y on LCD             //// 
.................... ////                                                                       //// 
.................... ////  lcd_cursor_on(int1 on)   Turn the cursor on (on=TRUE) or off         //// 
.................... ////              (on=FALSE).                                              //// 
.................... ////                                                                       //// 
.................... ////  lcd_set_cgram_char(w, *p)   Write a custom character to the CGRAM.   //// 
.................... ////                                                                       //// 
.................... ////                                                                       //// 
.................... ////  CONFIGURATION                                                        //// 
.................... ////  The LCD can be configured in one of two ways: a.) port access or     //// 
.................... ////  b.) pin access.  Port access requires the entire 7 bit interface     //// 
.................... ////  connected to one GPIO port, and the data bits (D4:D7 of the LCD)     //// 
.................... ////  connected to sequential pins on the GPIO.  Pin access                //// 
.................... ////  has no requirements, all 7 bits of the control interface can         //// 
.................... ////  can be connected to any GPIO using several ports.                    //// 
.................... ////                                                                       //// 
.................... ////  To use port access, #define LCD_DATA_PORT to the SFR location of     //// 
.................... ////  of the GPIO port that holds the interface, -AND- edit LCD_PIN_MAP    //// 
.................... ////  of this file to configure the pin order.  If you are using a         //// 
.................... ////  baseline PIC (PCB), then LCD_OUTPUT_MAP and LCD_INPUT_MAP also must  //// 
.................... ////  be defined.                                                          //// 
.................... ////                                                                       //// 
.................... ////  Example of port access:                                              //// 
.................... ////     #define LCD_DATA_PORT getenv("SFR:PORTD")                         //// 
.................... ////                                                                       //// 
.................... ////  To use pin access, the following pins must be defined:               //// 
.................... ////     LCD_ENABLE_PIN                                                    //// 
.................... ////     LCD_RS_PIN                                                        //// 
.................... ////     LCD_RW_PIN                                                        //// 
.................... ////     LCD_DATA4                                                         //// 
.................... ////     LCD_DATA5                                                         //// 
.................... ////     LCD_DATA6                                                         //// 
.................... ////     LCD_DATA7                                                         //// 
.................... ////                                                                       //// 
.................... ////  Example of pin access:                                               //// 
.................... ////     #define LCD_ENABLE_PIN  PIN_E0                                    //// 
.................... ////     #define LCD_RS_PIN      PIN_E1                                    //// 
.................... ////     #define LCD_RW_PIN      PIN_E2                                    //// 
.................... ////     #define LCD_DATA4       PIN_D4                                    //// 
.................... ////     #define LCD_DATA5       PIN_D5                                    //// 
.................... ////     #define LCD_DATA6       PIN_D6                                    //// 
.................... ////     #define LCD_DATA7       PIN_D7                                    //// 
.................... ////                                                                       //// 
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2010 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef __LCD_C__ 
.................... #define __LCD_C__ 
....................  
.................... // define the pinout. 
.................... // only required if port access is being used. 
.................... typedef struct   
.................... {                            // This structure is overlayed 
....................    int1 enable;           // on to an I/O port to gain 
....................    int1 rs;               // access to the LCD pins. 
....................    int1 rw;               // The bits are allocated from 
....................    int1 unused;           // low order up.  ENABLE will 
....................    unsigned int     data : 4;         // be LSB pin of that port. 
....................   #if defined(__PCD__)       // The port used will be LCD_DATA_PORT. 
....................    unsigned int    reserved: 8; 
....................   #endif 
.................... } LCD_PIN_MAP; 
....................  
.................... // this is to improve compatability with previous LCD drivers that accepted 
.................... // a define labeled 'use_portb_lcd' that configured the LCD onto port B. 
.................... #if ((defined(use_portb_lcd)) && (use_portb_lcd==TRUE)) 
....................  #define LCD_DATA_PORT getenv("SFR:PORTB") 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
....................    // these definitions only need to be modified for baseline PICs. 
....................    // all other PICs use LCD_PIN_MAP or individual LCD_xxx pin definitions. 
.................... /*                                    EN, RS,   RW,   UNUSED,  DATA  */ 
....................  const LCD_PIN_MAP LCD_OUTPUT_MAP =  {0,  0,    0,    0,       0}; 
....................  const LCD_PIN_MAP LCD_INPUT_MAP =   {0,  0,    0,    0,       0xF}; 
.................... #endif 
....................  
.................... ////////////////////// END CONFIGURATION /////////////////////////////////// 
....................  
.................... #ifndef LCD_ENABLE_PIN 
....................    #define lcd_output_enable(x) lcdlat.enable=x 
....................    #define lcd_enable_tris()   lcdtris.enable=0 
.................... #else 
....................    #define lcd_output_enable(x) output_bit(LCD_ENABLE_PIN, x) 
....................    #define lcd_enable_tris()  output_drive(LCD_ENABLE_PIN) 
.................... #endif 
....................  
.................... #ifndef LCD_RS_PIN 
....................    #define lcd_output_rs(x) lcdlat.rs=x 
....................    #define lcd_rs_tris()   lcdtris.rs=0 
.................... #else 
....................    #define lcd_output_rs(x) output_bit(LCD_RS_PIN, x) 
....................    #define lcd_rs_tris()  output_drive(LCD_RS_PIN) 
.................... #endif 
....................  
.................... #ifndef LCD_RW_PIN 
....................    #define lcd_output_rw(x) lcdlat.rw=x 
....................    #define lcd_rw_tris()   lcdtris.rw=0 
.................... #else 
....................    #define lcd_output_rw(x) output_bit(LCD_RW_PIN, x) 
....................    #define lcd_rw_tris()  output_drive(LCD_RW_PIN) 
.................... #endif 
....................  
.................... // original version of this library incorrectly labeled LCD_DATA0 as LCD_DATA4, 
.................... // LCD_DATA1 as LCD_DATA5, and so on.  this block of code makes the driver 
.................... // compatible with any code written for the original library 
.................... #if (defined(LCD_DATA0) && defined(LCD_DATA1) && defined(LCD_DATA2) && defined(LCD_DATA3) && !defined(LCD_DATA4) && !defined(LCD_DATA5) && !defined(LCD_DATA6) && !defined(LCD_DATA7)) 
....................    #define  LCD_DATA4    LCD_DATA0 
....................    #define  LCD_DATA5    LCD_DATA1 
....................    #define  LCD_DATA6    LCD_DATA2 
....................    #define  LCD_DATA7    LCD_DATA3 
.................... #endif 
....................  
.................... #ifndef LCD_DATA4 
.................... #ifndef LCD_DATA_PORT 
....................    #if defined(__PCB__) 
....................       #define LCD_DATA_PORT      0x06     //portb 
....................       #define set_tris_lcd(x)   set_tris_b(x) 
....................    #else 
....................      #if defined(PIN_D0) 
....................       #define LCD_DATA_PORT      getenv("SFR:PORTD")     //portd 
....................      #else 
....................       #define LCD_DATA_PORT      getenv("SFR:PORTB")     //portb 
....................      #endif 
....................    #endif    
.................... #endif 
....................  
.................... #if defined(__PCB__) 
....................    LCD_PIN_MAP lcd, lcdlat; 
....................    #byte lcd = LCD_DATA_PORT 
....................    #byte lcdlat = LCD_DATA_PORT 
.................... #elif defined(__PCM__) 
....................    LCD_PIN_MAP lcd, lcdlat, lcdtris; 
....................    #byte lcd = LCD_DATA_PORT 
....................    #byte lcdlat = LCD_DATA_PORT 
....................    #byte lcdtris = LCD_DATA_PORT+0x80 
.................... #elif defined(__PCH__) 
....................    LCD_PIN_MAP lcd, lcdlat, lcdtris; 
....................    #byte lcd = LCD_DATA_PORT 
....................    #byte lcdlat = LCD_DATA_PORT+9 
....................    #byte lcdtris = LCD_DATA_PORT+0x12 
.................... #elif defined(__PCD__) 
....................    LCD_PIN_MAP lcd, lcdlat, lcdtris; 
....................    #word lcd = LCD_DATA_PORT 
....................    #word lcdlat = LCD_DATA_PORT+2 
....................    #word lcdtris = LCD_DATA_PORT-0x02 
.................... #endif 
.................... #endif   //LCD_DATA4 not defined 
....................  
.................... #ifndef LCD_TYPE 
....................    #define LCD_TYPE 2           // 0=5x7, 1=5x10, 2=2 lines 
.................... #endif 
....................  
.................... #ifndef LCD_LINE_TWO 
....................    #define LCD_LINE_TWO 0x40    // LCD RAM address for the second line 
.................... #endif 
....................  
.................... #ifndef LCD_LINE_LENGTH 
....................    #define LCD_LINE_LENGTH 20 
.................... #endif 
....................  
.................... unsigned int8 lcd_read_nibble(void); 
....................  
.................... unsigned int8 lcd_read_byte(void) 
.................... { 
....................    unsigned int8 low,high; 
....................  
....................  #if defined(__PCB__) 
....................    set_tris_lcd(LCD_INPUT_MAP); 
....................  #else 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    output_float(LCD_DATA4); 
*
0202:  BSF    07.0
....................    output_float(LCD_DATA5); 
0203:  BSF    07.1
....................    output_float(LCD_DATA6); 
0204:  BSF    07.2
....................    output_float(LCD_DATA7); 
0205:  BSF    07.3
....................   #else 
....................    lcdtris.data = 0xF; 
....................   #endif 
....................  #endif 
....................          
....................    lcd_output_rw(1); 
0206:  BCF    03.5
0207:  BSF    09.2
0208:  BSF    03.5
0209:  BCF    09.2
....................    delay_cycles(1); 
020A:  NOP
....................    lcd_output_enable(1); 
020B:  BCF    03.5
020C:  BSF    09.0
020D:  BSF    03.5
020E:  BCF    09.0
....................    delay_cycles(1); 
020F:  NOP
....................    high = lcd_read_nibble(); 
0210:  BCF    03.5
0211:  CALL   1B7
0212:  MOVF   78,W
0213:  BSF    03.6
0214:  MOVWF  48
....................        
....................    lcd_output_enable(0); 
0215:  BCF    03.6
0216:  BCF    09.0
0217:  BSF    03.5
0218:  BCF    09.0
....................    delay_cycles(1); 
0219:  NOP
....................    lcd_output_enable(1); 
021A:  BCF    03.5
021B:  BSF    09.0
021C:  BSF    03.5
021D:  BCF    09.0
....................    delay_us(1); 
021E:  GOTO   21F
021F:  GOTO   220
0220:  NOP
....................    low = lcd_read_nibble(); 
0221:  BCF    03.5
0222:  CALL   1B7
0223:  MOVF   78,W
0224:  BSF    03.6
0225:  MOVWF  47
....................        
....................    lcd_output_enable(0); 
0226:  BCF    03.6
0227:  BCF    09.0
0228:  BSF    03.5
0229:  BCF    09.0
....................  
....................  #if defined(__PCB__) 
....................    set_tris_lcd(LCD_OUTPUT_MAP); 
....................  #else 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    output_drive(LCD_DATA4); 
022A:  BCF    03.5
022B:  BCF    31.0
022C:  MOVF   31,W
022D:  BSF    03.5
022E:  MOVWF  07
....................    output_drive(LCD_DATA5); 
022F:  BCF    03.5
0230:  BCF    31.1
0231:  MOVF   31,W
0232:  BSF    03.5
0233:  MOVWF  07
....................    output_drive(LCD_DATA6); 
0234:  BCF    03.5
0235:  BCF    31.2
0236:  MOVF   31,W
0237:  BSF    03.5
0238:  MOVWF  07
....................    output_drive(LCD_DATA7); 
0239:  BCF    03.5
023A:  BCF    31.3
023B:  MOVF   31,W
023C:  BSF    03.5
023D:  MOVWF  07
....................   #else 
....................    lcdtris.data = 0x0; 
....................   #endif 
....................  #endif 
....................  
....................    return( (high<<4) | low); 
023E:  BCF    03.5
023F:  BSF    03.6
0240:  SWAPF  48,W
0241:  MOVWF  77
0242:  MOVLW  F0
0243:  ANDWF  77,F
0244:  MOVF   77,W
0245:  IORWF  47,W
0246:  MOVWF  78
.................... } 
....................  
.................... unsigned int8 lcd_read_nibble(void) 
.................... { 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
*
01B7:  BSF    03.6
01B8:  CLRF   49
....................    unsigned int8 n = 0x00; 
....................  
....................    /* Read the data port */ 
....................    n |= input(LCD_DATA4); 
01B9:  BCF    03.6
01BA:  BSF    31.0
01BB:  MOVF   31,W
01BC:  BSF    03.5
01BD:  MOVWF  07
01BE:  MOVLW  00
01BF:  BCF    03.5
01C0:  BTFSC  07.0
01C1:  MOVLW  01
01C2:  BSF    03.6
01C3:  IORWF  49,F
....................    n |= input(LCD_DATA5) << 1; 
01C4:  BCF    03.6
01C5:  BSF    31.1
01C6:  MOVF   31,W
01C7:  BSF    03.5
01C8:  MOVWF  07
01C9:  MOVLW  00
01CA:  BCF    03.5
01CB:  BTFSC  07.1
01CC:  MOVLW  01
01CD:  MOVWF  77
01CE:  BCF    03.0
01CF:  RLF    77,F
01D0:  MOVF   77,W
01D1:  BSF    03.6
01D2:  IORWF  49,F
....................    n |= input(LCD_DATA6) << 2; 
01D3:  BCF    03.6
01D4:  BSF    31.2
01D5:  MOVF   31,W
01D6:  BSF    03.5
01D7:  MOVWF  07
01D8:  MOVLW  00
01D9:  BCF    03.5
01DA:  BTFSC  07.2
01DB:  MOVLW  01
01DC:  MOVWF  77
01DD:  RLF    77,F
01DE:  RLF    77,F
01DF:  MOVLW  FC
01E0:  ANDWF  77,F
01E1:  MOVF   77,W
01E2:  BSF    03.6
01E3:  IORWF  49,F
....................    n |= input(LCD_DATA7) << 3; 
01E4:  BCF    03.6
01E5:  BSF    31.3
01E6:  MOVF   31,W
01E7:  BSF    03.5
01E8:  MOVWF  07
01E9:  MOVLW  00
01EA:  BCF    03.5
01EB:  BTFSC  07.3
01EC:  MOVLW  01
01ED:  MOVWF  77
01EE:  RLF    77,F
01EF:  RLF    77,F
01F0:  RLF    77,F
01F1:  MOVLW  F8
01F2:  ANDWF  77,F
01F3:  MOVF   77,W
01F4:  BSF    03.6
01F5:  IORWF  49,F
....................     
....................    return(n); 
01F6:  MOVF   49,W
01F7:  MOVWF  78
....................   #else 
01F8:  BCF    03.6
01F9:  RETURN
....................    return(lcd.data); 
....................   #endif 
.................... } 
....................  
.................... void lcd_send_nibble(unsigned int8 n) 
.................... { 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    /* Write to the data port */ 
....................    output_bit(LCD_DATA4, bit_test(n, 0)); 
*
016F:  BSF    03.6
0170:  BTFSC  48.0
0171:  GOTO   176
0172:  BCF    03.6
0173:  BCF    07.0
0174:  GOTO   178
0175:  BSF    03.6
0176:  BCF    03.6
0177:  BSF    07.0
0178:  BCF    31.0
0179:  MOVF   31,W
017A:  BSF    03.5
017B:  MOVWF  07
....................    output_bit(LCD_DATA5, bit_test(n, 1)); 
017C:  BCF    03.5
017D:  BSF    03.6
017E:  BTFSC  48.1
017F:  GOTO   184
0180:  BCF    03.6
0181:  BCF    07.1
0182:  GOTO   186
0183:  BSF    03.6
0184:  BCF    03.6
0185:  BSF    07.1
0186:  BCF    31.1
0187:  MOVF   31,W
0188:  BSF    03.5
0189:  MOVWF  07
....................    output_bit(LCD_DATA6, bit_test(n, 2)); 
018A:  BCF    03.5
018B:  BSF    03.6
018C:  BTFSC  48.2
018D:  GOTO   192
018E:  BCF    03.6
018F:  BCF    07.2
0190:  GOTO   194
0191:  BSF    03.6
0192:  BCF    03.6
0193:  BSF    07.2
0194:  BCF    31.2
0195:  MOVF   31,W
0196:  BSF    03.5
0197:  MOVWF  07
....................    output_bit(LCD_DATA7, bit_test(n, 3)); 
0198:  BCF    03.5
0199:  BSF    03.6
019A:  BTFSC  48.3
019B:  GOTO   1A0
019C:  BCF    03.6
019D:  BCF    07.3
019E:  GOTO   1A2
019F:  BSF    03.6
01A0:  BCF    03.6
01A1:  BSF    07.3
01A2:  BCF    31.3
01A3:  MOVF   31,W
01A4:  BSF    03.5
01A5:  MOVWF  07
....................   #else       
....................    lcdlat.data = n; 
....................   #endif 
....................        
....................    delay_cycles(1); 
01A6:  NOP
....................    lcd_output_enable(1); 
01A7:  BCF    03.5
01A8:  BSF    09.0
01A9:  BSF    03.5
01AA:  BCF    09.0
....................    delay_us(2); 
01AB:  MOVLW  02
01AC:  MOVWF  77
01AD:  DECFSZ 77,F
01AE:  GOTO   1AD
01AF:  GOTO   1B0
01B0:  NOP
....................    lcd_output_enable(0); 
01B1:  BCF    03.5
01B2:  BCF    09.0
01B3:  BSF    03.5
01B4:  BCF    09.0
01B5:  BCF    03.5
01B6:  RETURN
.................... } 
....................  
.................... void lcd_send_byte(unsigned int8 address, unsigned int8 n) 
.................... { 
....................   #if defined(__PCB__) 
....................    set_tris_lcd(LCD_OUTPUT_MAP); 
....................   #else 
....................    lcd_enable_tris(); 
*
01FA:  BSF    03.5
01FB:  BCF    09.0
....................    lcd_rs_tris(); 
01FC:  BCF    09.1
....................    lcd_rw_tris(); 
01FD:  BCF    09.2
....................   #endif 
....................  
....................    lcd_output_rs(0); 
01FE:  BCF    03.5
01FF:  BCF    09.1
0200:  BSF    03.5
0201:  BCF    09.1
....................    while ( bit_test(lcd_read_byte(),7) ) ; 
*
0247:  MOVF   78,W
0248:  MOVWF  47
0249:  BTFSS  47.7
024A:  GOTO   24E
024B:  BSF    03.5
024C:  BCF    03.6
024D:  GOTO   202
....................    lcd_output_rs(address); 
024E:  MOVF   45,F
024F:  BTFSS  03.2
0250:  GOTO   255
0251:  BCF    03.6
0252:  BCF    09.1
0253:  GOTO   257
0254:  BSF    03.6
0255:  BCF    03.6
0256:  BSF    09.1
0257:  BSF    03.5
0258:  BCF    09.1
....................    delay_cycles(1); 
0259:  NOP
....................    lcd_output_rw(0); 
025A:  BCF    03.5
025B:  BCF    09.2
025C:  BSF    03.5
025D:  BCF    09.2
....................    delay_cycles(1); 
025E:  NOP
....................    lcd_output_enable(0); 
025F:  BCF    03.5
0260:  BCF    09.0
0261:  BSF    03.5
0262:  BCF    09.0
....................    lcd_send_nibble(n >> 4); 
0263:  BCF    03.5
0264:  BSF    03.6
0265:  SWAPF  46,W
0266:  MOVWF  47
0267:  MOVLW  0F
0268:  ANDWF  47,F
0269:  MOVF   47,W
026A:  MOVWF  48
026B:  BCF    03.6
026C:  CALL   16F
....................    lcd_send_nibble(n & 0xf); 
026D:  BSF    03.6
026E:  MOVF   46,W
026F:  ANDLW  0F
0270:  MOVWF  47
0271:  MOVWF  48
0272:  BCF    03.6
0273:  CALL   16F
0274:  RETURN
.................... } 
....................  
.................... #if defined(LCD_EXTENDED_NEWLINE) 
.................... unsigned int8 g_LcdX, g_LcdY; 
.................... #endif 
....................  
.................... void lcd_init(void)  
.................... { 
....................    unsigned int8 i; 
....................    unsigned int8 LCD_INIT_STRING[4] = {0x20 | (LCD_TYPE << 2), 0xc, 1, 6}; 
0275:  MOVLW  28
0276:  BSF    03.6
0277:  MOVWF  11
0278:  MOVLW  0C
0279:  MOVWF  12
027A:  MOVLW  01
027B:  MOVWF  13
027C:  MOVLW  06
027D:  MOVWF  14
....................                              // These bytes need to be sent to the LCD 
....................                              // to start it up. 
....................     
....................  
....................    lcd_output_enable(0); 
027E:  BCF    03.6
027F:  BCF    09.0
0280:  BSF    03.5
0281:  BCF    09.0
....................    lcd_output_rs(0); 
0282:  BCF    03.5
0283:  BCF    09.1
0284:  BSF    03.5
0285:  BCF    09.1
....................    lcd_output_rw(0); 
0286:  BCF    03.5
0287:  BCF    09.2
0288:  BSF    03.5
0289:  BCF    09.2
....................  
....................  #if defined(__PCB__) 
....................    set_tris_lcd(LCD_OUTPUT_MAP); 
....................  #else 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    output_drive(LCD_DATA4); 
028A:  BCF    03.5
028B:  BCF    31.0
028C:  MOVF   31,W
028D:  BSF    03.5
028E:  MOVWF  07
....................    output_drive(LCD_DATA5); 
028F:  BCF    03.5
0290:  BCF    31.1
0291:  MOVF   31,W
0292:  BSF    03.5
0293:  MOVWF  07
....................    output_drive(LCD_DATA6); 
0294:  BCF    03.5
0295:  BCF    31.2
0296:  MOVF   31,W
0297:  BSF    03.5
0298:  MOVWF  07
....................    output_drive(LCD_DATA7); 
0299:  BCF    03.5
029A:  BCF    31.3
029B:  MOVF   31,W
029C:  BSF    03.5
029D:  MOVWF  07
....................   #else 
....................    lcdtris.data = 0x0; 
....................   #endif 
....................    lcd_enable_tris(); 
029E:  BCF    09.0
....................    lcd_rs_tris(); 
029F:  BCF    09.1
....................    lcd_rw_tris(); 
02A0:  BCF    09.2
....................  #endif 
....................      
....................    delay_ms(15); 
02A1:  MOVLW  0F
02A2:  BCF    03.5
02A3:  BSF    03.6
02A4:  MOVWF  41
02A5:  BCF    03.6
02A6:  CALL   15B
....................    for(i=1;i<=3;++i) 
02A7:  MOVLW  01
02A8:  BSF    03.6
02A9:  MOVWF  10
02AA:  MOVF   10,W
02AB:  SUBLW  03
02AC:  BTFSS  03.0
02AD:  GOTO   2BA
....................    { 
....................        lcd_send_nibble(3); 
02AE:  MOVLW  03
02AF:  MOVWF  48
02B0:  BCF    03.6
02B1:  CALL   16F
....................        delay_ms(5); 
02B2:  MOVLW  05
02B3:  BSF    03.6
02B4:  MOVWF  41
02B5:  BCF    03.6
02B6:  CALL   15B
02B7:  BSF    03.6
02B8:  INCF   10,F
02B9:  GOTO   2AA
....................    } 
....................     
....................    lcd_send_nibble(2); 
02BA:  MOVLW  02
02BB:  MOVWF  48
02BC:  BCF    03.6
02BD:  CALL   16F
....................    delay_ms(5); 
02BE:  MOVLW  05
02BF:  BSF    03.6
02C0:  MOVWF  41
02C1:  BCF    03.6
02C2:  CALL   15B
....................    for(i=0;i<=3;++i) 
02C3:  BSF    03.6
02C4:  CLRF   10
02C5:  MOVF   10,W
02C6:  SUBLW  03
02C7:  BTFSS  03.0
02C8:  GOTO   2D7
....................       lcd_send_byte(0,LCD_INIT_STRING[i]); 
02C9:  MOVLW  11
02CA:  ADDWF  10,W
02CB:  MOVWF  04
02CC:  BSF    03.7
02CD:  MOVF   00,W
02CE:  MOVWF  15
02CF:  CLRF   45
02D0:  MOVF   15,W
02D1:  MOVWF  46
02D2:  BCF    03.6
02D3:  CALL   1FA
....................  
....................   #if defined(LCD_EXTENDED_NEWLINE) 
02D4:  BSF    03.6
02D5:  INCF   10,F
02D6:  GOTO   2C5
02D7:  BCF    03.6
02D8:  BCF    0A.3
02D9:  BSF    0A.4
02DA:  GOTO   277 (RETURN)
....................    g_LcdX = 0; 
....................    g_LcdY = 0; 
....................   #endif 
.................... } 
....................  
.................... void lcd_gotoxy(unsigned int8 x, unsigned int8 y) 
.................... { 
....................    unsigned int8 address; 
....................     
....................    if(y!=1) 
02DB:  BSF    03.6
02DC:  DECFSZ 42,W
02DD:  GOTO   2DF
02DE:  GOTO   2E2
....................       address=LCD_LINE_TWO; 
02DF:  MOVLW  40
02E0:  MOVWF  43
02E1:  GOTO   2E3
....................    else 
....................       address=0; 
02E2:  CLRF   43
....................       
....................    address+=x-1; 
02E3:  MOVLW  01
02E4:  SUBWF  41,W
02E5:  ADDWF  43,F
....................    lcd_send_byte(0,0x80|address); 
02E6:  MOVF   43,W
02E7:  IORLW  80
02E8:  MOVWF  44
02E9:  CLRF   45
02EA:  MOVF   44,W
02EB:  MOVWF  46
02EC:  BCF    03.6
02ED:  CALL   1FA
....................  
....................   #if defined(LCD_EXTENDED_NEWLINE) 
02EE:  RETURN
....................    g_LcdX = x - 1; 
....................    g_LcdY = y - 1; 
....................   #endif 
.................... } 
....................  
.................... void lcd_putc(char c) 
.................... { 
....................    switch (c) 
02EF:  BSF    03.6
02F0:  MOVF   40,W
02F1:  XORLW  07
02F2:  BCF    03.6
02F3:  BTFSC  03.2
02F4:  GOTO   2FF
02F5:  XORLW  0B
02F6:  BTFSC  03.2
02F7:  GOTO   306
02F8:  XORLW  06
02F9:  BTFSC  03.2
02FA:  GOTO   312
02FB:  XORLW  02
02FC:  BTFSC  03.2
02FD:  GOTO   31A
02FE:  GOTO   321
....................    { 
....................       case '\a'   :  lcd_gotoxy(1,1);     break; 
02FF:  MOVLW  01
0300:  BSF    03.6
0301:  MOVWF  41
0302:  MOVWF  42
0303:  BCF    03.6
0304:  CALL   2DB
0305:  GOTO   328
....................  
....................       case '\f'   :  lcd_send_byte(0,1); 
0306:  BSF    03.6
0307:  CLRF   45
0308:  MOVLW  01
0309:  MOVWF  46
030A:  BCF    03.6
030B:  CALL   1FA
....................                      delay_ms(2); 
030C:  MOVLW  02
030D:  BSF    03.6
030E:  MOVWF  41
030F:  BCF    03.6
0310:  CALL   15B
....................                     #if defined(LCD_EXTENDED_NEWLINE) 
....................                      g_LcdX = 0; 
....................                      g_LcdY = 0; 
....................                     #endif 
....................                      break; 
0311:  GOTO   328
....................  
....................      #if defined(LCD_EXTENDED_NEWLINE) 
....................       case '\r'   :  lcd_gotoxy(1, g_LcdY+1);   break; 
....................       case '\n'   : 
....................          while (g_LcdX++ < LCD_LINE_LENGTH) 
....................          { 
....................             lcd_send_byte(1, ' '); 
....................          } 
....................          lcd_gotoxy(1, g_LcdY+2); 
....................          break; 
....................      #else 
....................       case '\n'   : lcd_gotoxy(1,2);        break; 
0312:  MOVLW  01
0313:  BSF    03.6
0314:  MOVWF  41
0315:  MOVLW  02
0316:  MOVWF  42
0317:  BCF    03.6
0318:  CALL   2DB
0319:  GOTO   328
....................      #endif 
....................       
....................       case '\b'   : lcd_send_byte(0,0x10);  break; 
031A:  BSF    03.6
031B:  CLRF   45
031C:  MOVLW  10
031D:  MOVWF  46
031E:  BCF    03.6
031F:  CALL   1FA
0320:  GOTO   328
....................       
....................      #if defined(LCD_EXTENDED_NEWLINE) 
....................       default     :  
....................          if (g_LcdX < LCD_LINE_LENGTH) 
....................          { 
....................             lcd_send_byte(1, c); 
....................             g_LcdX++; 
....................          } 
....................          break; 
....................      #else 
....................       default     : lcd_send_byte(1,c);     break; 
0321:  MOVLW  01
0322:  BSF    03.6
0323:  MOVWF  45
0324:  MOVF   40,W
0325:  MOVWF  46
0326:  BCF    03.6
0327:  CALL   1FA
....................      #endif 
....................    } 
0328:  RETURN
.................... } 
....................   
.................... char lcd_getc(unsigned int8 x, unsigned int8 y) 
.................... { 
....................    char value; 
....................  
....................    lcd_gotoxy(x,y); 
....................    while ( bit_test(lcd_read_byte(),7) ); // wait until busy flag is low 
....................    lcd_output_rs(1); 
....................    value = lcd_read_byte(); 
....................    lcd_output_rs(0); 
....................     
....................    return(value); 
.................... } 
....................  
.................... // write a custom character to the ram 
.................... // which is 0-7 and specifies which character array we are modifying. 
.................... // ptr points to an array of 8 bytes, where each byte is the next row of 
.................... //    pixels.  only bits 0-4 are used.  the last row is the cursor row, and 
.................... //    usually you will want to leave this byte 0x00. 
.................... void lcd_set_cgram_char(unsigned int8 which, unsigned int8 *ptr) 
.................... { 
....................    unsigned int i; 
....................  
....................    which <<= 3; 
....................    which &= 0x38; 
....................  
....................    lcd_send_byte(0, 0x40 | which);  //set cgram address 
....................  
....................    for(i=0; i<8; i++) 
....................    { 
....................       lcd_send_byte(1, *ptr++); 
....................    } 
....................    
....................    #if defined(LCD_EXTENDED_NEWLINE) 
....................     lcd_gotoxy(g_LcdX+1, g_LcdY+1);  //set ddram address 
....................    #endif 
.................... } 
....................  
.................... void lcd_cursor_on(int1 on) 
.................... { 
....................    if (on) 
....................    { 
....................       lcd_send_byte(0,0x0F);           //turn LCD cursor ON 
....................    } 
....................    else 
....................    { 
....................       lcd_send_byte(0,0x0C);           //turn LCD cursor OFF 
....................    } 
.................... } 
....................  
.................... #endif 
....................  
.................... #BIT TMR1IF = 0x0C.0 //bit thu 0 (TMR1IF) cua PIR1 
....................  
.................... #INCLUDE <khaibaobien.c> // VARIABLE. 
.................... UNSIGNED INT16 KQADC; 
.................... UNSIGNED INT8 KET_QUA_ANALOG[]={0,0,0,0}; 
*
11E2:  CLRF   34
11E3:  CLRF   35
11E4:  CLRF   36
11E5:  CLRF   37
.................... UNSIGNED INT8 CONFIG_FUN=0; 
.................... UNSIGNED INT8 VT=0, KYTU=0;// KYTU[30],  
.................... UNSIGNED INT8 LENH_DIEU_KHIEN = 0; 
.................... UNSIGNED INT8 ID_GATEWAY[6] = {3,8,6,9,0,7}; 
11E6:  MOVLW  03
11E7:  MOVWF  3C
11E8:  MOVLW  08
11E9:  MOVWF  3D
11EA:  MOVLW  06
11EB:  MOVWF  3E
11EC:  MOVLW  09
11ED:  MOVWF  3F
11EE:  CLRF   40
11EF:  MOVLW  07
11F0:  MOVWF  41
.................... UNSIGNED INT8 ID_NODE[4] = {1,8,1,0}; 
11F1:  MOVLW  01
11F2:  MOVWF  42
11F3:  MOVLW  08
11F4:  MOVWF  43
11F5:  MOVLW  01
11F6:  MOVWF  44
11F7:  CLRF   45
.................... UNSIGNED INT8 LEN_PACKAGES = 0; 
.................... UNSIGNED INT8 LENHDIEUKHIEN =0, DODAI_DATA_NHAN =0; 
.................... UNSIGNED INT8 SOLUONGTHIETBI_CONFIG=0, SOLUONGCAMBIEN_CONFIG = 3; 
.................... SIGNED INT8 SOSANH_IDNODE=0, SOSANH_IDGW=0; 
.................... //INT1 TT_THIETBI [8]={0,0,0,0,0,0,0,0}; 
.................... INT1 TT_THIETBI_TEMP [8]={0,0,0,0,0,0,0,0}; 
11F8:  CLRF   4D
.................... INT1 TTNHAN = 0, TT_CONFIG=0, TT_CONTROL=0,TT_CONFIG_DONE=0, TT_FUN=0, TT_STT=0 , TT_CONFIG_OKE_UART = 0, TT_SW = 0; 
....................  
.................... CHAR *ID_NODE_CHAR[]= "0589"; 
11F9:  MOVLW  30
11FA:  MOVWF  51
11FB:  MOVLW  35
11FC:  MOVWF  52
11FD:  MOVLW  38
11FE:  MOVWF  53
11FF:  MOVLW  39
1200:  MOVWF  54
1201:  CLRF   55
1202:  CLRF   50
1203:  MOVLW  51
1204:  MOVWF  4F
.................... CHAR *ID_GATEWAY_CHAR[]= "127102"; 
1205:  MOVLW  31
1206:  MOVWF  58
1207:  MOVLW  32
1208:  MOVWF  59
1209:  MOVLW  37
120A:  MOVWF  5A
120B:  MOVLW  31
120C:  MOVWF  5B
120D:  MOVLW  30
120E:  MOVWF  5C
120F:  MOVLW  32
1210:  MOVWF  5D
1211:  CLRF   5E
1212:  CLRF   57
1213:  MOVLW  58
1214:  MOVWF  56
.................... CHAR *ID_NODE_NHAN[]= "0000"; 
1215:  MOVLW  30
1216:  MOVWF  61
1217:  MOVWF  62
1218:  MOVWF  63
1219:  MOVWF  64
121A:  CLRF   65
121B:  CLRF   60
121C:  MOVLW  61
121D:  MOVWF  5F
.................... CHAR *ID_GW_NHAN[]= "000000"; 
121E:  MOVLW  30
121F:  MOVWF  68
1220:  MOVWF  69
1221:  MOVWF  6A
1222:  MOVWF  6B
1223:  MOVWF  6C
1224:  MOVWF  6D
1225:  CLRF   6E
1226:  CLRF   67
1227:  MOVLW  68
1228:  MOVWF  66
.................... CHAR KYTUCHAR[50]="HIHI"; 
1229:  MOVLW  48
122A:  BSF    03.5
122B:  MOVWF  20
122C:  MOVLW  49
122D:  MOVWF  21
122E:  MOVLW  48
122F:  MOVWF  22
1230:  MOVLW  49
1231:  MOVWF  23
1232:  CLRF   24
.................... CHAR KYTUCHAR2[25]="HIHI"; 
1233:  MOVLW  48
1234:  MOVWF  52
1235:  MOVLW  49
1236:  MOVWF  53
1237:  MOVLW  48
1238:  MOVWF  54
1239:  MOVLW  49
123A:  MOVWF  55
123B:  CLRF   56
.................... //CHAR *DATA_NHANDUOC[]={"IDGW","IDNODE","COMMAN","DATA"}; 
.................... CHAR *TEMP_CHAR[]="0000";   
123C:  MOVLW  30
123D:  MOVWF  71
123E:  MOVWF  72
123F:  MOVWF  73
1240:  MOVWF  74
1241:  CLRF   75
1242:  CLRF   70
1243:  MOVLW  71
1244:  BCF    03.5
1245:  MOVWF  6F
.................... CHAR *TEMP_CHAR2[]="2700";  
1246:  MOVLW  32
1247:  BSF    03.5
1248:  MOVWF  6B
1249:  MOVLW  37
124A:  MOVWF  6C
124B:  MOVLW  30
124C:  MOVWF  6D
124D:  MOVWF  6E
124E:  CLRF   6F
124F:  CLRF   7C
1250:  MOVLW  EB
1251:  MOVWF  7B
.................... //CHAR *TEMP_CHAR3[]="000000";  
....................  
....................  
....................  
.................... //#INCLUDE <CONFIG_NODE.C> // CU HINH NODE. 
.................... #INCLUDE <config_1.C> // CU HINH NODE. 
....................  
.................... //--------------------------------------------------------------------// 
.................... VOID CHON_ID() 
.................... { 
....................    // TT_CONFIG_DONE; 
....................    TT_CONFIG_DONE = 0; 
*
05C2:  BCF    4E.3
....................    TT_STT = 1; 
05C3:  BSF    4E.5
....................    UNSIGNED INT8 NUM = 0; 
05C4:  BSF    03.6
05C5:  CLRF   10
....................    TEMP_CHAR = "0"; 
05C6:  CLRF   11
05C7:  CLRF   12
05C8:  MOVLW  6F
05C9:  MOVWF  04
05CA:  BCF    03.7
05CB:  MOVF   11,W
05CC:  ADDWF  04,F
05CD:  MOVF   12,W
05CE:  BCF    03.6
05CF:  CALL   058
05D0:  MOVWF  00
05D1:  IORLW  00
05D2:  BTFSC  03.2
05D3:  GOTO   5D9
05D4:  BSF    03.6
05D5:  INCF   12,F
05D6:  INCF   11,F
05D7:  GOTO   5C8
05D8:  BCF    03.6
....................    LCD_GOTOXY (1, 2) ; 
05D9:  MOVLW  01
05DA:  BSF    03.6
05DB:  MOVWF  41
05DC:  MOVLW  02
05DD:  MOVWF  42
05DE:  BCF    03.6
05DF:  CALL   2DB
....................    DELAY_MS (10); 
05E0:  MOVLW  0A
05E1:  BSF    03.6
05E2:  MOVWF  41
05E3:  BCF    03.6
05E4:  CALL   15B
....................    PRINTF (LCD_PUTC, "NODE: "); 
05E5:  MOVLW  6F
05E6:  BSF    03.6
05E7:  MOVWF  0D
05E8:  MOVLW  00
05E9:  MOVWF  0F
05EA:  BCF    03.6
05EB:  CALL   329
....................    PRINTF (LCD_PUTC, "0000          "); 
05EC:  MOVLW  73
05ED:  BSF    03.6
05EE:  MOVWF  0D
05EF:  MOVLW  00
05F0:  MOVWF  0F
05F1:  BCF    03.6
05F2:  CALL   329
....................    LCD_GOTOXY (1, 1) ; 
05F3:  MOVLW  01
05F4:  BSF    03.6
05F5:  MOVWF  41
05F6:  MOVWF  42
05F7:  BCF    03.6
05F8:  CALL   2DB
....................    PRINTF (LCD_PUTC, "      _              ");//6 SPACE PHIA TRUOC "_" 
05F9:  MOVLW  7B
05FA:  BSF    03.6
05FB:  MOVWF  0D
05FC:  MOVLW  00
05FD:  MOVWF  0F
05FE:  BCF    03.6
05FF:  CALL   329
....................    //ID_GW = "1234";     
....................  
....................    WHILE (TT_STT) 
0600:  BTFSS  4E.5
0601:  GOTO   67E
....................    { 
....................       IF (!INPUT (BT2_PIN)) //NEU NUT BAM DUOC BAM 
0602:  BSF    03.5
0603:  BSF    06.2
0604:  BCF    03.5
0605:  BTFSC  06.2
0606:  GOTO   625
....................       { 
....................           
....................          NUM++; 
0607:  BSF    03.6
0608:  INCF   10,F
....................          NUM = NUM % 4; 
0609:  MOVLW  03
060A:  ANDWF  10,F
....................          LCD_GOTOXY (3 + NUM, 1); 
060B:  ADDWF  10,W
060C:  MOVWF  11
060D:  MOVWF  41
060E:  MOVLW  01
060F:  MOVWF  42
0610:  BCF    03.6
0611:  CALL   2DB
....................          PRINTF (LCD_PUTC, "    _    ");//4SPACE 
0612:  MOVLW  86
0613:  BSF    03.6
0614:  MOVWF  0D
0615:  MOVLW  00
0616:  MOVWF  0F
0617:  BCF    03.6
0618:  CALL   329
....................          DELAY_MS (300);  
0619:  MOVLW  02
061A:  BSF    03.6
061B:  MOVWF  11
061C:  MOVLW  96
061D:  MOVWF  41
061E:  BCF    03.6
061F:  CALL   15B
0620:  BSF    03.6
0621:  DECFSZ 11,F
0622:  GOTO   61C
....................       } 
0623:  GOTO   67C
0624:  BCF    03.6
....................  
....................       ELSE IF (!INPUT (BT3_PIN)) 
0625:  BSF    03.5
0626:  BSF    06.3
0627:  BCF    03.5
0628:  BTFSC  06.3
0629:  GOTO   67D
....................       { 
....................          ID_NODE[NUM]++; 
062A:  MOVLW  42
062B:  BSF    03.6
062C:  ADDWF  10,W
062D:  MOVWF  04
062E:  BCF    03.7
062F:  INCF   00,F
....................          ID_NODE[NUM] = ID_NODE[NUM] % 10; 
0630:  MOVLW  42
0631:  ADDWF  10,W
0632:  MOVWF  78
0633:  CLRF   7A
0634:  BTFSC  03.0
0635:  INCF   7A,F
0636:  MOVF   78,W
0637:  MOVWF  11
0638:  MOVF   7A,W
0639:  MOVWF  12
063A:  MOVLW  42
063B:  ADDWF  10,W
063C:  MOVWF  04
063D:  BCF    03.7
063E:  MOVF   00,W
063F:  MOVWF  14
0640:  MOVLW  0A
0641:  MOVWF  15
0642:  BCF    03.6
0643:  CALL   532
0644:  MOVF   77,W
0645:  BSF    03.6
0646:  MOVWF  13
0647:  MOVF   11,W
0648:  MOVWF  04
0649:  BCF    03.7
064A:  BTFSC  12.0
064B:  BSF    03.7
064C:  MOVF   13,W
064D:  MOVWF  00
....................          ITOA (ID_NODE[NUM], 10, TEMP_CHAR); 
064E:  MOVLW  42
064F:  ADDWF  10,W
0650:  MOVWF  04
0651:  BCF    03.7
0652:  MOVF   00,W
0653:  MOVWF  11
0654:  CLRF   42
0655:  CLRF   41
0656:  CLRF   40
0657:  MOVF   11,W
0658:  MOVWF  3F
0659:  MOVLW  0A
065A:  MOVWF  43
065B:  CLRF   45
065C:  MOVLW  6F
065D:  MOVWF  44
065E:  BCF    03.6
065F:  CALL   3F5
....................          LCD_GOTOXY (7 + NUM, 2); 
0660:  MOVLW  07
0661:  BSF    03.6
0662:  ADDWF  10,W
0663:  MOVWF  11
0664:  MOVWF  41
0665:  MOVLW  02
0666:  MOVWF  42
0667:  BCF    03.6
0668:  CALL   2DB
....................          DELAY_MS (10); 
0669:  MOVLW  0A
066A:  BSF    03.6
066B:  MOVWF  41
066C:  BCF    03.6
066D:  CALL   15B
....................          PRINTF (LCD_PUTC, TEMP_CHAR); 
066E:  MOVLW  6F
066F:  MOVWF  04
0670:  BCF    03.7
0671:  CALL   515
....................          DELAY_MS (300); 
0672:  MOVLW  02
0673:  BSF    03.6
0674:  MOVWF  11
0675:  MOVLW  96
0676:  MOVWF  41
0677:  BCF    03.6
0678:  CALL   15B
0679:  BSF    03.6
067A:  DECFSZ 11,F
067B:  GOTO   675
067C:  BCF    03.6
....................       } 
067D:  GOTO   600
....................    } 
.................... } 
....................  
.................... VOID NHAPID_GW() 
*
067F:  BSF    03.6
0680:  CLRF   10
.................... { 
....................    UNSIGNED INT8 NUM = 0; 
....................    TEMP_CHAR = "0"; 
0681:  CLRF   11
0682:  CLRF   12
0683:  MOVLW  6F
0684:  MOVWF  04
0685:  BCF    03.7
0686:  MOVF   11,W
0687:  ADDWF  04,F
0688:  MOVF   12,W
0689:  BCF    03.6
068A:  CALL   058
068B:  MOVWF  00
068C:  IORLW  00
068D:  BTFSC  03.2
068E:  GOTO   694
068F:  BSF    03.6
0690:  INCF   12,F
0691:  INCF   11,F
0692:  GOTO   683
0693:  BCF    03.6
....................    TT_CONFIG_DONE = 0; 
0694:  BCF    4E.3
....................    TT_STT = 1; 
0695:  BSF    4E.5
....................    LCD_GOTOXY (1, 2) ; 
0696:  MOVLW  01
0697:  BSF    03.6
0698:  MOVWF  41
0699:  MOVLW  02
069A:  MOVWF  42
069B:  BCF    03.6
069C:  CALL   2DB
....................    DELAY_MS (10); 
069D:  MOVLW  0A
069E:  BSF    03.6
069F:  MOVWF  41
06A0:  BCF    03.6
06A1:  CALL   15B
....................    PRINTF (LCD_PUTC, "ID_GW:"); 
06A2:  MOVLW  8B
06A3:  BSF    03.6
06A4:  MOVWF  0D
06A5:  MOVLW  00
06A6:  MOVWF  0F
06A7:  BCF    03.6
06A8:  CALL   329
....................    PRINTF (LCD_PUTC, "000000        "); 
06A9:  MOVLW  8F
06AA:  BSF    03.6
06AB:  MOVWF  0D
06AC:  MOVLW  00
06AD:  MOVWF  0F
06AE:  BCF    03.6
06AF:  CALL   329
....................    LCD_GOTOXY (1, 1) ; 
06B0:  MOVLW  01
06B1:  BSF    03.6
06B2:  MOVWF  41
06B3:  MOVWF  42
06B4:  BCF    03.6
06B5:  CALL   2DB
....................    PRINTF (LCD_PUTC, "      _                ");//6 SPACE PHIA TRUOC "_" 
06B6:  MOVLW  97
06B7:  BSF    03.6
06B8:  MOVWF  0D
06B9:  MOVLW  00
06BA:  MOVWF  0F
06BB:  BCF    03.6
06BC:  CALL   329
....................    //ID_GW = "1234";     
....................  
....................    WHILE (TT_STT) 
06BD:  BTFSS  4E.5
06BE:  GOTO   743
....................    { 
....................       IF (!INPUT (BT2_PIN)) //NEU NUT BAM DUOC BAM 
06BF:  BSF    03.5
06C0:  BSF    06.2
06C1:  BCF    03.5
06C2:  BTFSC  06.2
06C3:  GOTO   6EA
....................       { 
....................           
....................          NUM++; 
06C4:  BSF    03.6
06C5:  INCF   10,F
....................          NUM = NUM % 6; 
06C6:  MOVF   10,W
06C7:  MOVWF  14
06C8:  MOVLW  06
06C9:  MOVWF  15
06CA:  BCF    03.6
06CB:  CALL   532
06CC:  MOVF   77,W
06CD:  BSF    03.6
06CE:  MOVWF  10
....................          LCD_GOTOXY (3 + NUM, 1); 
06CF:  MOVLW  03
06D0:  ADDWF  10,W
06D1:  MOVWF  11
06D2:  MOVWF  41
06D3:  MOVLW  01
06D4:  MOVWF  42
06D5:  BCF    03.6
06D6:  CALL   2DB
....................          PRINTF (LCD_PUTC, "    _        ");//4SPACE 
06D7:  MOVLW  A3
06D8:  BSF    03.6
06D9:  MOVWF  0D
06DA:  MOVLW  00
06DB:  MOVWF  0F
06DC:  BCF    03.6
06DD:  CALL   329
....................          DELAY_MS (300);  
06DE:  MOVLW  02
06DF:  BSF    03.6
06E0:  MOVWF  11
06E1:  MOVLW  96
06E2:  MOVWF  41
06E3:  BCF    03.6
06E4:  CALL   15B
06E5:  BSF    03.6
06E6:  DECFSZ 11,F
06E7:  GOTO   6E1
....................       } 
06E8:  GOTO   741
06E9:  BCF    03.6
....................  
....................       ELSE IF (!INPUT (BT3_PIN)) 
06EA:  BSF    03.5
06EB:  BSF    06.3
06EC:  BCF    03.5
06ED:  BTFSC  06.3
06EE:  GOTO   742
....................       { 
....................          ID_GATEWAY[NUM]++; 
06EF:  MOVLW  3C
06F0:  BSF    03.6
06F1:  ADDWF  10,W
06F2:  MOVWF  04
06F3:  BCF    03.7
06F4:  INCF   00,F
....................          ID_GATEWAY[NUM] = ID_GATEWAY[NUM] % 10; 
06F5:  MOVLW  3C
06F6:  ADDWF  10,W
06F7:  MOVWF  78
06F8:  CLRF   7A
06F9:  BTFSC  03.0
06FA:  INCF   7A,F
06FB:  MOVF   78,W
06FC:  MOVWF  11
06FD:  MOVF   7A,W
06FE:  MOVWF  12
06FF:  MOVLW  3C
0700:  ADDWF  10,W
0701:  MOVWF  04
0702:  BCF    03.7
0703:  MOVF   00,W
0704:  MOVWF  14
0705:  MOVLW  0A
0706:  MOVWF  15
0707:  BCF    03.6
0708:  CALL   532
0709:  MOVF   77,W
070A:  BSF    03.6
070B:  MOVWF  13
070C:  MOVF   11,W
070D:  MOVWF  04
070E:  BCF    03.7
070F:  BTFSC  12.0
0710:  BSF    03.7
0711:  MOVF   13,W
0712:  MOVWF  00
....................          ITOA (ID_GATEWAY[NUM], 10, TEMP_CHAR); 
0713:  MOVLW  3C
0714:  ADDWF  10,W
0715:  MOVWF  04
0716:  BCF    03.7
0717:  MOVF   00,W
0718:  MOVWF  11
0719:  CLRF   42
071A:  CLRF   41
071B:  CLRF   40
071C:  MOVF   11,W
071D:  MOVWF  3F
071E:  MOVLW  0A
071F:  MOVWF  43
0720:  CLRF   45
0721:  MOVLW  6F
0722:  MOVWF  44
0723:  BCF    03.6
0724:  CALL   3F5
....................          LCD_GOTOXY (7 + NUM, 2); 
0725:  MOVLW  07
0726:  BSF    03.6
0727:  ADDWF  10,W
0728:  MOVWF  11
0729:  MOVWF  41
072A:  MOVLW  02
072B:  MOVWF  42
072C:  BCF    03.6
072D:  CALL   2DB
....................          DELAY_MS (10); 
072E:  MOVLW  0A
072F:  BSF    03.6
0730:  MOVWF  41
0731:  BCF    03.6
0732:  CALL   15B
....................          PRINTF (LCD_PUTC, TEMP_CHAR); 
0733:  MOVLW  6F
0734:  MOVWF  04
0735:  BCF    03.7
0736:  CALL   515
....................          DELAY_MS (300); 
0737:  MOVLW  02
0738:  BSF    03.6
0739:  MOVWF  11
073A:  MOVLW  96
073B:  MOVWF  41
073C:  BCF    03.6
073D:  CALL   15B
073E:  BSF    03.6
073F:  DECFSZ 11,F
0740:  GOTO   73A
0741:  BCF    03.6
....................       } 
0742:  GOTO   6BD
....................    } 
.................... } 
....................  
.................... VOID BUTT_OKE() 
.................... { 
....................    TT_CONFIG_DONE = 0; 
*
0125:  BCF    03.6
0126:  BCF    4E.3
....................    TT_FUN = 0;//BREAK WHILE BUTT_FUN 
0127:  BCF    4E.4
....................    TT_STT = 0;// BREAK WHILE CHONID/NHAPID_GW 
0128:  BCF    4E.5
.................... } 
....................  
.................... VOID SELLECT_FUN() 
.................... { 
....................    TT_CONFIG_DONE = 0; 
*
05BA:  BCF    4E.3
....................  
....................    SWITCH (CONFIG_FUN) 
05BB:  MOVF   38,W
05BC:  BTFSC  03.2
05BD:  GOTO   5C2
05BE:  XORLW  01
05BF:  BTFSC  03.2
05C0:  GOTO   67F
05C1:  GOTO   743
....................    { 
....................       CASE 0: 
....................       CHON_ID (); 
....................       BREAK; 
*
067E:  GOTO   743
....................  
....................       CASE 1:     
....................       NHAPID_GW (); 
....................       BREAK; 
....................    } 
.................... } 
....................  
.................... VOID BUTT_FUN() 
.................... { 
....................    TT_FUN = 1; 
*
0549:  BSF    4E.4
....................    LCD_GOTOXY (1, 1) ; 
054A:  MOVLW  01
054B:  BSF    03.6
054C:  MOVWF  41
054D:  MOVWF  42
054E:  BCF    03.6
054F:  CALL   2DB
....................    DELAY_MS (10); 
0550:  MOVLW  0A
0551:  BSF    03.6
0552:  MOVWF  41
0553:  BCF    03.6
0554:  CALL   15B
....................    PRINTF (LCD_PUTC, "CONFIG:        "); 
0555:  MOVLW  AA
0556:  BSF    03.6
0557:  MOVWF  0D
0558:  MOVLW  00
0559:  MOVWF  0F
055A:  BCF    03.6
055B:  CALL   329
....................  
....................    // HIEN THI LCD 
....................    LCD_GOTOXY (1, 2) ; 
055C:  MOVLW  01
055D:  BSF    03.6
055E:  MOVWF  41
055F:  MOVLW  02
0560:  MOVWF  42
0561:  BCF    03.6
0562:  CALL   2DB
....................    DELAY_MS (10); 
0563:  MOVLW  0A
0564:  BSF    03.6
0565:  MOVWF  41
0566:  BCF    03.6
0567:  CALL   15B
....................    PRINTF (LCD_PUTC, "CASE:          ") ; 
0568:  MOVLW  B2
0569:  BSF    03.6
056A:  MOVWF  0D
056B:  MOVLW  00
056C:  MOVWF  0F
056D:  BCF    03.6
056E:  CALL   329
....................  
....................    WHILE (TT_FUN) 
056F:  BTFSS  4E.4
0570:  GOTO   5B8
....................    { 
....................       IF (INPUT (BT2_PIN) == 0) //NEU NUT BAM DUOC BAM 
0571:  BSF    03.5
0572:  BSF    06.2
0573:  BCF    03.5
0574:  BTFSC  06.2
0575:  GOTO   5B7
....................       { 
....................          CONFIG_FUN ++; 
0576:  INCF   38,F
....................          CONFIG_FUN = CONFIG_FUN % 2; 
0577:  MOVLW  01
0578:  ANDWF  38,F
....................          DELAY_MS (300); 
0579:  MOVLW  02
057A:  BSF    03.6
057B:  MOVWF  10
057C:  MOVLW  96
057D:  MOVWF  41
057E:  BCF    03.6
057F:  CALL   15B
0580:  BSF    03.6
0581:  DECFSZ 10,F
0582:  GOTO   57C
....................          //HIEN THI 
....................          LCD_GOTOXY (6, 2) ; 
0583:  MOVLW  06
0584:  MOVWF  41
0585:  MOVLW  02
0586:  MOVWF  42
0587:  BCF    03.6
0588:  CALL   2DB
....................          ITOA (CONFIG_FUN, 10, TEMP_CHAR); 
0589:  BSF    03.6
058A:  CLRF   42
058B:  CLRF   41
058C:  CLRF   40
058D:  BCF    03.6
058E:  MOVF   38,W
058F:  BSF    03.6
0590:  MOVWF  3F
0591:  MOVLW  0A
0592:  MOVWF  43
0593:  CLRF   45
0594:  MOVLW  6F
0595:  MOVWF  44
0596:  BCF    03.6
0597:  CALL   3F5
....................          DELAY_MS (10); 
0598:  MOVLW  0A
0599:  BSF    03.6
059A:  MOVWF  41
059B:  BCF    03.6
059C:  CALL   15B
....................          PRINTF (LCD_PUTC, TEMP_CHAR); 
059D:  MOVLW  6F
059E:  MOVWF  04
059F:  BCF    03.7
05A0:  CALL   515
....................  
....................          SWITCH (CONFIG_FUN) 
05A1:  MOVF   38,W
05A2:  BTFSC  03.2
05A3:  GOTO   5A8
05A4:  XORLW  01
05A5:  BTFSC  03.2
05A6:  GOTO   5B0
05A7:  GOTO   5B7
....................          { 
....................             CASE 0: 
....................             PRINTF (LCD_PUTC, " - ID-NODE      "); 
05A8:  MOVLW  BA
05A9:  BSF    03.6
05AA:  MOVWF  0D
05AB:  MOVLW  00
05AC:  MOVWF  0F
05AD:  BCF    03.6
05AE:  CALL   329
....................             BREAK; 
05AF:  GOTO   5B7
....................  
....................             CASE 1: 
....................             PRINTF (LCD_PUTC, " - ID-GW       "); 
05B0:  MOVLW  C3
05B1:  BSF    03.6
05B2:  MOVWF  0D
05B3:  MOVLW  00
05B4:  MOVWF  0F
05B5:  BCF    03.6
05B6:  CALL   329
....................             BREAK;             
....................          } 
....................       } 
05B7:  GOTO   56F
....................    } 
....................  
....................    ////// 
....................    IF (!TT_CONFIG_DONE) 
05B8:  BTFSC  4E.3
05B9:  GOTO   743
....................    { 
....................       SELLECT_FUN (); 
....................    } 
*
0743:  BCF    0A.3
0744:  BSF    0A.4
0745:  GOTO   284 (RETURN)
.................... } 
.................... VOID XULY_IDNODE_NHAP(){ 
....................    //*TEMP_CHAR3 = "\0"; 
....................    *ID_NODE_CHAR = "\0"; 
*
0891:  CLRF   7A
0892:  MOVLW  4F
0893:  MOVWF  3E
0894:  MOVF   7A,W
0895:  MOVWF  3F
0896:  MOVF   3E,W
0897:  MOVWF  04
0898:  BCF    03.7
0899:  BTFSC  3F.0
089A:  BSF    03.7
089B:  CLRF   00
....................    FOR (int j = 0; j < 4; j++) 
089C:  CLRF   3D
089D:  MOVF   3D,W
089E:  SUBLW  03
089F:  BTFSS  03.0
08A0:  GOTO   0CA
....................    { 
....................       ITOA (ID_NODE[j], 10, TEMP_CHAR); 
08A1:  MOVLW  42
08A2:  ADDWF  3D,W
08A3:  MOVWF  04
08A4:  BCF    03.7
08A5:  MOVF   00,W
08A6:  MOVWF  3E
08A7:  CLRF   42
08A8:  CLRF   41
08A9:  CLRF   40
08AA:  MOVF   3E,W
08AB:  MOVWF  3F
08AC:  MOVLW  0A
08AD:  MOVWF  43
08AE:  CLRF   45
08AF:  MOVLW  6F
08B0:  MOVWF  44
08B1:  BCF    0A.3
08B2:  BCF    03.6
08B3:  CALL   3F5
08B4:  BSF    0A.3
....................       DELAY_MS (1); 
08B5:  MOVLW  01
08B6:  BSF    03.6
08B7:  MOVWF  41
08B8:  BCF    0A.3
08B9:  BCF    03.6
08BA:  CALL   15B
08BB:  BSF    0A.3
....................       STRCAT (ID_NODE_CHAR, TEMP_CHAR); 
08BC:  BSF    03.6
08BD:  CLRF   3F
08BE:  MOVLW  4F
08BF:  MOVWF  3E
08C0:  CLRF   41
08C1:  MOVLW  6F
08C2:  MOVWF  40
08C3:  BCF    0A.3
08C4:  BCF    03.6
08C5:  CALL   746
08C6:  BSF    0A.3
08C7:  BSF    03.6
08C8:  INCF   3D,F
08C9:  GOTO   09D
....................    }   
....................    //ID_NODE_CHAR = TEMP_CHAR3;    
....................    //STRCPY(ID_NODE_CHAR,TEMP_CHAR3); 
....................    //strcpy 
.................... } 
.................... VOID XULY_IDGW_NHAP(){ 
....................  
....................    *ID_GATEWAY_CHAR = "\0"; 
*
0855:  CLRF   7A
0856:  MOVLW  56
0857:  MOVWF  3E
0858:  MOVF   7A,W
0859:  MOVWF  3F
085A:  MOVF   3E,W
085B:  MOVWF  04
085C:  BCF    03.7
085D:  BTFSC  3F.0
085E:  BSF    03.7
085F:  CLRF   00
....................    FOR (int j = 0; j < 6; j++) 
0860:  CLRF   3D
0861:  MOVF   3D,W
0862:  SUBLW  05
0863:  BTFSS  03.0
0864:  GOTO   08E
....................    { 
....................       ITOA (ID_GATEWAY[j], 10, TEMP_CHAR); 
0865:  MOVLW  3C
0866:  ADDWF  3D,W
0867:  MOVWF  04
0868:  BCF    03.7
0869:  MOVF   00,W
086A:  MOVWF  3E
086B:  CLRF   42
086C:  CLRF   41
086D:  CLRF   40
086E:  MOVF   3E,W
086F:  MOVWF  3F
0870:  MOVLW  0A
0871:  MOVWF  43
0872:  CLRF   45
0873:  MOVLW  6F
0874:  MOVWF  44
0875:  BCF    0A.3
0876:  BCF    03.6
0877:  CALL   3F5
0878:  BSF    0A.3
....................       DELAY_MS (1); 
0879:  MOVLW  01
087A:  BSF    03.6
087B:  MOVWF  41
087C:  BCF    0A.3
087D:  BCF    03.6
087E:  CALL   15B
087F:  BSF    0A.3
....................       STRCAT (ID_GATEWAY_CHAR, TEMP_CHAR); 
0880:  BSF    03.6
0881:  CLRF   3F
0882:  MOVLW  56
0883:  MOVWF  3E
0884:  CLRF   41
0885:  MOVLW  6F
0886:  MOVWF  40
0887:  BCF    0A.3
0888:  BCF    03.6
0889:  CALL   746
088A:  BSF    0A.3
088B:  BSF    03.6
088C:  INCF   3D,F
088D:  GOTO   061
....................    }   
.................... } 
....................  
....................  
.................... VOID CONFIG_DONE() 
.................... { 
....................    TT_FUN = 0; 
*
0800:  BCF    4E.4
....................    TT_STT = 0; 
0801:  BCF    4E.5
....................    CHAR *PACKAGE_CONFIG[]={"*", "LENGHT","CF", "ID_GW1234" ,"ID_NODE","#"}; 
0802:  MOVLW  2A
0803:  BSF    03.6
0804:  MOVWF  1C
0805:  CLRF   1D
0806:  MOVLW  4C
0807:  MOVWF  1E
0808:  MOVLW  45
0809:  MOVWF  1F
080A:  MOVLW  4E
080B:  MOVWF  20
080C:  MOVLW  47
080D:  MOVWF  21
080E:  MOVLW  48
080F:  MOVWF  22
0810:  MOVLW  54
0811:  MOVWF  23
0812:  CLRF   24
0813:  MOVLW  43
0814:  MOVWF  25
0815:  MOVLW  46
0816:  MOVWF  26
0817:  CLRF   27
0818:  MOVLW  49
0819:  MOVWF  28
081A:  MOVLW  44
081B:  MOVWF  29
081C:  MOVLW  5F
081D:  MOVWF  2A
081E:  MOVLW  47
081F:  MOVWF  2B
0820:  MOVLW  57
0821:  MOVWF  2C
0822:  MOVLW  31
0823:  MOVWF  2D
0824:  MOVLW  32
0825:  MOVWF  2E
0826:  MOVLW  33
0827:  MOVWF  2F
0828:  MOVLW  34
0829:  MOVWF  30
082A:  CLRF   31
082B:  MOVLW  49
082C:  MOVWF  32
082D:  MOVLW  44
082E:  MOVWF  33
082F:  MOVLW  5F
0830:  MOVWF  34
0831:  MOVLW  4E
0832:  MOVWF  35
0833:  MOVLW  4F
0834:  MOVWF  36
0835:  MOVLW  44
0836:  MOVWF  37
0837:  MOVLW  45
0838:  MOVWF  38
0839:  CLRF   39
083A:  MOVLW  23
083B:  MOVWF  3A
083C:  CLRF   3B
083D:  MOVLW  01
083E:  MOVWF  11
083F:  MOVLW  1C
0840:  MOVWF  10
0841:  MOVLW  01
0842:  MOVWF  13
0843:  MOVLW  1E
0844:  MOVWF  12
0845:  MOVLW  01
0846:  MOVWF  15
0847:  MOVLW  25
0848:  MOVWF  14
0849:  MOVLW  01
084A:  MOVWF  17
084B:  MOVLW  28
084C:  MOVWF  16
084D:  MOVLW  01
084E:  MOVWF  19
084F:  MOVLW  32
0850:  MOVWF  18
0851:  MOVLW  01
0852:  MOVWF  1B
0853:  MOVLW  3A
0854:  MOVWF  1A
....................    XULY_IDGW_NHAP(); 
....................    PACKAGE_CONFIG[3] = ID_GATEWAY_CHAR; 
*
088E:  CLRF   17
088F:  MOVLW  56
0890:  MOVWF  16
....................     
....................     
....................    XULY_IDNODE_NHAP(); 
....................  
....................    PACKAGE_CONFIG[4] = ID_NODE_CHAR;     
*
08CA:  CLRF   19
08CB:  MOVLW  4F
08CC:  MOVWF  18
....................       /*     
....................    LEN_PACKAGES = 0; 
....................    PACKAGE_CONFIG[1] = "12"; //DO DAI CUA LENGHT CO DO DAI = 2 
....................    FOR (int J = 0; J < 5; J++) 
....................    { 
....................       LEN_PACKAGES += strlen(PACKAGE_CONFIG[J]); 
....................    }    
....................    */ 
....................    LEN_PACKAGES = 20; //5 @ 
08CD:  MOVLW  14
08CE:  BCF    03.6
08CF:  MOVWF  46
....................    ITOA (LEN_PACKAGES, 10, TEMP_CHAR); 
08D0:  BSF    03.6
08D1:  CLRF   42
08D2:  CLRF   41
08D3:  CLRF   40
08D4:  BCF    03.6
08D5:  MOVF   46,W
08D6:  BSF    03.6
08D7:  MOVWF  3F
08D8:  MOVLW  0A
08D9:  MOVWF  43
08DA:  CLRF   45
08DB:  MOVLW  6F
08DC:  MOVWF  44
08DD:  BCF    0A.3
08DE:  BCF    03.6
08DF:  CALL   3F5
08E0:  BSF    0A.3
....................     
....................    PACKAGE_CONFIG[1] = TEMP_CHAR; 
08E1:  BSF    03.6
08E2:  CLRF   13
08E3:  MOVLW  6F
08E4:  MOVWF  12
....................     
....................    FOR (INT J = 0; J < 6; J++) 
08E5:  CLRF   3C
08E6:  MOVF   3C,W
08E7:  SUBLW  05
08E8:  BTFSS  03.0
08E9:  GOTO   104
....................    { 
....................       PRINTF (PACKAGE_CONFIG[J]); 
08EA:  BCF    03.0
08EB:  RLF    3C,W
08EC:  ADDLW  10
08ED:  MOVWF  04
08EE:  BSF    03.7
08EF:  INCF   04,F
08F0:  MOVF   00,W
08F1:  MOVWF  3E
08F2:  DECF   04,F
08F3:  MOVF   00,W
08F4:  MOVWF  3D
08F5:  MOVWF  04
08F6:  BCF    03.7
08F7:  BTFSC  3E.0
08F8:  BSF    03.7
08F9:  BCF    0A.3
08FA:  BCF    03.6
08FB:  CALL   784
08FC:  BSF    0A.3
....................       PRINTF ("@"); 
08FD:  MOVLW  40
08FE:  BTFSS  0C.4
08FF:  GOTO   0FE
0900:  MOVWF  19
0901:  BSF    03.6
0902:  INCF   3C,F
0903:  GOTO   0E6
....................    } 
....................  
....................  
....................    LCD_GOTOXY (1, 1) ; 
0904:  MOVLW  01
0905:  MOVWF  41
0906:  MOVWF  42
0907:  BCF    0A.3
0908:  BCF    03.6
0909:  CALL   2DB
090A:  BSF    0A.3
....................    DELAY_MS (10); 
090B:  MOVLW  0A
090C:  BSF    03.6
090D:  MOVWF  41
090E:  BCF    0A.3
090F:  BCF    03.6
0910:  CALL   15B
0911:  BSF    0A.3
....................    PRINTF (LCD_PUTC, "WAITING ....        ") ; 
0912:  MOVLW  CB
0913:  BSF    03.6
0914:  MOVWF  0D
0915:  MOVLW  00
0916:  MOVWF  0F
0917:  BCF    0A.3
0918:  BCF    03.6
0919:  CALL   329
091A:  BSF    0A.3
....................    LCD_GOTOXY (1, 2) ; 
091B:  MOVLW  01
091C:  BSF    03.6
091D:  MOVWF  41
091E:  MOVLW  02
091F:  MOVWF  42
0920:  BCF    0A.3
0921:  BCF    03.6
0922:  CALL   2DB
0923:  BSF    0A.3
....................    DELAY_MS (10); 
0924:  MOVLW  0A
0925:  BSF    03.6
0926:  MOVWF  41
0927:  BCF    0A.3
0928:  BCF    03.6
0929:  CALL   15B
092A:  BSF    0A.3
....................    PRINTF (LCD_PUTC, "WAITING ....        ") ;    
092B:  MOVLW  D6
092C:  BSF    03.6
092D:  MOVWF  0D
092E:  MOVLW  00
092F:  MOVWF  0F
0930:  BCF    0A.3
0931:  BCF    03.6
0932:  CALL   329
0933:  BSF    0A.3
....................    TT_CONFIG_DONE = 0; 
0934:  BCF    4E.3
0935:  BCF    0A.3
0936:  BSF    0A.4
0937:  GOTO   28B (RETURN)
.................... } 
....................  
....................  
....................  VOID XACNHANCONFIG() 
....................  {    
....................    KYTU=0;          
*
0D36:  CLRF   3A
....................    LCD_GOTOXY (1, 1) ; 
0D37:  MOVLW  01
0D38:  BSF    03.6
0D39:  MOVWF  41
0D3A:  MOVWF  42
0D3B:  BCF    0A.3
0D3C:  BCF    03.6
0D3D:  CALL   2DB
0D3E:  BSF    0A.3
....................    DELAY_MS (10); 
0D3F:  MOVLW  0A
0D40:  BSF    03.6
0D41:  MOVWF  41
0D42:  BCF    0A.3
0D43:  BCF    03.6
0D44:  CALL   15B
0D45:  BSF    0A.3
....................    TEMP_CHAR = "_"; 
0D46:  BSF    03.6
0D47:  CLRF   18
0D48:  CLRF   19
0D49:  MOVLW  6F
0D4A:  MOVWF  04
0D4B:  BCF    03.7
0D4C:  MOVF   18,W
0D4D:  ADDWF  04,F
0D4E:  MOVF   19,W
0D4F:  BCF    0A.3
0D50:  BCF    03.6
0D51:  CALL   05E
0D52:  BSF    0A.3
0D53:  MOVWF  00
0D54:  IORLW  00
0D55:  BTFSC  03.2
0D56:  GOTO   55C
0D57:  BSF    03.6
0D58:  INCF   19,F
0D59:  INCF   18,F
0D5A:  GOTO   549
0D5B:  BCF    03.6
....................    CHAR * TOKEN; 
....................    TOKEN = STRTOK (KYTUCHAR2, TEMP_CHAR);    
0D5C:  BSF    03.6
0D5D:  CLRF   19
0D5E:  MOVLW  D2
0D5F:  MOVWF  18
0D60:  CLRF   1B
0D61:  MOVLW  6F
0D62:  MOVWF  1A
0D63:  BCF    03.6
0D64:  CALL   138
0D65:  MOVF   79,W
0D66:  BSF    03.6
0D67:  MOVWF  17
0D68:  MOVF   78,W
0D69:  MOVWF  16
....................     WHILE (TOKEN != NULL) 
0D6A:  MOVF   16,F
0D6B:  BTFSS  03.2
0D6C:  GOTO   570
0D6D:  MOVF   17,F
0D6E:  BTFSC  03.2
0D6F:  GOTO   5B9
....................     {                 
....................        SWITCH(KYTU) 
0D70:  BCF    03.6
0D71:  MOVF   3A,W
0D72:  BTFSC  03.2
0D73:  GOTO   57B
0D74:  XORLW  01
0D75:  BTFSC  03.2
0D76:  GOTO   595
0D77:  XORLW  03
0D78:  BTFSC  03.2
0D79:  GOTO   59F
0D7A:  GOTO   5A8
....................        { 
....................          CASE 0: 
....................          DELAY_MS (1); 
0D7B:  MOVLW  01
0D7C:  BSF    03.6
0D7D:  MOVWF  41
0D7E:  BCF    0A.3
0D7F:  BCF    03.6
0D80:  CALL   15B
0D81:  BSF    0A.3
....................          PRINTF (LCD_PUTC,TOKEN); 
0D82:  BSF    03.6
0D83:  MOVF   16,W
0D84:  MOVWF  04
0D85:  BCF    03.7
0D86:  BTFSC  17.0
0D87:  BSF    03.7
0D88:  BCF    0A.3
0D89:  BCF    03.6
0D8A:  CALL   515
0D8B:  BSF    0A.3
....................          PRINTF (LCD_PUTC,"            "); 
0D8C:  MOVLW  E1
0D8D:  BSF    03.6
0D8E:  MOVWF  0D
0D8F:  MOVLW  00
0D90:  MOVWF  0F
0D91:  BCF    0A.3
0D92:  BCF    03.6
0D93:  CALL   329
0D94:  BSF    0A.3
....................          CASE 1:  
....................          SOLUONGTHIETBI_CONFIG = ATOI(TOKEN); 
0D95:  BSF    03.6
0D96:  MOVF   17,W
0D97:  MOVWF  19
0D98:  MOVF   16,W
0D99:  MOVWF  18
0D9A:  BCF    03.6
0D9B:  CALL   229
0D9C:  MOVF   78,W
0D9D:  MOVWF  49
....................          BREAK;                      
0D9E:  GOTO   5A8
....................          CASE 2: 
....................          SOLUONGCAMBIEN_CONFIG = ATOI(TOKEN); 
0D9F:  BSF    03.6
0DA0:  MOVF   17,W
0DA1:  MOVWF  19
0DA2:  MOVF   16,W
0DA3:  MOVWF  18
0DA4:  BCF    03.6
0DA5:  CALL   229
0DA6:  MOVF   78,W
0DA7:  MOVWF  4A
....................          BREAK;               
....................        }  
....................       TOKEN = STRTOK(NULL, TEMP_CHAR); 
0DA8:  BSF    03.6
0DA9:  CLRF   19
0DAA:  CLRF   18
0DAB:  CLRF   1B
0DAC:  MOVLW  6F
0DAD:  MOVWF  1A
0DAE:  BCF    03.6
0DAF:  CALL   138
0DB0:  MOVF   79,W
0DB1:  BSF    03.6
0DB2:  MOVWF  17
0DB3:  MOVF   78,W
0DB4:  MOVWF  16
....................       KYTU++;         
0DB5:  BCF    03.6
0DB6:  INCF   3A,F
0DB7:  BSF    03.6
0DB8:  GOTO   56A
....................     }           
....................    DELAY_MS (1);       
0DB9:  MOVLW  01
0DBA:  MOVWF  41
0DBB:  BCF    0A.3
0DBC:  BCF    03.6
0DBD:  CALL   15B
0DBE:  BSF    0A.3
....................    LCD_GOTOXY (1, 2) ; 
0DBF:  MOVLW  01
0DC0:  BSF    03.6
0DC1:  MOVWF  41
0DC2:  MOVLW  02
0DC3:  MOVWF  42
0DC4:  BCF    0A.3
0DC5:  BCF    03.6
0DC6:  CALL   2DB
0DC7:  BSF    0A.3
....................    DELAY_MS (10); 
0DC8:  MOVLW  0A
0DC9:  BSF    03.6
0DCA:  MOVWF  41
0DCB:  BCF    0A.3
0DCC:  BCF    03.6
0DCD:  CALL   15B
0DCE:  BSF    0A.3
....................    PRINTF (LCD_PUTC,"TB: ");    
0DCF:  MOVLW  E8
0DD0:  BSF    03.6
0DD1:  MOVWF  0D
0DD2:  MOVLW  00
0DD3:  MOVWF  0F
0DD4:  BCF    0A.3
0DD5:  BCF    03.6
0DD6:  CALL   329
0DD7:  BSF    0A.3
....................    ITOA (SOLUONGTHIETBI_CONFIG, 10, TEMP_CHAR);    
0DD8:  BSF    03.6
0DD9:  CLRF   42
0DDA:  CLRF   41
0DDB:  CLRF   40
0DDC:  BCF    03.6
0DDD:  MOVF   49,W
0DDE:  BSF    03.6
0DDF:  MOVWF  3F
0DE0:  MOVLW  0A
0DE1:  MOVWF  43
0DE2:  CLRF   45
0DE3:  MOVLW  6F
0DE4:  MOVWF  44
0DE5:  BCF    0A.3
0DE6:  BCF    03.6
0DE7:  CALL   3F5
0DE8:  BSF    0A.3
....................    PRINTF (LCD_PUTC,TEMP_CHAR);    
0DE9:  MOVLW  6F
0DEA:  MOVWF  04
0DEB:  BCF    03.7
0DEC:  BCF    0A.3
0DED:  CALL   515
0DEE:  BSF    0A.3
....................    PRINTF (LCD_PUTC,"    CB:");    
0DEF:  MOVLW  EB
0DF0:  BSF    03.6
0DF1:  MOVWF  0D
0DF2:  MOVLW  00
0DF3:  MOVWF  0F
0DF4:  BCF    0A.3
0DF5:  BCF    03.6
0DF6:  CALL   329
0DF7:  BSF    0A.3
....................    ITOA (SOLUONGCAMBIEN_CONFIG, 10, TEMP_CHAR);    
0DF8:  BSF    03.6
0DF9:  CLRF   42
0DFA:  CLRF   41
0DFB:  CLRF   40
0DFC:  BCF    03.6
0DFD:  MOVF   4A,W
0DFE:  BSF    03.6
0DFF:  MOVWF  3F
0E00:  MOVLW  0A
0E01:  MOVWF  43
0E02:  CLRF   45
0E03:  MOVLW  6F
0E04:  MOVWF  44
0E05:  BCF    0A.3
0E06:  BCF    03.6
0E07:  CALL   3F5
0E08:  BSF    0A.3
....................    PRINTF (LCD_PUTC,TEMP_CHAR);       
0E09:  MOVLW  6F
0E0A:  MOVWF  04
0E0B:  BCF    03.7
0E0C:  BCF    0A.3
0E0D:  CALL   515
0E0E:  BSF    0A.3
....................    TT_CONFIG_OKE_UART = 1; 
0E0F:  BSF    4E.6
....................     
....................  }  
.................... //--------------------------------------------------------------------// 
....................  
.................... #INCLUDE <DIEU_KHIEN.C> 
.................... VOID READ_BTN_STATE() 
*
0E4B:  BSF    03.6
0E4C:  CLRF   10
.................... { 
....................     
....................    INT TB = 0; 
....................    FOR (TB = 0; TB < 4; TB++) 
0E4D:  CLRF   10
0E4E:  MOVF   10,W
0E4F:  SUBLW  03
0E50:  BTFSS  03.0
0E51:  GOTO   68A
....................    {       
....................        IF (!INPUT (52 + TB)) 
0E52:  MOVLW  34
0E53:  ADDWF  10,W
0E54:  MOVWF  11
0E55:  MOVWF  19
0E56:  MOVLW  01
0E57:  MOVWF  1A
0E58:  CLRF   1C
0E59:  MOVLW  80
0E5A:  MOVWF  1B
0E5B:  BCF    0A.3
0E5C:  BCF    03.6
0E5D:  CALL   7C9
0E5E:  BSF    0A.3
0E5F:  BSF    03.6
0E60:  MOVF   11,W
0E61:  MOVWF  1C
0E62:  CLRF   1E
0E63:  CLRF   1D
0E64:  BCF    03.6
0E65:  CALL   352
0E66:  BTFSC  78.0
0E67:  GOTO   687
....................       {   
....................          DELAY_MS(200); 
0E68:  MOVLW  C8
0E69:  BSF    03.6
0E6A:  MOVWF  41
0E6B:  BCF    0A.3
0E6C:  BCF    03.6
0E6D:  CALL   15B
0E6E:  BSF    0A.3
....................          TT_THIETBI_TEMP[TB] = ~TT_THIETBI_TEMP[TB];          
0E6F:  BSF    03.6
0E70:  MOVF   10,W
0E71:  MOVWF  1C
0E72:  CLRF   1E
0E73:  MOVLW  4D
0E74:  MOVWF  1D
0E75:  BCF    03.6
0E76:  CALL   352
0E77:  MOVLW  00
0E78:  BTFSS  78.0
0E79:  MOVLW  01
0E7A:  BSF    03.6
0E7B:  MOVWF  11
0E7C:  MOVF   10,W
0E7D:  MOVWF  19
0E7E:  MOVF   11,W
0E7F:  MOVWF  1A
0E80:  CLRF   1C
0E81:  MOVLW  4D
0E82:  MOVWF  1B
0E83:  BCF    0A.3
0E84:  BCF    03.6
0E85:  CALL   7C9
0E86:  BSF    0A.3
....................       } 
0E87:  BSF    03.6
0E88:  INCF   10,F
0E89:  GOTO   64E
....................    } 
....................  
....................    FOR (TB = 0; TB < 4; TB++) 
0E8A:  CLRF   10
0E8B:  MOVF   10,W
0E8C:  SUBLW  03
0E8D:  BTFSS  03.0
0E8E:  GOTO   6CB
....................    { 
....................  
....................       IF (!INPUT (68 + TB)) 
0E8F:  MOVLW  44
0E90:  ADDWF  10,W
0E91:  MOVWF  11
0E92:  MOVWF  19
0E93:  MOVLW  01
0E94:  MOVWF  1A
0E95:  CLRF   1C
0E96:  MOVLW  80
0E97:  MOVWF  1B
0E98:  BCF    0A.3
0E99:  BCF    03.6
0E9A:  CALL   7C9
0E9B:  BSF    0A.3
0E9C:  BSF    03.6
0E9D:  MOVF   11,W
0E9E:  MOVWF  1C
0E9F:  CLRF   1E
0EA0:  CLRF   1D
0EA1:  BCF    03.6
0EA2:  CALL   352
0EA3:  BTFSC  78.0
0EA4:  GOTO   6C8
....................       { 
....................           DELAY_MS(200); 
0EA5:  MOVLW  C8
0EA6:  BSF    03.6
0EA7:  MOVWF  41
0EA8:  BCF    0A.3
0EA9:  BCF    03.6
0EAA:  CALL   15B
0EAB:  BSF    0A.3
....................           TT_THIETBI_TEMP[TB + 4] = ~TT_THIETBI_TEMP[TB + 4];            
0EAC:  MOVLW  04
0EAD:  BSF    03.6
0EAE:  ADDWF  10,W
0EAF:  MOVWF  11
0EB0:  MOVLW  04
0EB1:  ADDWF  10,W
0EB2:  MOVWF  1C
0EB3:  CLRF   1E
0EB4:  MOVLW  4D
0EB5:  MOVWF  1D
0EB6:  BCF    03.6
0EB7:  CALL   352
0EB8:  MOVLW  00
0EB9:  BTFSS  78.0
0EBA:  MOVLW  01
0EBB:  BSF    03.6
0EBC:  MOVWF  12
0EBD:  MOVF   11,W
0EBE:  MOVWF  19
0EBF:  MOVF   12,W
0EC0:  MOVWF  1A
0EC1:  CLRF   1C
0EC2:  MOVLW  4D
0EC3:  MOVWF  1B
0EC4:  BCF    0A.3
0EC5:  BCF    03.6
0EC6:  CALL   7C9
0EC7:  BSF    0A.3
....................       } 
0EC8:  BSF    03.6
0EC9:  INCF   10,F
0ECA:  GOTO   68B
....................    } 
0ECB:  BCF    03.6
0ECC:  BCF    0A.3
0ECD:  BSF    0A.4
0ECE:  GOTO   29F (RETURN)
.................... } 
.................... INT BIN_TO_DEC() 
*
0B6B:  BSF    03.6
0B6C:  CLRF   19
0B6D:  MOVLW  01
0B6E:  MOVWF  1A
.................... { 
....................    INT8 DEC_VL = 0 ;  
....................    INT8 BASE = 1; 
....................    INT8 I; 
....................    FOR (I=0;I<8;I++) 
0B6F:  CLRF   1B
0B70:  MOVF   1B,W
0B71:  SUBLW  07
0B72:  BTFSS  03.0
0B73:  GOTO   38F
....................    { 
....................    DEC_VL = DEC_VL+ BASE*TT_THIETBI_TEMP[I]; 
0B74:  MOVF   1B,W
0B75:  MOVWF  1C
0B76:  CLRF   1E
0B77:  MOVLW  4D
0B78:  MOVWF  1D
0B79:  BCF    03.6
0B7A:  CALL   352
0B7B:  MOVLW  00
0B7C:  BTFSC  78.0
0B7D:  MOVLW  01
0B7E:  BSF    03.6
0B7F:  MOVWF  1C
0B80:  MOVF   1A,W
0B81:  MOVWF  1F
0B82:  MOVF   1C,W
0B83:  MOVWF  20
0B84:  BCF    0A.3
0B85:  BCF    03.6
0B86:  CALL   7A2
0B87:  BSF    0A.3
0B88:  MOVF   78,W
0B89:  BSF    03.6
0B8A:  ADDWF  19,F
....................    BASE = BASE*2; 
0B8B:  BCF    03.0
0B8C:  RLF    1A,F
0B8D:  INCF   1B,F
0B8E:  GOTO   370
....................    } 
....................    RETURN DEC_VL; 
0B8F:  MOVF   19,W
0B90:  MOVWF  78
....................  
.................... } 
....................   
....................  VOID XUAT_DIEU_KHIEN() 
....................  { 
....................    LENH_DIEU_KHIEN = BIN_TO_DEC(); 
0B91:  MOVF   78,W
0B92:  BCF    03.6
0B93:  MOVWF  3B
....................    XUATTRANGTHAI (LENH_DIEU_KHIEN) ; 
0B94:  MOVF   3B,W
0B95:  BSF    03.6
0B96:  MOVWF  19
....................    LCD_GOTOXY (1, 2) ; 
*
0BBB:  MOVLW  01
0BBC:  BSF    03.6
0BBD:  MOVWF  41
0BBE:  MOVLW  02
0BBF:  MOVWF  42
0BC0:  BCF    0A.3
0BC1:  BCF    03.6
0BC2:  CALL   2DB
0BC3:  BSF    0A.3
....................    DELAY_MS (10); 
0BC4:  MOVLW  0A
0BC5:  BSF    03.6
0BC6:  MOVWF  41
0BC7:  BCF    0A.3
0BC8:  BCF    03.6
0BC9:  CALL   15B
0BCA:  BSF    0A.3
....................    PRINTF (LCD_PUTC, "SW: ");    
0BCB:  MOVLW  EF
0BCC:  BSF    03.6
0BCD:  MOVWF  0D
0BCE:  MOVLW  00
0BCF:  MOVWF  0F
0BD0:  BCF    0A.3
0BD1:  BCF    03.6
0BD2:  CALL   329
0BD3:  BSF    0A.3
....................    FOR (INT ST=0;ST<8;ST++){ 
0BD4:  BSF    03.6
0BD5:  CLRF   18
0BD6:  MOVF   18,W
0BD7:  SUBLW  07
0BD8:  BTFSS  03.0
0BD9:  GOTO   413
....................       TEMP_CHAR = "0"; 
0BDA:  CLRF   19
0BDB:  CLRF   1A
0BDC:  MOVLW  6F
0BDD:  MOVWF  04
0BDE:  BCF    03.7
0BDF:  MOVF   19,W
0BE0:  ADDWF  04,F
0BE1:  MOVF   1A,W
0BE2:  BCF    0A.3
0BE3:  BCF    03.6
0BE4:  CALL   058
0BE5:  BSF    0A.3
0BE6:  MOVWF  00
0BE7:  IORLW  00
0BE8:  BTFSC  03.2
0BE9:  GOTO   3EF
0BEA:  BSF    03.6
0BEB:  INCF   1A,F
0BEC:  INCF   19,F
0BED:  GOTO   3DC
0BEE:  BCF    03.6
....................       ITOA(TT_THIETBI_TEMP[ST],10,TEMP_CHAR); 
0BEF:  BSF    03.6
0BF0:  MOVF   18,W
0BF1:  MOVWF  1C
0BF2:  CLRF   1E
0BF3:  MOVLW  4D
0BF4:  MOVWF  1D
0BF5:  BCF    03.6
0BF6:  CALL   352
0BF7:  MOVLW  00
0BF8:  BTFSC  78.0
0BF9:  MOVLW  01
0BFA:  BSF    03.6
0BFB:  MOVWF  19
0BFC:  CLRF   42
0BFD:  CLRF   41
0BFE:  CLRF   40
0BFF:  MOVF   19,W
0C00:  MOVWF  3F
0C01:  MOVLW  0A
0C02:  MOVWF  43
0C03:  CLRF   45
0C04:  MOVLW  6F
0C05:  MOVWF  44
0C06:  BCF    0A.3
0C07:  BCF    03.6
0C08:  CALL   3F5
0C09:  BSF    0A.3
....................       PRINTF (LCD_PUTC, TEMP_CHAR); 
0C0A:  MOVLW  6F
0C0B:  MOVWF  04
0C0C:  BCF    03.7
0C0D:  BCF    0A.3
0C0E:  CALL   515
0C0F:  BSF    0A.3
0C10:  BSF    03.6
0C11:  INCF   18,F
0C12:  GOTO   3D6
....................    } 
0C13:  BCF    03.6
0C14:  RETURN
....................  } 
....................  VOID DIEUKHIENTHIETBI () 
*
0E11:  BSF    03.6
0E12:  CLRF   16
....................  { 
....................     INT MA_DEC = 0; 
....................     MA_DEC = ATOI (KYTUCHAR2); 
0E13:  CLRF   19
0E14:  MOVLW  D2
0E15:  MOVWF  18
0E16:  BCF    03.6
0E17:  CALL   229
0E18:  MOVF   78,W
0E19:  BSF    03.6
0E1A:  MOVWF  16
....................  
....................    UNSIGNED INT8   SB;    
....................    #BIT BSERI  = MA_DEC.0 
....................     
....................    FOR (SB=0;SB<8;SB++) 
0E1B:  CLRF   17
0E1C:  MOVF   17,W
0E1D:  SUBLW  07
0E1E:  BTFSS  03.0
0E1F:  GOTO   634
....................       {                                                     
....................          TT_THIETBI_TEMP[SB] = BSERI; 
0E20:  MOVLW  00
0E21:  BTFSC  16.0
0E22:  MOVLW  01
0E23:  MOVWF  18
0E24:  MOVF   17,W
0E25:  MOVWF  19
0E26:  MOVF   18,W
0E27:  MOVWF  1A
0E28:  CLRF   1C
0E29:  MOVLW  4D
0E2A:  MOVWF  1B
0E2B:  BCF    0A.3
0E2C:  BCF    03.6
0E2D:  CALL   7C9
0E2E:  BSF    0A.3
....................          MA_DEC=MA_DEC>>1;  
0E2F:  BCF    03.0
0E30:  BSF    03.6
0E31:  RRF    16,F
0E32:  INCF   17,F
0E33:  GOTO   61C
....................      }     
....................     XUAT_DIEU_KHIEN(); 
0E34:  BCF    03.6
0E35:  CALL   36B
....................  } 
....................  
....................  
....................  
....................  
....................  
....................  
....................  
.................... VOID QUET_PHIM() 
*
00F2:  BSF    03.6
00F3:  CLRF   64
.................... { 
....................    INT BDT = 0; 
....................    WHILE (!INPUT (BT1_PIN)) //NEU NUT BAM DUOC BAM 
00F4:  BSF    03.5
00F5:  BCF    03.6
00F6:  BSF    06.1
00F7:  BCF    03.5
00F8:  BTFSC  06.1
00F9:  GOTO   10F
....................    { 
....................       IF (TMR1IF) 
00FA:  BTFSS  0C.0
00FB:  GOTO   10C
....................       { 
....................          OUTPUT_TOGGLE (PIN_C4); 
00FC:  BCF    31.4
00FD:  MOVF   31,W
00FE:  BSF    03.5
00FF:  MOVWF  07
0100:  MOVLW  10
0101:  BCF    03.5
0102:  XORWF  07,F
....................          TMR1IF = 0; SET_TIMER1 (3036); BDT++; 
0103:  BCF    0C.0
0104:  CLRF   0E
0105:  MOVLW  0B
0106:  MOVWF  0F
0107:  MOVLW  DC
0108:  MOVWF  0E
0109:  BSF    03.6
010A:  INCF   64,F
010B:  BCF    03.6
....................       } 
010C:  BSF    03.6
010D:  GOTO   0F4
010E:  BCF    03.6
....................    } 
....................  
....................    IF (BDT > 20) 
010F:  BSF    03.6
0110:  MOVF   64,W
0111:  SUBLW  14
0112:  BTFSC  03.0
0113:  GOTO   11D
....................    { 
....................       //CONFIG NODE 
....................       TT_CONFIG = ~TT_CONFIG; // VAO TRANG THAI CONFIG 
0114:  MOVLW  02
0115:  BCF    03.6
0116:  XORWF  4E,F
....................       TT_CONTROL = ~TT_CONTROL; 
0117:  MOVLW  04
0118:  XORWF  4E,F
....................       //CONFIG_DONE (); 
....................       TT_CONFIG_DONE = 1; 
0119:  BSF    4E.3
....................       TT_FUN = 0; 
011A:  BCF    4E.4
....................    } 
011B:  GOTO   134
011C:  BSF    03.6
....................  
....................    ELSE IF (BDT > 1&&BDT < 20) 
011D:  MOVF   64,W
011E:  SUBLW  01
011F:  BTFSC  03.0
0120:  GOTO   12B
0121:  MOVF   64,W
0122:  SUBLW  13
0123:  BTFSS  03.0
0124:  GOTO   12B
....................    { 
....................       BUTT_OKE (); //OKE 
....................    } 
*
0129:  GOTO   134
012A:  BSF    03.6
....................  
....................    ELSE 
....................    {             
....................       //TMR1IF = 0; SET_TIMER1 (0);       
....................       TT_SW = 1; 
012B:  BCF    03.6
012C:  BSF    4E.7
....................       OUTPUT_TOGGLE (PIN_C4); 
012D:  BCF    31.4
012E:  MOVF   31,W
012F:  BSF    03.5
0130:  MOVWF  07
0131:  MOVLW  10
0132:  BCF    03.5
0133:  XORWF  07,F
....................       //READ_BTN_STATE () ;       
....................    } 
.................... } 
....................  
.................... #INT_EXT 
....................  
....................  VOID NGAT_NGOAI  () 
....................  { 
....................     QUET_PHIM (); 
....................  } 
....................  
0134:  BCF    0B.1
0135:  BCF    0A.3
0136:  BCF    0A.4
0137:  GOTO   031
....................  #INT_RDA 
....................  VOID NGAT  () 
....................  { 
....................     KYTUCHAR[VT] = GETCH (); 
0138:  MOVLW  A0
0139:  ADDWF  39,W
013A:  MOVWF  04
013B:  BCF    03.7
013C:  BTFSS  0C.5
013D:  GOTO   13C
013E:  MOVF   1A,W
013F:  MOVWF  00
....................  
....................     IF (KYTUCHAR[VT] == '.') 
0140:  MOVLW  A0
0141:  ADDWF  39,W
0142:  MOVWF  04
0143:  BCF    03.7
0144:  MOVF   00,W
0145:  SUBLW  2E
0146:  BTFSS  03.2
0147:  GOTO   150
....................     { 
....................        KYTUCHAR[VT] = '\0'; 
0148:  MOVLW  A0
0149:  ADDWF  39,W
014A:  MOVWF  04
014B:  BCF    03.7
014C:  CLRF   00
....................        VT = 0; 
014D:  CLRF   39
....................        TTNHAN = 1; 
014E:  BSF    4E.0
....................     } 
014F:  GOTO   151
....................  
....................     ELSE 
....................     VT++; 
0150:  INCF   39,F
0151:  BCF    0C.5
0152:  BCF    0A.3
0153:  BCF    0A.4
0154:  GOTO   031
....................  } 
....................  
....................  INT ADC_READ (INT KENH) 
....................  { 
....................     UNSIGNED INT8 ANALOG_PORT[] = {1, 2, 4, 8, 16, 32, 64}; 
*
1010:  MOVLW  01
1011:  MOVWF  14
1012:  MOVLW  02
1013:  MOVWF  15
1014:  MOVLW  04
1015:  MOVWF  16
1016:  MOVLW  08
1017:  MOVWF  17
1018:  MOVLW  10
1019:  MOVWF  18
101A:  MOVLW  20
101B:  MOVWF  19
101C:  MOVLW  40
101D:  MOVWF  1A
....................     SETUP_ADC_PORTS (ANALOG_PORT[KENH]); 
101E:  MOVLW  14
101F:  ADDWF  13,W
1020:  MOVWF  04
1021:  BSF    03.7
1022:  MOVF   00,W
1023:  MOVWF  1C
1024:  MOVWF  1D
1025:  CLRF   1E
1026:  CLRF   1F
1027:  CLRF   20
1028:  MOVLW  89
1029:  MOVWF  04
102A:  BSF    03.7
102B:  MOVLW  C0
102C:  ANDWF  00,F
102D:  MOVF   1F,W
102E:  IORWF  00,F
102F:  MOVLW  9F
1030:  MOVWF  04
1031:  BCF    03.7
1032:  MOVLW  CF
1033:  ANDWF  00,F
1034:  MOVF   1E,W
1035:  IORWF  00,F
1036:  MOVLW  88
1037:  MOVWF  04
1038:  BSF    03.7
1039:  MOVF   1D,W
103A:  MOVWF  00
....................     DELAY_MS (3) ; 
103B:  MOVLW  03
103C:  MOVWF  41
103D:  BCF    0A.4
103E:  BCF    03.6
103F:  CALL   15B
1040:  BSF    0A.4
....................     SET_ADC_CHANNEL (KENH); 
1041:  BSF    03.6
1042:  RLF    13,W
1043:  MOVWF  77
1044:  RLF    77,F
1045:  MOVLW  FC
1046:  ANDWF  77,F
1047:  BCF    03.6
1048:  MOVF   1F,W
1049:  ANDLW  C3
104A:  IORWF  77,W
104B:  MOVWF  1F
....................     DELAY_MS (3) ; 
104C:  MOVLW  03
104D:  BSF    03.6
104E:  MOVWF  41
104F:  BCF    0A.4
1050:  BCF    03.6
1051:  CALL   15B
1052:  BSF    0A.4
....................     KQADC = 0; 
1053:  CLRF   33
1054:  CLRF   32
....................     FOR (INT I = 0; I < 100; I++) 
1055:  BSF    03.6
1056:  CLRF   1B
1057:  MOVF   1B,W
1058:  SUBLW  63
1059:  BTFSS  03.0
105A:  GOTO   071
....................     { 
....................        KQADC = KQADC + READ_ADC () ; 
105B:  BCF    03.6
105C:  BSF    1F.1
105D:  BTFSC  1F.1
105E:  GOTO   05D
105F:  BSF    03.5
1060:  MOVF   1E,W
1061:  BCF    03.5
1062:  ADDWF  32,F
1063:  MOVF   1E,W
1064:  BTFSC  03.0
1065:  INCFSZ 1E,W
1066:  ADDWF  33,F
....................        DELAY_MS (1); 
1067:  MOVLW  01
1068:  BSF    03.6
1069:  MOVWF  41
106A:  BCF    0A.4
106B:  BCF    03.6
106C:  CALL   15B
106D:  BSF    0A.4
106E:  BSF    03.6
106F:  INCF   1B,F
1070:  GOTO   057
....................     } 
....................  
....................     KQADC = KQADC / (100 * 2.046); 
1071:  BCF    03.6
1072:  MOVF   33,W
1073:  BSF    03.6
1074:  MOVWF  1D
1075:  BCF    03.6
1076:  MOVF   32,W
1077:  BSF    03.6
1078:  MOVWF  1C
*
1095:  MOVF   7A,W
1096:  MOVWF  1F
1097:  MOVF   79,W
1098:  MOVWF  1E
1099:  MOVF   78,W
109A:  MOVWF  1D
109B:  MOVF   77,W
109C:  MOVWF  1C
109D:  MOVLW  9A
109E:  MOVWF  23
109F:  MOVLW  99
10A0:  MOVWF  22
10A1:  MOVLW  4C
10A2:  MOVWF  21
10A3:  MOVLW  86
10A4:  MOVWF  20
*
116E:  MOVF   7A,W
116F:  MOVWF  1F
1170:  MOVF   79,W
1171:  MOVWF  1E
1172:  MOVF   78,W
1173:  MOVWF  1D
1174:  MOVF   77,W
1175:  MOVWF  1C
*
1194:  MOVF   79,W
1195:  BCF    03.6
1196:  MOVWF  33
1197:  MOVF   78,W
1198:  MOVWF  32
....................     RETURN KQADC; 
1199:  MOVF   32,W
119A:  MOVWF  78
....................  } 
....................  
....................  VOID READ_ANALOG () 
....................  { 
....................     FOR (INT K = 0; K < SOLUONGCAMBIEN_CONFIG; K++) 
*
1000:  BSF    03.6
1001:  CLRF   10
1002:  BCF    03.6
1003:  MOVF   4A,W
1004:  BSF    03.6
1005:  SUBWF  10,W
1006:  BTFSC  03.0
1007:  GOTO   1A5
....................     { 
....................        KET_QUA_ANALOG[K] = ADC_READ (K); 
1008:  MOVLW  34
1009:  ADDWF  10,W
100A:  MOVWF  11
100B:  CLRF   12
100C:  BTFSC  03.0
100D:  INCF   12,F
100E:  MOVF   10,W
100F:  MOVWF  13
*
119B:  BSF    03.6
119C:  MOVF   11,W
119D:  MOVWF  04
119E:  BCF    03.7
119F:  BTFSC  12.0
11A0:  BSF    03.7
11A1:  MOVF   78,W
11A2:  MOVWF  00
11A3:  INCF   10,F
11A4:  GOTO   002
....................     } 
11A5:  BCF    03.6
11A6:  BCF    0A.3
11A7:  BSF    0A.4
11A8:  GOTO   2AF (RETURN)
....................  } 
....................  
....................  VOID SEND_ANALOG_UART () 
....................  { 
....................     OUTPUT_TOGGLE (PIN_C4) ; 
*
0F21:  BCF    31.4
0F22:  MOVF   31,W
0F23:  BSF    03.5
0F24:  MOVWF  07
0F25:  MOVLW  10
0F26:  BCF    03.5
0F27:  XORWF  07,F
....................     //CHAR * PACKAGE_SS[] ={" * ", "26", "SS", "IDGW12", "NODE", "ZZ", "AA", "VV", "CC", "SS"}; 
....................     CHAR * PACKAGE_SS[] ={"IDGW12", "NODE", "ZZ", "AA", "VV", "CC", "SS"}; 
0F28:  MOVLW  49
0F29:  BSF    03.6
0F2A:  MOVWF  1E
0F2B:  MOVLW  44
0F2C:  MOVWF  1F
0F2D:  MOVLW  47
0F2E:  MOVWF  20
0F2F:  MOVLW  57
0F30:  MOVWF  21
0F31:  MOVLW  31
0F32:  MOVWF  22
0F33:  MOVLW  32
0F34:  MOVWF  23
0F35:  CLRF   24
0F36:  MOVLW  4E
0F37:  MOVWF  25
0F38:  MOVLW  4F
0F39:  MOVWF  26
0F3A:  MOVLW  44
0F3B:  MOVWF  27
0F3C:  MOVLW  45
0F3D:  MOVWF  28
0F3E:  CLRF   29
0F3F:  MOVLW  5A
0F40:  MOVWF  2A
0F41:  MOVWF  2B
0F42:  CLRF   2C
0F43:  MOVLW  41
0F44:  MOVWF  2D
0F45:  MOVWF  2E
0F46:  CLRF   2F
0F47:  MOVLW  56
0F48:  MOVWF  30
0F49:  MOVWF  31
0F4A:  CLRF   32
0F4B:  MOVLW  43
0F4C:  MOVWF  33
0F4D:  MOVWF  34
0F4E:  CLRF   35
0F4F:  MOVLW  53
0F50:  MOVWF  36
0F51:  MOVWF  37
0F52:  CLRF   38
0F53:  MOVLW  01
0F54:  MOVWF  11
0F55:  MOVLW  1E
0F56:  MOVWF  10
0F57:  MOVLW  01
0F58:  MOVWF  13
0F59:  MOVLW  25
0F5A:  MOVWF  12
0F5B:  MOVLW  01
0F5C:  MOVWF  15
0F5D:  MOVLW  2A
0F5E:  MOVWF  14
0F5F:  MOVLW  01
0F60:  MOVWF  17
0F61:  MOVLW  2D
0F62:  MOVWF  16
0F63:  MOVLW  01
0F64:  MOVWF  19
0F65:  MOVLW  30
0F66:  MOVWF  18
0F67:  MOVLW  01
0F68:  MOVWF  1B
0F69:  MOVLW  33
0F6A:  MOVWF  1A
0F6B:  MOVLW  01
0F6C:  MOVWF  1D
0F6D:  MOVLW  36
0F6E:  MOVWF  1C
....................     PACKAGE_SS[0] = ID_GATEWAY_CHAR; 
0F6F:  CLRF   11
0F70:  MOVLW  56
0F71:  MOVWF  10
....................     PACKAGE_SS[1] = ID_NODE_CHAR; 
0F72:  CLRF   13
0F73:  MOVLW  4F
0F74:  MOVWF  12
....................     UNSIGNED INT8 DO_DAI = 20; 
0F75:  MOVLW  14
0F76:  MOVWF  39
....................      
....................     FOR (INT I = 0; I < SOLUONGCAMBIEN_CONFIG; I++) 
0F77:  CLRF   3A
0F78:  BCF    03.6
0F79:  MOVF   4A,W
0F7A:  BSF    03.6
0F7B:  SUBWF  3A,W
0F7C:  BTFSC  03.0
0F7D:  GOTO   7A7
....................     { 
....................        ITOA (KET_QUA_ANALOG[I], 10, PACKAGE_SS[2 + I]) ; 
0F7E:  MOVLW  34
0F7F:  ADDWF  3A,W
0F80:  MOVWF  04
0F81:  BCF    03.7
0F82:  MOVF   00,W
0F83:  MOVWF  3B
0F84:  MOVLW  02
0F85:  ADDWF  3A,W
0F86:  MOVWF  77
0F87:  BCF    03.0
0F88:  RLF    77,F
0F89:  MOVF   77,W
0F8A:  ADDLW  10
0F8B:  MOVWF  04
0F8C:  BSF    03.7
0F8D:  INCF   04,F
0F8E:  MOVF   00,W
0F8F:  MOVWF  3D
0F90:  DECF   04,F
0F91:  MOVF   00,W
0F92:  MOVWF  3C
0F93:  CLRF   42
0F94:  CLRF   41
0F95:  CLRF   40
0F96:  MOVF   3B,W
0F97:  MOVWF  3F
0F98:  MOVLW  0A
0F99:  MOVWF  43
0F9A:  MOVF   3D,W
0F9B:  MOVWF  45
0F9C:  MOVF   3C,W
0F9D:  MOVWF  44
0F9E:  BCF    0A.3
0F9F:  BCF    03.6
0FA0:  CALL   3F5
0FA1:  BSF    0A.3
....................        DO_DAI = DO_DAI + 3; 
0FA2:  MOVLW  03
0FA3:  BSF    03.6
0FA4:  ADDWF  39,F
0FA5:  INCF   3A,F
0FA6:  GOTO   778
....................     } 
....................  
....................     ITOA (DO_DAI, 10, TEMP_CHAR2) ; 
0FA7:  CLRF   42
0FA8:  CLRF   41
0FA9:  CLRF   40
0FAA:  MOVF   39,W
0FAB:  MOVWF  3F
0FAC:  MOVLW  0A
0FAD:  MOVWF  43
0FAE:  CLRF   45
0FAF:  MOVLW  7B
0FB0:  MOVWF  44
0FB1:  BCF    0A.3
0FB2:  BCF    03.6
0FB3:  CALL   3F5
0FB4:  BSF    0A.3
....................     PRINTF (" * @"); 
0FB5:  MOVLW  55
0FB6:  BSF    03.6
0FB7:  MOVWF  0D
0FB8:  MOVLW  01
0FB9:  MOVWF  0F
0FBA:  BCF    03.6
0FBB:  CALL   6CF
....................     PRINTF (TEMP_CHAR2); 
0FBC:  MOVLW  7B
0FBD:  MOVWF  04
0FBE:  BCF    03.7
0FBF:  BCF    0A.3
0FC0:  CALL   784
0FC1:  BSF    0A.3
....................     PRINTF ("@SS@"); 
0FC2:  MOVLW  58
0FC3:  BSF    03.6
0FC4:  MOVWF  0D
0FC5:  MOVLW  01
0FC6:  MOVWF  0F
0FC7:  BCF    03.6
0FC8:  CALL   6CF
....................     FOR (I = 0; I < 2 + SOLUONGCAMBIEN_CONFIG; I++) 
0FC9:  BSF    03.6
0FCA:  CLRF   3A
0FCB:  MOVLW  02
0FCC:  BCF    03.6
0FCD:  ADDWF  4A,W
0FCE:  BSF    03.6
0FCF:  SUBWF  3A,W
0FD0:  BTFSC  03.0
0FD1:  GOTO   7EC
....................     { 
....................        PRINTF (PACKAGE_SS[I]); 
0FD2:  BCF    03.0
0FD3:  RLF    3A,W
0FD4:  ADDLW  10
0FD5:  MOVWF  04
0FD6:  BSF    03.7
0FD7:  INCF   04,F
0FD8:  MOVF   00,W
0FD9:  MOVWF  3C
0FDA:  DECF   04,F
0FDB:  MOVF   00,W
0FDC:  MOVWF  3B
0FDD:  MOVWF  04
0FDE:  BCF    03.7
0FDF:  BTFSC  3C.0
0FE0:  BSF    03.7
0FE1:  BCF    0A.3
0FE2:  BCF    03.6
0FE3:  CALL   784
0FE4:  BSF    0A.3
....................        PRINTF ("@"); 
0FE5:  MOVLW  40
0FE6:  BTFSS  0C.4
0FE7:  GOTO   7E6
0FE8:  MOVWF  19
0FE9:  BSF    03.6
0FEA:  INCF   3A,F
0FEB:  GOTO   7CB
....................     } 
....................  
....................     PRINTF ("#"); 
0FEC:  MOVLW  23
0FED:  BCF    03.6
0FEE:  BTFSS  0C.4
0FEF:  GOTO   7EE
0FF0:  MOVWF  19
....................     OUTPUT_TOGGLE (PIN_C4) ; 
0FF1:  BCF    31.4
0FF2:  MOVF   31,W
0FF3:  BSF    03.5
0FF4:  MOVWF  07
0FF5:  MOVLW  10
0FF6:  BCF    03.5
0FF7:  XORWF  07,F
0FF8:  BCF    0A.3
0FF9:  BSF    0A.4
0FFA:  GOTO   2B6 (RETURN)
....................  } 
....................  
....................  
....................  
....................  
....................  VOID XU_LY_UART () 
*
0C15:  MOVLW  2A
0C16:  BSF    03.6
0C17:  MOVWF  10
....................  { 
....................     //ID_NODE_NHAN = KYTU[1] - 48; 
....................     //ID_DEVICE_NHAN = KYTU[2] - 48 + 64; 
....................     //TT_DEVICE_NHAN = KYTU[3] - 48; // - 48 ASCII -- > S?. + 64 -- > PORT_D (D0 = 64) 
....................     /* TINH DO DAI*/ 
....................     CHAR CH = '*'; 
....................     CHAR * RET; 
....................     * ID_NODE_NHAN = '\0'; 
0C18:  CLRF   7A
0C19:  MOVLW  5F
0C1A:  MOVWF  04
0C1B:  BCF    03.7
0C1C:  BTFSC  7A.0
0C1D:  BSF    03.7
0C1E:  CLRF   00
....................     * ID_GW_NHAN = '\0'; 
0C1F:  CLRF   7A
0C20:  MOVLW  66
0C21:  MOVWF  04
0C22:  BCF    03.7
0C23:  BTFSC  7A.0
0C24:  BSF    03.7
0C25:  CLRF   00
....................     KYTUCHAR2 = ""; 
0C26:  CLRF   16
0C27:  CLRF   17
0C28:  MOVLW  D2
0C29:  MOVWF  04
0C2A:  BCF    03.7
0C2B:  MOVF   16,W
0C2C:  ADDWF  04,F
0C2D:  MOVF   17,W
0C2E:  BCF    0A.3
0C2F:  BCF    03.6
0C30:  CALL   06A
0C31:  BSF    0A.3
0C32:  MOVWF  00
0C33:  IORLW  00
0C34:  BTFSC  03.2
0C35:  GOTO   43B
0C36:  BSF    03.6
0C37:  INCF   17,F
0C38:  INCF   16,F
0C39:  GOTO   428
0C3A:  BCF    03.6
....................     UNSIGNED INT8 LEN_RET; 
....................     RET = STRCHR (KYTUCHAR, CH); 
0C3B:  BSF    03.6
0C3C:  CLRF   17
0C3D:  MOVLW  A0
0C3E:  MOVWF  16
0C3F:  MOVF   10,W
0C40:  MOVWF  18
*
0C62:  MOVF   79,W
0C63:  MOVWF  12
0C64:  MOVF   78,W
0C65:  MOVWF  11
....................     LEN_RET = STRLEN (RET); 
0C66:  MOVF   12,W
0C67:  MOVWF  17
0C68:  MOVF   11,W
0C69:  MOVWF  16
*
0C87:  MOVF   78,W
0C88:  MOVWF  13
....................  
....................     /* LAY TOKEN DAU TIEN */ 
....................     KYTU = 0; 
0C89:  BCF    03.6
0C8A:  CLRF   3A
....................     TEMP_CHAR = "#"; 
0C8B:  BSF    03.6
0C8C:  CLRF   16
0C8D:  CLRF   17
0C8E:  MOVLW  6F
0C8F:  MOVWF  04
0C90:  BCF    03.7
0C91:  MOVF   16,W
0C92:  ADDWF  04,F
0C93:  MOVF   17,W
0C94:  BCF    0A.3
0C95:  BCF    03.6
0C96:  CALL   064
0C97:  BSF    0A.3
0C98:  MOVWF  00
0C99:  IORLW  00
0C9A:  BTFSC  03.2
0C9B:  GOTO   4A1
0C9C:  BSF    03.6
0C9D:  INCF   17,F
0C9E:  INCF   16,F
0C9F:  GOTO   48E
0CA0:  BCF    03.6
....................     CHAR * TOKEN; 
....................     TOKEN = STRTOK (KYTUCHAR, TEMP_CHAR); 
0CA1:  BSF    03.6
0CA2:  CLRF   19
0CA3:  MOVLW  A0
0CA4:  MOVWF  18
0CA5:  CLRF   1B
0CA6:  MOVLW  6F
0CA7:  MOVWF  1A
0CA8:  BCF    03.6
0CA9:  CALL   138
0CAA:  MOVF   79,W
0CAB:  BSF    03.6
0CAC:  MOVWF  15
0CAD:  MOVF   78,W
0CAE:  MOVWF  14
....................  
....................     /* DUYET QUA CAC TOKEN CON LAI */ 
....................     WHILE (TOKEN != NULL) 
0CAF:  MOVF   14,F
0CB0:  BTFSS  03.2
0CB1:  GOTO   4B5
0CB2:  MOVF   15,F
0CB3:  BTFSC  03.2
0CB4:  GOTO   508
....................     { 
....................        SWITCH (KYTU) 
0CB5:  BCF    03.6
0CB6:  MOVF   3A,W
0CB7:  ADDLW  FA
0CB8:  BTFSC  03.0
0CB9:  GOTO   4F7
0CBA:  ADDLW  06
0CBB:  GOTO   641
....................        { 
....................           CASE 0: 
....................           BREAK; 
0CBC:  GOTO   4F7
....................  
....................           CASE 1: 
....................           STRCAT (ID_GW_NHAN, TOKEN); 
0CBD:  BSF    03.6
0CBE:  CLRF   3F
0CBF:  MOVLW  66
0CC0:  MOVWF  3E
0CC1:  MOVF   15,W
0CC2:  MOVWF  41
0CC3:  MOVF   14,W
0CC4:  MOVWF  40
0CC5:  BCF    0A.3
0CC6:  BCF    03.6
0CC7:  CALL   746
0CC8:  BSF    0A.3
....................           BREAK; 
0CC9:  GOTO   4F7
....................  
....................           CASE 2: 
....................           STRCAT (ID_NODE_NHAN, TOKEN); 
0CCA:  BSF    03.6
0CCB:  CLRF   3F
0CCC:  MOVLW  5F
0CCD:  MOVWF  3E
0CCE:  MOVF   15,W
0CCF:  MOVWF  41
0CD0:  MOVF   14,W
0CD1:  MOVWF  40
0CD2:  BCF    0A.3
0CD3:  BCF    03.6
0CD4:  CALL   746
0CD5:  BSF    0A.3
....................           BREAK; 
0CD6:  GOTO   4F7
....................  
....................           CASE 3: 
....................           LENHDIEUKHIEN = ATOI (TOKEN); 
0CD7:  BSF    03.6
0CD8:  MOVF   15,W
0CD9:  MOVWF  19
0CDA:  MOVF   14,W
0CDB:  MOVWF  18
0CDC:  BCF    03.6
0CDD:  CALL   229
0CDE:  MOVF   78,W
0CDF:  MOVWF  47
....................           BREAK; 
0CE0:  GOTO   4F7
....................  
....................           CASE 4: 
....................           DODAI_DATA_NHAN = ATOI (TOKEN); 
0CE1:  BSF    03.6
0CE2:  MOVF   15,W
0CE3:  MOVWF  19
0CE4:  MOVF   14,W
0CE5:  MOVWF  18
0CE6:  BCF    03.6
0CE7:  CALL   229
0CE8:  MOVF   78,W
0CE9:  MOVWF  48
....................           BREAK; 
0CEA:  GOTO   4F7
....................  
....................           CASE 5: 
....................           STRCAT (KYTUCHAR2, TOKEN); 
0CEB:  BSF    03.6
0CEC:  CLRF   3F
0CED:  MOVLW  D2
0CEE:  MOVWF  3E
0CEF:  MOVF   15,W
0CF0:  MOVWF  41
0CF1:  MOVF   14,W
0CF2:  MOVWF  40
0CF3:  BCF    0A.3
0CF4:  BCF    03.6
0CF5:  CALL   746
0CF6:  BSF    0A.3
....................           BREAK; 
....................        } 
....................  
....................        TOKEN = STRTOK (NULL, TEMP_CHAR); 
0CF7:  BSF    03.6
0CF8:  CLRF   19
0CF9:  CLRF   18
0CFA:  CLRF   1B
0CFB:  MOVLW  6F
0CFC:  MOVWF  1A
0CFD:  BCF    03.6
0CFE:  CALL   138
0CFF:  MOVF   79,W
0D00:  BSF    03.6
0D01:  MOVWF  15
0D02:  MOVF   78,W
0D03:  MOVWF  14
....................        KYTU++; 
0D04:  BCF    03.6
0D05:  INCF   3A,F
0D06:  BSF    03.6
0D07:  GOTO   4AF
....................     } 
....................  
....................     /* SO SANH ID returns - 1 IF s1 < s2, 0 if s1 = s2, 1 if s1 > s2 */ 
....................     SOSANH_IDGW = STRCMP (ID_GW_NHAN, ID_GATEWAY_CHAR); 
0D08:  CLRF   17
0D09:  MOVLW  66
0D0A:  MOVWF  16
0D0B:  CLRF   19
0D0C:  MOVLW  56
0D0D:  MOVWF  18
0D0E:  BCF    03.6
0D0F:  CALL   30C
0D10:  MOVF   78,W
0D11:  MOVWF  4C
....................     SOSANH_IDNODE = STRCMP (ID_NODE_NHAN, ID_NODE_CHAR); 
0D12:  BSF    03.6
0D13:  CLRF   17
0D14:  MOVLW  5F
0D15:  MOVWF  16
0D16:  CLRF   19
0D17:  MOVLW  4F
0D18:  MOVWF  18
0D19:  BCF    03.6
0D1A:  CALL   30C
0D1B:  MOVF   78,W
0D1C:  MOVWF  4B
....................      
....................     IF (SOSANH_IDGW == 0&&SOSANH_IDNODE == 0&&LEN_RET == DODAI_DATA_NHAN) 
0D1D:  MOVF   4C,F
0D1E:  BTFSS  03.2
0D1F:  GOTO   637
0D20:  MOVF   4B,F
0D21:  BTFSS  03.2
0D22:  GOTO   637
0D23:  MOVF   48,W
0D24:  BSF    03.6
0D25:  SUBWF  13,W
0D26:  BTFSC  03.2
0D27:  GOTO   52A
0D28:  BCF    03.6
0D29:  GOTO   637
....................     { 
....................        SWITCH (LENHDIEUKHIEN) 
0D2A:  BCF    03.6
0D2B:  MOVF   47,W
0D2C:  BTFSC  03.2
0D2D:  GOTO   535
0D2E:  XORLW  01
0D2F:  BTFSC  03.2
0D30:  GOTO   536
0D31:  XORLW  03
0D32:  BTFSC  03.2
0D33:  GOTO   611
0D34:  GOTO   636
....................        { 
....................           CASE 0: 
....................           BREAK; 
0D35:  GOTO   636
....................  
....................           CASE 1: 
....................           XACNHANCONFIG () ; 
....................           BREAK; 
*
0E10:  GOTO   636
....................  
....................           CASE 2: 
....................           DIEUKHIENTHIETBI () ; 
....................           BREAK; 
....................        } 
....................     } 
*
0E36:  GOTO   63E
....................  
....................     ELSE 
....................     { 
....................        DELAY_MS (10); 
0E37:  MOVLW  0A
0E38:  BSF    03.6
0E39:  MOVWF  41
0E3A:  BCF    0A.3
0E3B:  BCF    03.6
0E3C:  CALL   15B
0E3D:  BSF    0A.3
....................  
....................        /* DATA RCV SAI ID NODE, ID GW HOAC LA SAI DO DAI*/ 
....................     } 
0E3E:  BCF    0A.3
0E3F:  BSF    0A.4
0E40:  GOTO   296 (RETURN)
....................  
....................  } 
....................  
....................  VOID MAIN () 
*
11A9:  MOVF   03,W
11AA:  ANDLW  1F
11AB:  MOVWF  03
11AC:  BSF    03.5
11AD:  BSF    03.6
11AE:  BSF    07.3
11AF:  MOVLW  08
11B0:  BCF    03.6
11B1:  MOVWF  19
11B2:  MOVLW  02
11B3:  MOVWF  1A
11B4:  MOVLW  A6
11B5:  MOVWF  18
11B6:  MOVLW  90
11B7:  BCF    03.5
11B8:  MOVWF  18
11B9:  MOVLW  FF
11BA:  MOVWF  31
11BB:  CLRF   38
11BC:  CLRF   39
11BD:  CLRF   3A
11BE:  CLRF   3B
11BF:  CLRF   46
11C0:  CLRF   47
11C1:  CLRF   48
11C2:  CLRF   49
11C3:  MOVLW  03
11C4:  MOVWF  4A
11C5:  CLRF   4B
11C6:  CLRF   4C
11C7:  BCF    4E.0
11C8:  BCF    4E.1
11C9:  BCF    4E.2
11CA:  BCF    4E.3
11CB:  BCF    4E.4
11CC:  BCF    4E.5
11CD:  BCF    4E.6
11CE:  BCF    4E.7
11CF:  BSF    03.5
11D0:  BSF    03.6
11D1:  MOVF   09,W
11D2:  ANDLW  C0
11D3:  MOVWF  09
11D4:  BCF    03.6
11D5:  BCF    1F.4
11D6:  BCF    1F.5
11D7:  MOVLW  00
11D8:  BSF    03.6
11D9:  MOVWF  08
11DA:  BCF    03.5
11DB:  CLRF   07
11DC:  CLRF   08
11DD:  CLRF   09
11DE:  BCF    03.7
....................  { 
....................     SET_TRIS_D (0XF0); 
*
1252:  MOVLW  F0
1253:  MOVWF  08
....................     SET_TRIS_B (0XFF); 
1254:  MOVLW  FF
1255:  MOVWF  06
....................     SET_TRIS_E (0); 
1256:  BCF    09.0
1257:  BCF    09.1
1258:  BCF    09.2
1259:  BCF    09.3
....................     SET_TRIS_C (0X80); 
125A:  MOVLW  80
125B:  MOVWF  07
125C:  BCF    03.5
125D:  MOVWF  31
....................     SETUP_ADC (ADC_CLOCK_DIV_8); 
125E:  BSF    1F.6
125F:  BCF    1F.7
1260:  BSF    03.5
1261:  BSF    1F.7
1262:  BCF    03.5
1263:  BSF    1F.0
....................     ENABLE_INTERRUPTS (INT_TIMER0); 
1264:  BSF    0B.5
....................     ENABLE_INTERRUPTS (INT_EXT); //CHO PHEP NGAT NGOAI 
1265:  BSF    0B.4
....................     ENABLE_INTERRUPTS (INT_EXT_H2L); //NGAT XAY RA KHI CO XUNG TU CAO XUONG THAP 
1266:  BSF    0B.4
1267:  BSF    03.5
1268:  BCF    01.6
....................     ENABLE_INTERRUPTS (INT_RDA); 
1269:  BSF    0C.5
....................     ENABLE_INTERRUPTS (GLOBAL); 
126A:  MOVLW  C0
126B:  BCF    03.5
126C:  IORWF  0B,F
....................      
....................     SETUP_TIMER_1 (T1_INTERNAL|T1_DIV_BY_8); 
126D:  MOVLW  35
126E:  MOVWF  10
....................     //SET_TIMER1 (0); 
....................     SET_TIMER1 (3036); 
126F:  CLRF   0E
1270:  MOVLW  0B
1271:  MOVWF  0F
1272:  MOVLW  DC
1273:  MOVWF  0E
....................     TMR1IF = 0; 
1274:  BCF    0C.0
....................     LCD_INIT (); // KHOI TAO LCD 
1275:  BCF    0A.4
1276:  GOTO   275
1277:  BSF    0A.4
....................     TT_CONFIG = 0; 
1278:  BCF    4E.1
....................     TT_CONFIG_DONE = 0; 
1279:  BCF    4E.3
....................     TT_CONTROL = 1; 
127A:  BSF    4E.2
....................     OUTPUT_HIGH (PIN_D3) ; 
127B:  BSF    03.5
127C:  BCF    08.3
127D:  BCF    03.5
127E:  BSF    08.3
....................     TTNHAN = 0; 
127F:  BCF    4E.0
....................  
....................  
....................      
....................     WHILE (TRUE) 
....................     { 
....................        IF (TT_CONFIG)   {BUTT_FUN (); } // GOI HAM CHON LENH (SWITCH CASE) 
1280:  BTFSS  4E.1
1281:  GOTO   286
1282:  BCF    0A.4
1283:  GOTO   549
1284:  BSF    0A.4
1285:  GOTO   2C6
....................        ELSE IF (TT_CONFIG_DONE) { CONFIG_DONE (); } 
1286:  BTFSS  4E.3
1287:  GOTO   28E
1288:  BCF    0A.4
1289:  BSF    0A.3
128A:  GOTO   000
128B:  BSF    0A.4
128C:  BCF    0A.3
128D:  GOTO   2C6
....................        ELSE 
....................        { 
....................           WHILE (!TT_CONFIG) 
128E:  BTFSC  4E.1
128F:  GOTO   2C6
....................           { 
....................              IF (TTNHAN == 1) 
1290:  BTFSS  4E.0
1291:  GOTO   298
....................              { 
....................                 TTNHAN = 0; 
1292:  BCF    4E.0
....................                 XU_LY_UART () ; 
1293:  BCF    0A.4
1294:  BSF    0A.3
1295:  GOTO   415
1296:  BSF    0A.4
1297:  BCF    0A.3
....................              } 
....................              IF (TT_CONFIG_OKE_UART == 1) 
1298:  BTFSS  4E.6
1299:  GOTO   2C5
....................              { 
....................                  
....................                IF (TT_SW) 
129A:  BTFSS  4E.7
129B:  GOTO   2A7
....................                { 
....................                   READ_BTN_STATE(); 
129C:  BCF    0A.4
129D:  BSF    0A.3
129E:  GOTO   64B
129F:  BSF    0A.4
12A0:  BCF    0A.3
....................                   TT_SW = 0;              
12A1:  BCF    4E.7
....................                   XUAT_DIEU_KHIEN(); 
12A2:  BCF    0A.4
12A3:  BSF    0A.3
12A4:  CALL   36B
12A5:  BSF    0A.4
12A6:  BCF    0A.3
....................                }                 
....................                 DELAY_MS (100) ; 
12A7:  MOVLW  64
12A8:  BSF    03.6
12A9:  MOVWF  41
12AA:  BCF    0A.4
12AB:  BCF    03.6
12AC:  CALL   15B
12AD:  BSF    0A.4
....................                 READ_ANALOG () ; 
12AE:  GOTO   000
....................  
....................                 IF (KET_QUA_ANALOG[0] > 28) 
12AF:  MOVF   34,W
12B0:  SUBLW  1C
12B1:  BTFSC  03.0
12B2:  GOTO   2C5
....................                 { 
....................                    SEND_ANALOG_UART () ; 
12B3:  BCF    0A.4
12B4:  BSF    0A.3
12B5:  GOTO   721
12B6:  BSF    0A.4
12B7:  BCF    0A.3
....................                    DELAY_MS (2000) ; 
12B8:  MOVLW  08
12B9:  BSF    03.6
12BA:  MOVWF  10
12BB:  MOVLW  FA
12BC:  MOVWF  41
12BD:  BCF    0A.4
12BE:  BCF    03.6
12BF:  CALL   15B
12C0:  BSF    0A.4
12C1:  BSF    03.6
12C2:  DECFSZ 10,F
12C3:  GOTO   2BB
12C4:  BCF    03.6
....................                 } 
....................              } 
12C5:  GOTO   28E
....................           } 
....................        } 
12C6:  GOTO   280
....................     } 
....................  } 
....................  
12C7:  SLEEP

Configuration Fuses:
   Word  1: 2FE2   HS NOWDT PUT MCLR NOPROTECT NOCPD BROWNOUT IESO FCMEN NOLVP NODEBUG
   Word  2: 3FFF   BORV40 NOWRT
