CCS PCM C Compiler, Version 5.015, 5967               01-Nov-21 02:03

               Filename:   E:\DATN_V2\NODE\pic\pic16f887\hellopic.lst

               ROM used:   4837 words (59%)
                           Largest free fragment is 2048
               RAM used:   144 (39%) at main() level
                           278 (76%) worst case
               Stack used: 7 locations (6 in main + 1 for interrupts)
               Stack size: 8

*
0000:  MOVLW  12
0001:  MOVWF  0A
0002:  GOTO   2E6
0003:  NOP
0004:  MOVWF  7F
0005:  SWAPF  03,W
0006:  CLRF   03
0007:  MOVWF  21
0008:  MOVF   0A,W
0009:  MOVWF  20
000A:  CLRF   0A
000B:  MOVF   04,W
000C:  MOVWF  22
000D:  MOVF   77,W
000E:  MOVWF  23
000F:  MOVF   78,W
0010:  MOVWF  24
0011:  MOVF   79,W
0012:  MOVWF  25
0013:  MOVF   7A,W
0014:  MOVWF  26
0015:  BSF    03.6
0016:  MOVF   0D,W
0017:  BCF    03.6
0018:  MOVWF  27
0019:  BSF    03.6
001A:  MOVF   0F,W
001B:  BCF    03.6
001C:  MOVWF  28
001D:  BSF    03.6
001E:  MOVF   0C,W
001F:  BCF    03.6
0020:  MOVWF  29
0021:  BSF    03.6
0022:  MOVF   0E,W
0023:  BCF    03.6
0024:  MOVWF  2A
0025:  BCF    03.7
0026:  BCF    03.5
0027:  BTFSS  0B.4
0028:  GOTO   02B
0029:  BTFSC  0B.1
002A:  GOTO   052
002B:  MOVLW  8C
002C:  MOVWF  04
002D:  BTFSS  00.5
002E:  GOTO   031
002F:  BTFSC  0C.5
0030:  GOTO   055
0031:  MOVF   22,W
0032:  MOVWF  04
0033:  MOVF   23,W
0034:  MOVWF  77
0035:  MOVF   24,W
0036:  MOVWF  78
0037:  MOVF   25,W
0038:  MOVWF  79
0039:  MOVF   26,W
003A:  MOVWF  7A
003B:  MOVF   27,W
003C:  BSF    03.6
003D:  MOVWF  0D
003E:  BCF    03.6
003F:  MOVF   28,W
0040:  BSF    03.6
0041:  MOVWF  0F
0042:  BCF    03.6
0043:  MOVF   29,W
0044:  BSF    03.6
0045:  MOVWF  0C
0046:  BCF    03.6
0047:  MOVF   2A,W
0048:  BSF    03.6
0049:  MOVWF  0E
004A:  BCF    03.6
004B:  MOVF   20,W
004C:  MOVWF  0A
004D:  SWAPF  21,W
004E:  MOVWF  03
004F:  SWAPF  7F,F
0050:  SWAPF  7F,W
0051:  RETFIE
0052:  BCF    0A.3
0053:  BCF    0A.4
0054:  GOTO   0EF
0055:  BCF    0A.3
0056:  BCF    0A.4
0057:  GOTO   128
....................  
.................... #INCLUDE <thuvien.c> 
.................... #INCLUDE <16F887.H> 
.................... //////////// Standard Header file for the PIC16F887 device //////////////// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2013 Custom Computer Services          //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... #device PIC16F887 
0058:  BCF    0A.0
0059:  BCF    0A.1
005A:  BCF    0A.2
005B:  ADDWF  02,F
005C:  RETLW  30
005D:  RETLW  00
005E:  BCF    0A.0
005F:  BCF    0A.1
0060:  BCF    0A.2
0061:  ADDWF  02,F
0062:  RETLW  5F
0063:  RETLW  00
0064:  BCF    0A.0
0065:  BCF    0A.1
0066:  BCF    0A.2
0067:  ADDWF  02,F
0068:  RETLW  23
0069:  RETLW  00
006A:  BCF    0A.0
006B:  BCF    0A.1
006C:  BCF    0A.2
006D:  ADDWF  02,F
006E:  RETLW  00
006F:  DATA CE,27
0070:  DATA C4,22
0071:  DATA 3A,10
0072:  DATA 00,00
0073:  DATA 30,18
0074:  DATA 30,18
0075:  DATA 20,10
0076:  DATA 20,10
0077:  DATA 20,10
0078:  DATA 20,10
0079:  DATA 20,10
007A:  DATA 00,01
007B:  DATA 20,10
007C:  DATA 20,10
007D:  DATA 20,10
007E:  DATA 5F,10
007F:  DATA 20,10
0080:  DATA 20,10
0081:  DATA 20,10
0082:  DATA 20,10
0083:  DATA 20,10
0084:  DATA 20,10
0085:  DATA 20,00
0086:  DATA 20,10
0087:  DATA 20,10
0088:  DATA 5F,10
0089:  DATA 20,10
008A:  DATA 20,00
008B:  DATA 49,22
008C:  DATA DF,23
008D:  DATA 57,1D
008E:  DATA 00,01
008F:  DATA 30,18
0090:  DATA 30,18
0091:  DATA 30,18
0092:  DATA 20,10
0093:  DATA 20,10
0094:  DATA 20,10
0095:  DATA 20,10
0096:  DATA 00,01
0097:  DATA 20,10
0098:  DATA 20,10
0099:  DATA 20,10
009A:  DATA 5F,10
009B:  DATA 20,10
009C:  DATA 20,10
009D:  DATA 20,10
009E:  DATA 20,10
009F:  DATA 20,10
00A0:  DATA 20,10
00A1:  DATA 20,10
00A2:  DATA 20,00
00A3:  DATA 20,10
00A4:  DATA 20,10
00A5:  DATA 5F,10
00A6:  DATA 20,10
00A7:  DATA 20,10
00A8:  DATA 20,10
00A9:  DATA 20,00
00AA:  DATA C3,27
00AB:  DATA 4E,23
00AC:  DATA C9,23
00AD:  DATA 3A,10
00AE:  DATA 20,10
00AF:  DATA 20,10
00B0:  DATA 20,10
00B1:  DATA 20,00
00B2:  DATA C3,20
00B3:  DATA D3,22
00B4:  DATA 3A,10
00B5:  DATA 20,10
00B6:  DATA 20,10
00B7:  DATA 20,10
00B8:  DATA 20,10
00B9:  DATA 20,00
00BA:  DATA A0,16
00BB:  DATA A0,24
00BC:  DATA C4,16
00BD:  DATA CE,27
00BE:  DATA C4,22
00BF:  DATA 20,10
00C0:  DATA 20,10
00C1:  DATA 20,10
00C2:  DATA 00,01
00C3:  DATA A0,16
00C4:  DATA A0,24
00C5:  DATA C4,16
00C6:  DATA C7,2B
00C7:  DATA 20,10
00C8:  DATA 20,10
00C9:  DATA 20,10
00CA:  DATA 20,00
00CB:  DATA D7,20
00CC:  DATA 49,2A
00CD:  DATA 49,27
00CE:  DATA 47,10
00CF:  DATA 2E,17
00D0:  DATA 2E,17
00D1:  DATA 20,10
00D2:  DATA 20,10
00D3:  DATA 20,10
00D4:  DATA 20,10
00D5:  DATA 00,01
00D6:  DATA D7,20
00D7:  DATA 49,2A
00D8:  DATA 49,27
00D9:  DATA 47,10
00DA:  DATA 2E,17
00DB:  DATA 2E,17
00DC:  DATA 20,10
00DD:  DATA 20,10
00DE:  DATA 20,10
00DF:  DATA 20,10
00E0:  DATA 00,00
00E1:  DATA 20,10
00E2:  DATA 20,10
00E3:  DATA 20,10
00E4:  DATA 20,10
00E5:  DATA 20,10
00E6:  DATA 20,10
00E7:  DATA 00,01
00E8:  DATA 54,21
00E9:  DATA 3A,10
00EA:  DATA 00,01
00EB:  DATA 20,10
00EC:  DATA 20,10
00ED:  DATA 43,21
00EE:  DATA 3A,00
*
0145:  DATA 68,10
0146:  DATA 20,10
0147:  DATA 20,10
0148:  DATA 20,10
0149:  DATA 20,10
014A:  DATA 20,10
014B:  DATA 20,10
014C:  DATA 20,10
014D:  DATA 20,10
014E:  DATA 20,10
014F:  DATA 20,10
0150:  DATA 00,01
0151:  DATA 20,10
0152:  DATA 20,10
0153:  DATA 20,10
0154:  DATA 20,10
0155:  DATA 20,10
0156:  DATA 20,10
0157:  DATA 20,10
0158:  DATA 20,10
0159:  DATA 20,00
015A:  DATA 20,10
015B:  DATA 20,10
015C:  DATA 20,10
015D:  DATA 20,10
015E:  DATA 20,10
015F:  DATA 20,10
0160:  DATA 20,10
0161:  DATA 20,10
0162:  DATA 20,00
*
033B:  MOVF   0B,W
033C:  BSF    03.6
033D:  MOVWF  3B
033E:  BCF    03.6
033F:  BCF    0B.7
0340:  BSF    03.5
0341:  BSF    03.6
0342:  BSF    0C.7
0343:  BSF    0C.0
0344:  NOP
0345:  NOP
0346:  BCF    03.5
0347:  BTFSS  3B.7
0348:  GOTO   34C
0349:  BCF    03.6
034A:  BSF    0B.7
034B:  BSF    03.6
034C:  MOVF   0C,W
034D:  ANDLW  7F
034E:  BTFSC  03.2
034F:  GOTO   389
0350:  MOVWF  3B
0351:  MOVF   0D,W
0352:  MOVWF  3C
0353:  MOVF   0F,W
0354:  MOVWF  3D
0355:  MOVF   3B,W
0356:  MOVWF  3F
0357:  BCF    03.6
0358:  CALL   301
0359:  BSF    03.6
035A:  MOVF   3C,W
035B:  MOVWF  0D
035C:  MOVF   3D,W
035D:  MOVWF  0F
035E:  BCF    03.6
035F:  MOVF   0B,W
0360:  BSF    03.6
0361:  MOVWF  3E
0362:  BCF    03.6
0363:  BCF    0B.7
0364:  BSF    03.5
0365:  BSF    03.6
0366:  BSF    0C.7
0367:  BSF    0C.0
0368:  NOP
0369:  NOP
036A:  BCF    03.5
036B:  BTFSS  3E.7
036C:  GOTO   370
036D:  BCF    03.6
036E:  BSF    0B.7
036F:  BSF    03.6
0370:  RLF    0C,W
0371:  RLF    0E,W
0372:  ANDLW  7F
0373:  BTFSC  03.2
0374:  GOTO   389
0375:  MOVWF  3B
0376:  MOVF   0D,W
0377:  MOVWF  3C
0378:  MOVF   0F,W
0379:  MOVWF  3D
037A:  MOVF   3B,W
037B:  MOVWF  3F
037C:  BCF    03.6
037D:  CALL   301
037E:  BSF    03.6
037F:  MOVF   3C,W
0380:  MOVWF  0D
0381:  MOVF   3D,W
0382:  MOVWF  0F
0383:  INCF   0D,F
0384:  BTFSC  03.2
0385:  INCF   0F,F
0386:  BCF    03.6
0387:  GOTO   33B
0388:  BSF    03.6
0389:  BCF    03.6
038A:  RETURN
038B:  BTFSC  03.1
038C:  GOTO   390
038D:  MOVLW  5B
038E:  MOVWF  04
038F:  BSF    03.7
0390:  BSF    03.6
0391:  MOVF   56,W
0392:  XORWF  5A,W
0393:  ANDLW  80
0394:  MOVWF  60
0395:  BTFSS  56.7
0396:  GOTO   3A2
0397:  COMF   53,F
0398:  COMF   54,F
0399:  COMF   55,F
039A:  COMF   56,F
039B:  INCF   53,F
039C:  BTFSC  03.2
039D:  INCF   54,F
039E:  BTFSC  03.2
039F:  INCF   55,F
03A0:  BTFSC  03.2
03A1:  INCF   56,F
03A2:  BTFSS  5A.7
03A3:  GOTO   3AF
03A4:  COMF   57,F
03A5:  COMF   58,F
03A6:  COMF   59,F
03A7:  COMF   5A,F
03A8:  INCF   57,F
03A9:  BTFSC  03.2
03AA:  INCF   58,F
03AB:  BTFSC  03.2
03AC:  INCF   59,F
03AD:  BTFSC  03.2
03AE:  INCF   5A,F
03AF:  CLRF   77
03B0:  CLRF   78
03B1:  CLRF   79
03B2:  CLRF   7A
03B3:  CLRF   5B
03B4:  CLRF   5C
03B5:  CLRF   5D
03B6:  CLRF   5E
03B7:  MOVF   5A,W
03B8:  IORWF  59,W
03B9:  IORWF  58,W
03BA:  IORWF  57,W
03BB:  BTFSC  03.2
03BC:  GOTO   3ED
03BD:  MOVLW  20
03BE:  MOVWF  5F
03BF:  BCF    03.0
03C0:  RLF    53,F
03C1:  RLF    54,F
03C2:  RLF    55,F
03C3:  RLF    56,F
03C4:  RLF    5B,F
03C5:  RLF    5C,F
03C6:  RLF    5D,F
03C7:  RLF    5E,F
03C8:  MOVF   5A,W
03C9:  SUBWF  5E,W
03CA:  BTFSS  03.2
03CB:  GOTO   3D6
03CC:  MOVF   59,W
03CD:  SUBWF  5D,W
03CE:  BTFSS  03.2
03CF:  GOTO   3D6
03D0:  MOVF   58,W
03D1:  SUBWF  5C,W
03D2:  BTFSS  03.2
03D3:  GOTO   3D6
03D4:  MOVF   57,W
03D5:  SUBWF  5B,W
03D6:  BTFSS  03.0
03D7:  GOTO   3E7
03D8:  MOVF   57,W
03D9:  SUBWF  5B,F
03DA:  MOVF   58,W
03DB:  BTFSS  03.0
03DC:  INCFSZ 58,W
03DD:  SUBWF  5C,F
03DE:  MOVF   59,W
03DF:  BTFSS  03.0
03E0:  INCFSZ 59,W
03E1:  SUBWF  5D,F
03E2:  MOVF   5A,W
03E3:  BTFSS  03.0
03E4:  INCFSZ 5A,W
03E5:  SUBWF  5E,F
03E6:  BSF    03.0
03E7:  RLF    77,F
03E8:  RLF    78,F
03E9:  RLF    79,F
03EA:  RLF    7A,F
03EB:  DECFSZ 5F,F
03EC:  GOTO   3BF
03ED:  BTFSS  60.7
03EE:  GOTO   3FA
03EF:  COMF   77,F
03F0:  COMF   78,F
03F1:  COMF   79,F
03F2:  COMF   7A,F
03F3:  INCF   77,F
03F4:  BTFSC  03.2
03F5:  INCF   78,F
03F6:  BTFSC  03.2
03F7:  INCF   79,F
03F8:  BTFSC  03.2
03F9:  INCF   7A,F
03FA:  MOVF   5B,W
03FB:  MOVWF  00
03FC:  INCF   04,F
03FD:  MOVF   5C,W
03FE:  MOVWF  00
03FF:  INCF   04,F
0400:  MOVF   5D,W
0401:  MOVWF  00
0402:  INCF   04,F
0403:  MOVF   5E,W
0404:  MOVWF  00
0405:  BCF    03.6
0406:  RETURN
*
0420:  MOVLW  20
0421:  MOVWF  57
0422:  CLRF   53
0423:  CLRF   54
0424:  CLRF   55
0425:  CLRF   56
0426:  MOVF   4E,W
0427:  MOVWF  7A
0428:  MOVF   4D,W
0429:  MOVWF  79
042A:  MOVF   4C,W
042B:  MOVWF  78
042C:  MOVF   4B,W
042D:  MOVWF  77
042E:  BCF    03.0
042F:  BTFSS  77.0
0430:  GOTO   43F
0431:  MOVF   4F,W
0432:  ADDWF  53,F
0433:  MOVF   50,W
0434:  BTFSC  03.0
0435:  INCFSZ 50,W
0436:  ADDWF  54,F
0437:  MOVF   51,W
0438:  BTFSC  03.0
0439:  INCFSZ 51,W
043A:  ADDWF  55,F
043B:  MOVF   52,W
043C:  BTFSC  03.0
043D:  INCFSZ 52,W
043E:  ADDWF  56,F
043F:  RRF    56,F
0440:  RRF    55,F
0441:  RRF    54,F
0442:  RRF    53,F
0443:  RRF    7A,F
0444:  RRF    79,F
0445:  RRF    78,F
0446:  RRF    77,F
0447:  DECFSZ 57,F
0448:  GOTO   42E
*
0527:  MOVF   00,F
0528:  BTFSC  03.2
0529:  GOTO   543
052A:  BSF    03.6
052B:  CLRF   3E
052C:  MOVF   04,W
052D:  MOVWF  3D
052E:  BCF    3E.0
052F:  BTFSC  03.7
0530:  BSF    3E.0
0531:  MOVF   00,W
0532:  MOVWF  3F
0533:  BCF    03.6
0534:  CALL   301
0535:  BSF    03.6
0536:  MOVF   3D,W
0537:  MOVWF  04
0538:  BCF    03.7
0539:  BTFSC  3E.0
053A:  BSF    03.7
053B:  INCF   04,F
053C:  BTFSS  03.2
053D:  GOTO   541
053E:  BCF    03.6
053F:  INCF   05,F
0540:  BSF    03.6
0541:  BCF    03.6
0542:  GOTO   527
0543:  RETURN
0544:  BSF    03.5
0545:  MOVF   55,W
0546:  CLRF   78
0547:  SUBWF  54,W
0548:  BTFSC  03.0
0549:  GOTO   54D
054A:  MOVF   54,W
054B:  MOVWF  77
054C:  GOTO   559
054D:  CLRF   77
054E:  MOVLW  08
054F:  MOVWF  56
0550:  RLF    54,F
0551:  RLF    77,F
0552:  MOVF   55,W
0553:  SUBWF  77,W
0554:  BTFSC  03.0
0555:  MOVWF  77
0556:  RLF    78,F
0557:  DECFSZ 56,F
0558:  GOTO   550
0559:  BCF    03.5
055A:  RETURN
*
07D6:  MOVF   00,F
07D7:  BTFSC  03.2
07D8:  GOTO   7F3
07D9:  BSF    03.6
07DA:  CLRF   3E
07DB:  MOVF   04,W
07DC:  MOVWF  3D
07DD:  BCF    3E.0
07DE:  BTFSC  03.7
07DF:  BSF    3E.0
07E0:  MOVF   00,W
07E1:  BCF    03.6
07E2:  BTFSS  0C.4
07E3:  GOTO   7E2
07E4:  MOVWF  19
07E5:  BSF    03.6
07E6:  MOVF   3D,W
07E7:  MOVWF  04
07E8:  BCF    03.7
07E9:  BTFSC  3E.0
07EA:  BSF    03.7
07EB:  INCF   04,F
07EC:  BTFSS  03.2
07ED:  GOTO   7F1
07EE:  BCF    03.6
07EF:  INCF   05,F
07F0:  BSF    03.6
07F1:  BCF    03.6
07F2:  GOTO   7D6
07F3:  RETURN
*
0AEB:  CLRF   77
0AEC:  CLRF   78
0AED:  MOVF   5F,W
0AEE:  BCF    03.0
0AEF:  BTFSC  60.0
0AF0:  ADDWF  77,F
0AF1:  RRF    77,F
0AF2:  RRF    78,F
0AF3:  BTFSC  60.1
0AF4:  ADDWF  77,F
0AF5:  RRF    77,F
0AF6:  RRF    78,F
0AF7:  BTFSC  60.2
0AF8:  ADDWF  77,F
0AF9:  RRF    77,F
0AFA:  RRF    78,F
0AFB:  BTFSC  60.3
0AFC:  ADDWF  77,F
0AFD:  RRF    77,F
0AFE:  RRF    78,F
0AFF:  BTFSC  60.4
0B00:  ADDWF  77,F
0B01:  RRF    77,F
0B02:  RRF    78,F
0B03:  BTFSC  60.5
0B04:  ADDWF  77,F
0B05:  RRF    77,F
0B06:  RRF    78,F
0B07:  BTFSC  60.6
0B08:  ADDWF  77,F
0B09:  RRF    77,F
0B0A:  RRF    78,F
0B0B:  BTFSC  60.7
0B0C:  ADDWF  77,F
0B0D:  RRF    77,F
0B0E:  RRF    78,F
*
0BC4:  BSF    03.5
0BC5:  MOVF   58,W
0BC6:  ANDLW  07
0BC7:  MOVWF  77
0BC8:  RRF    58,W
0BC9:  MOVWF  78
0BCA:  RRF    78,F
0BCB:  RRF    78,F
0BCC:  MOVLW  1F
0BCD:  ANDWF  78,F
0BCE:  MOVF   78,W
0BCF:  ADDWF  5A,W
0BD0:  MOVWF  04
0BD1:  BCF    03.7
0BD2:  BTFSC  5B.0
0BD3:  BSF    03.7
0BD4:  CLRF   78
0BD5:  INCF   78,F
0BD6:  INCF   77,F
0BD7:  GOTO   3D9
0BD8:  RLF    78,F
0BD9:  DECFSZ 77,F
0BDA:  GOTO   3D8
0BDB:  MOVF   59,F
0BDC:  BTFSC  03.2
0BDD:  GOTO   3E1
0BDE:  MOVF   78,W
0BDF:  IORWF  00,F
0BE0:  GOTO   3E4
0BE1:  COMF   78,F
0BE2:  MOVF   78,W
0BE3:  ANDWF  00,F
0BE4:  BCF    03.5
0BE5:  RETURN
*
0F0D:  BSF    0A.0
0F0E:  BSF    0A.1
0F0F:  BSF    0A.2
0F10:  ADDWF  02,F
0F11:  GOTO   47B
0F12:  GOTO   47C
0F13:  GOTO   491
0F14:  GOTO   4A6
0F15:  GOTO   4B0
0F16:  GOTO   4BA
*
107B:  MOVLW  8E
107C:  MOVWF  77
107D:  MOVF   5D,W
107E:  MOVWF  78
107F:  MOVF   5C,W
1080:  MOVWF  79
1081:  CLRF   7A
1082:  MOVF   78,F
1083:  BTFSS  03.2
1084:  GOTO   08F
1085:  MOVF   79,W
1086:  MOVWF  78
1087:  CLRF   79
1088:  MOVLW  08
1089:  SUBWF  77,F
108A:  MOVF   78,F
108B:  BTFSS  03.2
108C:  GOTO   08F
108D:  CLRF   77
108E:  GOTO   097
108F:  BCF    03.0
1090:  BTFSC  78.7
1091:  GOTO   096
1092:  RLF    79,F
1093:  RLF    78,F
1094:  DECF   77,F
1095:  GOTO   08F
1096:  BCF    78.7
*
10A7:  MOVF   5C,W
10A8:  BTFSC  03.2
10A9:  GOTO   16C
10AA:  MOVWF  68
10AB:  MOVF   60,W
10AC:  BTFSC  03.2
10AD:  GOTO   16C
10AE:  SUBWF  68,F
10AF:  BTFSS  03.0
10B0:  GOTO   0B6
10B1:  MOVLW  7F
10B2:  ADDWF  68,F
10B3:  BTFSC  03.0
10B4:  GOTO   16C
10B5:  GOTO   0BC
10B6:  MOVLW  81
10B7:  SUBWF  68,F
10B8:  BTFSS  03.0
10B9:  GOTO   16C
10BA:  BTFSC  03.2
10BB:  GOTO   16C
10BC:  MOVF   68,W
10BD:  MOVWF  77
10BE:  CLRF   78
10BF:  CLRF   79
10C0:  CLRF   7A
10C1:  CLRF   67
10C2:  MOVF   5D,W
10C3:  MOVWF  66
10C4:  BSF    66.7
10C5:  MOVF   5E,W
10C6:  MOVWF  65
10C7:  MOVF   5F,W
10C8:  MOVWF  64
10C9:  MOVLW  19
10CA:  MOVWF  68
10CB:  MOVF   63,W
10CC:  SUBWF  64,F
10CD:  BTFSC  03.0
10CE:  GOTO   0DF
10CF:  MOVLW  01
10D0:  SUBWF  65,F
10D1:  BTFSC  03.0
10D2:  GOTO   0DF
10D3:  SUBWF  66,F
10D4:  BTFSC  03.0
10D5:  GOTO   0DF
10D6:  SUBWF  67,F
10D7:  BTFSC  03.0
10D8:  GOTO   0DF
10D9:  INCF   67,F
10DA:  INCF   66,F
10DB:  INCF   65,F
10DC:  MOVF   63,W
10DD:  ADDWF  64,F
10DE:  GOTO   111
10DF:  MOVF   62,W
10E0:  SUBWF  65,F
10E1:  BTFSC  03.0
10E2:  GOTO   0FA
10E3:  MOVLW  01
10E4:  SUBWF  66,F
10E5:  BTFSC  03.0
10E6:  GOTO   0FA
10E7:  SUBWF  67,F
10E8:  BTFSC  03.0
10E9:  GOTO   0FA
10EA:  INCF   67,F
10EB:  INCF   66,F
10EC:  MOVF   62,W
10ED:  ADDWF  65,F
10EE:  MOVF   63,W
10EF:  ADDWF  64,F
10F0:  BTFSS  03.0
10F1:  GOTO   111
10F2:  INCF   65,F
10F3:  BTFSS  03.2
10F4:  GOTO   111
10F5:  INCF   66,F
10F6:  BTFSS  03.2
10F7:  GOTO   111
10F8:  INCF   67,F
10F9:  GOTO   111
10FA:  MOVF   61,W
10FB:  IORLW  80
10FC:  SUBWF  66,F
10FD:  BTFSC  03.0
10FE:  GOTO   110
10FF:  MOVLW  01
1100:  SUBWF  67,F
1101:  BTFSC  03.0
1102:  GOTO   110
1103:  INCF   67,F
1104:  MOVF   61,W
1105:  IORLW  80
1106:  ADDWF  66,F
1107:  MOVF   62,W
1108:  ADDWF  65,F
1109:  BTFSS  03.0
110A:  GOTO   0EE
110B:  INCF   66,F
110C:  BTFSS  03.2
110D:  GOTO   0EE
110E:  INCF   67,F
110F:  GOTO   0EE
1110:  BSF    7A.0
1111:  DECFSZ 68,F
1112:  GOTO   114
1113:  GOTO   11F
1114:  BCF    03.0
1115:  RLF    64,F
1116:  RLF    65,F
1117:  RLF    66,F
1118:  RLF    67,F
1119:  BCF    03.0
111A:  RLF    7A,F
111B:  RLF    79,F
111C:  RLF    78,F
111D:  RLF    69,F
111E:  GOTO   0CB
111F:  BTFSS  69.0
1120:  GOTO   127
1121:  BCF    03.0
1122:  RRF    78,F
1123:  RRF    79,F
1124:  RRF    7A,F
1125:  RRF    69,F
1126:  GOTO   12A
1127:  DECF   77,F
1128:  BTFSC  03.2
1129:  GOTO   16C
112A:  BTFSC  69.7
112B:  GOTO   153
112C:  BCF    03.0
112D:  RLF    64,F
112E:  RLF    65,F
112F:  RLF    66,F
1130:  RLF    67,F
1131:  MOVF   63,W
1132:  SUBWF  64,F
1133:  BTFSC  03.0
1134:  GOTO   13F
1135:  MOVLW  01
1136:  SUBWF  65,F
1137:  BTFSC  03.0
1138:  GOTO   13F
1139:  SUBWF  66,F
113A:  BTFSC  03.0
113B:  GOTO   13F
113C:  SUBWF  67,F
113D:  BTFSS  03.0
113E:  GOTO   162
113F:  MOVF   62,W
1140:  SUBWF  65,F
1141:  BTFSC  03.0
1142:  GOTO   14A
1143:  MOVLW  01
1144:  SUBWF  66,F
1145:  BTFSC  03.0
1146:  GOTO   14A
1147:  SUBWF  67,F
1148:  BTFSS  03.0
1149:  GOTO   162
114A:  MOVF   61,W
114B:  IORLW  80
114C:  SUBWF  66,F
114D:  BTFSC  03.0
114E:  GOTO   153
114F:  MOVLW  01
1150:  SUBWF  67,F
1151:  BTFSS  03.0
1152:  GOTO   162
1153:  INCF   7A,F
1154:  BTFSS  03.2
1155:  GOTO   162
1156:  INCF   79,F
1157:  BTFSS  03.2
1158:  GOTO   162
1159:  INCF   78,F
115A:  BTFSS  03.2
115B:  GOTO   162
115C:  INCF   77,F
115D:  BTFSC  03.2
115E:  GOTO   16C
115F:  RRF    78,F
1160:  RRF    79,F
1161:  RRF    7A,F
1162:  MOVF   5D,W
1163:  MOVWF  68
1164:  MOVF   61,W
1165:  XORWF  68,F
1166:  BTFSS  68.7
1167:  GOTO   16A
1168:  BSF    78.7
1169:  GOTO   170
116A:  BCF    78.7
116B:  GOTO   170
116C:  CLRF   77
116D:  CLRF   78
116E:  CLRF   79
116F:  CLRF   7A
*
1178:  MOVLW  8E
1179:  MOVWF  77
117A:  MOVF   5C,W
117B:  SUBWF  77,F
117C:  MOVF   5D,W
117D:  MOVWF  79
117E:  MOVF   5E,W
117F:  MOVWF  78
1180:  BSF    79.7
1181:  MOVF   77,F
1182:  BTFSC  03.2
1183:  GOTO   18F
1184:  BCF    03.0
1185:  MOVF   79,F
1186:  BTFSS  03.2
1187:  GOTO   18B
1188:  MOVF   78,F
1189:  BTFSC  03.2
118A:  GOTO   18F
118B:  RRF    79,F
118C:  RRF    78,F
118D:  DECFSZ 77,F
118E:  GOTO   184
118F:  BTFSS  5D.7
1190:  GOTO   196
1191:  COMF   78,F
1192:  COMF   79,F
1193:  INCF   78,F
1194:  BTFSC  03.2
1195:  INCF   79,F
....................  
.................... #list 
....................  
.................... #DEVICE ADC=10 
.................... #INCLUDE <STRING.H> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
*
0778:  BSF    03.6
0779:  MOVF   34,W
077A:  MOVWF  38
077B:  MOVF   33,W
077C:  MOVWF  37
077D:  MOVF   38,W
077E:  MOVWF  7A
077F:  MOVF   37,W
0780:  MOVWF  04
0781:  BCF    03.7
0782:  BTFSC  7A.0
0783:  BSF    03.7
0784:  MOVF   00,F
0785:  BTFSC  03.2
0786:  GOTO   78B
0787:  INCF   37,F
0788:  BTFSC  03.2
0789:  INCF   38,F
078A:  GOTO   77D
....................    while(*s2 != '\0') 
078B:  MOVF   36,W
078C:  MOVWF  7A
078D:  MOVF   35,W
078E:  MOVWF  04
078F:  BCF    03.7
0790:  BTFSC  7A.0
0791:  BSF    03.7
0792:  MOVF   00,F
0793:  BTFSC  03.2
0794:  GOTO   7AA
....................    { 
....................       *s = *s2; 
0795:  MOVF   35,W
0796:  MOVWF  04
0797:  BCF    03.7
0798:  BTFSC  36.0
0799:  BSF    03.7
079A:  MOVF   00,W
079B:  MOVWF  3B
079C:  MOVF   37,W
079D:  MOVWF  04
079E:  BCF    03.7
079F:  BTFSC  38.0
07A0:  BSF    03.7
07A1:  MOVF   3B,W
07A2:  MOVWF  00
....................       ++s; 
07A3:  INCF   37,F
07A4:  BTFSC  03.2
07A5:  INCF   38,F
....................       ++s2; 
07A6:  INCF   35,F
07A7:  BTFSC  03.2
07A8:  INCF   36,F
07A9:  GOTO   78B
....................    } 
....................  
....................    *s = '\0'; 
07AA:  MOVF   37,W
07AB:  MOVWF  04
07AC:  BCF    03.7
07AD:  BTFSC  38.0
07AE:  BSF    03.7
07AF:  CLRF   00
....................    return(s1); 
07B0:  MOVF   33,W
07B1:  MOVWF  78
07B2:  MOVF   34,W
07B3:  MOVWF  79
07B4:  BCF    03.6
07B5:  RETURN
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
*
0B7E:  BSF    03.5
0B7F:  MOVF   57,W
0B80:  MOVWF  7A
0B81:  MOVF   56,W
0B82:  MOVWF  04
0B83:  BCF    03.7
0B84:  BTFSC  7A.0
0B85:  BSF    03.7
0B86:  MOVF   00,W
0B87:  MOVWF  5A
0B88:  MOVF   59,W
0B89:  MOVWF  7A
0B8A:  MOVF   58,W
0B8B:  MOVWF  04
0B8C:  BCF    03.7
0B8D:  BTFSC  7A.0
0B8E:  BSF    03.7
0B8F:  MOVF   00,W
0B90:  SUBWF  5A,W
0B91:  BTFSS  03.2
0B92:  GOTO   3AA
....................       if (*s1 == '\0') 
0B93:  MOVF   57,W
0B94:  MOVWF  7A
0B95:  MOVF   56,W
0B96:  MOVWF  04
0B97:  BCF    03.7
0B98:  BTFSC  7A.0
0B99:  BSF    03.7
0B9A:  MOVF   00,F
0B9B:  BTFSS  03.2
0B9C:  GOTO   3A0
....................          return(0); 
0B9D:  MOVLW  00
0B9E:  MOVWF  78
0B9F:  GOTO   3C2
0BA0:  MOVF   57,W
0BA1:  MOVWF  7A
0BA2:  MOVF   56,W
0BA3:  INCF   56,F
0BA4:  BTFSC  03.2
0BA5:  INCF   57,F
0BA6:  INCF   58,F
0BA7:  BTFSC  03.2
0BA8:  INCF   59,F
0BA9:  GOTO   37F
....................    return((*s1 < *s2) ? -1: 1); 
0BAA:  MOVF   57,W
0BAB:  MOVWF  7A
0BAC:  MOVF   56,W
0BAD:  MOVWF  04
0BAE:  BCF    03.7
0BAF:  BTFSC  57.0
0BB0:  BSF    03.7
0BB1:  MOVF   00,W
0BB2:  MOVWF  5A
0BB3:  MOVF   59,W
0BB4:  MOVWF  7A
0BB5:  MOVF   58,W
0BB6:  MOVWF  04
0BB7:  BCF    03.7
0BB8:  BTFSC  59.0
0BB9:  BSF    03.7
0BBA:  MOVF   00,W
0BBB:  SUBWF  5A,W
0BBC:  BTFSC  03.0
0BBD:  GOTO   3C0
0BBE:  MOVLW  FF
0BBF:  GOTO   3C1
0BC0:  MOVLW  01
0BC1:  MOVWF  78
0BC2:  BCF    03.5
0BC3:  RETURN
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
*
0C12:  MOVF   57,W
0C13:  MOVWF  7A
0C14:  MOVF   56,W
0C15:  MOVWF  04
0C16:  BCF    03.7
0C17:  BTFSC  7A.0
0C18:  BSF    03.7
0C19:  MOVF   58,W
0C1A:  SUBWF  00,W
0C1B:  BTFSC  03.2
0C1C:  GOTO   42F
....................       if (*s == '\0') 
0C1D:  MOVF   57,W
0C1E:  MOVWF  7A
0C1F:  MOVF   56,W
0C20:  MOVWF  04
0C21:  BCF    03.7
0C22:  BTFSC  7A.0
0C23:  BSF    03.7
0C24:  MOVF   00,F
0C25:  BTFSS  03.2
0C26:  GOTO   42B
....................          return(0); 
0C27:  MOVLW  00
0C28:  MOVWF  78
0C29:  MOVWF  79
0C2A:  GOTO   433
0C2B:  INCF   56,F
0C2C:  BTFSC  03.2
0C2D:  INCF   57,F
0C2E:  GOTO   412
....................    return(s); 
0C2F:  MOVF   56,W
0C30:  MOVWF  78
0C31:  MOVF   57,W
0C32:  MOVWF  79
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
*
0A17:  MOVF   61,W
0A18:  MOVWF  65
0A19:  MOVF   60,W
0A1A:  MOVWF  64
0A1B:  MOVF   65,W
0A1C:  MOVWF  7A
0A1D:  MOVF   64,W
0A1E:  MOVWF  04
0A1F:  BCF    03.7
0A20:  BTFSC  7A.0
0A21:  BSF    03.7
0A22:  MOVF   00,F
0A23:  BTFSC  03.2
0A24:  GOTO   254
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
0A25:  MOVF   63,W
0A26:  MOVWF  67
0A27:  MOVF   62,W
0A28:  MOVWF  66
0A29:  MOVF   67,W
0A2A:  MOVWF  7A
0A2B:  MOVF   66,W
0A2C:  MOVWF  04
0A2D:  BCF    03.7
0A2E:  BTFSC  7A.0
0A2F:  BSF    03.7
0A30:  MOVF   00,F
0A31:  BTFSC  03.2
0A32:  GOTO   250
....................          if (*sc1 == *sc2) 
0A33:  MOVF   65,W
0A34:  MOVWF  7A
0A35:  MOVF   64,W
0A36:  MOVWF  04
0A37:  BCF    03.7
0A38:  BTFSC  7A.0
0A39:  BSF    03.7
0A3A:  MOVF   00,W
0A3B:  MOVWF  68
0A3C:  MOVF   67,W
0A3D:  MOVWF  7A
0A3E:  MOVF   66,W
0A3F:  MOVWF  04
0A40:  BCF    03.7
0A41:  BTFSC  7A.0
0A42:  BSF    03.7
0A43:  MOVF   00,W
0A44:  SUBWF  68,W
0A45:  BTFSS  03.2
0A46:  GOTO   24C
....................             return(sc1); 
0A47:  MOVF   64,W
0A48:  MOVWF  78
0A49:  MOVF   65,W
0A4A:  MOVWF  79
0A4B:  GOTO   257
0A4C:  INCF   66,F
0A4D:  BTFSC  03.2
0A4E:  INCF   67,F
0A4F:  GOTO   229
0A50:  INCF   64,F
0A51:  BTFSC  03.2
0A52:  INCF   65,F
0A53:  GOTO   21B
....................    return(0); 
0A54:  MOVLW  00
0A55:  MOVWF  78
0A56:  MOVWF  79
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
*
09A4:  MOVF   61,W
09A5:  MOVWF  65
09A6:  MOVF   60,W
09A7:  MOVWF  64
09A8:  MOVF   65,W
09A9:  MOVWF  7A
09AA:  MOVF   64,W
09AB:  MOVWF  04
09AC:  BCF    03.7
09AD:  BTFSC  7A.0
09AE:  BSF    03.7
09AF:  MOVF   00,F
09B0:  BTFSC  03.2
09B1:  GOTO   1E9
....................       for (sc2 = s2; ; sc2++) 
09B2:  MOVF   63,W
09B3:  MOVWF  67
09B4:  MOVF   62,W
09B5:  MOVWF  66
....................     if (*sc2 == '\0') 
09B6:  MOVF   67,W
09B7:  MOVWF  7A
09B8:  MOVF   66,W
09B9:  MOVWF  04
09BA:  BCF    03.7
09BB:  BTFSC  7A.0
09BC:  BSF    03.7
09BD:  MOVF   00,F
09BE:  BTFSS  03.2
09BF:  GOTO   1CD
....................        return(sc1 - s1); 
09C0:  MOVF   60,W
09C1:  SUBWF  64,W
09C2:  MOVWF  77
09C3:  MOVF   65,W
09C4:  MOVWF  7A
09C5:  MOVF   61,W
09C6:  BTFSS  03.0
09C7:  INCFSZ 61,W
09C8:  SUBWF  7A,F
09C9:  MOVF   77,W
09CA:  MOVWF  78
09CB:  GOTO   1F4
09CC:  GOTO   1E1
....................          else if (*sc1 == *sc2) 
09CD:  MOVF   65,W
09CE:  MOVWF  7A
09CF:  MOVF   64,W
09D0:  MOVWF  04
09D1:  BCF    03.7
09D2:  BTFSC  7A.0
09D3:  BSF    03.7
09D4:  MOVF   00,W
09D5:  MOVWF  68
09D6:  MOVF   67,W
09D7:  MOVWF  7A
09D8:  MOVF   66,W
09D9:  MOVWF  04
09DA:  BCF    03.7
09DB:  BTFSC  7A.0
09DC:  BSF    03.7
09DD:  MOVF   00,W
09DE:  SUBWF  68,W
09DF:  BTFSC  03.2
....................             break; 
09E0:  GOTO   1E5
09E1:  INCF   66,F
09E2:  BTFSC  03.2
09E3:  INCF   67,F
09E4:  GOTO   1B6
09E5:  INCF   64,F
09E6:  BTFSC  03.2
09E7:  INCF   65,F
09E8:  GOTO   1A8
....................    return(sc1 - s1); 
09E9:  MOVF   60,W
09EA:  SUBWF  64,W
09EB:  MOVWF  77
09EC:  MOVF   65,W
09ED:  MOVWF  7A
09EE:  MOVF   61,W
09EF:  BTFSS  03.0
09F0:  INCFSZ 61,W
09F1:  SUBWF  7A,F
09F2:  MOVF   77,W
09F3:  MOVWF  78
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
*
131A:  BCF    03.6
131B:  CLRF   2B
131C:  CLRF   2C
....................  
....................    beg = (s1)? s1: save; 
*
098B:  BSF    03.5
098C:  MOVF   58,W
098D:  IORWF  59,W
098E:  BTFSC  03.2
098F:  GOTO   194
0990:  MOVF   59,W
0991:  MOVWF  7A
0992:  MOVF   58,W
0993:  GOTO   199
0994:  BCF    03.5
0995:  MOVF   2C,W
0996:  MOVWF  7A
0997:  MOVF   2B,W
0998:  BSF    03.5
0999:  MOVWF  5C
099A:  MOVF   7A,W
099B:  MOVWF  5D
....................    beg += strspn(beg, s2); 
099C:  MOVF   5D,W
099D:  MOVWF  61
099E:  MOVF   5C,W
099F:  MOVWF  60
09A0:  MOVF   5B,W
09A1:  MOVWF  63
09A2:  MOVF   5A,W
09A3:  MOVWF  62
*
09F4:  MOVF   78,W
09F5:  ADDWF  5C,F
09F6:  BTFSC  03.0
09F7:  INCF   5D,F
....................    if (*beg == '\0') 
09F8:  MOVF   5D,W
09F9:  MOVWF  7A
09FA:  MOVF   5C,W
09FB:  MOVWF  04
09FC:  BCF    03.7
09FD:  BTFSC  7A.0
09FE:  BSF    03.7
09FF:  MOVF   00,F
0A00:  BTFSS  03.2
0A01:  GOTO   20F
....................    { 
....................       *save = ' '; 
0A02:  BCF    03.5
0A03:  MOVF   2B,W
0A04:  MOVWF  04
0A05:  BCF    03.7
0A06:  BTFSC  2C.0
0A07:  BSF    03.7
0A08:  MOVLW  20
0A09:  MOVWF  00
....................       return(0); 
0A0A:  MOVLW  00
0A0B:  MOVWF  78
0A0C:  MOVWF  79
0A0D:  GOTO   27B
0A0E:  BSF    03.5
....................    } 
....................    end = strpbrk(beg, s2); 
0A0F:  MOVF   5D,W
0A10:  MOVWF  61
0A11:  MOVF   5C,W
0A12:  MOVWF  60
0A13:  MOVF   5B,W
0A14:  MOVWF  63
0A15:  MOVF   5A,W
0A16:  MOVWF  62
*
0A57:  MOVF   79,W
0A58:  MOVWF  5F
0A59:  MOVF   78,W
0A5A:  MOVWF  5E
....................    if (*end != '\0') 
0A5B:  MOVF   5F,W
0A5C:  MOVWF  7A
0A5D:  MOVF   5E,W
0A5E:  MOVWF  04
0A5F:  BCF    03.7
0A60:  BTFSC  7A.0
0A61:  BSF    03.7
0A62:  MOVF   00,F
0A63:  BTFSC  03.2
0A64:  GOTO   26E
....................    { 
....................       *end = '\0'; 
0A65:  MOVF   5E,W
0A66:  MOVWF  04
0A67:  BCF    03.7
0A68:  BTFSC  5F.0
0A69:  BSF    03.7
0A6A:  CLRF   00
....................       end++; 
0A6B:  INCF   5E,F
0A6C:  BTFSC  03.2
0A6D:  INCF   5F,F
....................    } 
....................    save = end; 
0A6E:  MOVF   5F,W
0A6F:  BCF    03.5
0A70:  MOVWF  2C
0A71:  BSF    03.5
0A72:  MOVF   5E,W
0A73:  BCF    03.5
0A74:  MOVWF  2B
....................    return(beg); 
0A75:  BSF    03.5
0A76:  MOVF   5C,W
0A77:  MOVWF  78
0A78:  MOVF   5D,W
0A79:  MOVWF  79
0A7A:  BCF    03.5
0A7B:  RETURN
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
*
07B6:  BSF    03.6
07B7:  MOVF   35,W
07B8:  MOVWF  37
07B9:  MOVF   34,W
07BA:  MOVWF  36
07BB:  MOVF   37,W
07BC:  MOVWF  7A
07BD:  MOVF   36,W
07BE:  MOVWF  04
07BF:  BCF    03.7
07C0:  BTFSC  7A.0
07C1:  BSF    03.7
07C2:  MOVF   00,F
07C3:  BTFSC  03.2
07C4:  GOTO   7C9
07C5:  INCF   36,F
07C6:  BTFSC  03.2
07C7:  INCF   37,F
07C8:  GOTO   7BB
....................    return(sc - s); 
07C9:  MOVF   34,W
07CA:  SUBWF  36,W
07CB:  MOVWF  77
07CC:  MOVF   37,W
07CD:  MOVWF  7A
07CE:  MOVF   35,W
07CF:  BTFSS  03.0
07D0:  INCFSZ 35,W
07D1:  SUBWF  7A,F
07D2:  MOVF   77,W
07D3:  MOVWF  78
07D4:  BCF    03.6
07D5:  RETURN
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #INCLUDE <STDLIB.H> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... /* Standart template: float strtof(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... float strtof(char *s,char *endptr); 
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s,char *endptr); 
.................... float64 strtod(char *s,char *endptr); 
.................... #else 
.................... //provided for compatibility 
.................... #define strtof48(s, e) strtof(s, e) 
.................... #define strtod(s, e) strtof(s, e) 
.................... #endif 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof(s)   strtof(s, 0) 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof48(s) strtof48(s, 0) 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof64(s) strtod(s, 0) 
.................... #endif 
....................  
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float atoe(char * s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s); 
.................... #endif 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... unsigned int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................  
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
*
0A7C:  BSF    03.5
0A7D:  CLRF   5D
....................    sign = 0; 
0A7E:  CLRF   5B
....................    base = 10; 
0A7F:  MOVLW  0A
0A80:  MOVWF  5C
....................    result = 0; 
0A81:  CLRF   5A
....................  
....................    if (!s) 
0A82:  MOVF   58,W
0A83:  IORWF  59,W
0A84:  BTFSS  03.2
0A85:  GOTO   289
....................       return 0; 
0A86:  MOVLW  00
0A87:  MOVWF  78
0A88:  GOTO   37C
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
0A89:  MOVF   5D,W
0A8A:  INCF   5D,F
0A8B:  ADDWF  58,W
0A8C:  MOVWF  04
0A8D:  BCF    03.7
0A8E:  BTFSC  59.0
0A8F:  BSF    03.7
0A90:  MOVF   00,W
0A91:  MOVWF  5E
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
0A92:  MOVF   5E,W
0A93:  SUBLW  2D
0A94:  BTFSS  03.2
0A95:  GOTO   2A2
....................    { 
....................       sign = 1;         // Set the sign to negative 
0A96:  MOVLW  01
0A97:  MOVWF  5B
....................       c = s[index++]; 
0A98:  MOVF   5D,W
0A99:  INCF   5D,F
0A9A:  ADDWF  58,W
0A9B:  MOVWF  04
0A9C:  BCF    03.7
0A9D:  BTFSC  59.0
0A9E:  BSF    03.7
0A9F:  MOVF   00,W
0AA0:  MOVWF  5E
....................    } 
0AA1:  GOTO   2AF
....................    else if (c == '+') 
0AA2:  MOVF   5E,W
0AA3:  SUBLW  2B
0AA4:  BTFSS  03.2
0AA5:  GOTO   2AF
....................    { 
....................       c = s[index++]; 
0AA6:  MOVF   5D,W
0AA7:  INCF   5D,F
0AA8:  ADDWF  58,W
0AA9:  MOVWF  04
0AAA:  BCF    03.7
0AAB:  BTFSC  59.0
0AAC:  BSF    03.7
0AAD:  MOVF   00,W
0AAE:  MOVWF  5E
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
0AAF:  MOVF   5E,W
0AB0:  SUBLW  2F
0AB1:  BTFSC  03.0
0AB2:  GOTO   372
0AB3:  MOVF   5E,W
0AB4:  SUBLW  39
0AB5:  BTFSS  03.0
0AB6:  GOTO   372
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
0AB7:  MOVF   5E,W
0AB8:  SUBLW  30
0AB9:  BTFSS  03.2
0ABA:  GOTO   2DB
0ABB:  MOVF   5D,W
0ABC:  ADDWF  58,W
0ABD:  MOVWF  04
0ABE:  BCF    03.7
0ABF:  BTFSC  59.0
0AC0:  BSF    03.7
0AC1:  MOVF   00,W
0AC2:  SUBLW  78
0AC3:  BTFSC  03.2
0AC4:  GOTO   2CF
0AC5:  MOVF   5D,W
0AC6:  ADDWF  58,W
0AC7:  MOVWF  04
0AC8:  BCF    03.7
0AC9:  BTFSC  59.0
0ACA:  BSF    03.7
0ACB:  MOVF   00,W
0ACC:  SUBLW  58
0ACD:  BTFSS  03.2
0ACE:  GOTO   2DB
....................       { 
....................          base = 16; 
0ACF:  MOVLW  10
0AD0:  MOVWF  5C
....................          index++; 
0AD1:  INCF   5D,F
....................          c = s[index++]; 
0AD2:  MOVF   5D,W
0AD3:  INCF   5D,F
0AD4:  ADDWF  58,W
0AD5:  MOVWF  04
0AD6:  BCF    03.7
0AD7:  BTFSC  59.0
0AD8:  BSF    03.7
0AD9:  MOVF   00,W
0ADA:  MOVWF  5E
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
0ADB:  MOVF   5C,W
0ADC:  SUBLW  0A
0ADD:  BTFSS  03.2
0ADE:  GOTO   320
....................       { 
....................          while (c >= '0' && c <= '9') 
0ADF:  MOVF   5E,W
0AE0:  SUBLW  2F
0AE1:  BTFSC  03.0
0AE2:  GOTO   31F
0AE3:  MOVF   5E,W
0AE4:  SUBLW  39
0AE5:  BTFSS  03.0
0AE6:  GOTO   31F
....................          { 
....................             result = 10*result + (c - '0'); 
0AE7:  MOVLW  0A
0AE8:  MOVWF  5F
0AE9:  MOVF   5A,W
0AEA:  MOVWF  60
*
0B0F:  MOVF   78,W
0B10:  MOVWF  5F
0B11:  MOVLW  30
0B12:  SUBWF  5E,W
0B13:  ADDWF  5F,W
0B14:  MOVWF  5A
....................             c = s[index++]; 
0B15:  MOVF   5D,W
0B16:  INCF   5D,F
0B17:  ADDWF  58,W
0B18:  MOVWF  04
0B19:  BCF    03.7
0B1A:  BTFSC  59.0
0B1B:  BSF    03.7
0B1C:  MOVF   00,W
0B1D:  MOVWF  5E
0B1E:  GOTO   2DF
....................          } 
....................       } 
0B1F:  GOTO   372
....................       else if (base == 16)    // The number is a hexa number 
0B20:  MOVF   5C,W
0B21:  SUBLW  10
0B22:  BTFSS  03.2
0B23:  GOTO   372
....................       { 
....................          c = toupper(c); 
0B24:  MOVF   5E,W
0B25:  SUBLW  60
0B26:  BTFSC  03.0
0B27:  GOTO   32F
0B28:  MOVF   5E,W
0B29:  SUBLW  7A
0B2A:  BTFSS  03.0
0B2B:  GOTO   32F
0B2C:  MOVF   5E,W
0B2D:  ANDLW  DF
0B2E:  GOTO   330
0B2F:  MOVF   5E,W
0B30:  MOVWF  5E
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
0B31:  MOVF   5E,W
0B32:  SUBLW  2F
0B33:  BTFSC  03.0
0B34:  GOTO   339
0B35:  MOVF   5E,W
0B36:  SUBLW  39
0B37:  BTFSC  03.0
0B38:  GOTO   341
0B39:  MOVF   5E,W
0B3A:  SUBLW  40
0B3B:  BTFSC  03.0
0B3C:  GOTO   372
0B3D:  MOVF   5E,W
0B3E:  SUBLW  46
0B3F:  BTFSS  03.0
0B40:  GOTO   372
....................          { 
....................             if (c >= '0' && c <= '9') 
0B41:  MOVF   5E,W
0B42:  SUBLW  2F
0B43:  BTFSC  03.0
0B44:  GOTO   352
0B45:  MOVF   5E,W
0B46:  SUBLW  39
0B47:  BTFSS  03.0
0B48:  GOTO   352
....................                result = (result << 4) + (c - '0'); 
0B49:  SWAPF  5A,W
0B4A:  MOVWF  5F
0B4B:  MOVLW  F0
0B4C:  ANDWF  5F,F
0B4D:  MOVLW  30
0B4E:  SUBWF  5E,W
0B4F:  ADDWF  5F,W
0B50:  MOVWF  5A
0B51:  GOTO   35B
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
0B52:  SWAPF  5A,W
0B53:  MOVWF  5F
0B54:  MOVLW  F0
0B55:  ANDWF  5F,F
0B56:  MOVLW  41
0B57:  SUBWF  5E,W
0B58:  ADDLW  0A
0B59:  ADDWF  5F,W
0B5A:  MOVWF  5A
....................  
....................             c = s[index++]; 
0B5B:  MOVF   5D,W
0B5C:  INCF   5D,F
0B5D:  ADDWF  58,W
0B5E:  MOVWF  04
0B5F:  BCF    03.7
0B60:  BTFSC  59.0
0B61:  BSF    03.7
0B62:  MOVF   00,W
0B63:  MOVWF  5E
....................             c = toupper(c); 
0B64:  MOVF   5E,W
0B65:  SUBLW  60
0B66:  BTFSC  03.0
0B67:  GOTO   36F
0B68:  MOVF   5E,W
0B69:  SUBLW  7A
0B6A:  BTFSS  03.0
0B6B:  GOTO   36F
0B6C:  MOVF   5E,W
0B6D:  ANDLW  DF
0B6E:  GOTO   370
0B6F:  MOVF   5E,W
0B70:  MOVWF  5E
0B71:  GOTO   331
....................          } 
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
0B72:  DECFSZ 5B,W
0B73:  GOTO   37A
0B74:  MOVF   5C,W
0B75:  SUBLW  0A
0B76:  BTFSS  03.2
0B77:  GOTO   37A
....................        result = -result; 
0B78:  COMF   5A,F
0B79:  INCF   5A,F
....................  
....................    return(result); 
0B7A:  MOVF   5A,W
0B7B:  MOVWF  78
0B7C:  BCF    03.5
0B7D:  RETURN
.................... } 
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
*
0407:  BSF    03.6
0408:  CLRF   46
0409:  CLRF   45
040A:  CLRF   44
040B:  MOVLW  01
040C:  MOVWF  43
040D:  CLRF   48
040E:  CLRF   49
.................... { 
....................      unsigned int32 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
040F:  BTFSS  3F.7
0410:  GOTO   451
....................          sign=1;        // Check for negative number 
0411:  MOVLW  01
0412:  MOVWF  48
....................          num*=-1; 
0413:  MOVF   3F,W
0414:  MOVWF  4E
0415:  MOVF   3E,W
0416:  MOVWF  4D
0417:  MOVF   3D,W
0418:  MOVWF  4C
0419:  MOVF   3C,W
041A:  MOVWF  4B
041B:  MOVLW  FF
041C:  MOVWF  52
041D:  MOVWF  51
041E:  MOVWF  50
041F:  MOVWF  4F
*
0449:  MOVF   7A,W
044A:  MOVWF  3F
044B:  MOVF   79,W
044C:  MOVWF  3E
044D:  MOVF   78,W
044E:  MOVWF  3D
044F:  MOVF   77,W
0450:  MOVWF  3C
....................      } 
....................  
....................      while(temp>0) { 
0451:  MOVF   43,F
0452:  BTFSS  03.2
0453:  GOTO   45D
0454:  MOVF   44,F
0455:  BTFSS  03.2
0456:  GOTO   45D
0457:  MOVF   45,F
0458:  BTFSS  03.2
0459:  GOTO   45D
045A:  MOVF   46,F
045B:  BTFSC  03.2
045C:  GOTO   4D9
....................          temp=(num/base); 
045D:  BCF    03.1
045E:  MOVF   3F,W
045F:  MOVWF  56
0460:  MOVF   3E,W
0461:  MOVWF  55
0462:  MOVF   3D,W
0463:  MOVWF  54
0464:  MOVF   3C,W
0465:  MOVWF  53
0466:  CLRF   5A
0467:  CLRF   59
0468:  CLRF   58
0469:  MOVF   40,W
046A:  MOVWF  57
046B:  BCF    03.6
046C:  CALL   38B
046D:  MOVF   7A,W
046E:  BSF    03.6
046F:  MOVWF  46
0470:  MOVF   79,W
0471:  MOVWF  45
0472:  MOVF   78,W
0473:  MOVWF  44
0474:  MOVF   77,W
0475:  MOVWF  43
....................          s[cnt]=(num%base)+'0';    // Conversion 
0476:  MOVF   49,W
0477:  ADDWF  41,W
0478:  MOVWF  78
0479:  MOVF   42,W
047A:  MOVWF  7A
047B:  BTFSC  03.0
047C:  INCF   7A,F
047D:  MOVF   78,W
047E:  MOVWF  4B
047F:  MOVF   7A,W
0480:  MOVWF  4C
0481:  CLRF   4E
0482:  MOVF   04,W
0483:  MOVWF  4D
0484:  BCF    4E.0
0485:  BTFSC  03.7
0486:  BSF    4E.0
0487:  BSF    03.1
0488:  MOVLW  4F
0489:  MOVWF  04
048A:  BSF    03.7
048B:  MOVF   3F,W
048C:  MOVWF  56
048D:  MOVF   3E,W
048E:  MOVWF  55
048F:  MOVF   3D,W
0490:  MOVWF  54
0491:  MOVF   3C,W
0492:  MOVWF  53
0493:  CLRF   5A
0494:  CLRF   59
0495:  CLRF   58
0496:  MOVF   40,W
0497:  MOVWF  57
0498:  BCF    03.6
0499:  CALL   38B
049A:  BSF    03.6
049B:  MOVF   4D,W
049C:  MOVWF  04
049D:  BCF    03.7
049E:  BTFSC  4E.0
049F:  BSF    03.7
04A0:  MOVLW  30
04A1:  ADDWF  4F,W
04A2:  MOVWF  77
04A3:  MOVF   50,W
04A4:  MOVWF  78
04A5:  MOVLW  00
04A6:  BTFSC  03.0
04A7:  MOVLW  01
04A8:  ADDWF  78,F
04A9:  MOVF   51,W
04AA:  MOVWF  79
04AB:  MOVLW  00
04AC:  BTFSC  03.0
04AD:  MOVLW  01
04AE:  ADDWF  79,F
04AF:  MOVF   52,W
04B0:  MOVWF  7A
04B1:  MOVLW  00
04B2:  BTFSC  03.0
04B3:  MOVLW  01
04B4:  ADDWF  7A,F
04B5:  MOVF   4B,W
04B6:  MOVWF  04
04B7:  BCF    03.7
04B8:  BTFSC  4C.0
04B9:  BSF    03.7
04BA:  MOVF   77,W
04BB:  MOVWF  00
....................  
....................          if(s[cnt]>0x39) 
04BC:  MOVF   49,W
04BD:  ADDWF  41,W
04BE:  MOVWF  04
04BF:  BCF    03.7
04C0:  BTFSC  42.0
04C1:  BSF    03.7
04C2:  MOVF   00,W
04C3:  SUBLW  39
04C4:  BTFSC  03.0
04C5:  GOTO   4CF
....................             s[cnt]+=0x7; 
04C6:  MOVF   49,W
04C7:  ADDWF  41,W
04C8:  MOVWF  04
04C9:  BCF    03.7
04CA:  BTFSC  42.0
04CB:  BSF    03.7
04CC:  MOVLW  07
04CD:  ADDWF  00,W
04CE:  MOVWF  00
....................  
....................          cnt++; 
04CF:  INCF   49,F
....................          num=temp; 
04D0:  MOVF   46,W
04D1:  MOVWF  3F
04D2:  MOVF   45,W
04D3:  MOVWF  3E
04D4:  MOVF   44,W
04D5:  MOVWF  3D
04D6:  MOVF   43,W
04D7:  MOVWF  3C
04D8:  GOTO   451
....................      } 
....................  
....................      if(sign==1) { 
04D9:  DECFSZ 48,W
04DA:  GOTO   4E4
....................          s[cnt]=0x2D;      // Negative sign 
04DB:  MOVF   49,W
04DC:  ADDWF  41,W
04DD:  MOVWF  04
04DE:  BCF    03.7
04DF:  BTFSC  42.0
04E0:  BSF    03.7
04E1:  MOVLW  2D
04E2:  MOVWF  00
....................          cnt++; 
04E3:  INCF   49,F
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
04E4:  CLRF   47
04E5:  BCF    03.0
04E6:  RRF    49,W
04E7:  SUBWF  47,W
04E8:  BTFSC  03.0
04E9:  GOTO   51A
....................  
....................          c=s[i]; 
04EA:  MOVF   47,W
04EB:  ADDWF  41,W
04EC:  MOVWF  04
04ED:  BCF    03.7
04EE:  BTFSC  42.0
04EF:  BSF    03.7
04F0:  MOVF   00,W
04F1:  MOVWF  4A
....................          s[i]=s[cnt-i-1];        // Reverse the number 
04F2:  MOVF   47,W
04F3:  ADDWF  41,W
04F4:  MOVWF  78
04F5:  MOVF   42,W
04F6:  MOVWF  7A
04F7:  BTFSC  03.0
04F8:  INCF   7A,F
04F9:  MOVF   78,W
04FA:  MOVWF  4B
04FB:  MOVF   7A,W
04FC:  MOVWF  4C
04FD:  MOVF   47,W
04FE:  SUBWF  49,W
04FF:  ADDLW  FF
0500:  ADDWF  41,W
0501:  MOVWF  04
0502:  BCF    03.7
0503:  BTFSC  42.0
0504:  BSF    03.7
0505:  MOVF   00,W
0506:  MOVWF  4D
0507:  MOVF   4B,W
0508:  MOVWF  04
0509:  BCF    03.7
050A:  BTFSC  4C.0
050B:  BSF    03.7
050C:  MOVF   4D,W
050D:  MOVWF  00
....................          s[cnt-i-1]=c; 
050E:  MOVF   47,W
050F:  SUBWF  49,W
0510:  ADDLW  FF
0511:  ADDWF  41,W
0512:  MOVWF  04
0513:  BCF    03.7
0514:  BTFSC  42.0
0515:  BSF    03.7
0516:  MOVF   4A,W
0517:  MOVWF  00
0518:  INCF   47,F
0519:  GOTO   4E5
....................      } 
....................      s[cnt]='\0';     // End the string 
051A:  MOVF   49,W
051B:  ADDWF  41,W
051C:  MOVWF  04
051D:  BCF    03.7
051E:  BTFSC  42.0
051F:  BSF    03.7
0520:  CLRF   00
....................      return s; 
0521:  MOVF   41,W
0522:  MOVWF  78
0523:  MOVF   42,W
0524:  MOVWF  79
0525:  BCF    03.6
0526:  RETURN
.................... } 
....................  
.................... #if defined(__PCD__) 
....................  
.................... char * itoa(signed int48 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int48 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... char * itoa(signed int64 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int64 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................       
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1;         
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................              
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #endif 
....................  
.................... float strtof(char *s, char *endptr) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s, char *endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float48)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float48)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s, char *endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float64)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float64)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtoulGO; 
....................  
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................    { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... int8 mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #if !defined(__PCD__) 
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2);  
.................... #else  
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2);  
.................... #endif 
....................  
....................  
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    unsigned int8 t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=1; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = 0; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
.................... #INCLUDE <STDIO.H> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDIO 
.................... #define _STDIO 
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #ifndef getc 
.................... #define getc getch 
.................... #define getchar getch 
.................... #define puts(s) {printf(s); putchar(13); putchar(10);} 
.................... #define putc putchar 
.................... #endif 
.................... /* maps error number to an error message. Writes a sequence of characters to 
.................... stderr stream thus: if s is not null then string pointed to by s follwed by 
.................... a colon (:) and a space and the appropriate error message returned by strerror 
.................... function with argument errno 
....................  
.................... Returns: no value 
.................... */ 
....................  
.................... #ifdef _ERRNO 
.................... void perror(char *s) 
.................... { 
....................   if(s) 
....................   fprintf(STDERR,"%s: ",s); 
....................   fprintf(STDERR,"%s\r\n",strerror(errno)); 
.................... } 
.................... #endif 
.................... #endif 
....................  
.................... #INCLUDE <MATH.H> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2011 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                    //// 
.................... //// History:                                                           //// 
.................... ////  * 9/20/2001 :  Improvments are made to sin/cos code.              //// 
.................... ////                 The code now is small, much faster,                //// 
.................... ////                 and more accurate.                                 //// 
.................... ////  * 2/21/2007 :  Compiler handles & operator differently and does   //// 
.................... ////                 not return generic (int8 *) so type cast is done   //// 
.................... ////  * 6/19/2010 :  Divisions by constants converted to multiplication //// 
.................... ////                 by its inverse to improve computation speed        //// 
.................... ////  * 1/21/2011 :  Constants used for double precision math updated   //// 
.................... ////                 Updated routines include 64 bit versions of cos,   //// 
.................... ////                 asin,atan,exp,log and dependant functions          //// 
.................... ////  * 1/31/2011 :  Optimized current 32-bit float routines for cos    //// 
.................... ////                 and log function                                   //// 
.................... ////  * 6/13/2011 :  Fixed PCD overload CEIL_FLOOR functions for values //// 
.................... ////                 greater then 10000000 and less then -10000000      //// 
.................... ////                                                                    //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef MATH_H 
.................... #define MATH_H 
....................  
.................... #ifdef PI 
.................... #undef  PI 
.................... #endif 
.................... #define PI     3.1415926535897932 
....................  
....................  
.................... #define SQRT2  1.4142135623730950 
....................  
.................... //float const ps[4] = {5.9304945, 21.125224, 8.9403076, 0.29730279}; 
.................... //float const qs[4] = {1.0000000, 15.035723, 17.764134, 2.4934718}; 
....................  
.................... ///////////////////////////// Round Functions ////////////////////////////// 
....................  
.................... float32 CEIL_FLOOR(float32 x, unsigned int8 n) 
.................... { 
....................    float32 y, res; 
....................    unsigned int16 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................       res = (float32)(unsigned int16)y; 
....................  
....................  else if (y < 10000000.0) 
....................    {  
....................       l = (unsigned int16)(y*0.000030517578125); 
....................       y = 32768.0*(y*0.000030517578125 - (float32)l); 
....................       res = 32768.0*(float32)l; 
....................       res += (float32)(unsigned int16)y; 
....................    } 
....................  
....................  else 
....................   res = y; 
....................  
....................  y = y - (float32)(unsigned int16)y; 
....................  
....................  if (s) 
....................   res = -res; 
....................  
....................  if (y != 0) 
....................  { 
....................   if (s == 1 && n == 0) 
....................    res -= 1.0; 
....................  
....................   if (s == 0 && n == 1) 
....................    res += 1.0; 
....................  } 
....................  if (x == 0) 
....................     res = 0; 
....................  
....................  return (res); 
.................... } 
....................  
.................... // Overloaded Functions to take care for new Data types in PCD 
.................... // Overloaded function CEIL_FLOOR() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 CEIL_FLOOR(float48 x, unsigned int8 n) 
.................... { 
....................    float48 y, res; 
....................    unsigned int32 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................       res = (float48)(unsigned int16)y; 
....................  
....................    else if (y < 549755813888.0) 
....................    { 
....................       l = (unsigned int32)(y*0.000030517578125); 
....................       y = 32768.0*(y*0.000030517578125 - (float48)l); 
....................       res = 32768.0*(float48)l; 
....................       res += (float48)(unsigned int16)y; 
....................    } 
....................    else 
....................    {   
....................       res = y; 
....................       y = 0.0; 
....................    } 
....................     
....................    if(y != 0) 
....................       y = y - (float48)(unsigned int16)y; 
....................  
....................    if (s) 
....................       res = -res; 
....................  
....................    if (y != 0) 
....................    { 
....................       if (s == 1 && n == 0) 
....................          res -= 1.0; 
....................  
....................       if (s == 0 && n == 1) 
....................          res += 1.0; 
....................    } 
....................    if (x == 0) 
....................       res = 0; 
....................  
....................    return (res); 
.................... } 
....................  
....................  
.................... // Overloaded function CEIL_FLOOR() for data type - Float64 
.................... float64 CEIL_FLOOR(float64 x, unsigned int8 n) 
.................... { 
....................    float64 y, res; 
....................    int64 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................       res = (float64)(unsigned int16)y; 
....................    else if (y < 4503599627370496.0) 
....................    { 
....................       l = (int64)(y*0.000030517578125); 
....................       y = 32768.0*(y*0.000030517578125 - (float64)l); 
....................       res = 32768.0*(float64)l; 
....................       res += (float64)(unsigned int16)y; 
....................    } 
....................    else 
....................    { 
....................       res = y; 
....................       y = 0.0; 
....................    } 
....................     
....................    if(y != 0) 
....................       y = y - (float64)(unsigned int16)y; 
....................  
....................    if (s) 
....................       res = -res; 
....................  
....................    if (y != 0) 
....................    { 
....................       if (s == 1 && n == 0) 
....................          res -= 1.0; 
....................  
....................       if (s == 0 && n == 1) 
....................          res += 1.0; 
....................    } 
....................     
....................    if (x == 0) 
....................       res = 0; 
....................  
....................    return (res); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float floor(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : rounds down the number x. 
.................... // Date : N/A 
.................... // 
.................... float32 floor(float32 x) 
.................... { 
....................    return CEIL_FLOOR(x,0); 
.................... } 
.................... // Following 2 functions are overloaded functions of floor() for PCD 
.................... // Overloaded function floor() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 floor(float48 x) 
.................... { 
....................    return CEIL_FLOOR(x, 0); 
.................... } 
....................  
.................... // Overloaded function floor() for data type - Float64 
.................... float64 floor(float64 x) 
.................... { 
....................    return CEIL_FLOOR(x, 0); 
.................... } 
.................... #endif 
....................  
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float ceil(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : rounds up the number x. 
.................... // Date : N/A 
.................... // 
.................... float32 ceil(float32 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
.................... // Following 2 functions are overloaded functions of ceil() for PCD 
.................... // Overloaded function ceil() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 ceil(float48 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
....................  
.................... // Overloaded function ceil() for data type - Float64 
.................... float64 ceil(float64 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
.................... #endif 
....................  
....................  //////////////////////////////////////////////////////////////////////////// 
.................... //   float fabs(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the absolute value of floating point number x 
.................... // Returns : returns the absolute value of x 
.................... // Date : N/A 
.................... // 
.................... #define fabs abs 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float fmod(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the floating point remainder of x/y 
.................... // Returns : returns the value of x= i*y, for some integer i such that, if y 
.................... // is non zero, the result has the same isgn of x na dmagnitude less than the 
.................... // magnitude of y. If y is zero then a domain error occurs. 
.................... // Date : N/A 
.................... // 
....................  
.................... float fmod(float32 x,float32 y) 
.................... { 
....................    float32 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... //Overloaded function for fmod() for PCD 
.................... // Overloaded function fmod() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 fmod(float48 x,float48 y) 
.................... { 
....................    float48 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... // Overloaded function fmod() for data type - Float64 
.................... float64 fmod(float64 x,float64 y) 
.................... { 
....................    float64 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... #endif 
.................... //////////////////// Exponential and logarithmic functions //////////////////// 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float exp(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (e^x) 
.................... // Date : N/A 
.................... // 
.................... #define LN2 0.6931471805599453 
.................... #define LN2_INV 1.4426950408889634073 
....................  
.................... float const pe[6] = {0.000207455774, 0.00127100575, 0.00965065093, 
....................                      0.0554965651,  0.240227138,  0.693147172}; 
....................  
....................  
.................... float32 exp(float32 x) 
.................... { 
....................    float32 y, res, r; 
....................    #if defined(__PCD__) 
....................    int8 data1; 
....................    #endif 
....................    signed int8 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 88.722838) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    n = (signed int16)(x*LN2_INV); 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
.................... #if !defined(__PCD__) 
....................    *((unsigned int8 *)(&res)) = n + 0x7F; 
.................... #endif 
....................  
.................... #if defined(__PCD__)  // Takes care of IEEE format for PCD 
....................    data1 = n+0x7F; 
....................    if(bit_test(data1,0)) 
....................    bit_set(*(((unsigned int8 *)(&res)+2)),7); 
....................    rotate_right(&data1,1); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&res)+3)) = data1; 
.................... #endif 
....................  
....................    y = y*LN2_INV - (float32)n; 
....................  
....................    r = pe[0]*y + pe[1]; 
....................    r = r*y + pe[2]; 
....................    r = r*y + pe[3]; 
....................    r = r*y + pe[4]; 
....................    r = r*y + pe[5]; 
....................  
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
....................  
....................  
.................... //Overloaded function for exp() for PCD 
.................... // Overloaded function exp() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 exp(float48 x) 
.................... { 
....................    float48 y, res, r; 
....................    int8 data1; 
....................    signed int8 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 88.722838) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    n = (signed int16)(x*LN2_INV); 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
....................  
....................    data1 = n+0x7F; 
....................    if(bit_test(data1,0)) 
....................    bit_set(*(((unsigned int8 *)(&res)+4)),7); 
....................    rotate_right(&data1,1); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&res)+5)) = data1; 
....................  
....................    y = y*LN2_INV - (float48)n; 
....................  
....................    r = pe[0]*y + pe[1]; 
....................    r = r*y + pe[2]; 
....................    r = r*y + pe[3]; 
....................    r = r*y + pe[4]; 
....................    r = r*y + pe[5]; 
....................  
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function exp() for data type - Float64 
.................... float64 const pe_64[12] ={9.30741400474913e-011,-4.28655416283316e-011, 
....................                           8.71486547014137e-009,9.84458531538385e-008, 
....................                           1.32588296983536e-006,1.52489283823016e-005, 
....................                           0.000154037598423921,0.00133335487036216, 
....................                           0.00961812936407326,0.0555041086222122, 
....................                           0.240226506962827,0.693147180559823}; 
....................  
.................... float64 exp(float64 x) 
.................... { 
....................    float64 y, res, r; 
....................    unsigned int16 data1, data2; 
....................    unsigned int16 *p; 
....................    signed int16 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 709.7827128) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x*LN2_INV; 
....................    n = (signed int16)y; 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
....................  
.................... #if !defined(__PCD__) 
....................    *((unsigned int16 *)(&res)) = n + 0x7F; 
.................... #endif 
....................    p= (((unsigned int16 *)(&res))+3); 
....................    data1 = *p; 
....................    data2 = *p;    
....................    data1 = n + 0x3FF; 
....................    data1 = data1 <<4; 
....................    if(bit_test(data2,15)) 
....................    bit_set(data1,15); 
....................    data2 = data2 & 0x000F; 
....................    data1 ^= data2; 
....................  
....................    *(((unsigned int16 *)(&res)+3)) = data1; 
....................  
....................  
....................    y = y*LN2_INV - (float64)n; 
....................  
....................    r = pe_64[0]*y + pe_64[1]; 
....................    r = r*y + pe_64[2]; 
....................    r = r*y + pe_64[3]; 
....................    r = r*y + pe_64[4]; 
....................    r = r*y + pe_64[5]; 
....................    r = r*y + pe_64[6]; 
....................    r = r*y + pe_64[7]; 
....................    r = r*y + pe_64[8]; 
....................    r = r*y + pe_64[9]; 
....................    r = r*y + pe_64[10]; 
....................    r = r*y + pe_64[11]; 
....................     
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
.................... #ENDIF 
....................  
....................  
.................... /************************************************************/ 
....................  
.................... float32 const pl[4] = {-1.080310025160955, 1.999999947089217}; 
.................... float32 const ql[4] = {0.091284365719509, -0.873491916557671}; 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float log(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the the natural log of x 
.................... // Date : N/A 
.................... // 
.................... float32 log(float32 x) 
.................... { 
....................    float32 y, res, r, y2; 
....................    #if defined(__PCD__) 
....................    unsigned int8  data1,data2; 
....................    #endif 
....................    signed int8 n; 
....................    #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
.................... #if !defined(__PCD__) 
....................     *((unsigned int8 *)(&y)) = 0x7E;  
.................... #endif 
....................  
.................... #if defined(__PCD__) // Takes care of IEEE format 
....................    data2 = *(((unsigned int8 *)(&y))+3); 
....................    *(((unsigned int8 *)(&y))+3) = 0x3F; 
....................    data1 = *(((unsigned int8 *)(&y))+2); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&y))+2) = data1; 
....................    if(bit_test(data2,7)) 
....................      bit_set(*(((unsigned int8 *)(&y))+3),7); 
.................... #endif 
....................  
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl[0]*y2 + pl[1]; 
....................  
....................       r = ql[0]*y2 + ql[1]; 
....................       r = r*y2 + 1.0; 
....................  
....................       res = y*res/r; 
.................... #if !defined(__PCD__) 
....................       n = *((unsigned int8 *)(&x)) - 0x7E; 
.................... #endif 
.................... #if defined(__PCD__)  
....................     data1 = *(((unsigned int8 *)(&x)+3)); 
....................     rotate_left(&data1,1); 
....................     data2 = *(((unsigned int8 *)(&x)+2)); 
....................     if(bit_test (data2,7)) 
....................       bit_set(data1,0); 
....................     n = data1 - 0x7E; 
.................... #endif 
....................  
....................       if (n<0)  
....................          r = -(float32)-n; 
....................       else 
....................          r = (float32)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................       res = 0.0; 
....................  
....................    return(res); 
.................... } 
....................  
.................... //Overloaded function for log() for PCD 
.................... // Overloaded function log() for data type - Float48 
.................... #if defined(__PCD__) 
.................... // Overloaded function log() for data type - float64 
.................... float64 const pl_64[4] = {-0.145694052150681, 1.365485300000370, 
....................                           -3.120535668274329, 2.000000000000000}; 
....................  
.................... float64 const ql_64[4] = {0.006047500465908, -0.208298281937234, 
....................                           1.113943039156721, -1.893601167470470}; 
....................  
.................... float48 log(float48 x) 
.................... { 
....................    float48 y, res, r, y2; 
....................    unsigned int8  data1,data2; 
....................    signed int8 n; 
.................... #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
.................... #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
....................  
.................... #if !defined(__PCD__) 
....................       *((unsigned int8 *)(&y)) = 0x7E;  
.................... #endif 
....................       data2 = *(((unsigned int8 *)(&y))+5); 
....................       *(((unsigned int8 *)(&y))+5) = 0x3F; 
....................       data1 = *(((unsigned int8 *)(&y))+4); 
....................       bit_clear(data1,7); 
....................       *(((unsigned int8 *)(&y))+4) = data1; 
....................  
....................       if(bit_test(data2,7)) 
....................       bit_set(*(((unsigned int8 *)(&y))+4),7); 
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl_64[0]*y2 + pl_64[1]; 
....................       res = res*y2 + pl_64[2]; 
....................       res = res*y2 + pl_64[3]; 
....................  
....................       r = ql_64[0]*y2 + ql_64[1]; 
....................       r = r*y2 + ql_64[2]; 
....................       r = r*y2 + ql_64[3]; 
....................       r = r*y2 + 1.0;  
....................       res = y*res/r; 
....................  
....................       data1 = *(((unsigned int8 *)(&x)+5)); 
....................       rotate_left(&data1,1); 
....................       data2 = *(((unsigned int8 *)(&x)+4)); 
....................       if(bit_test (data2,7)) 
....................       bit_set(data1,0); 
....................        
....................       n = data1 - 0x7E; 
....................  
....................       if (n<0) 
....................       r = -(float48)-n; 
....................       else 
....................       r = (float48)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................    res = 0.0; 
....................  
....................    return(res); 
.................... } 
....................  
.................... float64 log(float64 x) 
.................... { 
....................    float64 y, res, r, y2; 
....................    unsigned int16  data1,data2; 
....................    unsigned int16 *p; 
....................    signed int16 n; 
....................    #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
....................    #if !defined(__PCD__) 
....................        *((unsigned int8 *)(&y)) = 0x7E;  
....................    #endif 
....................       p= (((unsigned int16 *)(&y))+3); 
....................       data1 = *p; 
....................       data2 = *p; 
....................       data1 = 0x3FE; 
....................       data1 = data1 <<4; 
....................       if(bit_test (data2,15)) 
....................          bit_set(data1,15); 
....................       data2 = data2 & 0x000F; 
....................       data1 ^=data2; 
....................  
....................       *p = data1; 
....................  
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl_64[0]*y2 + pl_64[1]; 
....................       res = res*y2 + pl_64[2]; 
....................       res = res*y2 + pl_64[3]; 
....................  
....................       r = ql_64[0]*y2 + ql_64[1]; 
....................       r = r*y2 + ql_64[2]; 
....................       r = r*y2 + ql_64[3]; 
....................       r = r*y2 + 1.0; 
....................  
....................       res = y*res/r; 
....................   
....................       p= (((unsigned int16 *)(&x))+3); 
....................       data1 = *p; 
....................       bit_clear(data1,15); 
....................       data1 = data1 >>4;     
....................       n = data1 - 0x3FE; 
....................  
....................  
....................       if (n<0) 
....................          r = -(float64)-n; 
....................       else 
....................          r = (float64)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................       res = 0.0; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
....................  
.................... #define LN10 2.3025850929940456 
.................... #define LN10_INV 0.4342944819032518276 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float log10(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the the log base 10 of x 
.................... // Date : N/A 
.................... // 
.................... float32 log10(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = log(x); 
....................    r = r*LN10_INV; 
....................    return(r); 
.................... } 
....................  
.................... //Overloaded functions for log10() for PCD 
.................... // Overloaded function log10() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 log10(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = log(x); 
....................    r = r*LN10_INV; 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function log10() for data type - Float64 
.................... float64 log10(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = log(x); 
....................    r = r*LN10_INV; 
....................    return(r); 
.................... } 
.................... #endif 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float modf(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description :breaks the argument value int integral and fractional parts, 
.................... // ach of which have the same sign as the argument.  It stores the integral part 
.................... // as a float in the object pointed to by the iptr 
.................... // Returns : returns the signed fractional part of value. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 modf(float32 value,float32 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... //Overloaded functions for modf() for PCD 
.................... // Overloaded function modf() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 modf(float48 value,float48 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... // Overloaded function modf() for data type - Float64 
.................... float64 modf(float64 value,float64 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float pwr(float x,float y) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (x^y) 
.................... // Date : N/A 
.................... // Note : 0 is returned when the function will generate an imaginary number 
.................... // 
.................... float32 pwr(float32 x,float32 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... //Overloaded functions for pwr() for PCD 
.................... // Overloaded function pwr() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 pwr(float48 x,float48 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... // Overloaded function pwr() for data type - Float64 
.................... float64 pwr(float64 x,float64 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////// Power functions //////////////////// 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float pow(float x,float y) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (x^y) 
.................... // Date : N/A 
.................... // Note : 0 is returned when the function will generate an imaginary number 
.................... // 
.................... float32 pow(float32 x,float32 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... //Overloaded functions for pow() for PCD 
.................... // Overloaded function for pow() data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 pow(float48 x,float48 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
....................  
.................... // Overloaded function pow() for data type - Float64 
.................... float64 pow(float64 x,float64 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sqrt(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the square root of x 
.................... // Date : N/A 
.................... // 
.................... float32 sqrt(float32 x) 
.................... { 
....................    float32 y, res; 
....................    #if defined(__PCD__) 
....................    unsigned int16 data1,data2; 
....................    #endif 
....................    unsigned int8 *p; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................     
....................    #if !defined(__PCD__) 
....................     p=&y; 
....................    (*p)=(unsigned int8)((((unsigned int16)(*p)) + 127) >> 1); 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     p = (((unsigned int8 *)(&y))+3); 
....................     data1 = *(((unsigned int8 *)(&y))+3); 
....................     data2 = *(((unsigned int8 *)(&y))+2); 
....................     rotate_left(&data1,1);     
....................     if(bit_test(data2,7))     
....................        bit_set(data1,0);     
....................     data1 = ((data1+127) >>1); 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+3) = data1; 
....................     *(((unsigned int8 *)(&y))+2) = data2; 
....................      
....................   #endif 
....................  
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................  
....................       #if !defined(__PCD__) 
....................      (*p)--; 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     data1 = *(((unsigned int8 *)(&y))+3); 
....................     data2 = *(((unsigned int8 *)(&y))+2); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................        bit_set(data1,0);     
....................     data1--; 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+3) = data1; 
....................     *(((unsigned int8 *)(&y))+2) = data2; 
....................      
....................   #endif 
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
.................... //Overloaded functions for sqrt() for PCD 
.................... // Overloaded function sqrt() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sqrt(float48 x) 
.................... { 
....................    float48 y, res; 
....................    unsigned int16 data1,data2; 
....................    unsigned int8 *p; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................     
....................    #if !defined(__PCD__) 
....................     p=&y; 
....................    (*p)=(unsigned int8)((((unsigned int16)(*p)) + 127) >> 1); 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     p = (((unsigned int8 *)(&y))+5); 
....................     data1 = *(((unsigned int8 *)(&y))+5); 
....................     data2 = *(((unsigned int8 *)(&y))+4); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................        bit_set(data1,0);     
....................     data1 = ((data1+127) >>1); 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+5) = data1; 
....................     *(((unsigned int8 *)(&y))+4) = data2; 
....................      
....................   #endif 
....................  
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................  
....................       #if !defined(__PCD__) 
....................      (*p)--; 
....................    #endif 
....................     
....................     data1 = *(((unsigned int8 *)(&y))+5); 
....................     data2 = *(((unsigned int8 *)(&y))+4); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................        bit_set(data1,0);     
....................     data1--; 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+5) = data1; 
....................     *(((unsigned int8 *)(&y))+4) = data2; 
....................      
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function sqrt() for data type - Float64 
.................... float64 sqrt(float64 x) 
.................... { 
....................    float64 y, res; 
....................    unsigned int16 *p; 
....................    unsigned int16 temp1,temp2; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................    p= (((unsigned int16 *)(&y))+3); 
....................    temp1 = *p; 
....................    temp2 = *p; 
....................    bit_clear(temp1,15); 
....................    temp1 = (temp1>>4)+1023; 
....................    temp1 = temp1 >> 1; 
....................    temp1 = (temp1<<4) & 0xFFF0; 
....................    if(bit_test(temp2,15)) 
....................       bit_set(temp1,15); 
....................    temp2 = temp2 & 0x000F; 
....................    temp1 ^= temp2; 
....................     
....................    (*p) = temp1; 
....................     
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................      temp1 = *p; 
....................      temp2 = *p; 
....................      bit_clear(temp1,15); 
....................      temp1 = (temp1>>4); 
....................      temp1--; 
....................      temp1 = (temp1<<4) & 0xFFF0; 
....................      if(bit_test(temp2,15)) 
....................         bit_set(temp1,15); 
....................      temp2 = temp2 & 0x000F; 
....................      temp1 ^= temp2; 
....................      (*p) = temp1; 
....................  
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... ////////////////////////////// Trig Functions ////////////////////////////// 
.................... #ifdef PI_DIV_BY_TWO_INV 
.................... #undef PI_DIV_BY_TWO_INV 
.................... #endif 
.................... #define PI_DIV_BY_TWO_INV 0.63661977236758134 
.................... #ifdef PI_DIV_BY_TWO 
.................... #undef PI_DIV_BY_TWO 
.................... #endif 
.................... #define PI_DIV_BY_TWO   1.5707963267948966 
.................... #ifdef TWOBYPI 
.................... #undef TWOBYPI 
.................... #endif 
.................... #define TWOBYPI          0.6366197723675813 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float cos(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the cosine value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 cos(float32 x) 
.................... { 
....................    float32 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float32 frac; 
....................    float32 p[5] = {                    //by the series definition for cosine 
....................       -0.49999999456337096,            // sum ( ( (-1)^n * x^2n )/(2n)! ) 
....................        0.04166663896921267, 
....................       -0.00138883894522527, 
....................        0.00002476138231734, 
....................       -0.00000026070414770 
....................       //-0.00000000001147, 
....................       // 0.00000000000005 
....................    }; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant 
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 1.0; 
....................    t = t * t; 
....................    for (i = 0; i <= 4; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
....................  
.................... //Overloaded functions for cos() for PCD 
.................... // Overloaded function cos() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 cos(float48 x) 
.................... { 
....................    float48 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float48 frac; 
....................    float48 p[6] = {                    //by the series definition for cosine 
....................       -0.5,                            // sum ( ( (-1)^n * x^2n )/(2n)! ) 
....................        0.04166666666667, 
....................       -0.00138888888889, 
....................        0.00002480158730, 
....................       -0.00000027557319, 
....................        0.00000000208767, 
....................       //-0.00000000001147, 
....................       // 0.00000000000005 
....................    }; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant 
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 0.999999999781; 
....................    t = t * t; 
....................    for (i = 0; i <= 5; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
.................... // Overloaded function cos() for data type - Float64 
.................... float64 cos(float64 x) 
.................... { 
....................    float64 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float64 frac; 
....................    float64 p_64[9] = {               //by the series definition for cosine 
....................      -0.49999999999998740,           // sum ( ( (-1)^n * x^2n )/(2n)! )              
....................       0.04166666666656518, 
....................      -0.00138888888851691, 
....................       0.00002480158658490, 
....................      -0.00000027557239796, 
....................       0.00000000208715031, 
....................      -0.00000000001126577, 
....................       0.00000000000000427, 
....................       0.00000000000000372}; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant 
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 1.0; 
....................    t = t * t; 
....................    for (i = 0; i <= 8; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p_64[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sin(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the sine value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 sin(float32 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
....................  
.................... //Overloaded functions for sin() for PCD 
.................... // Overloaded function sin() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sin(float48 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
....................  
.................... // Overloaded function sin() for data type - Float48 
.................... float64 sin(float64 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float tan(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the tangent value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 tan(float32 x) 
.................... { 
....................    float32 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
.................... //Overloaded functions for tan() for PCD 
.................... // Overloaded function tan() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 tan(float48 x) 
.................... { 
....................    float48 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
....................  
.................... // Overloaded function tan() for data type - Float48 
.................... float64 tan(float64 x) 
.................... { 
....................    float64 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
.................... #endif 
....................  
.................... float32 const pas[3] = {0.49559947, -4.6145309, 5.6036290}; 
.................... float32 const qas[3] = {1.0000000,  -5.5484666, 5.6036290}; 
....................  
.................... float32 ASIN_COS(float32 x, unsigned int8 n) 
.................... { 
....................    float32 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)*0.5); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas[0]*y2 + pas[1]; 
....................    res = res*y2 + pas[2]; 
....................  
....................    r = qas[0]*y2 + qas[1]; 
....................    r = r*y2 + qas[2]; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
....................  
....................  
.................... //Overloaded functions for ASIN_COS() for PCD 
.................... // Overloaded function ASIN_COS() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 ASIN_COS(float48 x, unsigned int8 n) 
.................... { 
....................    float48 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)*0.5); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas[0]*y2 + pas[1]; 
....................    res = res*y2 + pas[2]; 
....................  
....................    r = qas[0]*y2 + qas[1]; 
....................    r = r*y2 + qas[2]; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function ASIN_COS() for data type - Float64 
.................... double pas_64[5]={1.000000000000000,-2.069938587724477,1.421444580548907, 
....................                  -0.360690137621842,0.024929451660228}; 
....................  
.................... double qas_64[5]={-2.236605254391134,1.719212122946451,-0.524122954476133, 
....................                    0.052808872045749,-0.000662536036570}; 
....................                     
.................... float64 ASIN_COS(float64 x, unsigned int8 n) 
.................... { 
....................    float64 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)*0.5); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas_64[4]*y2 + pas_64[3]; 
....................    res = res*y2 + pas_64[2]; 
....................    res = res*y2 + pas_64[1]; 
....................    res = res*y2 + pas_64[0]; 
....................  
....................    r = qas_64[4]*y2 + qas_64[3]; 
....................    r = r*y2 + qas_64[2]; 
....................    r = r*y2 + qas_64[1]; 
....................    r = r*y2 + qas_64[0]; 
....................    r = r*y2 + 1.0; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float asin(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arcsine value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 asin(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
.................... //Overloaded functions for asin() for PCD 
.................... // Overloaded function asin() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 asin(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function asin() for data type - Float64 
.................... float64 asin(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float acos(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arccosine value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 acos(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
.................... //Overloaded functions for acos() for PCD 
.................... // Overloaded function acos() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 acos(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function acos() for data type - Float64 
.................... float64 acos(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
.................... #endif 
....................  
.................... float32 const pat[4] = {0.17630401, 5.6710795, 22.376096, 19.818457}; 
.................... float32 const qat[4] = {1.0000000,  11.368190, 28.982246, 19.818457}; 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float atan(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arctangent value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 atan(float32 x) 
.................... { 
....................    float32 y, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................  
....................    res = pat[0]*y*y + pat[1]; 
....................    res = res*y*y + pat[2]; 
....................    res = res*y*y + pat[3]; 
....................  
....................    r = qat[0]*y*y + qat[1]; 
....................    r = r*y*y + qat[2]; 
....................    r = r*y*y + qat[3]; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
.................... //Overloaded functions for atan() for PCD 
.................... // Overloaded function atan() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 atan(float48 x) 
.................... { 
....................    float48 y, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................  
....................    res = pat[0]*y*y + pat[1]; 
....................    res = res*y*y + pat[2]; 
....................    res = res*y*y + pat[3]; 
....................  
....................    r = qat[0]*y*y + qat[1]; 
....................    r = r*y*y + qat[2]; 
....................    r = r*y*y + qat[3]; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
....................  
.................... float64 pat_64[6]={0.999999999999999,2.249923645595566,1.771541617806449, 
....................                    0.579678874003185,0.072162702162882,0.002281100141660}; 
....................  
.................... float64 qat_64[6]={2.583256978928510,2.432627277466967,1.016760379885393, 
....................                    0.182482977188688,0.011155377971690,0.000100013019160}; 
.................... // Overloaded function atan() for data type - Float64 
.................... float64 atan(float64 x) 
.................... { 
....................    float64 y,y2, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................    y2 = y*y; 
....................    res = pat_64[5]*y2 + pat_64[4]; 
....................    res = res*y2 + pat_64[3]; 
....................    res = res*y2 + pat_64[2]; 
....................    res = res*y2 + pat_64[1]; 
....................    res = res*y2 + pat_64[0]; 
....................  
....................    r = qat_64[5]*y2 + qat_64[4]; 
....................    r = r*y2 + qat_64[3]; 
....................    r = r*y2 + qat_64[2]; 
....................    r = r*y2 + qat_64[1]; 
....................    r = r*y2 + qat_64[0]; 
....................    r = r*y2 + 1.0; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... ///////////////////////////////////////////////////////////////////////////// 
.................... //   float atan2(float y, float x) 
.................... ///////////////////////////////////////////////////////////////////////////// 
.................... // Description :computes the principal value of arc tangent of y/x, using the 
.................... // signs of both the arguments to determine the quadrant of the return value 
.................... // Returns : returns the arc tangent of y/x. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 atan2(float32 y,float32 x) 
.................... { 
....................    float32 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
....................  
.................... //Overloaded functions for atan2() for PCD 
.................... // Overloaded function atan2() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 atan2(float48 y,float48 x) 
.................... { 
....................    float48 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
....................  
.................... // Overloaded function atan2() for data type - Float64 
.................... float64 atan2(float64 y,float64 x) 
.................... { 
....................    float64 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////// Hyperbolic functions //////////////////// 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float cosh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic cosine value of x 
.................... // Returns : returns the hyperbolic cosine value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 cosh(float32 x) 
.................... { 
....................    return ((exp(x)+exp(-x))*0.5); 
.................... } 
.................... //Overloaded functions for cosh() for PCD 
.................... // Overloaded function cosh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 cosh(float48 x) 
.................... { 
....................    return ((exp(x)+exp(-x))*0.5); 
.................... } 
....................  
.................... // Overloaded function cosh() for data type - Float64 
.................... float64 cosh(float64 x) 
.................... { 
....................    return ((exp(x)+exp(-x))*0.5); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sinh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic sine value of x 
.................... // Returns : returns the hyperbolic sine value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 sinh(float32 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))*0.5); 
.................... } 
.................... //Overloaded functions for sinh() for PCD 
.................... // Overloaded function sinh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sinh(float48 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))*0.5); 
.................... } 
....................  
.................... // Overloaded function sinh() for data type - Float48 
.................... float64 sinh(float64 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))*0.5); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float tanh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic tangent value of x 
.................... // Returns : returns the hyperbolic tangent value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 tanh(float32 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
.................... //Overloaded functions for tanh() for PCD 
.................... // Overloaded function tanh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 tanh(float48 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
....................  
.................... // Overloaded function tanh() for data type - Float64 
.................... float64 tanh(float64 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float frexp(float x, signed int *exp) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : breaks a floating point number into a normalized fraction and an integral 
.................... // power of 2. It stores the integer in the signed int object pointed to by exp. 
.................... // Returns : returns the value x, such that x is a double with magnitude in the interval 
.................... // [1/2,1) or zero, and value equals x times 2 raised to the power *exp.If value is zero, 
.................... // both parts of the result are zero. 
.................... // Date : N/A 
.................... // 
....................  
.................... #define LOG2 .30102999566398119521 
.................... #define LOG2_INV 3.32192809488736234787 
.................... float32 frexp(float32 x, signed int8 *exp) 
.................... { 
....................    float32 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)*LOG2_INV)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
....................  
.................... //Overloaded functions for frexp() for PCD 
.................... // Overloaded function frexp() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 frexp(float48 x, signed int8 *exp) 
.................... { 
....................    float48 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)*LOG2_INV)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
....................  
.................... // Overloaded function frexp() for data type - Float64 
.................... float64 frexp(float64 x, signed int8 *exp) 
.................... { 
....................    float64 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)*LOG2_INV)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
.................... #endif 
....................  
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... //   float ldexp(float x, signed int *exp) 
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... // Description : multiplies a floating point number by an integral power of 2. 
.................... // Returns : returns the value of x times 2 raised to the power exp. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 ldexp(float32 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... //Overloaded functions for ldexp() for PCD 
.................... // Overloaded function ldexp() for data type - Float48 
....................  
.................... #if defined(__PCD__) 
.................... float48 ldexp(float48 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... // Overloaded function ldexp() for data type - Float64 
.................... float64 ldexp(float64 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... #endif 
....................  
.................... #endif 
....................  
.................... #FUSES NOWDT, PUT, HS 
.................... #USE DELAY(CLOCK=20M) 
*
0163:  MOVLW  40
0164:  MOVWF  04
0165:  BSF    03.7
0166:  MOVF   00,W
0167:  BTFSC  03.2
0168:  GOTO   176
0169:  MOVLW  06
016A:  MOVWF  78
016B:  CLRF   77
016C:  DECFSZ 77,F
016D:  GOTO   16C
016E:  DECFSZ 78,F
016F:  GOTO   16B
0170:  MOVLW  7B
0171:  MOVWF  77
0172:  DECFSZ 77,F
0173:  GOTO   172
0174:  DECFSZ 00,F
0175:  GOTO   169
0176:  RETURN
.................... #USE RS232(BAUD=9600,XMIT=PIN_C6,RCV=PIN_C7) 
.................... #DEFINE BT1_PIN PIN_B1 
.................... #DEFINE BT2_PIN PIN_B2 
.................... #DEFINE BT3_PIN PIN_B3 
.................... #DEFINE LCD_ENABLE_PIN  PIN_E0                                    
.................... #DEFINE LCD_RS_PIN      PIN_E1                                 
.................... #DEFINE LCD_RW_PIN      PIN_E2   
.................... #DEFINE LCD_DATA4       PIN_C0                                
.................... #DEFINE LCD_DATA5       PIN_C1                                  
.................... #DEFINE LCD_DATA6       PIN_C2                                    
.................... #DEFINE LCD_DATA7       PIN_C3   
.................... #INCLUDE <LCD.C> 
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... ////                             LCD.C                                     //// 
.................... ////                 Driver for common LCD modules                         //// 
.................... ////                                                                       //// 
.................... ////  lcd_init()   Must be called before any other function.               //// 
.................... ////                                                                       //// 
.................... ////  lcd_putc(c)  Will display c on the next position of the LCD.         //// 
.................... ////                 \a  Set cursor position to upper left                 //// 
.................... ////                 \f  Clear display, set cursor to upper left           //// 
.................... ////                 \n  Go to start of second line                        //// 
.................... ////                 \b  Move back one position                            //// 
.................... ////              If LCD_EXTENDED_NEWLINE is defined, the \n character     //// 
.................... ////              will erase all remanining characters on the current      //// 
.................... ////              line, and move the cursor to the beginning of the next   //// 
.................... ////              line.                                                    //// 
.................... ////              If LCD_EXTENDED_NEWLINE is defined, the \r character     //// 
.................... ////              will move the cursor to the start of the current         //// 
.................... ////              line.                                                    //// 
.................... ////                                                                       //// 
.................... ////  lcd_gotoxy(x,y) Set write position on LCD (upper left is 1,1)        //// 
.................... ////                                                                       //// 
.................... ////  lcd_getc(x,y)   Returns character at position x,y on LCD             //// 
.................... ////                                                                       //// 
.................... ////  lcd_cursor_on(int1 on)   Turn the cursor on (on=TRUE) or off         //// 
.................... ////              (on=FALSE).                                              //// 
.................... ////                                                                       //// 
.................... ////  lcd_set_cgram_char(w, *p)   Write a custom character to the CGRAM.   //// 
.................... ////                                                                       //// 
.................... ////                                                                       //// 
.................... ////  CONFIGURATION                                                        //// 
.................... ////  The LCD can be configured in one of two ways: a.) port access or     //// 
.................... ////  b.) pin access.  Port access requires the entire 7 bit interface     //// 
.................... ////  connected to one GPIO port, and the data bits (D4:D7 of the LCD)     //// 
.................... ////  connected to sequential pins on the GPIO.  Pin access                //// 
.................... ////  has no requirements, all 7 bits of the control interface can         //// 
.................... ////  can be connected to any GPIO using several ports.                    //// 
.................... ////                                                                       //// 
.................... ////  To use port access, #define LCD_DATA_PORT to the SFR location of     //// 
.................... ////  of the GPIO port that holds the interface, -AND- edit LCD_PIN_MAP    //// 
.................... ////  of this file to configure the pin order.  If you are using a         //// 
.................... ////  baseline PIC (PCB), then LCD_OUTPUT_MAP and LCD_INPUT_MAP also must  //// 
.................... ////  be defined.                                                          //// 
.................... ////                                                                       //// 
.................... ////  Example of port access:                                              //// 
.................... ////     #define LCD_DATA_PORT getenv("SFR:PORTD")                         //// 
.................... ////                                                                       //// 
.................... ////  To use pin access, the following pins must be defined:               //// 
.................... ////     LCD_ENABLE_PIN                                                    //// 
.................... ////     LCD_RS_PIN                                                        //// 
.................... ////     LCD_RW_PIN                                                        //// 
.................... ////     LCD_DATA4                                                         //// 
.................... ////     LCD_DATA5                                                         //// 
.................... ////     LCD_DATA6                                                         //// 
.................... ////     LCD_DATA7                                                         //// 
.................... ////                                                                       //// 
.................... ////  Example of pin access:                                               //// 
.................... ////     #define LCD_ENABLE_PIN  PIN_E0                                    //// 
.................... ////     #define LCD_RS_PIN      PIN_E1                                    //// 
.................... ////     #define LCD_RW_PIN      PIN_E2                                    //// 
.................... ////     #define LCD_DATA4       PIN_D4                                    //// 
.................... ////     #define LCD_DATA5       PIN_D5                                    //// 
.................... ////     #define LCD_DATA6       PIN_D6                                    //// 
.................... ////     #define LCD_DATA7       PIN_D7                                    //// 
.................... ////                                                                       //// 
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2010 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef __LCD_C__ 
.................... #define __LCD_C__ 
....................  
.................... // define the pinout. 
.................... // only required if port access is being used. 
.................... typedef struct   
.................... {                            // This structure is overlayed 
....................    int1 enable;           // on to an I/O port to gain 
....................    int1 rs;               // access to the LCD pins. 
....................    int1 rw;               // The bits are allocated from 
....................    int1 unused;           // low order up.  ENABLE will 
....................    unsigned int     data : 4;         // be LSB pin of that port. 
....................   #if defined(__PCD__)       // The port used will be LCD_DATA_PORT. 
....................    unsigned int    reserved: 8; 
....................   #endif 
.................... } LCD_PIN_MAP; 
....................  
.................... // this is to improve compatability with previous LCD drivers that accepted 
.................... // a define labeled 'use_portb_lcd' that configured the LCD onto port B. 
.................... #if ((defined(use_portb_lcd)) && (use_portb_lcd==TRUE)) 
....................  #define LCD_DATA_PORT getenv("SFR:PORTB") 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
....................    // these definitions only need to be modified for baseline PICs. 
....................    // all other PICs use LCD_PIN_MAP or individual LCD_xxx pin definitions. 
.................... /*                                    EN, RS,   RW,   UNUSED,  DATA  */ 
....................  const LCD_PIN_MAP LCD_OUTPUT_MAP =  {0,  0,    0,    0,       0}; 
....................  const LCD_PIN_MAP LCD_INPUT_MAP =   {0,  0,    0,    0,       0xF}; 
.................... #endif 
....................  
.................... ////////////////////// END CONFIGURATION /////////////////////////////////// 
....................  
.................... #ifndef LCD_ENABLE_PIN 
....................    #define lcd_output_enable(x) lcdlat.enable=x 
....................    #define lcd_enable_tris()   lcdtris.enable=0 
.................... #else 
....................    #define lcd_output_enable(x) output_bit(LCD_ENABLE_PIN, x) 
....................    #define lcd_enable_tris()  output_drive(LCD_ENABLE_PIN) 
.................... #endif 
....................  
.................... #ifndef LCD_RS_PIN 
....................    #define lcd_output_rs(x) lcdlat.rs=x 
....................    #define lcd_rs_tris()   lcdtris.rs=0 
.................... #else 
....................    #define lcd_output_rs(x) output_bit(LCD_RS_PIN, x) 
....................    #define lcd_rs_tris()  output_drive(LCD_RS_PIN) 
.................... #endif 
....................  
.................... #ifndef LCD_RW_PIN 
....................    #define lcd_output_rw(x) lcdlat.rw=x 
....................    #define lcd_rw_tris()   lcdtris.rw=0 
.................... #else 
....................    #define lcd_output_rw(x) output_bit(LCD_RW_PIN, x) 
....................    #define lcd_rw_tris()  output_drive(LCD_RW_PIN) 
.................... #endif 
....................  
.................... // original version of this library incorrectly labeled LCD_DATA0 as LCD_DATA4, 
.................... // LCD_DATA1 as LCD_DATA5, and so on.  this block of code makes the driver 
.................... // compatible with any code written for the original library 
.................... #if (defined(LCD_DATA0) && defined(LCD_DATA1) && defined(LCD_DATA2) && defined(LCD_DATA3) && !defined(LCD_DATA4) && !defined(LCD_DATA5) && !defined(LCD_DATA6) && !defined(LCD_DATA7)) 
....................    #define  LCD_DATA4    LCD_DATA0 
....................    #define  LCD_DATA5    LCD_DATA1 
....................    #define  LCD_DATA6    LCD_DATA2 
....................    #define  LCD_DATA7    LCD_DATA3 
.................... #endif 
....................  
.................... #ifndef LCD_DATA4 
.................... #ifndef LCD_DATA_PORT 
....................    #if defined(__PCB__) 
....................       #define LCD_DATA_PORT      0x06     //portb 
....................       #define set_tris_lcd(x)   set_tris_b(x) 
....................    #else 
....................      #if defined(PIN_D0) 
....................       #define LCD_DATA_PORT      getenv("SFR:PORTD")     //portd 
....................      #else 
....................       #define LCD_DATA_PORT      getenv("SFR:PORTB")     //portb 
....................      #endif 
....................    #endif    
.................... #endif 
....................  
.................... #if defined(__PCB__) 
....................    LCD_PIN_MAP lcd, lcdlat; 
....................    #byte lcd = LCD_DATA_PORT 
....................    #byte lcdlat = LCD_DATA_PORT 
.................... #elif defined(__PCM__) 
....................    LCD_PIN_MAP lcd, lcdlat, lcdtris; 
....................    #byte lcd = LCD_DATA_PORT 
....................    #byte lcdlat = LCD_DATA_PORT 
....................    #byte lcdtris = LCD_DATA_PORT+0x80 
.................... #elif defined(__PCH__) 
....................    LCD_PIN_MAP lcd, lcdlat, lcdtris; 
....................    #byte lcd = LCD_DATA_PORT 
....................    #byte lcdlat = LCD_DATA_PORT+9 
....................    #byte lcdtris = LCD_DATA_PORT+0x12 
.................... #elif defined(__PCD__) 
....................    LCD_PIN_MAP lcd, lcdlat, lcdtris; 
....................    #word lcd = LCD_DATA_PORT 
....................    #word lcdlat = LCD_DATA_PORT+2 
....................    #word lcdtris = LCD_DATA_PORT-0x02 
.................... #endif 
.................... #endif   //LCD_DATA4 not defined 
....................  
.................... #ifndef LCD_TYPE 
....................    #define LCD_TYPE 2           // 0=5x7, 1=5x10, 2=2 lines 
.................... #endif 
....................  
.................... #ifndef LCD_LINE_TWO 
....................    #define LCD_LINE_TWO 0x40    // LCD RAM address for the second line 
.................... #endif 
....................  
.................... #ifndef LCD_LINE_LENGTH 
....................    #define LCD_LINE_LENGTH 20 
.................... #endif 
....................  
.................... unsigned int8 lcd_read_nibble(void); 
....................  
.................... unsigned int8 lcd_read_byte(void) 
.................... { 
....................    unsigned int8 low,high; 
....................  
....................  #if defined(__PCB__) 
....................    set_tris_lcd(LCD_INPUT_MAP); 
....................  #else 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    output_float(LCD_DATA4); 
*
020A:  BSF    07.0
....................    output_float(LCD_DATA5); 
020B:  BSF    07.1
....................    output_float(LCD_DATA6); 
020C:  BSF    07.2
....................    output_float(LCD_DATA7); 
020D:  BSF    07.3
....................   #else 
....................    lcdtris.data = 0xF; 
....................   #endif 
....................  #endif 
....................          
....................    lcd_output_rw(1); 
020E:  BCF    03.5
020F:  BSF    09.2
0210:  BSF    03.5
0211:  BCF    09.2
....................    delay_cycles(1); 
0212:  NOP
....................    lcd_output_enable(1); 
0213:  BCF    03.5
0214:  BSF    09.0
0215:  BSF    03.5
0216:  BCF    09.0
....................    delay_cycles(1); 
0217:  NOP
....................    high = lcd_read_nibble(); 
0218:  BCF    03.5
0219:  CALL   1BF
021A:  MOVF   78,W
021B:  BSF    03.6
021C:  MOVWF  47
....................        
....................    lcd_output_enable(0); 
021D:  BCF    03.6
021E:  BCF    09.0
021F:  BSF    03.5
0220:  BCF    09.0
....................    delay_cycles(1); 
0221:  NOP
....................    lcd_output_enable(1); 
0222:  BCF    03.5
0223:  BSF    09.0
0224:  BSF    03.5
0225:  BCF    09.0
....................    delay_us(1); 
0226:  GOTO   227
0227:  GOTO   228
0228:  NOP
....................    low = lcd_read_nibble(); 
0229:  BCF    03.5
022A:  CALL   1BF
022B:  MOVF   78,W
022C:  BSF    03.6
022D:  MOVWF  46
....................        
....................    lcd_output_enable(0); 
022E:  BCF    03.6
022F:  BCF    09.0
0230:  BSF    03.5
0231:  BCF    09.0
....................  
....................  #if defined(__PCB__) 
....................    set_tris_lcd(LCD_OUTPUT_MAP); 
....................  #else 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    output_drive(LCD_DATA4); 
0232:  BCF    03.5
0233:  BCF    31.0
0234:  MOVF   31,W
0235:  BSF    03.5
0236:  MOVWF  07
....................    output_drive(LCD_DATA5); 
0237:  BCF    03.5
0238:  BCF    31.1
0239:  MOVF   31,W
023A:  BSF    03.5
023B:  MOVWF  07
....................    output_drive(LCD_DATA6); 
023C:  BCF    03.5
023D:  BCF    31.2
023E:  MOVF   31,W
023F:  BSF    03.5
0240:  MOVWF  07
....................    output_drive(LCD_DATA7); 
0241:  BCF    03.5
0242:  BCF    31.3
0243:  MOVF   31,W
0244:  BSF    03.5
0245:  MOVWF  07
....................   #else 
....................    lcdtris.data = 0x0; 
....................   #endif 
....................  #endif 
....................  
....................    return( (high<<4) | low); 
0246:  BCF    03.5
0247:  BSF    03.6
0248:  SWAPF  47,W
0249:  MOVWF  77
024A:  MOVLW  F0
024B:  ANDWF  77,F
024C:  MOVF   77,W
024D:  IORWF  46,W
024E:  MOVWF  78
.................... } 
....................  
.................... unsigned int8 lcd_read_nibble(void) 
.................... { 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
*
01BF:  BSF    03.6
01C0:  CLRF   48
....................    unsigned int8 n = 0x00; 
....................  
....................    /* Read the data port */ 
....................    n |= input(LCD_DATA4); 
01C1:  BCF    03.6
01C2:  BSF    31.0
01C3:  MOVF   31,W
01C4:  BSF    03.5
01C5:  MOVWF  07
01C6:  MOVLW  00
01C7:  BCF    03.5
01C8:  BTFSC  07.0
01C9:  MOVLW  01
01CA:  BSF    03.6
01CB:  IORWF  48,F
....................    n |= input(LCD_DATA5) << 1; 
01CC:  BCF    03.6
01CD:  BSF    31.1
01CE:  MOVF   31,W
01CF:  BSF    03.5
01D0:  MOVWF  07
01D1:  MOVLW  00
01D2:  BCF    03.5
01D3:  BTFSC  07.1
01D4:  MOVLW  01
01D5:  MOVWF  77
01D6:  BCF    03.0
01D7:  RLF    77,F
01D8:  MOVF   77,W
01D9:  BSF    03.6
01DA:  IORWF  48,F
....................    n |= input(LCD_DATA6) << 2; 
01DB:  BCF    03.6
01DC:  BSF    31.2
01DD:  MOVF   31,W
01DE:  BSF    03.5
01DF:  MOVWF  07
01E0:  MOVLW  00
01E1:  BCF    03.5
01E2:  BTFSC  07.2
01E3:  MOVLW  01
01E4:  MOVWF  77
01E5:  RLF    77,F
01E6:  RLF    77,F
01E7:  MOVLW  FC
01E8:  ANDWF  77,F
01E9:  MOVF   77,W
01EA:  BSF    03.6
01EB:  IORWF  48,F
....................    n |= input(LCD_DATA7) << 3; 
01EC:  BCF    03.6
01ED:  BSF    31.3
01EE:  MOVF   31,W
01EF:  BSF    03.5
01F0:  MOVWF  07
01F1:  MOVLW  00
01F2:  BCF    03.5
01F3:  BTFSC  07.3
01F4:  MOVLW  01
01F5:  MOVWF  77
01F6:  RLF    77,F
01F7:  RLF    77,F
01F8:  RLF    77,F
01F9:  MOVLW  F8
01FA:  ANDWF  77,F
01FB:  MOVF   77,W
01FC:  BSF    03.6
01FD:  IORWF  48,F
....................     
....................    return(n); 
01FE:  MOVF   48,W
01FF:  MOVWF  78
....................   #else 
0200:  BCF    03.6
0201:  RETURN
....................    return(lcd.data); 
....................   #endif 
.................... } 
....................  
.................... void lcd_send_nibble(unsigned int8 n) 
.................... { 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    /* Write to the data port */ 
....................    output_bit(LCD_DATA4, bit_test(n, 0)); 
*
0177:  BSF    03.6
0178:  BTFSC  47.0
0179:  GOTO   17E
017A:  BCF    03.6
017B:  BCF    07.0
017C:  GOTO   180
017D:  BSF    03.6
017E:  BCF    03.6
017F:  BSF    07.0
0180:  BCF    31.0
0181:  MOVF   31,W
0182:  BSF    03.5
0183:  MOVWF  07
....................    output_bit(LCD_DATA5, bit_test(n, 1)); 
0184:  BCF    03.5
0185:  BSF    03.6
0186:  BTFSC  47.1
0187:  GOTO   18C
0188:  BCF    03.6
0189:  BCF    07.1
018A:  GOTO   18E
018B:  BSF    03.6
018C:  BCF    03.6
018D:  BSF    07.1
018E:  BCF    31.1
018F:  MOVF   31,W
0190:  BSF    03.5
0191:  MOVWF  07
....................    output_bit(LCD_DATA6, bit_test(n, 2)); 
0192:  BCF    03.5
0193:  BSF    03.6
0194:  BTFSC  47.2
0195:  GOTO   19A
0196:  BCF    03.6
0197:  BCF    07.2
0198:  GOTO   19C
0199:  BSF    03.6
019A:  BCF    03.6
019B:  BSF    07.2
019C:  BCF    31.2
019D:  MOVF   31,W
019E:  BSF    03.5
019F:  MOVWF  07
....................    output_bit(LCD_DATA7, bit_test(n, 3)); 
01A0:  BCF    03.5
01A1:  BSF    03.6
01A2:  BTFSC  47.3
01A3:  GOTO   1A8
01A4:  BCF    03.6
01A5:  BCF    07.3
01A6:  GOTO   1AA
01A7:  BSF    03.6
01A8:  BCF    03.6
01A9:  BSF    07.3
01AA:  BCF    31.3
01AB:  MOVF   31,W
01AC:  BSF    03.5
01AD:  MOVWF  07
....................   #else       
....................    lcdlat.data = n; 
....................   #endif 
....................        
....................    delay_cycles(1); 
01AE:  NOP
....................    lcd_output_enable(1); 
01AF:  BCF    03.5
01B0:  BSF    09.0
01B1:  BSF    03.5
01B2:  BCF    09.0
....................    delay_us(2); 
01B3:  MOVLW  02
01B4:  MOVWF  77
01B5:  DECFSZ 77,F
01B6:  GOTO   1B5
01B7:  GOTO   1B8
01B8:  NOP
....................    lcd_output_enable(0); 
01B9:  BCF    03.5
01BA:  BCF    09.0
01BB:  BSF    03.5
01BC:  BCF    09.0
01BD:  BCF    03.5
01BE:  RETURN
.................... } 
....................  
.................... void lcd_send_byte(unsigned int8 address, unsigned int8 n) 
.................... { 
....................   #if defined(__PCB__) 
....................    set_tris_lcd(LCD_OUTPUT_MAP); 
....................   #else 
....................    lcd_enable_tris(); 
*
0202:  BSF    03.5
0203:  BCF    09.0
....................    lcd_rs_tris(); 
0204:  BCF    09.1
....................    lcd_rw_tris(); 
0205:  BCF    09.2
....................   #endif 
....................  
....................    lcd_output_rs(0); 
0206:  BCF    03.5
0207:  BCF    09.1
0208:  BSF    03.5
0209:  BCF    09.1
....................    while ( bit_test(lcd_read_byte(),7) ) ; 
*
024F:  MOVF   78,W
0250:  MOVWF  46
0251:  BTFSS  46.7
0252:  GOTO   256
0253:  BSF    03.5
0254:  BCF    03.6
0255:  GOTO   20A
....................    lcd_output_rs(address); 
0256:  MOVF   44,F
0257:  BTFSS  03.2
0258:  GOTO   25D
0259:  BCF    03.6
025A:  BCF    09.1
025B:  GOTO   25F
025C:  BSF    03.6
025D:  BCF    03.6
025E:  BSF    09.1
025F:  BSF    03.5
0260:  BCF    09.1
....................    delay_cycles(1); 
0261:  NOP
....................    lcd_output_rw(0); 
0262:  BCF    03.5
0263:  BCF    09.2
0264:  BSF    03.5
0265:  BCF    09.2
....................    delay_cycles(1); 
0266:  NOP
....................    lcd_output_enable(0); 
0267:  BCF    03.5
0268:  BCF    09.0
0269:  BSF    03.5
026A:  BCF    09.0
....................    lcd_send_nibble(n >> 4); 
026B:  BCF    03.5
026C:  BSF    03.6
026D:  SWAPF  45,W
026E:  MOVWF  46
026F:  MOVLW  0F
0270:  ANDWF  46,F
0271:  MOVF   46,W
0272:  MOVWF  47
0273:  BCF    03.6
0274:  CALL   177
....................    lcd_send_nibble(n & 0xf); 
0275:  BSF    03.6
0276:  MOVF   45,W
0277:  ANDLW  0F
0278:  MOVWF  46
0279:  MOVWF  47
027A:  BCF    03.6
027B:  CALL   177
027C:  RETURN
.................... } 
....................  
.................... #if defined(LCD_EXTENDED_NEWLINE) 
.................... unsigned int8 g_LcdX, g_LcdY; 
.................... #endif 
....................  
.................... void lcd_init(void)  
.................... { 
....................    unsigned int8 i; 
....................    unsigned int8 LCD_INIT_STRING[4] = {0x20 | (LCD_TYPE << 2), 0xc, 1, 6}; 
027D:  MOVLW  28
027E:  BSF    03.5
027F:  MOVWF  51
0280:  MOVLW  0C
0281:  MOVWF  52
0282:  MOVLW  01
0283:  MOVWF  53
0284:  MOVLW  06
0285:  MOVWF  54
....................                              // These bytes need to be sent to the LCD 
....................                              // to start it up. 
....................     
....................  
....................    lcd_output_enable(0); 
0286:  BCF    03.5
0287:  BCF    09.0
0288:  BSF    03.5
0289:  BCF    09.0
....................    lcd_output_rs(0); 
028A:  BCF    03.5
028B:  BCF    09.1
028C:  BSF    03.5
028D:  BCF    09.1
....................    lcd_output_rw(0); 
028E:  BCF    03.5
028F:  BCF    09.2
0290:  BSF    03.5
0291:  BCF    09.2
....................  
....................  #if defined(__PCB__) 
....................    set_tris_lcd(LCD_OUTPUT_MAP); 
....................  #else 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    output_drive(LCD_DATA4); 
0292:  BCF    03.5
0293:  BCF    31.0
0294:  MOVF   31,W
0295:  BSF    03.5
0296:  MOVWF  07
....................    output_drive(LCD_DATA5); 
0297:  BCF    03.5
0298:  BCF    31.1
0299:  MOVF   31,W
029A:  BSF    03.5
029B:  MOVWF  07
....................    output_drive(LCD_DATA6); 
029C:  BCF    03.5
029D:  BCF    31.2
029E:  MOVF   31,W
029F:  BSF    03.5
02A0:  MOVWF  07
....................    output_drive(LCD_DATA7); 
02A1:  BCF    03.5
02A2:  BCF    31.3
02A3:  MOVF   31,W
02A4:  BSF    03.5
02A5:  MOVWF  07
....................   #else 
....................    lcdtris.data = 0x0; 
....................   #endif 
....................    lcd_enable_tris(); 
02A6:  BCF    09.0
....................    lcd_rs_tris(); 
02A7:  BCF    09.1
....................    lcd_rw_tris(); 
02A8:  BCF    09.2
....................  #endif 
....................      
....................    delay_ms(15); 
02A9:  MOVLW  0F
02AA:  BCF    03.5
02AB:  BSF    03.6
02AC:  MOVWF  40
02AD:  BCF    03.6
02AE:  CALL   163
....................    for(i=1;i<=3;++i) 
02AF:  MOVLW  01
02B0:  BSF    03.5
02B1:  MOVWF  50
02B2:  MOVF   50,W
02B3:  SUBLW  03
02B4:  BTFSS  03.0
02B5:  GOTO   2C4
....................    { 
....................        lcd_send_nibble(3); 
02B6:  MOVLW  03
02B7:  BCF    03.5
02B8:  BSF    03.6
02B9:  MOVWF  47
02BA:  BCF    03.6
02BB:  CALL   177
....................        delay_ms(5); 
02BC:  MOVLW  05
02BD:  BSF    03.6
02BE:  MOVWF  40
02BF:  BCF    03.6
02C0:  CALL   163
02C1:  BSF    03.5
02C2:  INCF   50,F
02C3:  GOTO   2B2
....................    } 
....................     
....................    lcd_send_nibble(2); 
02C4:  MOVLW  02
02C5:  BCF    03.5
02C6:  BSF    03.6
02C7:  MOVWF  47
02C8:  BCF    03.6
02C9:  CALL   177
....................    delay_ms(5); 
02CA:  MOVLW  05
02CB:  BSF    03.6
02CC:  MOVWF  40
02CD:  BCF    03.6
02CE:  CALL   163
....................    for(i=0;i<=3;++i) 
02CF:  BSF    03.5
02D0:  CLRF   50
02D1:  MOVF   50,W
02D2:  SUBLW  03
02D3:  BTFSS  03.0
02D4:  GOTO   2E9
....................       lcd_send_byte(0,LCD_INIT_STRING[i]); 
02D5:  MOVLW  D1
02D6:  ADDWF  50,W
02D7:  MOVWF  04
02D8:  BCF    03.7
02D9:  MOVF   00,W
02DA:  MOVWF  55
02DB:  BCF    03.5
02DC:  BSF    03.6
02DD:  CLRF   44
02DE:  BSF    03.5
02DF:  BCF    03.6
02E0:  MOVF   55,W
02E1:  BCF    03.5
02E2:  BSF    03.6
02E3:  MOVWF  45
02E4:  BCF    03.6
02E5:  CALL   202
....................  
....................   #if defined(LCD_EXTENDED_NEWLINE) 
02E6:  BSF    03.5
02E7:  INCF   50,F
02E8:  GOTO   2D1
02E9:  BCF    03.5
02EA:  BCF    0A.3
02EB:  BSF    0A.4
02EC:  GOTO   3AA (RETURN)
....................    g_LcdX = 0; 
....................    g_LcdY = 0; 
....................   #endif 
.................... } 
....................  
.................... void lcd_gotoxy(unsigned int8 x, unsigned int8 y) 
.................... { 
....................    unsigned int8 address; 
....................     
....................    if(y!=1) 
02ED:  BSF    03.6
02EE:  DECFSZ 41,W
02EF:  GOTO   2F1
02F0:  GOTO   2F4
....................       address=LCD_LINE_TWO; 
02F1:  MOVLW  40
02F2:  MOVWF  42
02F3:  GOTO   2F5
....................    else 
....................       address=0; 
02F4:  CLRF   42
....................       
....................    address+=x-1; 
02F5:  MOVLW  01
02F6:  SUBWF  40,W
02F7:  ADDWF  42,F
....................    lcd_send_byte(0,0x80|address); 
02F8:  MOVF   42,W
02F9:  IORLW  80
02FA:  MOVWF  43
02FB:  CLRF   44
02FC:  MOVF   43,W
02FD:  MOVWF  45
02FE:  BCF    03.6
02FF:  CALL   202
....................  
....................   #if defined(LCD_EXTENDED_NEWLINE) 
0300:  RETURN
....................    g_LcdX = x - 1; 
....................    g_LcdY = y - 1; 
....................   #endif 
.................... } 
....................  
.................... void lcd_putc(char c) 
.................... { 
....................    switch (c) 
0301:  BSF    03.6
0302:  MOVF   3F,W
0303:  XORLW  07
0304:  BCF    03.6
0305:  BTFSC  03.2
0306:  GOTO   311
0307:  XORLW  0B
0308:  BTFSC  03.2
0309:  GOTO   318
030A:  XORLW  06
030B:  BTFSC  03.2
030C:  GOTO   324
030D:  XORLW  02
030E:  BTFSC  03.2
030F:  GOTO   32C
0310:  GOTO   333
....................    { 
....................       case '\a'   :  lcd_gotoxy(1,1);     break; 
0311:  MOVLW  01
0312:  BSF    03.6
0313:  MOVWF  40
0314:  MOVWF  41
0315:  BCF    03.6
0316:  CALL   2ED
0317:  GOTO   33A
....................  
....................       case '\f'   :  lcd_send_byte(0,1); 
0318:  BSF    03.6
0319:  CLRF   44
031A:  MOVLW  01
031B:  MOVWF  45
031C:  BCF    03.6
031D:  CALL   202
....................                      delay_ms(2); 
031E:  MOVLW  02
031F:  BSF    03.6
0320:  MOVWF  40
0321:  BCF    03.6
0322:  CALL   163
....................                     #if defined(LCD_EXTENDED_NEWLINE) 
....................                      g_LcdX = 0; 
....................                      g_LcdY = 0; 
....................                     #endif 
....................                      break; 
0323:  GOTO   33A
....................  
....................      #if defined(LCD_EXTENDED_NEWLINE) 
....................       case '\r'   :  lcd_gotoxy(1, g_LcdY+1);   break; 
....................       case '\n'   : 
....................          while (g_LcdX++ < LCD_LINE_LENGTH) 
....................          { 
....................             lcd_send_byte(1, ' '); 
....................          } 
....................          lcd_gotoxy(1, g_LcdY+2); 
....................          break; 
....................      #else 
....................       case '\n'   : lcd_gotoxy(1,2);        break; 
0324:  MOVLW  01
0325:  BSF    03.6
0326:  MOVWF  40
0327:  MOVLW  02
0328:  MOVWF  41
0329:  BCF    03.6
032A:  CALL   2ED
032B:  GOTO   33A
....................      #endif 
....................       
....................       case '\b'   : lcd_send_byte(0,0x10);  break; 
032C:  BSF    03.6
032D:  CLRF   44
032E:  MOVLW  10
032F:  MOVWF  45
0330:  BCF    03.6
0331:  CALL   202
0332:  GOTO   33A
....................       
....................      #if defined(LCD_EXTENDED_NEWLINE) 
....................       default     :  
....................          if (g_LcdX < LCD_LINE_LENGTH) 
....................          { 
....................             lcd_send_byte(1, c); 
....................             g_LcdX++; 
....................          } 
....................          break; 
....................      #else 
....................       default     : lcd_send_byte(1,c);     break; 
0333:  MOVLW  01
0334:  BSF    03.6
0335:  MOVWF  44
0336:  MOVF   3F,W
0337:  MOVWF  45
0338:  BCF    03.6
0339:  CALL   202
....................      #endif 
....................    } 
033A:  RETURN
.................... } 
....................   
.................... char lcd_getc(unsigned int8 x, unsigned int8 y) 
.................... { 
....................    char value; 
....................  
....................    lcd_gotoxy(x,y); 
....................    while ( bit_test(lcd_read_byte(),7) ); // wait until busy flag is low 
....................    lcd_output_rs(1); 
....................    value = lcd_read_byte(); 
....................    lcd_output_rs(0); 
....................     
....................    return(value); 
.................... } 
....................  
.................... // write a custom character to the ram 
.................... // which is 0-7 and specifies which character array we are modifying. 
.................... // ptr points to an array of 8 bytes, where each byte is the next row of 
.................... //    pixels.  only bits 0-4 are used.  the last row is the cursor row, and 
.................... //    usually you will want to leave this byte 0x00. 
.................... void lcd_set_cgram_char(unsigned int8 which, unsigned int8 *ptr) 
.................... { 
....................    unsigned int i; 
....................  
....................    which <<= 3; 
....................    which &= 0x38; 
....................  
....................    lcd_send_byte(0, 0x40 | which);  //set cgram address 
....................  
....................    for(i=0; i<8; i++) 
....................    { 
....................       lcd_send_byte(1, *ptr++); 
....................    } 
....................    
....................    #if defined(LCD_EXTENDED_NEWLINE) 
....................     lcd_gotoxy(g_LcdX+1, g_LcdY+1);  //set ddram address 
....................    #endif 
.................... } 
....................  
.................... void lcd_cursor_on(int1 on) 
.................... { 
....................    if (on) 
....................    { 
....................       lcd_send_byte(0,0x0F);           //turn LCD cursor ON 
....................    } 
....................    else 
....................    { 
....................       lcd_send_byte(0,0x0C);           //turn LCD cursor OFF 
....................    } 
.................... } 
....................  
.................... #endif 
....................  
.................... #BIT TMR1IF = 0x0C.0 //bit thu 0 (TMR1IF) cua PIR1 
....................  
.................... #INCLUDE <khaibaobien.c> // VARIABLE. 
.................... UNSIGNED INT16 KQADC,AN0, AN1; 
.................... UNSIGNED INT8 KET_QUA_ANALOG[]={0,0,0,0}; 
*
131D:  CLRF   38
131E:  CLRF   39
131F:  CLRF   3A
1320:  CLRF   3B
.................... UNSIGNED INT8 CONFIG_FUN=0; 
.................... UNSIGNED INT8 VT=0, KYTU=0;// KYTU[30],  
.................... UNSIGNED INT8 ID_DEVICE_NHAN,TT_DEVICE_NHAN; 
.................... UNSIGNED INT8 ID_GATEWAY[6] = {3,7,4,2,5,3}; 
1321:  MOVLW  03
1322:  MOVWF  41
1323:  MOVLW  07
1324:  MOVWF  42
1325:  MOVLW  04
1326:  MOVWF  43
1327:  MOVLW  02
1328:  MOVWF  44
1329:  MOVLW  05
132A:  MOVWF  45
132B:  MOVLW  03
132C:  MOVWF  46
.................... UNSIGNED INT8 ID_NODE[4] = {3,8,9,7}; 
132D:  MOVWF  47
132E:  MOVLW  08
132F:  MOVWF  48
1330:  MOVLW  09
1331:  MOVWF  49
1332:  MOVLW  07
1333:  MOVWF  4A
.................... UNSIGNED INT8 LEN_PACKAGES = 0; 
.................... UNSIGNED INT8 LENHDIEUKHIEN =0, DODAI_DATA_NHAN =0; 
.................... UNSIGNED INT8 SOLUONGTHIETBI_CONFIG=0, SOLUONGCAMBIEN_CONFIG = 3; 
.................... SIGNED INT8 SOSANH_IDNODE=0, SOSANH_IDGW=0; 
....................  
.................... INT1 TTNHAN = 0, TT_CONFIG=0, TT_CONTROL=0,TT_CONFIG_DONE=0, TT_FUN=0, TT_STT=0 , TT_CONFIG_OKE_UART = 0; 
....................  
.................... CHAR *ID_NODE_CHAR[]= "0589"; 
1334:  MOVLW  30
1335:  MOVWF  55
1336:  MOVLW  35
1337:  MOVWF  56
1338:  MOVLW  38
1339:  MOVWF  57
133A:  MOVLW  39
133B:  MOVWF  58
133C:  CLRF   59
133D:  CLRF   54
133E:  MOVLW  55
133F:  MOVWF  53
.................... CHAR *ID_GATEWAY_CHAR[]= "127102"; 
1340:  MOVLW  31
1341:  MOVWF  5C
1342:  MOVLW  32
1343:  MOVWF  5D
1344:  MOVLW  37
1345:  MOVWF  5E
1346:  MOVLW  31
1347:  MOVWF  5F
1348:  MOVLW  30
1349:  MOVWF  60
134A:  MOVLW  32
134B:  MOVWF  61
134C:  CLRF   62
134D:  CLRF   5B
134E:  MOVLW  5C
134F:  MOVWF  5A
.................... CHAR *ID_NODE_NHAN[]= "0000"; 
1350:  MOVLW  30
1351:  MOVWF  65
1352:  MOVWF  66
1353:  MOVWF  67
1354:  MOVWF  68
1355:  CLRF   69
1356:  CLRF   64
1357:  MOVLW  65
1358:  MOVWF  63
.................... CHAR *ID_GW_NHAN[]= "000000"; 
1359:  MOVLW  30
135A:  MOVWF  6C
135B:  MOVWF  6D
135C:  MOVWF  6E
135D:  MOVWF  6F
135E:  MOVWF  70
135F:  MOVWF  71
1360:  CLRF   72
1361:  CLRF   6B
1362:  MOVLW  6C
1363:  MOVWF  6A
.................... CHAR KYTUCHAR[30]="HIHI"; 
1364:  MOVLW  48
1365:  BSF    03.5
1366:  MOVWF  20
1367:  MOVLW  49
1368:  MOVWF  21
1369:  MOVLW  48
136A:  MOVWF  22
136B:  MOVLW  49
136C:  MOVWF  23
136D:  CLRF   24
.................... CHAR KYTUCHAR2[15]="HIHI"; 
136E:  MOVLW  48
136F:  MOVWF  3E
1370:  MOVLW  49
1371:  MOVWF  3F
1372:  MOVLW  48
1373:  MOVWF  40
1374:  MOVLW  49
1375:  MOVWF  41
1376:  CLRF   42
.................... //CHAR *DATA_NHANDUOC[]={"IDGW","IDNODE","COMMAN","DATA"}; 
.................... CHAR *TEMP_CHAR[]="00";   
1377:  MOVLW  30
1378:  MOVWF  7B
1379:  MOVWF  7C
137A:  CLRF   7D
137B:  CLRF   74
137C:  MOVLW  7B
137D:  MOVWF  73
.................... CHAR *TEMP_CHAR2[]="00";  
137E:  MOVLW  30
137F:  MOVWF  4D
1380:  MOVWF  4E
1381:  CLRF   4F
1382:  CLRF   76
1383:  MOVLW  CD
1384:  MOVWF  75
.................... //CHAR *TEMP_CHAR3[]="000000";  
....................  
....................  
....................  
.................... //#INCLUDE <CONFIG_NODE.C> // CU HINH NODE. 
.................... #INCLUDE <config_1.C> // CU HINH NODE. 
....................  
.................... //--------------------------------------------------------------------// 
.................... VOID CHON_ID() 
.................... { 
....................    // TT_CONFIG_DONE; 
....................    TT_CONFIG_DONE = 0; 
*
05D8:  BCF    52.3
....................    TT_STT = 1; 
05D9:  BSF    52.5
....................    UNSIGNED INT8 NUM = 0; 
05DA:  BSF    03.5
05DB:  CLRF   50
....................    TEMP_CHAR = "0"; 
05DC:  CLRF   51
05DD:  CLRF   52
05DE:  MOVLW  73
05DF:  MOVWF  04
05E0:  BCF    03.7
05E1:  MOVF   51,W
05E2:  ADDWF  04,F
05E3:  MOVF   52,W
05E4:  BCF    03.5
05E5:  CALL   058
05E6:  MOVWF  00
05E7:  IORLW  00
05E8:  BTFSC  03.2
05E9:  GOTO   5EF
05EA:  BSF    03.5
05EB:  INCF   52,F
05EC:  INCF   51,F
05ED:  GOTO   5DE
05EE:  BCF    03.5
....................    LCD_GOTOXY (1, 2) ; 
05EF:  MOVLW  01
05F0:  BSF    03.6
05F1:  MOVWF  40
05F2:  MOVLW  02
05F3:  MOVWF  41
05F4:  BCF    03.6
05F5:  CALL   2ED
....................    DELAY_MS (10); 
05F6:  MOVLW  0A
05F7:  BSF    03.6
05F8:  MOVWF  40
05F9:  BCF    03.6
05FA:  CALL   163
....................    PRINTF (LCD_PUTC, "NODE: "); 
05FB:  MOVLW  6F
05FC:  BSF    03.6
05FD:  MOVWF  0D
05FE:  MOVLW  00
05FF:  MOVWF  0F
0600:  BCF    03.6
0601:  CALL   33B
....................    PRINTF (LCD_PUTC, "0000          "); 
0602:  MOVLW  73
0603:  BSF    03.6
0604:  MOVWF  0D
0605:  MOVLW  00
0606:  MOVWF  0F
0607:  BCF    03.6
0608:  CALL   33B
....................    LCD_GOTOXY (1, 1) ; 
0609:  MOVLW  01
060A:  BSF    03.6
060B:  MOVWF  40
060C:  MOVWF  41
060D:  BCF    03.6
060E:  CALL   2ED
....................    PRINTF (LCD_PUTC, "      _              ");//6 SPACE PHIA TRUOC "_" 
060F:  MOVLW  7B
0610:  BSF    03.6
0611:  MOVWF  0D
0612:  MOVLW  00
0613:  MOVWF  0F
0614:  BCF    03.6
0615:  CALL   33B
....................    //ID_GW = "1234";     
....................  
....................    WHILE (TT_STT) 
0616:  BTFSS  52.5
0617:  GOTO   6A2
....................    { 
....................       IF (!INPUT (BT2_PIN)) //NEU NUT BAM DUOC BAM 
0618:  BSF    03.5
0619:  BSF    06.2
061A:  BCF    03.5
061B:  BTFSC  06.2
061C:  GOTO   63F
....................       { 
....................           
....................          NUM++; 
061D:  BSF    03.5
061E:  INCF   50,F
....................          NUM = NUM % 4; 
061F:  MOVLW  03
0620:  ANDWF  50,F
....................          LCD_GOTOXY (3 + NUM, 1); 
0621:  ADDWF  50,W
0622:  MOVWF  51
0623:  BCF    03.5
0624:  BSF    03.6
0625:  MOVWF  40
0626:  MOVLW  01
0627:  MOVWF  41
0628:  BCF    03.6
0629:  CALL   2ED
....................          PRINTF (LCD_PUTC, "    _    ");//4SPACE 
062A:  MOVLW  86
062B:  BSF    03.6
062C:  MOVWF  0D
062D:  MOVLW  00
062E:  MOVWF  0F
062F:  BCF    03.6
0630:  CALL   33B
....................          DELAY_MS (300);  
0631:  MOVLW  02
0632:  BSF    03.5
0633:  MOVWF  51
0634:  MOVLW  96
0635:  BCF    03.5
0636:  BSF    03.6
0637:  MOVWF  40
0638:  BCF    03.6
0639:  CALL   163
063A:  BSF    03.5
063B:  DECFSZ 51,F
063C:  GOTO   634
....................       } 
063D:  GOTO   6A0
063E:  BCF    03.5
....................  
....................       ELSE IF (!INPUT (BT3_PIN)) 
063F:  BSF    03.5
0640:  BSF    06.3
0641:  BCF    03.5
0642:  BTFSC  06.3
0643:  GOTO   6A1
....................       { 
....................          ID_NODE[NUM]++; 
0644:  MOVLW  47
0645:  BSF    03.5
0646:  ADDWF  50,W
0647:  MOVWF  04
0648:  BCF    03.7
0649:  INCF   00,F
....................          ID_NODE[NUM] = ID_NODE[NUM] % 10; 
064A:  MOVLW  47
064B:  ADDWF  50,W
064C:  MOVWF  78
064D:  CLRF   7A
064E:  BTFSC  03.0
064F:  INCF   7A,F
0650:  MOVF   78,W
0651:  MOVWF  51
0652:  MOVF   7A,W
0653:  MOVWF  52
0654:  MOVLW  47
0655:  ADDWF  50,W
0656:  MOVWF  04
0657:  BCF    03.7
0658:  MOVF   00,W
0659:  MOVWF  54
065A:  MOVLW  0A
065B:  MOVWF  55
065C:  BCF    03.5
065D:  CALL   544
065E:  MOVF   77,W
065F:  BSF    03.5
0660:  MOVWF  53
0661:  MOVF   51,W
0662:  MOVWF  04
0663:  BCF    03.7
0664:  BTFSC  52.0
0665:  BSF    03.7
0666:  MOVF   53,W
0667:  MOVWF  00
....................          ITOA (ID_NODE[NUM], 10, TEMP_CHAR); 
0668:  MOVLW  47
0669:  ADDWF  50,W
066A:  MOVWF  04
066B:  BCF    03.7
066C:  MOVF   00,W
066D:  MOVWF  51
066E:  BCF    03.5
066F:  BSF    03.6
0670:  CLRF   3F
0671:  CLRF   3E
0672:  CLRF   3D
0673:  BSF    03.5
0674:  BCF    03.6
0675:  MOVF   51,W
0676:  BCF    03.5
0677:  BSF    03.6
0678:  MOVWF  3C
0679:  MOVLW  0A
067A:  MOVWF  40
067B:  CLRF   42
067C:  MOVLW  73
067D:  MOVWF  41
067E:  BCF    03.6
067F:  CALL   407
....................          LCD_GOTOXY (7 + NUM, 2); 
0680:  MOVLW  07
0681:  BSF    03.5
0682:  ADDWF  50,W
0683:  MOVWF  51
0684:  BCF    03.5
0685:  BSF    03.6
0686:  MOVWF  40
0687:  MOVLW  02
0688:  MOVWF  41
0689:  BCF    03.6
068A:  CALL   2ED
....................          DELAY_MS (10); 
068B:  MOVLW  0A
068C:  BSF    03.6
068D:  MOVWF  40
068E:  BCF    03.6
068F:  CALL   163
....................          PRINTF (LCD_PUTC, TEMP_CHAR); 
0690:  MOVLW  73
0691:  MOVWF  04
0692:  BCF    03.7
0693:  CALL   527
....................          DELAY_MS (300); 
0694:  MOVLW  02
0695:  BSF    03.5
0696:  MOVWF  51
0697:  MOVLW  96
0698:  BCF    03.5
0699:  BSF    03.6
069A:  MOVWF  40
069B:  BCF    03.6
069C:  CALL   163
069D:  BSF    03.5
069E:  DECFSZ 51,F
069F:  GOTO   697
06A0:  BCF    03.5
....................       } 
06A1:  GOTO   616
....................    } 
.................... } 
....................  
.................... VOID NHAPID_GW() 
*
06A3:  BSF    03.5
06A4:  CLRF   50
.................... { 
....................    UNSIGNED INT8 NUM = 0; 
....................    TEMP_CHAR = "0"; 
06A5:  CLRF   51
06A6:  CLRF   52
06A7:  MOVLW  73
06A8:  MOVWF  04
06A9:  BCF    03.7
06AA:  MOVF   51,W
06AB:  ADDWF  04,F
06AC:  MOVF   52,W
06AD:  BCF    03.5
06AE:  CALL   058
06AF:  MOVWF  00
06B0:  IORLW  00
06B1:  BTFSC  03.2
06B2:  GOTO   6B8
06B3:  BSF    03.5
06B4:  INCF   52,F
06B5:  INCF   51,F
06B6:  GOTO   6A7
06B7:  BCF    03.5
....................    TT_CONFIG_DONE = 0; 
06B8:  BCF    52.3
....................    TT_STT = 1; 
06B9:  BSF    52.5
....................    LCD_GOTOXY (1, 2) ; 
06BA:  MOVLW  01
06BB:  BSF    03.6
06BC:  MOVWF  40
06BD:  MOVLW  02
06BE:  MOVWF  41
06BF:  BCF    03.6
06C0:  CALL   2ED
....................    DELAY_MS (10); 
06C1:  MOVLW  0A
06C2:  BSF    03.6
06C3:  MOVWF  40
06C4:  BCF    03.6
06C5:  CALL   163
....................    PRINTF (LCD_PUTC, "ID_GW:"); 
06C6:  MOVLW  8B
06C7:  BSF    03.6
06C8:  MOVWF  0D
06C9:  MOVLW  00
06CA:  MOVWF  0F
06CB:  BCF    03.6
06CC:  CALL   33B
....................    PRINTF (LCD_PUTC, "000000        "); 
06CD:  MOVLW  8F
06CE:  BSF    03.6
06CF:  MOVWF  0D
06D0:  MOVLW  00
06D1:  MOVWF  0F
06D2:  BCF    03.6
06D3:  CALL   33B
....................    LCD_GOTOXY (1, 1) ; 
06D4:  MOVLW  01
06D5:  BSF    03.6
06D6:  MOVWF  40
06D7:  MOVWF  41
06D8:  BCF    03.6
06D9:  CALL   2ED
....................    PRINTF (LCD_PUTC, "      _                ");//6 SPACE PHIA TRUOC "_" 
06DA:  MOVLW  97
06DB:  BSF    03.6
06DC:  MOVWF  0D
06DD:  MOVLW  00
06DE:  MOVWF  0F
06DF:  BCF    03.6
06E0:  CALL   33B
....................    //ID_GW = "1234";     
....................  
....................    WHILE (TT_STT) 
06E1:  BTFSS  52.5
06E2:  GOTO   775
....................    { 
....................       IF (!INPUT (BT2_PIN)) //NEU NUT BAM DUOC BAM 
06E3:  BSF    03.5
06E4:  BSF    06.2
06E5:  BCF    03.5
06E6:  BTFSC  06.2
06E7:  GOTO   712
....................       { 
....................           
....................          NUM++; 
06E8:  BSF    03.5
06E9:  INCF   50,F
....................          NUM = NUM % 6; 
06EA:  MOVF   50,W
06EB:  MOVWF  54
06EC:  MOVLW  06
06ED:  MOVWF  55
06EE:  BCF    03.5
06EF:  CALL   544
06F0:  MOVF   77,W
06F1:  BSF    03.5
06F2:  MOVWF  50
....................          LCD_GOTOXY (3 + NUM, 1); 
06F3:  MOVLW  03
06F4:  ADDWF  50,W
06F5:  MOVWF  51
06F6:  BCF    03.5
06F7:  BSF    03.6
06F8:  MOVWF  40
06F9:  MOVLW  01
06FA:  MOVWF  41
06FB:  BCF    03.6
06FC:  CALL   2ED
....................          PRINTF (LCD_PUTC, "    _        ");//4SPACE 
06FD:  MOVLW  A3
06FE:  BSF    03.6
06FF:  MOVWF  0D
0700:  MOVLW  00
0701:  MOVWF  0F
0702:  BCF    03.6
0703:  CALL   33B
....................          DELAY_MS (300);  
0704:  MOVLW  02
0705:  BSF    03.5
0706:  MOVWF  51
0707:  MOVLW  96
0708:  BCF    03.5
0709:  BSF    03.6
070A:  MOVWF  40
070B:  BCF    03.6
070C:  CALL   163
070D:  BSF    03.5
070E:  DECFSZ 51,F
070F:  GOTO   707
....................       } 
0710:  GOTO   773
0711:  BCF    03.5
....................  
....................       ELSE IF (!INPUT (BT3_PIN)) 
0712:  BSF    03.5
0713:  BSF    06.3
0714:  BCF    03.5
0715:  BTFSC  06.3
0716:  GOTO   774
....................       { 
....................          ID_GATEWAY[NUM]++; 
0717:  MOVLW  41
0718:  BSF    03.5
0719:  ADDWF  50,W
071A:  MOVWF  04
071B:  BCF    03.7
071C:  INCF   00,F
....................          ID_GATEWAY[NUM] = ID_GATEWAY[NUM] % 10; 
071D:  MOVLW  41
071E:  ADDWF  50,W
071F:  MOVWF  78
0720:  CLRF   7A
0721:  BTFSC  03.0
0722:  INCF   7A,F
0723:  MOVF   78,W
0724:  MOVWF  51
0725:  MOVF   7A,W
0726:  MOVWF  52
0727:  MOVLW  41
0728:  ADDWF  50,W
0729:  MOVWF  04
072A:  BCF    03.7
072B:  MOVF   00,W
072C:  MOVWF  54
072D:  MOVLW  0A
072E:  MOVWF  55
072F:  BCF    03.5
0730:  CALL   544
0731:  MOVF   77,W
0732:  BSF    03.5
0733:  MOVWF  53
0734:  MOVF   51,W
0735:  MOVWF  04
0736:  BCF    03.7
0737:  BTFSC  52.0
0738:  BSF    03.7
0739:  MOVF   53,W
073A:  MOVWF  00
....................          ITOA (ID_GATEWAY[NUM], 10, TEMP_CHAR); 
073B:  MOVLW  41
073C:  ADDWF  50,W
073D:  MOVWF  04
073E:  BCF    03.7
073F:  MOVF   00,W
0740:  MOVWF  51
0741:  BCF    03.5
0742:  BSF    03.6
0743:  CLRF   3F
0744:  CLRF   3E
0745:  CLRF   3D
0746:  BSF    03.5
0747:  BCF    03.6
0748:  MOVF   51,W
0749:  BCF    03.5
074A:  BSF    03.6
074B:  MOVWF  3C
074C:  MOVLW  0A
074D:  MOVWF  40
074E:  CLRF   42
074F:  MOVLW  73
0750:  MOVWF  41
0751:  BCF    03.6
0752:  CALL   407
....................          LCD_GOTOXY (7 + NUM, 2); 
0753:  MOVLW  07
0754:  BSF    03.5
0755:  ADDWF  50,W
0756:  MOVWF  51
0757:  BCF    03.5
0758:  BSF    03.6
0759:  MOVWF  40
075A:  MOVLW  02
075B:  MOVWF  41
075C:  BCF    03.6
075D:  CALL   2ED
....................          DELAY_MS (10); 
075E:  MOVLW  0A
075F:  BSF    03.6
0760:  MOVWF  40
0761:  BCF    03.6
0762:  CALL   163
....................          PRINTF (LCD_PUTC, TEMP_CHAR); 
0763:  MOVLW  73
0764:  MOVWF  04
0765:  BCF    03.7
0766:  CALL   527
....................          DELAY_MS (300); 
0767:  MOVLW  02
0768:  BSF    03.5
0769:  MOVWF  51
076A:  MOVLW  96
076B:  BCF    03.5
076C:  BSF    03.6
076D:  MOVWF  40
076E:  BCF    03.6
076F:  CALL   163
0770:  BSF    03.5
0771:  DECFSZ 51,F
0772:  GOTO   76A
0773:  BCF    03.5
....................       } 
0774:  GOTO   6E1
....................    } 
.................... } 
....................  
.................... VOID BUTT_OKE() 
.................... { 
....................    TT_CONFIG_DONE = 0; 
*
011F:  BCF    03.5
0120:  BCF    03.6
0121:  BCF    52.3
....................    TT_FUN = 0;//BREAK WHILE BUTT_FUN 
0122:  BCF    52.4
....................    TT_STT = 0;// BREAK WHILE CHONID/NHAPID_GW 
0123:  BCF    52.5
.................... } 
....................  
.................... VOID SELLECT_FUN() 
.................... { 
....................    TT_CONFIG_DONE = 0; 
*
05D0:  BCF    52.3
....................  
....................    SWITCH (CONFIG_FUN) 
05D1:  MOVF   3C,W
05D2:  BTFSC  03.2
05D3:  GOTO   5D8
05D4:  XORLW  01
05D5:  BTFSC  03.2
05D6:  GOTO   6A3
05D7:  GOTO   775
....................    { 
....................       CASE 0: 
....................       CHON_ID (); 
....................       BREAK; 
*
06A2:  GOTO   775
....................  
....................       CASE 1:     
....................       NHAPID_GW (); 
....................       BREAK; 
....................    } 
.................... } 
....................  
.................... VOID BUTT_FUN() 
.................... { 
....................    TT_FUN = 1; 
*
055B:  BSF    52.4
....................    LCD_GOTOXY (1, 1) ; 
055C:  MOVLW  01
055D:  BSF    03.6
055E:  MOVWF  40
055F:  MOVWF  41
0560:  BCF    03.6
0561:  CALL   2ED
....................    DELAY_MS (10); 
0562:  MOVLW  0A
0563:  BSF    03.6
0564:  MOVWF  40
0565:  BCF    03.6
0566:  CALL   163
....................    PRINTF (LCD_PUTC, "CONFIG:        "); 
0567:  MOVLW  AA
0568:  BSF    03.6
0569:  MOVWF  0D
056A:  MOVLW  00
056B:  MOVWF  0F
056C:  BCF    03.6
056D:  CALL   33B
....................  
....................    // HIEN THI LCD 
....................    LCD_GOTOXY (1, 2) ; 
056E:  MOVLW  01
056F:  BSF    03.6
0570:  MOVWF  40
0571:  MOVLW  02
0572:  MOVWF  41
0573:  BCF    03.6
0574:  CALL   2ED
....................    DELAY_MS (10); 
0575:  MOVLW  0A
0576:  BSF    03.6
0577:  MOVWF  40
0578:  BCF    03.6
0579:  CALL   163
....................    PRINTF (LCD_PUTC, "CASE:          ") ; 
057A:  MOVLW  B2
057B:  BSF    03.6
057C:  MOVWF  0D
057D:  MOVLW  00
057E:  MOVWF  0F
057F:  BCF    03.6
0580:  CALL   33B
....................  
....................    WHILE (TT_FUN) 
0581:  BTFSS  52.4
0582:  GOTO   5CE
....................    { 
....................       IF (INPUT (BT2_PIN) == 0) //NEU NUT BAM DUOC BAM 
0583:  BSF    03.5
0584:  BSF    06.2
0585:  BCF    03.5
0586:  BTFSC  06.2
0587:  GOTO   5CD
....................       { 
....................          CONFIG_FUN ++; 
0588:  INCF   3C,F
....................          CONFIG_FUN = CONFIG_FUN % 2; 
0589:  MOVLW  01
058A:  ANDWF  3C,F
....................          DELAY_MS (300); 
058B:  MOVLW  02
058C:  BSF    03.5
058D:  MOVWF  50
058E:  MOVLW  96
058F:  BCF    03.5
0590:  BSF    03.6
0591:  MOVWF  40
0592:  BCF    03.6
0593:  CALL   163
0594:  BSF    03.5
0595:  DECFSZ 50,F
0596:  GOTO   58E
....................          //HIEN THI 
....................          LCD_GOTOXY (6, 2) ; 
0597:  MOVLW  06
0598:  BCF    03.5
0599:  BSF    03.6
059A:  MOVWF  40
059B:  MOVLW  02
059C:  MOVWF  41
059D:  BCF    03.6
059E:  CALL   2ED
....................          ITOA (CONFIG_FUN, 10, TEMP_CHAR); 
059F:  BSF    03.6
05A0:  CLRF   3F
05A1:  CLRF   3E
05A2:  CLRF   3D
05A3:  BCF    03.6
05A4:  MOVF   3C,W
05A5:  BSF    03.6
05A6:  MOVWF  3C
05A7:  MOVLW  0A
05A8:  MOVWF  40
05A9:  CLRF   42
05AA:  MOVLW  73
05AB:  MOVWF  41
05AC:  BCF    03.6
05AD:  CALL   407
....................          DELAY_MS (10); 
05AE:  MOVLW  0A
05AF:  BSF    03.6
05B0:  MOVWF  40
05B1:  BCF    03.6
05B2:  CALL   163
....................          PRINTF (LCD_PUTC, TEMP_CHAR); 
05B3:  MOVLW  73
05B4:  MOVWF  04
05B5:  BCF    03.7
05B6:  CALL   527
....................  
....................          SWITCH (CONFIG_FUN) 
05B7:  MOVF   3C,W
05B8:  BTFSC  03.2
05B9:  GOTO   5BE
05BA:  XORLW  01
05BB:  BTFSC  03.2
05BC:  GOTO   5C6
05BD:  GOTO   5CD
....................          { 
....................             CASE 0: 
....................             PRINTF (LCD_PUTC, " - ID-NODE      "); 
05BE:  MOVLW  BA
05BF:  BSF    03.6
05C0:  MOVWF  0D
05C1:  MOVLW  00
05C2:  MOVWF  0F
05C3:  BCF    03.6
05C4:  CALL   33B
....................             BREAK; 
05C5:  GOTO   5CD
....................  
....................             CASE 1: 
....................             PRINTF (LCD_PUTC, " - ID-GW       "); 
05C6:  MOVLW  C3
05C7:  BSF    03.6
05C8:  MOVWF  0D
05C9:  MOVLW  00
05CA:  MOVWF  0F
05CB:  BCF    03.6
05CC:  CALL   33B
....................             BREAK;             
....................          } 
....................       } 
05CD:  GOTO   581
....................    } 
....................  
....................    ////// 
....................    IF (!TT_CONFIG_DONE) 
05CE:  BTFSC  52.3
05CF:  GOTO   775
....................    { 
....................       SELLECT_FUN (); 
....................    } 
*
0775:  BCF    0A.3
0776:  BSF    0A.4
0777:  GOTO   3B7 (RETURN)
.................... } 
.................... VOID XULY_IDNODE_NHAP(){ 
....................    //*TEMP_CHAR3 = "\0"; 
....................    *ID_NODE_CHAR = "\0"; 
*
0899:  CLRF   7A
089A:  MOVLW  53
089B:  BCF    03.5
089C:  BSF    03.6
089D:  MOVWF  33
089E:  MOVF   7A,W
089F:  MOVWF  34
08A0:  MOVF   33,W
08A1:  MOVWF  04
08A2:  BCF    03.7
08A3:  BTFSC  34.0
08A4:  BSF    03.7
08A5:  CLRF   00
....................    FOR (int j = 0; j < 4; j++) 
08A6:  CLRF   32
08A7:  MOVF   32,W
08A8:  SUBLW  03
08A9:  BTFSS  03.0
08AA:  GOTO   0D4
....................    { 
....................       ITOA (ID_NODE[j], 10, TEMP_CHAR); 
08AB:  MOVLW  47
08AC:  ADDWF  32,W
08AD:  MOVWF  04
08AE:  BCF    03.7
08AF:  MOVF   00,W
08B0:  MOVWF  33
08B1:  CLRF   3F
08B2:  CLRF   3E
08B3:  CLRF   3D
08B4:  MOVF   33,W
08B5:  MOVWF  3C
08B6:  MOVLW  0A
08B7:  MOVWF  40
08B8:  CLRF   42
08B9:  MOVLW  73
08BA:  MOVWF  41
08BB:  BCF    0A.3
08BC:  BCF    03.6
08BD:  CALL   407
08BE:  BSF    0A.3
....................       DELAY_MS (1); 
08BF:  MOVLW  01
08C0:  BSF    03.6
08C1:  MOVWF  40
08C2:  BCF    0A.3
08C3:  BCF    03.6
08C4:  CALL   163
08C5:  BSF    0A.3
....................       STRCAT (ID_NODE_CHAR, TEMP_CHAR); 
08C6:  BSF    03.6
08C7:  CLRF   34
08C8:  MOVLW  53
08C9:  MOVWF  33
08CA:  CLRF   36
08CB:  MOVLW  73
08CC:  MOVWF  35
08CD:  BCF    0A.3
08CE:  BCF    03.6
08CF:  CALL   778
08D0:  BSF    0A.3
08D1:  BSF    03.6
08D2:  INCF   32,F
08D3:  GOTO   0A7
....................    }   
....................    //ID_NODE_CHAR = TEMP_CHAR3;    
....................    //STRCPY(ID_NODE_CHAR,TEMP_CHAR3); 
....................    //strcpy 
.................... } 
.................... VOID XULY_IDGW_NHAP(){ 
....................  
....................    *ID_GATEWAY_CHAR = "\0"; 
*
0859:  CLRF   7A
085A:  MOVLW  5A
085B:  BCF    03.5
085C:  BSF    03.6
085D:  MOVWF  33
085E:  MOVF   7A,W
085F:  MOVWF  34
0860:  MOVF   33,W
0861:  MOVWF  04
0862:  BCF    03.7
0863:  BTFSC  34.0
0864:  BSF    03.7
0865:  CLRF   00
....................    FOR (int j = 0; j < 6; j++) 
0866:  CLRF   32
0867:  MOVF   32,W
0868:  SUBLW  05
0869:  BTFSS  03.0
086A:  GOTO   094
....................    { 
....................       ITOA (ID_GATEWAY[j], 10, TEMP_CHAR); 
086B:  MOVLW  41
086C:  ADDWF  32,W
086D:  MOVWF  04
086E:  BCF    03.7
086F:  MOVF   00,W
0870:  MOVWF  33
0871:  CLRF   3F
0872:  CLRF   3E
0873:  CLRF   3D
0874:  MOVF   33,W
0875:  MOVWF  3C
0876:  MOVLW  0A
0877:  MOVWF  40
0878:  CLRF   42
0879:  MOVLW  73
087A:  MOVWF  41
087B:  BCF    0A.3
087C:  BCF    03.6
087D:  CALL   407
087E:  BSF    0A.3
....................       DELAY_MS (1); 
087F:  MOVLW  01
0880:  BSF    03.6
0881:  MOVWF  40
0882:  BCF    0A.3
0883:  BCF    03.6
0884:  CALL   163
0885:  BSF    0A.3
....................       STRCAT (ID_GATEWAY_CHAR, TEMP_CHAR); 
0886:  BSF    03.6
0887:  CLRF   34
0888:  MOVLW  5A
0889:  MOVWF  33
088A:  CLRF   36
088B:  MOVLW  73
088C:  MOVWF  35
088D:  BCF    0A.3
088E:  BCF    03.6
088F:  CALL   778
0890:  BSF    0A.3
0891:  BSF    03.6
0892:  INCF   32,F
0893:  GOTO   067
....................    }   
.................... } 
....................  
....................  
.................... VOID CONFIG_DONE() 
.................... { 
....................    TT_FUN = 0; 
*
0800:  BCF    52.4
....................    TT_STT = 0; 
0801:  BCF    52.5
....................    CHAR *PACKAGE_CONFIG[]={"*", "LENGHT","C_F", "ID_GW1234" ,"ID_NODE","#"}; 
0802:  MOVLW  2A
0803:  BSF    03.6
0804:  MOVWF  10
0805:  CLRF   11
0806:  MOVLW  4C
0807:  MOVWF  12
0808:  MOVLW  45
0809:  MOVWF  13
080A:  MOVLW  4E
080B:  MOVWF  14
080C:  MOVLW  47
080D:  MOVWF  15
080E:  MOVLW  48
080F:  MOVWF  16
0810:  MOVLW  54
0811:  MOVWF  17
0812:  CLRF   18
0813:  MOVLW  43
0814:  MOVWF  19
0815:  MOVLW  5F
0816:  MOVWF  1A
0817:  MOVLW  46
0818:  MOVWF  1B
0819:  CLRF   1C
081A:  MOVLW  49
081B:  MOVWF  1D
081C:  MOVLW  44
081D:  MOVWF  1E
081E:  MOVLW  5F
081F:  MOVWF  1F
0820:  MOVLW  47
0821:  MOVWF  20
0822:  MOVLW  57
0823:  MOVWF  21
0824:  MOVLW  31
0825:  MOVWF  22
0826:  MOVLW  32
0827:  MOVWF  23
0828:  MOVLW  33
0829:  MOVWF  24
082A:  MOVLW  34
082B:  MOVWF  25
082C:  CLRF   26
082D:  MOVLW  49
082E:  MOVWF  27
082F:  MOVLW  44
0830:  MOVWF  28
0831:  MOVLW  5F
0832:  MOVWF  29
0833:  MOVLW  4E
0834:  MOVWF  2A
0835:  MOVLW  4F
0836:  MOVWF  2B
0837:  MOVLW  44
0838:  MOVWF  2C
0839:  MOVLW  45
083A:  MOVWF  2D
083B:  CLRF   2E
083C:  MOVLW  23
083D:  MOVWF  2F
083E:  CLRF   30
083F:  MOVLW  01
0840:  BSF    03.5
0841:  BCF    03.6
0842:  MOVWF  51
0843:  MOVLW  10
0844:  MOVWF  50
0845:  MOVLW  01
0846:  MOVWF  53
0847:  MOVLW  12
0848:  MOVWF  52
0849:  MOVLW  01
084A:  MOVWF  55
084B:  MOVLW  19
084C:  MOVWF  54
084D:  MOVLW  01
084E:  MOVWF  57
084F:  MOVLW  1D
0850:  MOVWF  56
0851:  MOVLW  01
0852:  MOVWF  59
0853:  MOVLW  27
0854:  MOVWF  58
0855:  MOVLW  01
0856:  MOVWF  5B
0857:  MOVLW  2F
0858:  MOVWF  5A
....................    XULY_IDGW_NHAP(); 
....................    PACKAGE_CONFIG[3] = ID_GATEWAY_CHAR; 
*
0894:  BSF    03.5
0895:  BCF    03.6
0896:  CLRF   57
0897:  MOVLW  5A
0898:  MOVWF  56
....................     
....................     
....................    XULY_IDNODE_NHAP(); 
....................    PACKAGE_CONFIG[4] = ID_NODE_CHAR;     
*
08D4:  BSF    03.5
08D5:  BCF    03.6
08D6:  CLRF   59
08D7:  MOVLW  53
08D8:  MOVWF  58
....................         
....................    LEN_PACKAGES = 0; 
08D9:  BCF    03.5
08DA:  CLRF   4B
....................    PACKAGE_CONFIG[1] = "12"; //DO DAI CUA LENGHT CO DO DAI = 2 
08DB:  MOVLW  31
08DC:  BSF    03.5
08DD:  MOVWF  52
08DE:  MOVLW  32
08DF:  MOVWF  53
....................    FOR (int J = 0; J < 6; J++) 
08E0:  CLRF   5C
08E1:  MOVF   5C,W
08E2:  SUBLW  05
08E3:  BTFSS  03.0
08E4:  GOTO   103
....................    { 
....................       LEN_PACKAGES += strlen(PACKAGE_CONFIG[J]); 
08E5:  BCF    03.0
08E6:  RLF    5C,W
08E7:  ADDLW  D0
08E8:  MOVWF  04
08E9:  BCF    03.7
08EA:  INCF   04,F
08EB:  MOVF   00,W
08EC:  MOVWF  5E
08ED:  DECF   04,F
08EE:  MOVF   00,W
08EF:  MOVWF  5D
08F0:  MOVF   5E,W
08F1:  BCF    03.5
08F2:  BSF    03.6
08F3:  MOVWF  35
08F4:  BSF    03.5
08F5:  BCF    03.6
08F6:  MOVF   5D,W
08F7:  BCF    03.5
08F8:  BSF    03.6
08F9:  MOVWF  34
08FA:  BCF    0A.3
08FB:  BCF    03.6
08FC:  CALL   7B6
08FD:  BSF    0A.3
08FE:  MOVF   78,W
08FF:  ADDWF  4B,F
0900:  BSF    03.5
0901:  INCF   5C,F
0902:  GOTO   0E1
....................    }    
....................    LEN_PACKAGES = LEN_PACKAGES+5; //5 @ 
0903:  MOVLW  05
0904:  BCF    03.5
0905:  ADDWF  4B,F
....................    ITOA (LEN_PACKAGES, 10, TEMP_CHAR); 
0906:  BSF    03.6
0907:  CLRF   3F
0908:  CLRF   3E
0909:  CLRF   3D
090A:  BCF    03.6
090B:  MOVF   4B,W
090C:  BSF    03.6
090D:  MOVWF  3C
090E:  MOVLW  0A
090F:  MOVWF  40
0910:  CLRF   42
0911:  MOVLW  73
0912:  MOVWF  41
0913:  BCF    0A.3
0914:  BCF    03.6
0915:  CALL   407
0916:  BSF    0A.3
....................    PACKAGE_CONFIG[1] = TEMP_CHAR; 
0917:  BSF    03.5
0918:  CLRF   53
0919:  MOVLW  73
091A:  MOVWF  52
....................     
....................    FOR ( J = 0; J < 6; J++) 
091B:  CLRF   5C
091C:  MOVF   5C,W
091D:  SUBLW  05
091E:  BTFSS  03.0
091F:  GOTO   13A
....................    { 
....................       PRINTF (PACKAGE_CONFIG[J]); 
0920:  BCF    03.0
0921:  RLF    5C,W
0922:  ADDLW  D0
0923:  MOVWF  04
0924:  BCF    03.7
0925:  INCF   04,F
0926:  MOVF   00,W
0927:  MOVWF  5E
0928:  DECF   04,F
0929:  MOVF   00,W
092A:  MOVWF  5D
092B:  MOVWF  04
092C:  BCF    03.7
092D:  BTFSC  5E.0
092E:  BSF    03.7
092F:  BCF    0A.3
0930:  BCF    03.5
0931:  CALL   7D6
0932:  BSF    0A.3
....................       PRINTF ("@"); 
0933:  MOVLW  40
0934:  BTFSS  0C.4
0935:  GOTO   134
0936:  MOVWF  19
0937:  BSF    03.5
0938:  INCF   5C,F
0939:  GOTO   11C
....................    } 
....................  
....................  
....................    LCD_GOTOXY (1, 1) ; 
093A:  MOVLW  01
093B:  BCF    03.5
093C:  BSF    03.6
093D:  MOVWF  40
093E:  MOVWF  41
093F:  BCF    0A.3
0940:  BCF    03.6
0941:  CALL   2ED
0942:  BSF    0A.3
....................    DELAY_MS (10); 
0943:  MOVLW  0A
0944:  BSF    03.6
0945:  MOVWF  40
0946:  BCF    0A.3
0947:  BCF    03.6
0948:  CALL   163
0949:  BSF    0A.3
....................    PRINTF (LCD_PUTC, "WAITING ....        ") ; 
094A:  MOVLW  CB
094B:  BSF    03.6
094C:  MOVWF  0D
094D:  MOVLW  00
094E:  MOVWF  0F
094F:  BCF    0A.3
0950:  BCF    03.6
0951:  CALL   33B
0952:  BSF    0A.3
....................    LCD_GOTOXY (1, 2) ; 
0953:  MOVLW  01
0954:  BSF    03.6
0955:  MOVWF  40
0956:  MOVLW  02
0957:  MOVWF  41
0958:  BCF    0A.3
0959:  BCF    03.6
095A:  CALL   2ED
095B:  BSF    0A.3
....................    DELAY_MS (10); 
095C:  MOVLW  0A
095D:  BSF    03.6
095E:  MOVWF  40
095F:  BCF    0A.3
0960:  BCF    03.6
0961:  CALL   163
0962:  BSF    0A.3
....................    PRINTF (LCD_PUTC, "WAITING ....        ") ;    
0963:  MOVLW  D6
0964:  BSF    03.6
0965:  MOVWF  0D
0966:  MOVLW  00
0967:  MOVWF  0F
0968:  BCF    0A.3
0969:  BCF    03.6
096A:  CALL   33B
096B:  BSF    0A.3
....................    TT_CONFIG_DONE = 0; 
096C:  BCF    52.3
096D:  BCF    0A.3
096E:  BSF    0A.4
096F:  GOTO   3BE (RETURN)
.................... } 
....................  
....................  
....................  VOID XACNHANCONFIG() 
....................  {    
....................    KYTU=0; 
*
0D0D:  CLRF   3E
....................    OUTPUT_D (0XFF);        
0D0E:  BSF    03.5
0D0F:  CLRF   08
0D10:  MOVLW  FF
0D11:  BCF    03.5
0D12:  MOVWF  08
....................    LCD_GOTOXY (1, 1) ; 
0D13:  MOVLW  01
0D14:  BSF    03.6
0D15:  MOVWF  40
0D16:  MOVWF  41
0D17:  BCF    0A.3
0D18:  BCF    03.6
0D19:  CALL   2ED
0D1A:  BSF    0A.3
....................    DELAY_MS (10); 
0D1B:  MOVLW  0A
0D1C:  BSF    03.6
0D1D:  MOVWF  40
0D1E:  BCF    0A.3
0D1F:  BCF    03.6
0D20:  CALL   163
0D21:  BSF    0A.3
....................    TEMP_CHAR = "_"; 
0D22:  BSF    03.5
0D23:  CLRF   58
0D24:  CLRF   59
0D25:  MOVLW  73
0D26:  MOVWF  04
0D27:  BCF    03.7
0D28:  MOVF   58,W
0D29:  ADDWF  04,F
0D2A:  MOVF   59,W
0D2B:  BCF    0A.3
0D2C:  BCF    03.5
0D2D:  CALL   05E
0D2E:  BSF    0A.3
0D2F:  MOVWF  00
0D30:  IORLW  00
0D31:  BTFSC  03.2
0D32:  GOTO   538
0D33:  BSF    03.5
0D34:  INCF   59,F
0D35:  INCF   58,F
0D36:  GOTO   525
0D37:  BCF    03.5
....................    CHAR * TOKEN; 
....................    TOKEN = STRTOK (KYTUCHAR2, TEMP_CHAR);    
0D38:  BSF    03.5
0D39:  CLRF   59
0D3A:  MOVLW  BE
0D3B:  MOVWF  58
0D3C:  CLRF   5B
0D3D:  MOVLW  73
0D3E:  MOVWF  5A
0D3F:  BCF    03.5
0D40:  CALL   18B
0D41:  MOVF   79,W
0D42:  BSF    03.5
0D43:  MOVWF  57
0D44:  MOVF   78,W
0D45:  MOVWF  56
....................     WHILE (TOKEN != NULL) 
0D46:  MOVF   56,F
0D47:  BTFSS  03.2
0D48:  GOTO   54C
0D49:  MOVF   57,F
0D4A:  BTFSC  03.2
0D4B:  GOTO   595
....................     {                 
....................        SWITCH(KYTU) 
0D4C:  BCF    03.5
0D4D:  MOVF   3E,W
0D4E:  BTFSC  03.2
0D4F:  GOTO   557
0D50:  XORLW  01
0D51:  BTFSC  03.2
0D52:  GOTO   571
0D53:  XORLW  03
0D54:  BTFSC  03.2
0D55:  GOTO   57B
0D56:  GOTO   584
....................        { 
....................          CASE 0: 
....................          DELAY_MS (1); 
0D57:  MOVLW  01
0D58:  BSF    03.6
0D59:  MOVWF  40
0D5A:  BCF    0A.3
0D5B:  BCF    03.6
0D5C:  CALL   163
0D5D:  BSF    0A.3
....................          PRINTF (LCD_PUTC,TOKEN); 
0D5E:  BSF    03.5
0D5F:  MOVF   56,W
0D60:  MOVWF  04
0D61:  BCF    03.7
0D62:  BTFSC  57.0
0D63:  BSF    03.7
0D64:  BCF    0A.3
0D65:  BCF    03.5
0D66:  CALL   527
0D67:  BSF    0A.3
....................          PRINTF (LCD_PUTC,"            "); 
0D68:  MOVLW  E1
0D69:  BSF    03.6
0D6A:  MOVWF  0D
0D6B:  MOVLW  00
0D6C:  MOVWF  0F
0D6D:  BCF    0A.3
0D6E:  BCF    03.6
0D6F:  CALL   33B
0D70:  BSF    0A.3
....................          CASE 1:  
....................          SOLUONGTHIETBI_CONFIG = ATOI(TOKEN); 
0D71:  BSF    03.5
0D72:  MOVF   57,W
0D73:  MOVWF  59
0D74:  MOVF   56,W
0D75:  MOVWF  58
0D76:  BCF    03.5
0D77:  CALL   27C
0D78:  MOVF   78,W
0D79:  MOVWF  4E
....................          BREAK;                      
0D7A:  GOTO   584
....................          CASE 2: 
....................          SOLUONGCAMBIEN_CONFIG = ATOI(TOKEN); 
0D7B:  BSF    03.5
0D7C:  MOVF   57,W
0D7D:  MOVWF  59
0D7E:  MOVF   56,W
0D7F:  MOVWF  58
0D80:  BCF    03.5
0D81:  CALL   27C
0D82:  MOVF   78,W
0D83:  MOVWF  4F
....................          BREAK;               
....................        }  
....................       TOKEN = STRTOK(NULL, TEMP_CHAR); 
0D84:  BSF    03.5
0D85:  CLRF   59
0D86:  CLRF   58
0D87:  CLRF   5B
0D88:  MOVLW  73
0D89:  MOVWF  5A
0D8A:  BCF    03.5
0D8B:  CALL   18B
0D8C:  MOVF   79,W
0D8D:  BSF    03.5
0D8E:  MOVWF  57
0D8F:  MOVF   78,W
0D90:  MOVWF  56
....................       KYTU++;         
0D91:  BCF    03.5
0D92:  INCF   3E,F
0D93:  BSF    03.5
0D94:  GOTO   546
....................     }           
....................    DELAY_MS(500); 
0D95:  MOVLW  02
0D96:  MOVWF  58
0D97:  MOVLW  FA
0D98:  BCF    03.5
0D99:  BSF    03.6
0D9A:  MOVWF  40
0D9B:  BCF    0A.3
0D9C:  BCF    03.6
0D9D:  CALL   163
0D9E:  BSF    0A.3
0D9F:  BSF    03.5
0DA0:  DECFSZ 58,F
0DA1:  GOTO   597
....................    DELAY_MS (1);  
0DA2:  MOVLW  01
0DA3:  BCF    03.5
0DA4:  BSF    03.6
0DA5:  MOVWF  40
0DA6:  BCF    0A.3
0DA7:  BCF    03.6
0DA8:  CALL   163
0DA9:  BSF    0A.3
....................    OUTPUT_D (0XFF);      
0DAA:  BSF    03.5
0DAB:  CLRF   08
0DAC:  MOVLW  FF
0DAD:  BCF    03.5
0DAE:  MOVWF  08
....................    LCD_GOTOXY (1, 2) ; 
0DAF:  MOVLW  01
0DB0:  BSF    03.6
0DB1:  MOVWF  40
0DB2:  MOVLW  02
0DB3:  MOVWF  41
0DB4:  BCF    0A.3
0DB5:  BCF    03.6
0DB6:  CALL   2ED
0DB7:  BSF    0A.3
....................    DELAY_MS (10); 
0DB8:  MOVLW  0A
0DB9:  BSF    03.6
0DBA:  MOVWF  40
0DBB:  BCF    0A.3
0DBC:  BCF    03.6
0DBD:  CALL   163
0DBE:  BSF    0A.3
....................    PRINTF (LCD_PUTC,"TB: ");    
0DBF:  MOVLW  E8
0DC0:  BSF    03.6
0DC1:  MOVWF  0D
0DC2:  MOVLW  00
0DC3:  MOVWF  0F
0DC4:  BCF    0A.3
0DC5:  BCF    03.6
0DC6:  CALL   33B
0DC7:  BSF    0A.3
....................    ITOA (SOLUONGTHIETBI_CONFIG, 10, TEMP_CHAR);    
0DC8:  BSF    03.6
0DC9:  CLRF   3F
0DCA:  CLRF   3E
0DCB:  CLRF   3D
0DCC:  BCF    03.6
0DCD:  MOVF   4E,W
0DCE:  BSF    03.6
0DCF:  MOVWF  3C
0DD0:  MOVLW  0A
0DD1:  MOVWF  40
0DD2:  CLRF   42
0DD3:  MOVLW  73
0DD4:  MOVWF  41
0DD5:  BCF    0A.3
0DD6:  BCF    03.6
0DD7:  CALL   407
0DD8:  BSF    0A.3
....................    PRINTF (LCD_PUTC,TEMP_CHAR);    
0DD9:  MOVLW  73
0DDA:  MOVWF  04
0DDB:  BCF    03.7
0DDC:  BCF    0A.3
0DDD:  CALL   527
0DDE:  BSF    0A.3
....................    PRINTF (LCD_PUTC,"    CB:");    
0DDF:  MOVLW  EB
0DE0:  BSF    03.6
0DE1:  MOVWF  0D
0DE2:  MOVLW  00
0DE3:  MOVWF  0F
0DE4:  BCF    0A.3
0DE5:  BCF    03.6
0DE6:  CALL   33B
0DE7:  BSF    0A.3
....................    ITOA (SOLUONGCAMBIEN_CONFIG, 10, TEMP_CHAR);    
0DE8:  BSF    03.6
0DE9:  CLRF   3F
0DEA:  CLRF   3E
0DEB:  CLRF   3D
0DEC:  BCF    03.6
0DED:  MOVF   4F,W
0DEE:  BSF    03.6
0DEF:  MOVWF  3C
0DF0:  MOVLW  0A
0DF1:  MOVWF  40
0DF2:  CLRF   42
0DF3:  MOVLW  73
0DF4:  MOVWF  41
0DF5:  BCF    0A.3
0DF6:  BCF    03.6
0DF7:  CALL   407
0DF8:  BSF    0A.3
....................    PRINTF (LCD_PUTC,TEMP_CHAR);       
0DF9:  MOVLW  73
0DFA:  MOVWF  04
0DFB:  BCF    03.7
0DFC:  BCF    0A.3
0DFD:  CALL   527
0DFE:  BSF    0A.3
....................    OUTPUT_D (0X00); 
0DFF:  BSF    03.5
0E00:  CLRF   08
0E01:  BCF    03.5
0E02:  CLRF   08
....................    DELAY_MS(500); 
0E03:  MOVLW  02
0E04:  BSF    03.5
0E05:  MOVWF  58
0E06:  MOVLW  FA
0E07:  BCF    03.5
0E08:  BSF    03.6
0E09:  MOVWF  40
0E0A:  BCF    0A.3
0E0B:  BCF    03.6
0E0C:  CALL   163
0E0D:  BSF    0A.3
0E0E:  BSF    03.5
0E0F:  DECFSZ 58,F
0E10:  GOTO   606
....................    OUTPUT_D (0XFF);     
0E11:  CLRF   08
0E12:  MOVLW  FF
0E13:  BCF    03.5
0E14:  MOVWF  08
....................    DELAY_MS(500); 
0E15:  MOVLW  02
0E16:  BSF    03.5
0E17:  MOVWF  58
0E18:  MOVLW  FA
0E19:  BCF    03.5
0E1A:  BSF    03.6
0E1B:  MOVWF  40
0E1C:  BCF    0A.3
0E1D:  BCF    03.6
0E1E:  CALL   163
0E1F:  BSF    0A.3
0E20:  BSF    03.5
0E21:  DECFSZ 58,F
0E22:  GOTO   618
....................    OUTPUT_D (0X00); 
0E23:  CLRF   08
0E24:  BCF    03.5
0E25:  CLRF   08
....................    TT_CONFIG_OKE_UART = 1; 
0E26:  BSF    52.6
....................     
....................  }  
.................... //--------------------------------------------------------------------// 
....................  
....................  
....................  
....................  
....................  
.................... VOID QUET_PHIM() 
*
00EF:  BSF    03.5
00F0:  BSF    03.6
00F1:  CLRF   15
.................... { 
....................    INT BDT = 0; 
....................  
....................    WHILE (!INPUT (BT1_PIN)) //NEU NUT BAM DUOC BAM 
00F2:  BCF    03.6
00F3:  BSF    06.1
00F4:  BCF    03.5
00F5:  BTFSC  06.1
00F6:  GOTO   10E
....................    { 
....................       IF (TMR1IF) 
00F7:  BTFSS  0C.0
00F8:  GOTO   109
....................       { 
....................          OUTPUT_TOGGLE (PIN_D2); 
00F9:  BSF    03.5
00FA:  BCF    08.2
00FB:  MOVLW  04
00FC:  BCF    03.5
00FD:  XORWF  08,F
....................          TMR1IF = 0; SET_TIMER1 (3036); BDT++; 
00FE:  BCF    0C.0
00FF:  CLRF   0E
0100:  MOVLW  0B
0101:  MOVWF  0F
0102:  MOVLW  DC
0103:  MOVWF  0E
0104:  BSF    03.5
0105:  BSF    03.6
0106:  INCF   15,F
0107:  BCF    03.5
0108:  BCF    03.6
....................       } 
0109:  BSF    03.5
010A:  BSF    03.6
010B:  GOTO   0F2
010C:  BCF    03.5
010D:  BCF    03.6
....................    } 
....................  
....................    IF (BDT > 20) 
010E:  BSF    03.5
010F:  BSF    03.6
0110:  MOVF   15,W
0111:  SUBLW  14
0112:  BTFSC  03.0
0113:  GOTO   11F
....................    { 
....................       //CONFIG NODE 
....................       TT_CONFIG = ~TT_CONFIG; // VAO TRANG THAI CONFIG 
0114:  MOVLW  02
0115:  BCF    03.5
0116:  BCF    03.6
0117:  XORWF  52,F
....................       TT_CONTROL = ~TT_CONTROL; 
0118:  MOVLW  04
0119:  XORWF  52,F
....................       //CONFIG_DONE (); 
....................       TT_CONFIG_DONE = 1; 
011A:  BSF    52.3
....................       TT_FUN = 0; 
011B:  BCF    52.4
....................    } 
011C:  GOTO   124
011D:  BSF    03.5
011E:  BSF    03.6
....................  
....................    ELSE 
....................    { 
....................       BUTT_OKE (); //OKE 
....................    } 
.................... } 
....................  
.................... #INT_EXT 
....................  
....................  VOID NGAT_NGOAI () 
....................  { 
....................     QUET_PHIM (); 
....................  } 
....................  
*
0124:  BCF    0B.1
0125:  BCF    0A.3
0126:  BCF    0A.4
0127:  GOTO   031
....................  #INT_RDA 
....................  VOID NGAT () 
....................  { 
....................     KYTUCHAR[VT] = GETCH (); 
0128:  MOVLW  A0
0129:  ADDWF  3D,W
012A:  MOVWF  04
012B:  BCF    03.7
012C:  BTFSS  0C.5
012D:  GOTO   12C
012E:  MOVF   1A,W
012F:  MOVWF  00
....................  
....................     IF (KYTUCHAR[VT] == '.') 
0130:  MOVLW  A0
0131:  ADDWF  3D,W
0132:  MOVWF  04
0133:  BCF    03.7
0134:  MOVF   00,W
0135:  SUBLW  2E
0136:  BTFSS  03.2
0137:  GOTO   140
....................     { 
....................        KYTUCHAR[VT] = '\0'; 
0138:  MOVLW  A0
0139:  ADDWF  3D,W
013A:  MOVWF  04
013B:  BCF    03.7
013C:  CLRF   00
....................        VT = 0; 
013D:  CLRF   3D
....................        TTNHAN = 1; 
013E:  BSF    52.0
....................     } 
013F:  GOTO   141
....................     ELSE 
....................     VT++; 
0140:  INCF   3D,F
0141:  BCF    0C.5
0142:  BCF    0A.3
0143:  BCF    0A.4
0144:  GOTO   031
....................  } 
....................   INT ADC_READ (INT KENH) 
....................  { 
....................     UNSIGNED INT8 ANALOG_PORT[] = {1,2,4,8,16,32,64};  
*
1010:  MOVLW  01
1011:  MOVWF  54
1012:  MOVLW  02
1013:  MOVWF  55
1014:  MOVLW  04
1015:  MOVWF  56
1016:  MOVLW  08
1017:  MOVWF  57
1018:  MOVLW  10
1019:  MOVWF  58
101A:  MOVLW  20
101B:  MOVWF  59
101C:  MOVLW  40
101D:  MOVWF  5A
....................     SETUP_ADC_PORTS (ANALOG_PORT[KENH]); 
101E:  MOVLW  D4
101F:  ADDWF  53,W
1020:  MOVWF  04
1021:  BCF    03.7
1022:  MOVF   00,W
1023:  MOVWF  5C
1024:  MOVWF  5D
1025:  CLRF   5E
1026:  CLRF   5F
1027:  CLRF   60
1028:  MOVLW  89
1029:  MOVWF  04
102A:  BSF    03.7
102B:  MOVLW  C0
102C:  ANDWF  00,F
102D:  MOVF   5F,W
102E:  IORWF  00,F
102F:  MOVLW  9F
1030:  MOVWF  04
1031:  BCF    03.7
1032:  MOVLW  CF
1033:  ANDWF  00,F
1034:  MOVF   5E,W
1035:  IORWF  00,F
1036:  MOVLW  88
1037:  MOVWF  04
1038:  BSF    03.7
1039:  MOVF   5D,W
103A:  MOVWF  00
....................     DELAY_MS(3); 
103B:  MOVLW  03
103C:  BCF    03.5
103D:  BSF    03.6
103E:  MOVWF  40
103F:  BCF    0A.4
1040:  BCF    03.6
1041:  CALL   163
1042:  BSF    0A.4
....................     SET_ADC_CHANNEL (KENH); 
1043:  BSF    03.5
1044:  RLF    53,W
1045:  MOVWF  77
1046:  RLF    77,F
1047:  MOVLW  FC
1048:  ANDWF  77,F
1049:  BCF    03.5
104A:  MOVF   1F,W
104B:  ANDLW  C3
104C:  IORWF  77,W
104D:  MOVWF  1F
....................     DELAY_MS(3); 
104E:  MOVLW  03
104F:  BSF    03.6
1050:  MOVWF  40
1051:  BCF    0A.4
1052:  BCF    03.6
1053:  CALL   163
1054:  BSF    0A.4
....................     KQADC = 0; 
1055:  CLRF   33
1056:  CLRF   32
....................     FOR (INT I = 0; I < 100; I++) 
1057:  BSF    03.5
1058:  CLRF   5B
1059:  MOVF   5B,W
105A:  SUBLW  63
105B:  BTFSS  03.0
105C:  GOTO   073
....................     { 
....................        KQADC = KQADC + READ_ADC () ; 
105D:  BCF    03.5
105E:  BSF    1F.1
105F:  BTFSC  1F.1
1060:  GOTO   05F
1061:  BSF    03.5
1062:  MOVF   1E,W
1063:  BCF    03.5
1064:  ADDWF  32,F
1065:  MOVF   1E,W
1066:  BTFSC  03.0
1067:  INCFSZ 1E,W
1068:  ADDWF  33,F
....................        DELAY_MS (1); 
1069:  MOVLW  01
106A:  BSF    03.6
106B:  MOVWF  40
106C:  BCF    0A.4
106D:  BCF    03.6
106E:  CALL   163
106F:  BSF    0A.4
1070:  BSF    03.5
1071:  INCF   5B,F
1072:  GOTO   059
....................     } 
....................  
....................     KQADC = KQADC / (100 * 2.046); 
1073:  BCF    03.5
1074:  MOVF   33,W
1075:  BSF    03.5
1076:  MOVWF  5D
1077:  BCF    03.5
1078:  MOVF   32,W
1079:  BSF    03.5
107A:  MOVWF  5C
*
1097:  MOVF   7A,W
1098:  MOVWF  5F
1099:  MOVF   79,W
109A:  MOVWF  5E
109B:  MOVF   78,W
109C:  MOVWF  5D
109D:  MOVF   77,W
109E:  MOVWF  5C
109F:  MOVLW  9A
10A0:  MOVWF  63
10A1:  MOVLW  99
10A2:  MOVWF  62
10A3:  MOVLW  4C
10A4:  MOVWF  61
10A5:  MOVLW  86
10A6:  MOVWF  60
*
1170:  MOVF   7A,W
1171:  MOVWF  5F
1172:  MOVF   79,W
1173:  MOVWF  5E
1174:  MOVF   78,W
1175:  MOVWF  5D
1176:  MOVF   77,W
1177:  MOVWF  5C
*
1196:  MOVF   79,W
1197:  BCF    03.5
1198:  MOVWF  33
1199:  MOVF   78,W
119A:  MOVWF  32
....................     RETURN KQADC; 
119B:  MOVF   32,W
119C:  MOVWF  78
....................  } 
....................  
....................  
....................  VOID READ_ANALOG ( ) 
....................  { 
....................    FOR(INT K = 0; K<SOLUONGCAMBIEN_CONFIG; K++){ 
*
1000:  BSF    03.5
1001:  CLRF   50
1002:  BCF    03.5
1003:  MOVF   4F,W
1004:  BSF    03.5
1005:  SUBWF  50,W
1006:  BTFSC  03.0
1007:  GOTO   1A7
....................       KET_QUA_ANALOG[K] = ADC_READ (K);   
1008:  MOVLW  38
1009:  ADDWF  50,W
100A:  MOVWF  51
100B:  CLRF   52
100C:  BTFSC  03.0
100D:  INCF   52,F
100E:  MOVF   50,W
100F:  MOVWF  53
*
119D:  BSF    03.5
119E:  MOVF   51,W
119F:  MOVWF  04
11A0:  BCF    03.7
11A1:  BTFSC  52.0
11A2:  BSF    03.7
11A3:  MOVF   78,W
11A4:  MOVWF  00
11A5:  INCF   50,F
11A6:  GOTO   002
....................    } 
11A7:  BCF    03.5
11A8:  BCF    0A.3
11A9:  BSF    0A.4
11AA:  GOTO   3D3 (RETURN)
....................  } 
....................  
....................  VOID SEND_ANALOG_UART() 
....................  { 
....................    OUTPUT_TOGGLE(PIN_D6); 
11AB:  BSF    03.5
11AC:  BCF    08.6
11AD:  MOVLW  40
11AE:  BCF    03.5
11AF:  XORWF  08,F
....................    CHAR *PACKAGE_SS[]={"*", "26","SS", "ID_GW1234" ,"ID_NODE","ZZ","AA","VV","CC","SS"}; 
11B0:  MOVLW  2A
11B1:  BSF    03.6
11B2:  MOVWF  10
11B3:  CLRF   11
11B4:  MOVLW  32
11B5:  MOVWF  12
11B6:  MOVLW  36
11B7:  MOVWF  13
11B8:  CLRF   14
11B9:  MOVLW  53
11BA:  MOVWF  15
11BB:  MOVWF  16
11BC:  CLRF   17
11BD:  MOVLW  49
11BE:  MOVWF  18
11BF:  MOVLW  44
11C0:  MOVWF  19
11C1:  MOVLW  5F
11C2:  MOVWF  1A
11C3:  MOVLW  47
11C4:  MOVWF  1B
11C5:  MOVLW  57
11C6:  MOVWF  1C
11C7:  MOVLW  31
11C8:  MOVWF  1D
11C9:  MOVLW  32
11CA:  MOVWF  1E
11CB:  MOVLW  33
11CC:  MOVWF  1F
11CD:  MOVLW  34
11CE:  MOVWF  20
11CF:  CLRF   21
11D0:  MOVLW  49
11D1:  MOVWF  22
11D2:  MOVLW  44
11D3:  MOVWF  23
11D4:  MOVLW  5F
11D5:  MOVWF  24
11D6:  MOVLW  4E
11D7:  MOVWF  25
11D8:  MOVLW  4F
11D9:  MOVWF  26
11DA:  MOVLW  44
11DB:  MOVWF  27
11DC:  MOVLW  45
11DD:  MOVWF  28
11DE:  CLRF   29
11DF:  MOVLW  5A
11E0:  MOVWF  2A
11E1:  MOVWF  2B
11E2:  CLRF   2C
11E3:  MOVLW  41
11E4:  MOVWF  2D
11E5:  MOVWF  2E
11E6:  CLRF   2F
11E7:  MOVLW  56
11E8:  MOVWF  30
11E9:  MOVWF  31
11EA:  CLRF   32
11EB:  MOVLW  43
11EC:  MOVWF  33
11ED:  MOVWF  34
11EE:  CLRF   35
11EF:  MOVLW  53
11F0:  MOVWF  36
11F1:  MOVWF  37
11F2:  CLRF   38
11F3:  MOVLW  01
11F4:  BSF    03.5
11F5:  BCF    03.6
11F6:  MOVWF  51
11F7:  MOVLW  10
11F8:  MOVWF  50
11F9:  MOVLW  01
11FA:  MOVWF  53
11FB:  MOVLW  12
11FC:  MOVWF  52
11FD:  MOVLW  01
11FE:  MOVWF  55
11FF:  MOVLW  15
1200:  MOVWF  54
1201:  MOVLW  01
1202:  MOVWF  57
1203:  MOVLW  18
1204:  MOVWF  56
1205:  MOVLW  01
1206:  MOVWF  59
1207:  MOVLW  22
1208:  MOVWF  58
1209:  MOVLW  01
120A:  MOVWF  5B
120B:  MOVLW  2A
120C:  MOVWF  5A
120D:  MOVLW  01
120E:  MOVWF  5D
120F:  MOVLW  2D
1210:  MOVWF  5C
1211:  MOVLW  01
1212:  MOVWF  5F
1213:  MOVLW  30
1214:  MOVWF  5E
1215:  MOVLW  01
1216:  MOVWF  61
1217:  MOVLW  33
1218:  MOVWF  60
1219:  MOVLW  01
121A:  MOVWF  63
121B:  MOVLW  36
121C:  MOVWF  62
....................    PACKAGE_SS[3] = ID_GATEWAY_CHAR; 
121D:  CLRF   57
121E:  MOVLW  5A
121F:  MOVWF  56
....................    PACKAGE_SS[4] = ID_NODE_CHAR; 
1220:  CLRF   59
1221:  MOVLW  53
1222:  MOVWF  58
....................    UNSIGNED INT8 DO_DAI =20; 
1223:  MOVLW  14
1224:  MOVWF  64
....................    FOR(INT I = 0; I<SOLUONGCAMBIEN_CONFIG; I++) 
1225:  CLRF   65
1226:  BCF    03.5
1227:  MOVF   4F,W
1228:  BSF    03.5
1229:  SUBWF  65,W
122A:  BTFSC  03.0
122B:  GOTO   259
....................    { 
....................       ITOA(KET_QUA_ANALOG[I],10,TEMP_CHAR); 
122C:  MOVLW  38
122D:  ADDWF  65,W
122E:  MOVWF  04
122F:  BCF    03.7
1230:  MOVF   00,W
1231:  MOVWF  66
1232:  BCF    03.5
1233:  BSF    03.6
1234:  CLRF   3F
1235:  CLRF   3E
1236:  CLRF   3D
1237:  BSF    03.5
1238:  BCF    03.6
1239:  MOVF   66,W
123A:  BCF    03.5
123B:  BSF    03.6
123C:  MOVWF  3C
123D:  MOVLW  0A
123E:  MOVWF  40
123F:  CLRF   42
1240:  MOVLW  73
1241:  MOVWF  41
1242:  BCF    0A.4
1243:  BCF    03.6
1244:  CALL   407
1245:  BSF    0A.4
....................       PACKAGE_SS[5+I] = TEMP_CHAR;       
1246:  MOVLW  05
1247:  BSF    03.5
1248:  ADDWF  65,W
1249:  MOVWF  77
124A:  BCF    03.0
124B:  RLF    77,F
124C:  MOVF   77,W
124D:  ADDLW  D0
124E:  MOVWF  04
124F:  BCF    03.7
1250:  INCF   04,F
1251:  CLRF   00
1252:  DECF   04,F
1253:  MOVLW  73
1254:  MOVWF  00
....................       DO_DAI = DO_DAI + 3; 
1255:  MOVLW  03
1256:  ADDWF  64,F
1257:  INCF   65,F
1258:  GOTO   226
....................    } 
....................     
....................    ITOA(DO_DAI,10,TEMP_CHAR2); 
1259:  BCF    03.5
125A:  BSF    03.6
125B:  CLRF   3F
125C:  CLRF   3E
125D:  CLRF   3D
125E:  BSF    03.5
125F:  BCF    03.6
1260:  MOVF   64,W
1261:  BCF    03.5
1262:  BSF    03.6
1263:  MOVWF  3C
1264:  MOVLW  0A
1265:  MOVWF  40
1266:  CLRF   42
1267:  MOVLW  75
1268:  MOVWF  41
1269:  BCF    0A.4
126A:  BCF    03.6
126B:  CALL   407
126C:  BSF    0A.4
....................    PACKAGE_SS[1] = TEMP_CHAR2; 
126D:  BSF    03.5
126E:  CLRF   53
126F:  MOVLW  75
1270:  MOVWF  52
....................     
....................    FOR ( I = 0; I < 5 + SOLUONGCAMBIEN_CONFIG; I++) 
1271:  CLRF   65
1272:  MOVLW  05
1273:  BCF    03.5
1274:  ADDWF  4F,W
1275:  BSF    03.5
1276:  SUBWF  65,W
1277:  BTFSC  03.0
1278:  GOTO   2B7
....................    { 
....................       LCD_GOTOXY (5, 1) ;     
1279:  MOVLW  05
127A:  BCF    03.5
127B:  BSF    03.6
127C:  MOVWF  40
127D:  MOVLW  01
127E:  MOVWF  41
127F:  BCF    0A.4
1280:  BCF    03.6
1281:  CALL   2ED
1282:  BSF    0A.4
....................       PRINTF (LCD_PUTC,"h") ; 
1283:  MOVLW  68
1284:  BSF    03.6
1285:  MOVWF  3F
1286:  BCF    0A.4
1287:  BCF    03.6
1288:  CALL   301
1289:  BSF    0A.4
....................       PRINTF (LCD_PUTC,PACKAGE_SS[I] ) ; 
128A:  BCF    03.0
128B:  BSF    03.5
128C:  RLF    65,W
128D:  ADDLW  D0
128E:  MOVWF  04
128F:  BCF    03.7
1290:  INCF   04,F
1291:  MOVF   00,W
1292:  MOVWF  67
1293:  DECF   04,F
1294:  MOVF   00,W
1295:  MOVWF  66
1296:  MOVWF  04
1297:  BCF    03.7
1298:  BTFSC  67.0
1299:  BSF    03.7
129A:  BCF    0A.4
129B:  BCF    03.5
129C:  CALL   527
129D:  BSF    0A.4
....................       PRINTF (LCD_PUTC,"h                     ") ; 
129E:  MOVLW  45
129F:  BSF    03.6
12A0:  MOVWF  0D
12A1:  MOVLW  01
12A2:  MOVWF  0F
12A3:  BCF    0A.4
12A4:  BCF    03.6
12A5:  CALL   33B
12A6:  BSF    0A.4
....................       DELAY_MS (900); 
12A7:  MOVLW  04
12A8:  BSF    03.5
12A9:  MOVWF  66
12AA:  MOVLW  E1
12AB:  BCF    03.5
12AC:  BSF    03.6
12AD:  MOVWF  40
12AE:  BCF    0A.4
12AF:  BCF    03.6
12B0:  CALL   163
12B1:  BSF    0A.4
12B2:  BSF    03.5
12B3:  DECFSZ 66,F
12B4:  GOTO   2AA
12B5:  INCF   65,F
12B6:  GOTO   272
....................    } 
....................     
....................     
....................    FOR ( I = 0; I < 5 + SOLUONGCAMBIEN_CONFIG; I++) 
12B7:  CLRF   65
12B8:  MOVLW  05
12B9:  BCF    03.5
12BA:  ADDWF  4F,W
12BB:  BSF    03.5
12BC:  SUBWF  65,W
12BD:  BTFSC  03.0
12BE:  GOTO   2D9
....................    { 
....................       PRINTF (PACKAGE_SS[I]); 
12BF:  BCF    03.0
12C0:  RLF    65,W
12C1:  ADDLW  D0
12C2:  MOVWF  04
12C3:  BCF    03.7
12C4:  INCF   04,F
12C5:  MOVF   00,W
12C6:  MOVWF  67
12C7:  DECF   04,F
12C8:  MOVF   00,W
12C9:  MOVWF  66
12CA:  MOVWF  04
12CB:  BCF    03.7
12CC:  BTFSC  67.0
12CD:  BSF    03.7
12CE:  BCF    0A.4
12CF:  BCF    03.5
12D0:  CALL   7D6
12D1:  BSF    0A.4
....................       PRINTF ("@"); 
12D2:  MOVLW  40
12D3:  BTFSS  0C.4
12D4:  GOTO   2D3
12D5:  MOVWF  19
12D6:  BSF    03.5
12D7:  INCF   65,F
12D8:  GOTO   2B8
....................    } 
....................    PRINTF ("#"); 
12D9:  MOVLW  23
12DA:  BCF    03.5
12DB:  BTFSS  0C.4
12DC:  GOTO   2DB
12DD:  MOVWF  19
....................    OUTPUT_TOGGLE(PIN_D6); 
12DE:  BSF    03.5
12DF:  BCF    08.6
12E0:  MOVLW  40
12E1:  BCF    03.5
12E2:  XORWF  08,F
12E3:  BCF    0A.3
12E4:  BSF    0A.4
12E5:  GOTO   3D7 (RETURN)
....................     
....................  } 
....................  VOID DIEUKHIENTHIETBI() 
....................  { 
....................     /* LAY TOKEN DAU TIEN */     
....................     KYTU = 0; 
*
0E28:  CLRF   3E
....................     TEMP_CHAR = "_"; 
0E29:  BSF    03.5
0E2A:  CLRF   58
0E2B:  CLRF   59
0E2C:  MOVLW  73
0E2D:  MOVWF  04
0E2E:  BCF    03.7
0E2F:  MOVF   58,W
0E30:  ADDWF  04,F
0E31:  MOVF   59,W
0E32:  BCF    0A.3
0E33:  BCF    03.5
0E34:  CALL   05E
0E35:  BSF    0A.3
0E36:  MOVWF  00
0E37:  IORLW  00
0E38:  BTFSC  03.2
0E39:  GOTO   63F
0E3A:  BSF    03.5
0E3B:  INCF   59,F
0E3C:  INCF   58,F
0E3D:  GOTO   62C
0E3E:  BCF    03.5
....................     LCD_GOTOXY (1, 1) ; 
0E3F:  MOVLW  01
0E40:  BSF    03.6
0E41:  MOVWF  40
0E42:  MOVWF  41
0E43:  BCF    0A.3
0E44:  BCF    03.6
0E45:  CALL   2ED
0E46:  BSF    0A.3
....................     DELAY_MS (10);        
0E47:  MOVLW  0A
0E48:  BSF    03.6
0E49:  MOVWF  40
0E4A:  BCF    0A.3
0E4B:  BCF    03.6
0E4C:  CALL   163
0E4D:  BSF    0A.3
....................     PRINTF (LCD_PUTC, KYTUCHAR2);    
0E4E:  MOVLW  BE
0E4F:  MOVWF  04
0E50:  BCF    03.7
0E51:  BCF    0A.3
0E52:  CALL   527
0E53:  BSF    0A.3
....................     PRINTF (LCD_PUTC, "                 "); 
0E54:  MOVLW  51
0E55:  BSF    03.6
0E56:  MOVWF  0D
0E57:  MOVLW  01
0E58:  MOVWF  0F
0E59:  BCF    0A.3
0E5A:  BCF    03.6
0E5B:  CALL   33B
0E5C:  BSF    0A.3
....................     LCD_GOTOXY (1, 2) ; 
0E5D:  MOVLW  01
0E5E:  BSF    03.6
0E5F:  MOVWF  40
0E60:  MOVLW  02
0E61:  MOVWF  41
0E62:  BCF    0A.3
0E63:  BCF    03.6
0E64:  CALL   2ED
0E65:  BSF    0A.3
....................     DELAY_MS (10);           
0E66:  MOVLW  0A
0E67:  BSF    03.6
0E68:  MOVWF  40
0E69:  BCF    0A.3
0E6A:  BCF    03.6
0E6B:  CALL   163
0E6C:  BSF    0A.3
....................     PRINTF (LCD_PUTC, "                 ");     
0E6D:  MOVLW  5A
0E6E:  BSF    03.6
0E6F:  MOVWF  0D
0E70:  MOVLW  01
0E71:  MOVWF  0F
0E72:  BCF    0A.3
0E73:  BCF    03.6
0E74:  CALL   33B
0E75:  BSF    0A.3
....................     CHAR * TOKEN; 
....................     TOKEN = STRTOK (KYTUCHAR2, TEMP_CHAR);    
0E76:  BSF    03.5
0E77:  CLRF   59
0E78:  MOVLW  BE
0E79:  MOVWF  58
0E7A:  CLRF   5B
0E7B:  MOVLW  73
0E7C:  MOVWF  5A
0E7D:  BCF    03.5
0E7E:  CALL   18B
0E7F:  MOVF   79,W
0E80:  BSF    03.5
0E81:  MOVWF  57
0E82:  MOVF   78,W
0E83:  MOVWF  56
....................      
....................     /* DUYET QUA CAC TOKEN CON LAI */                 
....................     WHILE (TOKEN != NULL) 
0E84:  MOVF   56,F
0E85:  BTFSS  03.2
0E86:  GOTO   68A
0E87:  MOVF   57,F
0E88:  BTFSC  03.2
0E89:  GOTO   6E8
....................     {                 
....................        SWITCH(KYTU) 
0E8A:  BCF    03.5
0E8B:  MOVF   3E,W
0E8C:  BTFSC  03.2
0E8D:  GOTO   695
0E8E:  XORLW  01
0E8F:  BTFSC  03.2
0E90:  GOTO   69F
0E91:  XORLW  03
0E92:  BTFSC  03.2
0E93:  GOTO   6A9
0E94:  GOTO   6BD
....................        { 
....................          CASE 0: 
....................          ID_DEVICE_NHAN =  ATOI(TOKEN) +64 ;        
0E95:  BSF    03.5
0E96:  MOVF   57,W
0E97:  MOVWF  59
0E98:  MOVF   56,W
0E99:  MOVWF  58
0E9A:  BCF    03.5
0E9B:  CALL   27C
0E9C:  MOVLW  40
0E9D:  ADDWF  78,W
0E9E:  MOVWF  3F
....................          CASE 1:  
....................          TT_DEVICE_NHAN =  ATOI(TOKEN);        
0E9F:  BSF    03.5
0EA0:  MOVF   57,W
0EA1:  MOVWF  59
0EA2:  MOVF   56,W
0EA3:  MOVWF  58
0EA4:  BCF    03.5
0EA5:  CALL   27C
0EA6:  MOVF   78,W
0EA7:  MOVWF  40
....................          BREAK;                      
0EA8:  GOTO   6BD
....................          CASE 2: 
....................          STRCAT (ID_NODE_NHAN, TOKEN); 
0EA9:  BSF    03.6
0EAA:  CLRF   34
0EAB:  MOVLW  63
0EAC:  MOVWF  33
0EAD:  BSF    03.5
0EAE:  BCF    03.6
0EAF:  MOVF   57,W
0EB0:  BCF    03.5
0EB1:  BSF    03.6
0EB2:  MOVWF  36
0EB3:  BSF    03.5
0EB4:  BCF    03.6
0EB5:  MOVF   56,W
0EB6:  BCF    03.5
0EB7:  BSF    03.6
0EB8:  MOVWF  35
0EB9:  BCF    0A.3
0EBA:  BCF    03.6
0EBB:  CALL   778
0EBC:  BSF    0A.3
....................          BREAK;               
....................        }  
....................        LCD_GOTOXY (7, 2) ; 
0EBD:  MOVLW  07
0EBE:  BSF    03.6
0EBF:  MOVWF  40
0EC0:  MOVLW  02
0EC1:  MOVWF  41
0EC2:  BCF    0A.3
0EC3:  BCF    03.6
0EC4:  CALL   2ED
0EC5:  BSF    0A.3
....................        DELAY_MS (10);        
0EC6:  MOVLW  0A
0EC7:  BSF    03.6
0EC8:  MOVWF  40
0EC9:  BCF    0A.3
0ECA:  BCF    03.6
0ECB:  CALL   163
0ECC:  BSF    0A.3
....................        PRINTF (LCD_PUTC, TOKEN); 
0ECD:  BSF    03.5
0ECE:  MOVF   56,W
0ECF:  MOVWF  04
0ED0:  BCF    03.7
0ED1:  BTFSC  57.0
0ED2:  BSF    03.7
0ED3:  BCF    0A.3
0ED4:  BCF    03.5
0ED5:  CALL   527
0ED6:  BSF    0A.3
....................       TOKEN = STRTOK(NULL, TEMP_CHAR); 
0ED7:  BSF    03.5
0ED8:  CLRF   59
0ED9:  CLRF   58
0EDA:  CLRF   5B
0EDB:  MOVLW  73
0EDC:  MOVWF  5A
0EDD:  BCF    03.5
0EDE:  CALL   18B
0EDF:  MOVF   79,W
0EE0:  BSF    03.5
0EE1:  MOVWF  57
0EE2:  MOVF   78,W
0EE3:  MOVWF  56
....................       KYTU++;         
0EE4:  BCF    03.5
0EE5:  INCF   3E,F
0EE6:  BSF    03.5
0EE7:  GOTO   684
....................     }  
....................     OUTPUT_BIT (ID_DEVICE_NHAN, TT_DEVICE_NHAN); 
0EE8:  BCF    03.5
0EE9:  MOVF   40,F
0EEA:  BTFSS  03.2
0EEB:  GOTO   6EE
0EEC:  MOVLW  00
0EED:  GOTO   6EF
0EEE:  MOVLW  01
0EEF:  MOVWF  77
0EF0:  MOVF   3F,W
0EF1:  BSF    03.5
0EF2:  MOVWF  58
0EF3:  MOVF   77,W
0EF4:  MOVWF  59
0EF5:  CLRF   5B
0EF6:  CLRF   5A
0EF7:  BCF    03.5
0EF8:  CALL   3C4
0EF9:  MOVF   3F,W
0EFA:  BSF    03.5
0EFB:  MOVWF  58
0EFC:  CLRF   59
0EFD:  CLRF   5B
0EFE:  MOVLW  80
0EFF:  MOVWF  5A
0F00:  BCF    03.5
0F01:  CALL   3C4
....................  } 
....................  
....................  VOID XU_LY_UART() 
*
0BE6:  MOVLW  2A
0BE7:  BSF    03.5
0BE8:  MOVWF  50
....................  { 
....................      //ID_NODE_NHAN = KYTU[1] - 48; 
....................     //ID_DEVICE_NHAN = KYTU[2] - 48 + 64; 
....................     //TT_DEVICE_NHAN = KYTU[3] - 48; // - 48 ASCII -- > S?. + 64 -- > PORT_D (D0 = 64)                
....................  
....................     /*TINH DO DAI*/ 
....................     CHAR CH = '*'; 
....................     CHAR *RET; 
....................     *ID_NODE_NHAN = '\0'; 
0BE9:  CLRF   7A
0BEA:  MOVLW  63
0BEB:  MOVWF  04
0BEC:  BCF    03.7
0BED:  BTFSC  7A.0
0BEE:  BSF    03.7
0BEF:  CLRF   00
....................     *ID_GW_NHAN = '\0'; 
0BF0:  CLRF   7A
0BF1:  MOVLW  6A
0BF2:  MOVWF  04
0BF3:  BCF    03.7
0BF4:  BTFSC  7A.0
0BF5:  BSF    03.7
0BF6:  CLRF   00
....................     KYTUCHAR2 = ""; 
0BF7:  CLRF   56
0BF8:  CLRF   57
0BF9:  MOVLW  BE
0BFA:  MOVWF  04
0BFB:  BCF    03.7
0BFC:  MOVF   56,W
0BFD:  ADDWF  04,F
0BFE:  MOVF   57,W
0BFF:  BCF    0A.3
0C00:  BCF    03.5
0C01:  CALL   06A
0C02:  BSF    0A.3
0C03:  MOVWF  00
0C04:  IORLW  00
0C05:  BTFSC  03.2
0C06:  GOTO   40C
0C07:  BSF    03.5
0C08:  INCF   57,F
0C09:  INCF   56,F
0C0A:  GOTO   3F9
0C0B:  BCF    03.5
....................     UNSIGNED INT8 LEN_RET;     
....................     RET = STRCHR(KYTUCHAR,CH); 
0C0C:  BSF    03.5
0C0D:  CLRF   57
0C0E:  MOVLW  A0
0C0F:  MOVWF  56
0C10:  MOVF   50,W
0C11:  MOVWF  58
*
0C33:  MOVF   79,W
0C34:  MOVWF  52
0C35:  MOVF   78,W
0C36:  MOVWF  51
....................     LEN_RET = STRLEN(RET);  
0C37:  MOVF   52,W
0C38:  BCF    03.5
0C39:  BSF    03.6
0C3A:  MOVWF  35
0C3B:  BSF    03.5
0C3C:  BCF    03.6
0C3D:  MOVF   51,W
0C3E:  BCF    03.5
0C3F:  BSF    03.6
0C40:  MOVWF  34
0C41:  BCF    0A.3
0C42:  BCF    03.6
0C43:  CALL   7B6
0C44:  BSF    0A.3
0C45:  MOVF   78,W
0C46:  BSF    03.5
0C47:  MOVWF  53
....................     /* LAY TOKEN DAU TIEN */     
....................     KYTU = 0; 
0C48:  BCF    03.5
0C49:  CLRF   3E
....................     TEMP_CHAR = "#"; 
0C4A:  BSF    03.5
0C4B:  CLRF   56
0C4C:  CLRF   57
0C4D:  MOVLW  73
0C4E:  MOVWF  04
0C4F:  BCF    03.7
0C50:  MOVF   56,W
0C51:  ADDWF  04,F
0C52:  MOVF   57,W
0C53:  BCF    0A.3
0C54:  BCF    03.5
0C55:  CALL   064
0C56:  BSF    0A.3
0C57:  MOVWF  00
0C58:  IORLW  00
0C59:  BTFSC  03.2
0C5A:  GOTO   460
0C5B:  BSF    03.5
0C5C:  INCF   57,F
0C5D:  INCF   56,F
0C5E:  GOTO   44D
0C5F:  BCF    03.5
....................     CHAR * TOKEN; 
....................     TOKEN = STRTOK (KYTUCHAR, TEMP_CHAR);                 
0C60:  BSF    03.5
0C61:  CLRF   59
0C62:  MOVLW  A0
0C63:  MOVWF  58
0C64:  CLRF   5B
0C65:  MOVLW  73
0C66:  MOVWF  5A
0C67:  BCF    03.5
0C68:  CALL   18B
0C69:  MOVF   79,W
0C6A:  BSF    03.5
0C6B:  MOVWF  55
0C6C:  MOVF   78,W
0C6D:  MOVWF  54
....................     /* DUYET QUA CAC TOKEN CON LAI */                 
....................     WHILE (TOKEN != NULL) 
0C6E:  MOVF   54,F
0C6F:  BTFSS  03.2
0C70:  GOTO   474
0C71:  MOVF   55,F
0C72:  BTFSC  03.2
0C73:  GOTO   4DF
....................     {                 
....................        SWITCH(KYTU) 
0C74:  BCF    03.5
0C75:  MOVF   3E,W
0C76:  ADDLW  FA
0C77:  BTFSC  03.0
0C78:  GOTO   4CE
0C79:  ADDLW  06
0C7A:  GOTO   70D
....................        { 
....................          CASE 0: 
....................          BREAK; 
0C7B:  GOTO   4CE
....................          CASE 1:  
....................          STRCAT (ID_GW_NHAN, TOKEN); 
0C7C:  BSF    03.6
0C7D:  CLRF   34
0C7E:  MOVLW  6A
0C7F:  MOVWF  33
0C80:  BSF    03.5
0C81:  BCF    03.6
0C82:  MOVF   55,W
0C83:  BCF    03.5
0C84:  BSF    03.6
0C85:  MOVWF  36
0C86:  BSF    03.5
0C87:  BCF    03.6
0C88:  MOVF   54,W
0C89:  BCF    03.5
0C8A:  BSF    03.6
0C8B:  MOVWF  35
0C8C:  BCF    0A.3
0C8D:  BCF    03.6
0C8E:  CALL   778
0C8F:  BSF    0A.3
....................          BREAK;                      
0C90:  GOTO   4CE
....................          CASE 2: 
....................          STRCAT (ID_NODE_NHAN, TOKEN); 
0C91:  BSF    03.6
0C92:  CLRF   34
0C93:  MOVLW  63
0C94:  MOVWF  33
0C95:  BSF    03.5
0C96:  BCF    03.6
0C97:  MOVF   55,W
0C98:  BCF    03.5
0C99:  BSF    03.6
0C9A:  MOVWF  36
0C9B:  BSF    03.5
0C9C:  BCF    03.6
0C9D:  MOVF   54,W
0C9E:  BCF    03.5
0C9F:  BSF    03.6
0CA0:  MOVWF  35
0CA1:  BCF    0A.3
0CA2:  BCF    03.6
0CA3:  CALL   778
0CA4:  BSF    0A.3
....................          BREAK;       
0CA5:  GOTO   4CE
....................          CASE 3: 
....................          LENHDIEUKHIEN =  ATOI(TOKEN);                  
0CA6:  BSF    03.5
0CA7:  MOVF   55,W
0CA8:  MOVWF  59
0CA9:  MOVF   54,W
0CAA:  MOVWF  58
0CAB:  BCF    03.5
0CAC:  CALL   27C
0CAD:  MOVF   78,W
0CAE:  MOVWF  4C
....................          BREAK;     
0CAF:  GOTO   4CE
....................          CASE 4: 
....................          DODAI_DATA_NHAN =  ATOI(TOKEN);                  
0CB0:  BSF    03.5
0CB1:  MOVF   55,W
0CB2:  MOVWF  59
0CB3:  MOVF   54,W
0CB4:  MOVWF  58
0CB5:  BCF    03.5
0CB6:  CALL   27C
0CB7:  MOVF   78,W
0CB8:  MOVWF  4D
....................          BREAK;   
0CB9:  GOTO   4CE
....................          CASE 5:   
....................          STRCAT (KYTUCHAR2, TOKEN); 
0CBA:  BSF    03.6
0CBB:  CLRF   34
0CBC:  MOVLW  BE
0CBD:  MOVWF  33
0CBE:  BSF    03.5
0CBF:  BCF    03.6
0CC0:  MOVF   55,W
0CC1:  BCF    03.5
0CC2:  BSF    03.6
0CC3:  MOVWF  36
0CC4:  BSF    03.5
0CC5:  BCF    03.6
0CC6:  MOVF   54,W
0CC7:  BCF    03.5
0CC8:  BSF    03.6
0CC9:  MOVWF  35
0CCA:  BCF    0A.3
0CCB:  BCF    03.6
0CCC:  CALL   778
0CCD:  BSF    0A.3
....................          BREAK;          
....................        }          
....................       TOKEN = STRTOK(NULL, TEMP_CHAR); 
0CCE:  BSF    03.5
0CCF:  CLRF   59
0CD0:  CLRF   58
0CD1:  CLRF   5B
0CD2:  MOVLW  73
0CD3:  MOVWF  5A
0CD4:  BCF    03.5
0CD5:  CALL   18B
0CD6:  MOVF   79,W
0CD7:  BSF    03.5
0CD8:  MOVWF  55
0CD9:  MOVF   78,W
0CDA:  MOVWF  54
....................       KYTU++;         
0CDB:  BCF    03.5
0CDC:  INCF   3E,F
0CDD:  BSF    03.5
0CDE:  GOTO   46E
....................     }               
....................       /* SO SANH ID returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................       SOSANH_IDGW = STRCMP(ID_GW_NHAN,ID_GATEWAY_CHAR);       
0CDF:  CLRF   57
0CE0:  MOVLW  6A
0CE1:  MOVWF  56
0CE2:  CLRF   59
0CE3:  MOVLW  5A
0CE4:  MOVWF  58
0CE5:  BCF    03.5
0CE6:  CALL   37E
0CE7:  MOVF   78,W
0CE8:  MOVWF  51
....................       SOSANH_IDNODE = STRCMP(ID_NODE_NHAN,ID_NODE_CHAR);     
0CE9:  BSF    03.5
0CEA:  CLRF   57
0CEB:  MOVLW  63
0CEC:  MOVWF  56
0CED:  CLRF   59
0CEE:  MOVLW  53
0CEF:  MOVWF  58
0CF0:  BCF    03.5
0CF1:  CALL   37E
0CF2:  MOVF   78,W
0CF3:  MOVWF  50
....................     IF ( SOSANH_IDGW == 0 && SOSANH_IDNODE == 0 && LEN_RET == DODAI_DATA_NHAN) 
0CF4:  MOVF   51,F
0CF5:  BTFSS  03.2
0CF6:  GOTO   703
0CF7:  MOVF   50,F
0CF8:  BTFSS  03.2
0CF9:  GOTO   703
0CFA:  MOVF   4D,W
0CFB:  BSF    03.5
0CFC:  SUBWF  53,W
0CFD:  BTFSC  03.2
0CFE:  GOTO   501
0CFF:  BCF    03.5
0D00:  GOTO   703
....................     {                       
....................       SWITCH(LENHDIEUKHIEN) 
0D01:  BCF    03.5
0D02:  MOVF   4C,W
0D03:  BTFSC  03.2
0D04:  GOTO   50C
0D05:  XORLW  01
0D06:  BTFSC  03.2
0D07:  GOTO   50D
0D08:  XORLW  03
0D09:  BTFSC  03.2
0D0A:  GOTO   628
0D0B:  GOTO   702
....................        { 
....................          CASE 0: 
....................          BREAK; 
0D0C:  GOTO   702
....................          CASE 1: 
....................          XACNHANCONFIG(); 
....................          BREAK;                      
*
0E27:  GOTO   702
....................          CASE 2: 
....................          DIEUKHIENTHIETBI(); 
....................          BREAK;               
....................        }  
....................     } 
*
0F02:  GOTO   70A
....................     ELSE{ 
....................       DELAY_MS (10); 
0F03:  MOVLW  0A
0F04:  BSF    03.6
0F05:  MOVWF  40
0F06:  BCF    0A.3
0F07:  BCF    03.6
0F08:  CALL   163
0F09:  BSF    0A.3
....................       /*DATA RCV SAI ID NODE, ID GW HOAC LA SAI DO DAI*/ 
....................     } 
0F0A:  BCF    0A.3
0F0B:  BSF    0A.4
0F0C:  GOTO   3CE (RETURN)
....................      
....................  } 
....................  
....................  
....................  VOID CHUONG_TRINH_CON () 
....................  { 
....................     FOR (INT I = 0; I <= 30; I++) 
*
0970:  BSF    03.5
0971:  CLRF   50
0972:  MOVF   50,W
0973:  SUBLW  1E
0974:  BTFSS  03.0
0975:  GOTO   184
....................     { 
....................        OUTPUT_TOGGLE (PIN_D1); 
0976:  BCF    08.1
0977:  MOVLW  02
0978:  BCF    03.5
0979:  XORWF  08,F
....................        DELAY_MS (100); 
097A:  MOVLW  64
097B:  BSF    03.6
097C:  MOVWF  40
097D:  BCF    0A.3
097E:  BCF    03.6
097F:  CALL   163
0980:  BSF    0A.3
0981:  BSF    03.5
0982:  INCF   50,F
0983:  GOTO   172
....................     } 
....................     OUTPUT_TOGGLE(PIN_D0); 
0984:  BCF    08.0
0985:  MOVLW  01
0986:  BCF    03.5
0987:  XORWF  08,F
0988:  BCF    0A.3
0989:  BSF    0A.4
098A:  GOTO   3C6 (RETURN)
....................  } 
....................  
....................  VOID MAIN  () 
*
12E6:  MOVF   03,W
12E7:  ANDLW  1F
12E8:  MOVWF  03
12E9:  BSF    03.5
12EA:  BSF    03.6
12EB:  BSF    07.3
12EC:  MOVLW  08
12ED:  BCF    03.6
12EE:  MOVWF  19
12EF:  MOVLW  02
12F0:  MOVWF  1A
12F1:  MOVLW  A6
12F2:  MOVWF  18
12F3:  MOVLW  90
12F4:  BCF    03.5
12F5:  MOVWF  18
12F6:  MOVLW  FF
12F7:  MOVWF  31
12F8:  CLRF   3C
12F9:  CLRF   3D
12FA:  CLRF   3E
12FB:  CLRF   4B
12FC:  CLRF   4C
12FD:  CLRF   4D
12FE:  CLRF   4E
12FF:  MOVLW  03
1300:  MOVWF  4F
1301:  CLRF   50
1302:  CLRF   51
1303:  BCF    52.0
1304:  BCF    52.1
1305:  BCF    52.2
1306:  BCF    52.3
1307:  BCF    52.4
1308:  BCF    52.5
1309:  BCF    52.6
130A:  BSF    03.5
130B:  BSF    03.6
130C:  MOVF   09,W
130D:  ANDLW  C0
130E:  MOVWF  09
130F:  BCF    03.6
1310:  BCF    1F.4
1311:  BCF    1F.5
1312:  MOVLW  00
1313:  BSF    03.6
1314:  MOVWF  08
1315:  BCF    03.5
1316:  CLRF   07
1317:  CLRF   08
1318:  CLRF   09
1319:  BCF    03.7
....................  { 
....................     SET_TRIS_D (0X00); 
*
1385:  MOVLW  00
1386:  MOVWF  08
....................     SET_TRIS_B (0XFF); 
1387:  MOVLW  FF
1388:  MOVWF  06
....................     SET_TRIS_E (0); 
1389:  BCF    09.0
138A:  BCF    09.1
138B:  BCF    09.2
138C:  BCF    09.3
....................     SET_TRIS_C (0X80); 
138D:  MOVLW  80
138E:  MOVWF  07
138F:  BCF    03.5
1390:  MOVWF  31
....................     SETUP_ADC (ADC_CLOCK_DIV_8);        
1391:  BSF    1F.6
1392:  BCF    1F.7
1393:  BSF    03.5
1394:  BSF    1F.7
1395:  BCF    03.5
1396:  BSF    1F.0
....................     ENABLE_INTERRUPTS (INT_TIMER0); 
1397:  BSF    0B.5
....................     ENABLE_INTERRUPTS (INT_EXT); //CHO PHEP NGAT NGOAI 
1398:  BSF    0B.4
....................     ENABLE_INTERRUPTS (INT_EXT_H2L); //NGAT XAY RA KHI CO XUNG TU CAO XUONG THAP 
1399:  BSF    0B.4
139A:  BSF    03.5
139B:  BCF    01.6
....................     ENABLE_INTERRUPTS (INT_RDA); 
139C:  BSF    0C.5
....................     ENABLE_INTERRUPTS (GLOBAL); 
139D:  MOVLW  C0
139E:  BCF    03.5
139F:  IORWF  0B,F
....................      
....................     SETUP_TIMER_1 (T1_INTERNAL|T1_DIV_BY_8); 
13A0:  MOVLW  35
13A1:  MOVWF  10
....................     //SET_TIMER1 (0); 
....................     SET_TIMER1 (3036); 
13A2:  CLRF   0E
13A3:  MOVLW  0B
13A4:  MOVWF  0F
13A5:  MOVLW  DC
13A6:  MOVWF  0E
....................     TMR1IF = 0; 
13A7:  BCF    0C.0
....................     LCD_INIT (); // KHOI TAO LCD 
13A8:  BCF    0A.4
13A9:  GOTO   27D
13AA:  BSF    0A.4
....................  
....................     TT_CONFIG = 0; 
13AB:  BCF    52.1
....................     TT_CONFIG_DONE = 0; 
13AC:  BCF    52.3
....................     TT_CONTROL = 1; 
13AD:  BSF    52.2
....................     OUTPUT_D (0X00); 
13AE:  BSF    03.5
13AF:  CLRF   08
13B0:  BCF    03.5
13B1:  CLRF   08
....................     TTNHAN = 0; 
13B2:  BCF    52.0
....................      
....................     
....................     WHILE (TRUE) 
....................     { 
....................        IF (TT_CONFIG)             {BUTT_FUN (); } // GOI HAM CHON LENH (SWITCH CASE) 
13B3:  BTFSS  52.1
13B4:  GOTO   3B9
13B5:  BCF    0A.4
13B6:  GOTO   55B
13B7:  BSF    0A.4
13B8:  GOTO   3D8
....................        ELSE IF (TT_CONFIG_DONE)   { CONFIG_DONE ();}        
13B9:  BTFSS  52.3
13BA:  GOTO   3C1
13BB:  BCF    0A.4
13BC:  BSF    0A.3
13BD:  GOTO   000
13BE:  BSF    0A.4
13BF:  BCF    0A.3
13C0:  GOTO   3D8
....................        ELSE 
....................        { 
....................           WHILE (!TT_CONFIG) 
13C1:  BTFSC  52.1
13C2:  GOTO   3D8
....................           { 
....................              CHUONG_TRINH_CON ();                       
13C3:  BCF    0A.4
13C4:  BSF    0A.3
13C5:  GOTO   170
13C6:  BSF    0A.4
13C7:  BCF    0A.3
....................              IF (TTNHAN == 1) 
13C8:  BTFSS  52.0
13C9:  GOTO   3D0
....................              { 
....................                 TTNHAN = 0; 
13CA:  BCF    52.0
....................                 XU_LY_UART(); 
13CB:  BCF    0A.4
13CC:  BSF    0A.3
13CD:  GOTO   3E6
13CE:  BSF    0A.4
13CF:  BCF    0A.3
....................              }  
....................               
....................              IF (TT_CONFIG_OKE_UART == 1){ 
13D0:  BTFSS  52.6
13D1:  GOTO   3D7
....................                READ_ANALOG(); 
13D2:  GOTO   000
....................                IF (KET_QUA_ANALOG[0]>28) 
13D3:  MOVF   38,W
13D4:  SUBLW  1C
13D5:  BTFSS  03.0
....................                { 
....................                SEND_ANALOG_UART(); 
13D6:  GOTO   1AB
....................                } 
....................              } 
13D7:  GOTO   3C1
....................  
....................           } 
....................        } 
13D8:  GOTO   3B3
....................     } 
....................  } 
....................  
13D9:  SLEEP

Configuration Fuses:
   Word  1: 2FE2   HS NOWDT PUT MCLR NOPROTECT NOCPD BROWNOUT IESO FCMEN NOLVP NODEBUG
   Word  2: 3FFF   BORV40 NOWRT
