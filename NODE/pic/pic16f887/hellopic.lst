CCS PCM C Compiler, Version 5.015, 5967               08-Nov-21 17:54

               Filename:   E:\DATN_V2\NODE\pic\pic16f887\hellopic.lst

               ROM used:   4816 words (59%)
                           Largest free fragment is 2048
               RAM used:   175 (48%) at main() level
                           261 (71%) worst case
               Stack used: 7 locations (6 in main + 1 for interrupts)
               Stack size: 8

*
0000:  MOVLW  11
0001:  MOVWF  0A
0002:  GOTO   127
0003:  NOP
0004:  MOVWF  7F
0005:  SWAPF  03,W
0006:  CLRF   03
0007:  MOVWF  21
0008:  MOVF   0A,W
0009:  MOVWF  20
000A:  CLRF   0A
000B:  MOVF   04,W
000C:  MOVWF  22
000D:  MOVF   77,W
000E:  MOVWF  23
000F:  MOVF   78,W
0010:  MOVWF  24
0011:  MOVF   79,W
0012:  MOVWF  25
0013:  MOVF   7A,W
0014:  MOVWF  26
0015:  BSF    03.6
0016:  MOVF   0D,W
0017:  BCF    03.6
0018:  MOVWF  27
0019:  BSF    03.6
001A:  MOVF   0F,W
001B:  BCF    03.6
001C:  MOVWF  28
001D:  BSF    03.6
001E:  MOVF   0C,W
001F:  BCF    03.6
0020:  MOVWF  29
0021:  BSF    03.6
0022:  MOVF   0E,W
0023:  BCF    03.6
0024:  MOVWF  2A
0025:  BCF    03.7
0026:  BCF    03.5
0027:  BTFSS  0B.4
0028:  GOTO   02B
0029:  BTFSC  0B.1
002A:  GOTO   052
002B:  MOVLW  8C
002C:  MOVWF  04
002D:  BTFSS  00.5
002E:  GOTO   031
002F:  BTFSC  0C.5
0030:  GOTO   055
0031:  MOVF   22,W
0032:  MOVWF  04
0033:  MOVF   23,W
0034:  MOVWF  77
0035:  MOVF   24,W
0036:  MOVWF  78
0037:  MOVF   25,W
0038:  MOVWF  79
0039:  MOVF   26,W
003A:  MOVWF  7A
003B:  MOVF   27,W
003C:  BSF    03.6
003D:  MOVWF  0D
003E:  BCF    03.6
003F:  MOVF   28,W
0040:  BSF    03.6
0041:  MOVWF  0F
0042:  BCF    03.6
0043:  MOVF   29,W
0044:  BSF    03.6
0045:  MOVWF  0C
0046:  BCF    03.6
0047:  MOVF   2A,W
0048:  BSF    03.6
0049:  MOVWF  0E
004A:  BCF    03.6
004B:  MOVF   20,W
004C:  MOVWF  0A
004D:  SWAPF  21,W
004E:  MOVWF  03
004F:  SWAPF  7F,F
0050:  SWAPF  7F,W
0051:  RETFIE
0052:  BCF    0A.3
0053:  BCF    0A.4
0054:  GOTO   0EF
0055:  BCF    0A.3
0056:  BCF    0A.4
0057:  GOTO   132
....................  
.................... #INCLUDE <thuvien.c> 
.................... #INCLUDE <16F887.H> 
.................... //////////// Standard Header file for the PIC16F887 device //////////////// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2013 Custom Computer Services          //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... #device PIC16F887 
0058:  BCF    0A.0
0059:  BCF    0A.1
005A:  BCF    0A.2
005B:  ADDWF  02,F
005C:  RETLW  30
005D:  RETLW  00
005E:  BCF    0A.0
005F:  BCF    0A.1
0060:  BCF    0A.2
0061:  ADDWF  02,F
0062:  RETLW  5F
0063:  RETLW  00
0064:  BCF    0A.0
0065:  BCF    0A.1
0066:  BCF    0A.2
0067:  ADDWF  02,F
0068:  RETLW  23
0069:  RETLW  00
006A:  BCF    0A.0
006B:  BCF    0A.1
006C:  BCF    0A.2
006D:  ADDWF  02,F
006E:  RETLW  00
006F:  DATA CE,27
0070:  DATA C4,22
0071:  DATA 3A,10
0072:  DATA 00,00
0073:  DATA 30,18
0074:  DATA 30,18
0075:  DATA 20,10
0076:  DATA 20,10
0077:  DATA 20,10
0078:  DATA 20,10
0079:  DATA 20,10
007A:  DATA 00,01
007B:  DATA 20,10
007C:  DATA 20,10
007D:  DATA 20,10
007E:  DATA 5F,10
007F:  DATA 20,10
0080:  DATA 20,10
0081:  DATA 20,10
0082:  DATA 20,10
0083:  DATA 20,10
0084:  DATA 20,10
0085:  DATA 20,00
0086:  DATA 20,10
0087:  DATA 20,10
0088:  DATA 5F,10
0089:  DATA 20,10
008A:  DATA 20,00
008B:  DATA 49,22
008C:  DATA DF,23
008D:  DATA 57,1D
008E:  DATA 00,01
008F:  DATA 30,18
0090:  DATA 30,18
0091:  DATA 30,18
0092:  DATA 20,10
0093:  DATA 20,10
0094:  DATA 20,10
0095:  DATA 20,10
0096:  DATA 00,01
0097:  DATA 20,10
0098:  DATA 20,10
0099:  DATA 20,10
009A:  DATA 5F,10
009B:  DATA 20,10
009C:  DATA 20,10
009D:  DATA 20,10
009E:  DATA 20,10
009F:  DATA 20,10
00A0:  DATA 20,10
00A1:  DATA 20,10
00A2:  DATA 20,00
00A3:  DATA 20,10
00A4:  DATA 20,10
00A5:  DATA 5F,10
00A6:  DATA 20,10
00A7:  DATA 20,10
00A8:  DATA 20,10
00A9:  DATA 20,00
00AA:  DATA C3,27
00AB:  DATA 4E,23
00AC:  DATA C9,23
00AD:  DATA 3A,10
00AE:  DATA 20,10
00AF:  DATA 20,10
00B0:  DATA 20,10
00B1:  DATA 20,00
00B2:  DATA C3,20
00B3:  DATA D3,22
00B4:  DATA 3A,10
00B5:  DATA 20,10
00B6:  DATA 20,10
00B7:  DATA 20,10
00B8:  DATA 20,10
00B9:  DATA 20,00
00BA:  DATA A0,16
00BB:  DATA A0,24
00BC:  DATA C4,16
00BD:  DATA CE,27
00BE:  DATA C4,22
00BF:  DATA 20,10
00C0:  DATA 20,10
00C1:  DATA 20,10
00C2:  DATA 00,01
00C3:  DATA A0,16
00C4:  DATA A0,24
00C5:  DATA C4,16
00C6:  DATA C7,2B
00C7:  DATA 20,10
00C8:  DATA 20,10
00C9:  DATA 20,10
00CA:  DATA 20,00
00CB:  DATA D7,20
00CC:  DATA 49,2A
00CD:  DATA 49,27
00CE:  DATA 47,10
00CF:  DATA 2E,17
00D0:  DATA 2E,17
00D1:  DATA 20,10
00D2:  DATA 20,10
00D3:  DATA 20,10
00D4:  DATA 20,10
00D5:  DATA 00,01
00D6:  DATA D7,20
00D7:  DATA 49,2A
00D8:  DATA 49,27
00D9:  DATA 47,10
00DA:  DATA 2E,17
00DB:  DATA 2E,17
00DC:  DATA 20,10
00DD:  DATA 20,10
00DE:  DATA 20,10
00DF:  DATA 20,10
00E0:  DATA 00,00
00E1:  DATA 20,10
00E2:  DATA 20,10
00E3:  DATA 20,10
00E4:  DATA 20,10
00E5:  DATA 20,10
00E6:  DATA 20,10
00E7:  DATA 00,01
00E8:  DATA 54,21
00E9:  DATA 3A,10
00EA:  DATA 00,01
00EB:  DATA 20,10
00EC:  DATA 20,10
00ED:  DATA 43,21
00EE:  DATA 3A,00
*
014F:  DATA C0,29
0150:  DATA 53,20
0151:  DATA 00,00
0152:  DATA D3,2B
0153:  DATA 3A,10
0154:  DATA 00,00
*
02D5:  BSF    03.6
02D6:  MOVF   14,W
02D7:  ANDLW  07
02D8:  MOVWF  77
02D9:  RRF    14,W
02DA:  MOVWF  78
02DB:  RRF    78,F
02DC:  RRF    78,F
02DD:  MOVLW  1F
02DE:  ANDWF  78,F
02DF:  MOVF   78,W
02E0:  ADDWF  16,W
02E1:  MOVWF  04
02E2:  BCF    03.7
02E3:  BTFSC  17.0
02E4:  BSF    03.7
02E5:  CLRF   78
02E6:  INCF   78,F
02E7:  INCF   77,F
02E8:  GOTO   2EA
02E9:  RLF    78,F
02EA:  DECFSZ 77,F
02EB:  GOTO   2E9
02EC:  MOVF   15,F
02ED:  BTFSC  03.2
02EE:  GOTO   2F2
02EF:  MOVF   78,W
02F0:  IORWF  00,F
02F1:  GOTO   2F5
02F2:  COMF   78,F
02F3:  MOVF   78,W
02F4:  ANDWF  00,F
02F5:  BCF    03.6
02F6:  RETURN
02F7:  BSF    03.6
02F8:  MOVF   14,W
02F9:  ANDLW  07
02FA:  MOVWF  77
02FB:  RRF    14,W
02FC:  MOVWF  78
02FD:  RRF    78,F
02FE:  RRF    78,F
02FF:  MOVLW  1F
0300:  ANDWF  78,F
0301:  MOVF   78,W
0302:  ADDWF  15,W
0303:  MOVWF  04
0304:  BCF    03.7
0305:  BTFSC  16.0
0306:  BSF    03.7
0307:  MOVF   00,W
0308:  MOVWF  78
0309:  INCF   77,F
030A:  GOTO   30C
030B:  RRF    78,F
030C:  DECFSZ 77,F
030D:  GOTO   30B
030E:  BCF    03.6
030F:  RETURN
*
035E:  MOVF   0B,W
035F:  BSF    03.6
0360:  MOVWF  3F
0361:  BCF    03.6
0362:  BCF    0B.7
0363:  BSF    03.5
0364:  BSF    03.6
0365:  BSF    0C.7
0366:  BSF    0C.0
0367:  NOP
0368:  NOP
0369:  BCF    03.5
036A:  BTFSS  3F.7
036B:  GOTO   36F
036C:  BCF    03.6
036D:  BSF    0B.7
036E:  BSF    03.6
036F:  MOVF   0C,W
0370:  ANDLW  7F
0371:  BTFSC  03.2
0372:  GOTO   3AC
0373:  MOVWF  3F
0374:  MOVF   0D,W
0375:  MOVWF  40
0376:  MOVF   0F,W
0377:  MOVWF  41
0378:  MOVF   3F,W
0379:  MOVWF  42
037A:  BCF    03.6
037B:  CALL   324
037C:  BSF    03.6
037D:  MOVF   40,W
037E:  MOVWF  0D
037F:  MOVF   41,W
0380:  MOVWF  0F
0381:  BCF    03.6
0382:  MOVF   0B,W
0383:  BSF    03.6
0384:  MOVWF  42
0385:  BCF    03.6
0386:  BCF    0B.7
0387:  BSF    03.5
0388:  BSF    03.6
0389:  BSF    0C.7
038A:  BSF    0C.0
038B:  NOP
038C:  NOP
038D:  BCF    03.5
038E:  BTFSS  42.7
038F:  GOTO   393
0390:  BCF    03.6
0391:  BSF    0B.7
0392:  BSF    03.6
0393:  RLF    0C,W
0394:  RLF    0E,W
0395:  ANDLW  7F
0396:  BTFSC  03.2
0397:  GOTO   3AC
0398:  MOVWF  3F
0399:  MOVF   0D,W
039A:  MOVWF  40
039B:  MOVF   0F,W
039C:  MOVWF  41
039D:  MOVF   3F,W
039E:  MOVWF  42
039F:  BCF    03.6
03A0:  CALL   324
03A1:  BSF    03.6
03A2:  MOVF   40,W
03A3:  MOVWF  0D
03A4:  MOVF   41,W
03A5:  MOVWF  0F
03A6:  INCF   0D,F
03A7:  BTFSC  03.2
03A8:  INCF   0F,F
03A9:  BCF    03.6
03AA:  GOTO   35E
03AB:  BSF    03.6
03AC:  BCF    03.6
03AD:  RETURN
03AE:  BTFSC  03.1
03AF:  GOTO   3B3
03B0:  MOVLW  60
03B1:  MOVWF  04
03B2:  BSF    03.7
03B3:  BSF    03.6
03B4:  MOVF   5B,W
03B5:  XORWF  5F,W
03B6:  ANDLW  80
03B7:  MOVWF  65
03B8:  BTFSS  5B.7
03B9:  GOTO   3C5
03BA:  COMF   58,F
03BB:  COMF   59,F
03BC:  COMF   5A,F
03BD:  COMF   5B,F
03BE:  INCF   58,F
03BF:  BTFSC  03.2
03C0:  INCF   59,F
03C1:  BTFSC  03.2
03C2:  INCF   5A,F
03C3:  BTFSC  03.2
03C4:  INCF   5B,F
03C5:  BTFSS  5F.7
03C6:  GOTO   3D2
03C7:  COMF   5C,F
03C8:  COMF   5D,F
03C9:  COMF   5E,F
03CA:  COMF   5F,F
03CB:  INCF   5C,F
03CC:  BTFSC  03.2
03CD:  INCF   5D,F
03CE:  BTFSC  03.2
03CF:  INCF   5E,F
03D0:  BTFSC  03.2
03D1:  INCF   5F,F
03D2:  CLRF   77
03D3:  CLRF   78
03D4:  CLRF   79
03D5:  CLRF   7A
03D6:  CLRF   60
03D7:  CLRF   61
03D8:  CLRF   62
03D9:  CLRF   63
03DA:  MOVF   5F,W
03DB:  IORWF  5E,W
03DC:  IORWF  5D,W
03DD:  IORWF  5C,W
03DE:  BTFSC  03.2
03DF:  GOTO   410
03E0:  MOVLW  20
03E1:  MOVWF  64
03E2:  BCF    03.0
03E3:  RLF    58,F
03E4:  RLF    59,F
03E5:  RLF    5A,F
03E6:  RLF    5B,F
03E7:  RLF    60,F
03E8:  RLF    61,F
03E9:  RLF    62,F
03EA:  RLF    63,F
03EB:  MOVF   5F,W
03EC:  SUBWF  63,W
03ED:  BTFSS  03.2
03EE:  GOTO   3F9
03EF:  MOVF   5E,W
03F0:  SUBWF  62,W
03F1:  BTFSS  03.2
03F2:  GOTO   3F9
03F3:  MOVF   5D,W
03F4:  SUBWF  61,W
03F5:  BTFSS  03.2
03F6:  GOTO   3F9
03F7:  MOVF   5C,W
03F8:  SUBWF  60,W
03F9:  BTFSS  03.0
03FA:  GOTO   40A
03FB:  MOVF   5C,W
03FC:  SUBWF  60,F
03FD:  MOVF   5D,W
03FE:  BTFSS  03.0
03FF:  INCFSZ 5D,W
0400:  SUBWF  61,F
0401:  MOVF   5E,W
0402:  BTFSS  03.0
0403:  INCFSZ 5E,W
0404:  SUBWF  62,F
0405:  MOVF   5F,W
0406:  BTFSS  03.0
0407:  INCFSZ 5F,W
0408:  SUBWF  63,F
0409:  BSF    03.0
040A:  RLF    77,F
040B:  RLF    78,F
040C:  RLF    79,F
040D:  RLF    7A,F
040E:  DECFSZ 64,F
040F:  GOTO   3E2
0410:  BTFSS  65.7
0411:  GOTO   41D
0412:  COMF   77,F
0413:  COMF   78,F
0414:  COMF   79,F
0415:  COMF   7A,F
0416:  INCF   77,F
0417:  BTFSC  03.2
0418:  INCF   78,F
0419:  BTFSC  03.2
041A:  INCF   79,F
041B:  BTFSC  03.2
041C:  INCF   7A,F
041D:  MOVF   60,W
041E:  MOVWF  00
041F:  INCF   04,F
0420:  MOVF   61,W
0421:  MOVWF  00
0422:  INCF   04,F
0423:  MOVF   62,W
0424:  MOVWF  00
0425:  INCF   04,F
0426:  MOVF   63,W
0427:  MOVWF  00
0428:  BCF    03.6
0429:  RETURN
*
0443:  MOVLW  20
0444:  MOVWF  5C
0445:  CLRF   58
0446:  CLRF   59
0447:  CLRF   5A
0448:  CLRF   5B
0449:  MOVF   53,W
044A:  MOVWF  7A
044B:  MOVF   52,W
044C:  MOVWF  79
044D:  MOVF   51,W
044E:  MOVWF  78
044F:  MOVF   50,W
0450:  MOVWF  77
0451:  BCF    03.0
0452:  BTFSS  77.0
0453:  GOTO   462
0454:  MOVF   54,W
0455:  ADDWF  58,F
0456:  MOVF   55,W
0457:  BTFSC  03.0
0458:  INCFSZ 55,W
0459:  ADDWF  59,F
045A:  MOVF   56,W
045B:  BTFSC  03.0
045C:  INCFSZ 56,W
045D:  ADDWF  5A,F
045E:  MOVF   57,W
045F:  BTFSC  03.0
0460:  INCFSZ 57,W
0461:  ADDWF  5B,F
0462:  RRF    5B,F
0463:  RRF    5A,F
0464:  RRF    59,F
0465:  RRF    58,F
0466:  RRF    7A,F
0467:  RRF    79,F
0468:  RRF    78,F
0469:  RRF    77,F
046A:  DECFSZ 5C,F
046B:  GOTO   451
*
054A:  MOVF   00,F
054B:  BTFSC  03.2
054C:  GOTO   566
054D:  BSF    03.6
054E:  CLRF   1B
054F:  MOVF   04,W
0550:  MOVWF  1A
0551:  BCF    1B.0
0552:  BTFSC  03.7
0553:  BSF    1B.0
0554:  MOVF   00,W
0555:  MOVWF  42
0556:  BCF    03.6
0557:  CALL   324
0558:  BSF    03.6
0559:  MOVF   1A,W
055A:  MOVWF  04
055B:  BCF    03.7
055C:  BTFSC  1B.0
055D:  BSF    03.7
055E:  INCF   04,F
055F:  BTFSS  03.2
0560:  GOTO   564
0561:  BCF    03.6
0562:  INCF   05,F
0563:  BSF    03.6
0564:  BCF    03.6
0565:  GOTO   54A
0566:  RETURN
0567:  BSF    03.6
0568:  MOVF   17,W
0569:  CLRF   78
056A:  SUBWF  16,W
056B:  BTFSC  03.0
056C:  GOTO   570
056D:  MOVF   16,W
056E:  MOVWF  77
056F:  GOTO   57C
0570:  CLRF   77
0571:  MOVLW  08
0572:  MOVWF  18
0573:  RLF    16,F
0574:  RLF    77,F
0575:  MOVF   17,W
0576:  SUBWF  77,W
0577:  BTFSC  03.0
0578:  MOVWF  77
0579:  RLF    78,F
057A:  DECFSZ 18,F
057B:  GOTO   573
057C:  BCF    03.6
057D:  RETURN
*
07B9:  MOVF   00,F
07BA:  BTFSC  03.2
07BB:  GOTO   7D6
07BC:  BSF    03.6
07BD:  CLRF   42
07BE:  MOVF   04,W
07BF:  MOVWF  41
07C0:  BCF    42.0
07C1:  BTFSC  03.7
07C2:  BSF    42.0
07C3:  MOVF   00,W
07C4:  BCF    03.6
07C5:  BTFSS  0C.4
07C6:  GOTO   7C5
07C7:  MOVWF  19
07C8:  BSF    03.6
07C9:  MOVF   41,W
07CA:  MOVWF  04
07CB:  BCF    03.7
07CC:  BTFSC  42.0
07CD:  BSF    03.7
07CE:  INCF   04,F
07CF:  BTFSS  03.2
07D0:  GOTO   7D4
07D1:  BCF    03.6
07D2:  INCF   05,F
07D3:  BSF    03.6
07D4:  BCF    03.6
07D5:  GOTO   7B9
07D6:  RETURN
*
0A98:  CLRF   77
0A99:  CLRF   78
0A9A:  MOVF   21,W
0A9B:  BCF    03.0
0A9C:  BTFSC  22.0
0A9D:  ADDWF  77,F
0A9E:  RRF    77,F
0A9F:  RRF    78,F
0AA0:  BTFSC  22.1
0AA1:  ADDWF  77,F
0AA2:  RRF    77,F
0AA3:  RRF    78,F
0AA4:  BTFSC  22.2
0AA5:  ADDWF  77,F
0AA6:  RRF    77,F
0AA7:  RRF    78,F
0AA8:  BTFSC  22.3
0AA9:  ADDWF  77,F
0AAA:  RRF    77,F
0AAB:  RRF    78,F
0AAC:  BTFSC  22.4
0AAD:  ADDWF  77,F
0AAE:  RRF    77,F
0AAF:  RRF    78,F
0AB0:  BTFSC  22.5
0AB1:  ADDWF  77,F
0AB2:  RRF    77,F
0AB3:  RRF    78,F
0AB4:  BTFSC  22.6
0AB5:  ADDWF  77,F
0AB6:  RRF    77,F
0AB7:  RRF    78,F
0AB8:  BTFSC  22.7
0AB9:  ADDWF  77,F
0ABA:  RRF    77,F
0ABB:  RRF    78,F
*
0DA8:  BSF    0A.0
0DA9:  BCF    0A.1
0DAA:  BSF    0A.2
0DAB:  ADDWF  02,F
0DAC:  GOTO   418
0DAD:  GOTO   419
0DAE:  GOTO   426
0DAF:  GOTO   433
0DB0:  GOTO   43D
0DB1:  GOTO   447
*
0E2F:  MOVLW  8E
0E30:  MOVWF  77
0E31:  MOVF   1F,W
0E32:  MOVWF  78
0E33:  MOVF   1E,W
0E34:  MOVWF  79
0E35:  CLRF   7A
0E36:  MOVF   78,F
0E37:  BTFSS  03.2
0E38:  GOTO   643
0E39:  MOVF   79,W
0E3A:  MOVWF  78
0E3B:  CLRF   79
0E3C:  MOVLW  08
0E3D:  SUBWF  77,F
0E3E:  MOVF   78,F
0E3F:  BTFSS  03.2
0E40:  GOTO   643
0E41:  CLRF   77
0E42:  GOTO   64B
0E43:  BCF    03.0
0E44:  BTFSC  78.7
0E45:  GOTO   64A
0E46:  RLF    79,F
0E47:  RLF    78,F
0E48:  DECF   77,F
0E49:  GOTO   643
0E4A:  BCF    78.7
*
0E5B:  MOVF   1E,W
0E5C:  BTFSC  03.2
0E5D:  GOTO   720
0E5E:  MOVWF  2A
0E5F:  MOVF   22,W
0E60:  BTFSC  03.2
0E61:  GOTO   720
0E62:  SUBWF  2A,F
0E63:  BTFSS  03.0
0E64:  GOTO   66A
0E65:  MOVLW  7F
0E66:  ADDWF  2A,F
0E67:  BTFSC  03.0
0E68:  GOTO   720
0E69:  GOTO   670
0E6A:  MOVLW  81
0E6B:  SUBWF  2A,F
0E6C:  BTFSS  03.0
0E6D:  GOTO   720
0E6E:  BTFSC  03.2
0E6F:  GOTO   720
0E70:  MOVF   2A,W
0E71:  MOVWF  77
0E72:  CLRF   78
0E73:  CLRF   79
0E74:  CLRF   7A
0E75:  CLRF   29
0E76:  MOVF   1F,W
0E77:  MOVWF  28
0E78:  BSF    28.7
0E79:  MOVF   20,W
0E7A:  MOVWF  27
0E7B:  MOVF   21,W
0E7C:  MOVWF  26
0E7D:  MOVLW  19
0E7E:  MOVWF  2A
0E7F:  MOVF   25,W
0E80:  SUBWF  26,F
0E81:  BTFSC  03.0
0E82:  GOTO   693
0E83:  MOVLW  01
0E84:  SUBWF  27,F
0E85:  BTFSC  03.0
0E86:  GOTO   693
0E87:  SUBWF  28,F
0E88:  BTFSC  03.0
0E89:  GOTO   693
0E8A:  SUBWF  29,F
0E8B:  BTFSC  03.0
0E8C:  GOTO   693
0E8D:  INCF   29,F
0E8E:  INCF   28,F
0E8F:  INCF   27,F
0E90:  MOVF   25,W
0E91:  ADDWF  26,F
0E92:  GOTO   6C5
0E93:  MOVF   24,W
0E94:  SUBWF  27,F
0E95:  BTFSC  03.0
0E96:  GOTO   6AE
0E97:  MOVLW  01
0E98:  SUBWF  28,F
0E99:  BTFSC  03.0
0E9A:  GOTO   6AE
0E9B:  SUBWF  29,F
0E9C:  BTFSC  03.0
0E9D:  GOTO   6AE
0E9E:  INCF   29,F
0E9F:  INCF   28,F
0EA0:  MOVF   24,W
0EA1:  ADDWF  27,F
0EA2:  MOVF   25,W
0EA3:  ADDWF  26,F
0EA4:  BTFSS  03.0
0EA5:  GOTO   6C5
0EA6:  INCF   27,F
0EA7:  BTFSS  03.2
0EA8:  GOTO   6C5
0EA9:  INCF   28,F
0EAA:  BTFSS  03.2
0EAB:  GOTO   6C5
0EAC:  INCF   29,F
0EAD:  GOTO   6C5
0EAE:  MOVF   23,W
0EAF:  IORLW  80
0EB0:  SUBWF  28,F
0EB1:  BTFSC  03.0
0EB2:  GOTO   6C4
0EB3:  MOVLW  01
0EB4:  SUBWF  29,F
0EB5:  BTFSC  03.0
0EB6:  GOTO   6C4
0EB7:  INCF   29,F
0EB8:  MOVF   23,W
0EB9:  IORLW  80
0EBA:  ADDWF  28,F
0EBB:  MOVF   24,W
0EBC:  ADDWF  27,F
0EBD:  BTFSS  03.0
0EBE:  GOTO   6A2
0EBF:  INCF   28,F
0EC0:  BTFSS  03.2
0EC1:  GOTO   6A2
0EC2:  INCF   29,F
0EC3:  GOTO   6A2
0EC4:  BSF    7A.0
0EC5:  DECFSZ 2A,F
0EC6:  GOTO   6C8
0EC7:  GOTO   6D3
0EC8:  BCF    03.0
0EC9:  RLF    26,F
0ECA:  RLF    27,F
0ECB:  RLF    28,F
0ECC:  RLF    29,F
0ECD:  BCF    03.0
0ECE:  RLF    7A,F
0ECF:  RLF    79,F
0ED0:  RLF    78,F
0ED1:  RLF    2B,F
0ED2:  GOTO   67F
0ED3:  BTFSS  2B.0
0ED4:  GOTO   6DB
0ED5:  BCF    03.0
0ED6:  RRF    78,F
0ED7:  RRF    79,F
0ED8:  RRF    7A,F
0ED9:  RRF    2B,F
0EDA:  GOTO   6DE
0EDB:  DECF   77,F
0EDC:  BTFSC  03.2
0EDD:  GOTO   720
0EDE:  BTFSC  2B.7
0EDF:  GOTO   707
0EE0:  BCF    03.0
0EE1:  RLF    26,F
0EE2:  RLF    27,F
0EE3:  RLF    28,F
0EE4:  RLF    29,F
0EE5:  MOVF   25,W
0EE6:  SUBWF  26,F
0EE7:  BTFSC  03.0
0EE8:  GOTO   6F3
0EE9:  MOVLW  01
0EEA:  SUBWF  27,F
0EEB:  BTFSC  03.0
0EEC:  GOTO   6F3
0EED:  SUBWF  28,F
0EEE:  BTFSC  03.0
0EEF:  GOTO   6F3
0EF0:  SUBWF  29,F
0EF1:  BTFSS  03.0
0EF2:  GOTO   716
0EF3:  MOVF   24,W
0EF4:  SUBWF  27,F
0EF5:  BTFSC  03.0
0EF6:  GOTO   6FE
0EF7:  MOVLW  01
0EF8:  SUBWF  28,F
0EF9:  BTFSC  03.0
0EFA:  GOTO   6FE
0EFB:  SUBWF  29,F
0EFC:  BTFSS  03.0
0EFD:  GOTO   716
0EFE:  MOVF   23,W
0EFF:  IORLW  80
0F00:  SUBWF  28,F
0F01:  BTFSC  03.0
0F02:  GOTO   707
0F03:  MOVLW  01
0F04:  SUBWF  29,F
0F05:  BTFSS  03.0
0F06:  GOTO   716
0F07:  INCF   7A,F
0F08:  BTFSS  03.2
0F09:  GOTO   716
0F0A:  INCF   79,F
0F0B:  BTFSS  03.2
0F0C:  GOTO   716
0F0D:  INCF   78,F
0F0E:  BTFSS  03.2
0F0F:  GOTO   716
0F10:  INCF   77,F
0F11:  BTFSC  03.2
0F12:  GOTO   720
0F13:  RRF    78,F
0F14:  RRF    79,F
0F15:  RRF    7A,F
0F16:  MOVF   1F,W
0F17:  MOVWF  2A
0F18:  MOVF   23,W
0F19:  XORWF  2A,F
0F1A:  BTFSS  2A.7
0F1B:  GOTO   71E
0F1C:  BSF    78.7
0F1D:  GOTO   724
0F1E:  BCF    78.7
0F1F:  GOTO   724
0F20:  CLRF   77
0F21:  CLRF   78
0F22:  CLRF   79
0F23:  CLRF   7A
*
0F2C:  MOVLW  8E
0F2D:  MOVWF  77
0F2E:  MOVF   1E,W
0F2F:  SUBWF  77,F
0F30:  MOVF   1F,W
0F31:  MOVWF  79
0F32:  MOVF   20,W
0F33:  MOVWF  78
0F34:  BSF    79.7
0F35:  MOVF   77,F
0F36:  BTFSC  03.2
0F37:  GOTO   743
0F38:  BCF    03.0
0F39:  MOVF   79,F
0F3A:  BTFSS  03.2
0F3B:  GOTO   73F
0F3C:  MOVF   78,F
0F3D:  BTFSC  03.2
0F3E:  GOTO   743
0F3F:  RRF    79,F
0F40:  RRF    78,F
0F41:  DECFSZ 77,F
0F42:  GOTO   738
0F43:  BTFSS  1F.7
0F44:  GOTO   74A
0F45:  COMF   78,F
0F46:  COMF   79,F
0F47:  INCF   78,F
0F48:  BTFSC  03.2
0F49:  INCF   79,F
*
10A7:  BCF    03.6
10A8:  MOVF   0B,W
10A9:  BSF    03.6
10AA:  MOVWF  3D
10AB:  BCF    03.6
10AC:  BCF    0B.7
10AD:  BSF    03.5
10AE:  BSF    03.6
10AF:  BSF    0C.7
10B0:  BSF    0C.0
10B1:  NOP
10B2:  NOP
10B3:  BCF    03.5
10B4:  BTFSS  3D.7
10B5:  GOTO   0B9
10B6:  BCF    03.6
10B7:  BSF    0B.7
10B8:  BSF    03.6
10B9:  MOVF   0C,W
10BA:  ANDLW  7F
10BB:  BTFSC  03.2
10BC:  GOTO   0F6
10BD:  MOVWF  3D
10BE:  MOVF   0D,W
10BF:  MOVWF  3E
10C0:  MOVF   0F,W
10C1:  MOVWF  3F
10C2:  MOVF   3D,W
10C3:  BCF    03.6
10C4:  BTFSS  0C.4
10C5:  GOTO   0C4
10C6:  MOVWF  19
10C7:  BSF    03.6
10C8:  MOVF   3E,W
10C9:  MOVWF  0D
10CA:  MOVF   3F,W
10CB:  MOVWF  0F
10CC:  BCF    03.6
10CD:  MOVF   0B,W
10CE:  BSF    03.6
10CF:  MOVWF  40
10D0:  BCF    03.6
10D1:  BCF    0B.7
10D2:  BSF    03.5
10D3:  BSF    03.6
10D4:  BSF    0C.7
10D5:  BSF    0C.0
10D6:  NOP
10D7:  NOP
10D8:  BCF    03.5
10D9:  BTFSS  40.7
10DA:  GOTO   0DE
10DB:  BCF    03.6
10DC:  BSF    0B.7
10DD:  BSF    03.6
10DE:  RLF    0C,W
10DF:  RLF    0E,W
10E0:  ANDLW  7F
10E1:  BTFSC  03.2
10E2:  GOTO   0F6
10E3:  MOVWF  3D
10E4:  MOVF   0D,W
10E5:  MOVWF  3E
10E6:  MOVF   0F,W
10E7:  MOVWF  3F
10E8:  MOVF   3D,W
10E9:  BCF    03.6
10EA:  BTFSS  0C.4
10EB:  GOTO   0EA
10EC:  MOVWF  19
10ED:  BSF    03.6
10EE:  MOVF   3E,W
10EF:  MOVWF  0D
10F0:  MOVF   3F,W
10F1:  MOVWF  0F
10F2:  INCF   0D,F
10F3:  BTFSC  03.2
10F4:  INCF   0F,F
10F5:  GOTO   0A7
....................  
.................... #list 
....................  
.................... #DEVICE ADC=10 
.................... #INCLUDE <STRING.H> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
*
077B:  BSF    03.6
077C:  MOVF   41,W
077D:  MOVWF  45
077E:  MOVF   40,W
077F:  MOVWF  44
0780:  MOVF   45,W
0781:  MOVWF  7A
0782:  MOVF   44,W
0783:  MOVWF  04
0784:  BCF    03.7
0785:  BTFSC  7A.0
0786:  BSF    03.7
0787:  MOVF   00,F
0788:  BTFSC  03.2
0789:  GOTO   78E
078A:  INCF   44,F
078B:  BTFSC  03.2
078C:  INCF   45,F
078D:  GOTO   780
....................    while(*s2 != '\0') 
078E:  MOVF   43,W
078F:  MOVWF  7A
0790:  MOVF   42,W
0791:  MOVWF  04
0792:  BCF    03.7
0793:  BTFSC  7A.0
0794:  BSF    03.7
0795:  MOVF   00,F
0796:  BTFSC  03.2
0797:  GOTO   7AD
....................    { 
....................       *s = *s2; 
0798:  MOVF   42,W
0799:  MOVWF  04
079A:  BCF    03.7
079B:  BTFSC  43.0
079C:  BSF    03.7
079D:  MOVF   00,W
079E:  MOVWF  48
079F:  MOVF   44,W
07A0:  MOVWF  04
07A1:  BCF    03.7
07A2:  BTFSC  45.0
07A3:  BSF    03.7
07A4:  MOVF   48,W
07A5:  MOVWF  00
....................       ++s; 
07A6:  INCF   44,F
07A7:  BTFSC  03.2
07A8:  INCF   45,F
....................       ++s2; 
07A9:  INCF   42,F
07AA:  BTFSC  03.2
07AB:  INCF   43,F
07AC:  GOTO   78E
....................    } 
....................  
....................    *s = '\0'; 
07AD:  MOVF   44,W
07AE:  MOVWF  04
07AF:  BCF    03.7
07B0:  BTFSC  45.0
07B1:  BSF    03.7
07B2:  CLRF   00
....................    return(s1); 
07B3:  MOVF   40,W
07B4:  MOVWF  78
07B5:  MOVF   41,W
07B6:  MOVWF  79
07B7:  BCF    03.6
07B8:  RETURN
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
*
0B2B:  BSF    03.6
0B2C:  MOVF   19,W
0B2D:  MOVWF  7A
0B2E:  MOVF   18,W
0B2F:  MOVWF  04
0B30:  BCF    03.7
0B31:  BTFSC  7A.0
0B32:  BSF    03.7
0B33:  MOVF   00,W
0B34:  MOVWF  1C
0B35:  MOVF   1B,W
0B36:  MOVWF  7A
0B37:  MOVF   1A,W
0B38:  MOVWF  04
0B39:  BCF    03.7
0B3A:  BTFSC  7A.0
0B3B:  BSF    03.7
0B3C:  MOVF   00,W
0B3D:  SUBWF  1C,W
0B3E:  BTFSS  03.2
0B3F:  GOTO   357
....................       if (*s1 == '\0') 
0B40:  MOVF   19,W
0B41:  MOVWF  7A
0B42:  MOVF   18,W
0B43:  MOVWF  04
0B44:  BCF    03.7
0B45:  BTFSC  7A.0
0B46:  BSF    03.7
0B47:  MOVF   00,F
0B48:  BTFSS  03.2
0B49:  GOTO   34D
....................          return(0); 
0B4A:  MOVLW  00
0B4B:  MOVWF  78
0B4C:  GOTO   36F
0B4D:  MOVF   19,W
0B4E:  MOVWF  7A
0B4F:  MOVF   18,W
0B50:  INCF   18,F
0B51:  BTFSC  03.2
0B52:  INCF   19,F
0B53:  INCF   1A,F
0B54:  BTFSC  03.2
0B55:  INCF   1B,F
0B56:  GOTO   32C
....................    return((*s1 < *s2) ? -1: 1); 
0B57:  MOVF   19,W
0B58:  MOVWF  7A
0B59:  MOVF   18,W
0B5A:  MOVWF  04
0B5B:  BCF    03.7
0B5C:  BTFSC  19.0
0B5D:  BSF    03.7
0B5E:  MOVF   00,W
0B5F:  MOVWF  1C
0B60:  MOVF   1B,W
0B61:  MOVWF  7A
0B62:  MOVF   1A,W
0B63:  MOVWF  04
0B64:  BCF    03.7
0B65:  BTFSC  1B.0
0B66:  BSF    03.7
0B67:  MOVF   00,W
0B68:  SUBWF  1C,W
0B69:  BTFSC  03.0
0B6A:  GOTO   36D
0B6B:  MOVLW  FF
0B6C:  GOTO   36E
0B6D:  MOVLW  01
0B6E:  MOVWF  78
0B6F:  BCF    03.6
0B70:  RETURN
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
*
0B9D:  MOVF   19,W
0B9E:  MOVWF  7A
0B9F:  MOVF   18,W
0BA0:  MOVWF  04
0BA1:  BCF    03.7
0BA2:  BTFSC  7A.0
0BA3:  BSF    03.7
0BA4:  MOVF   1A,W
0BA5:  SUBWF  00,W
0BA6:  BTFSC  03.2
0BA7:  GOTO   3BA
....................       if (*s == '\0') 
0BA8:  MOVF   19,W
0BA9:  MOVWF  7A
0BAA:  MOVF   18,W
0BAB:  MOVWF  04
0BAC:  BCF    03.7
0BAD:  BTFSC  7A.0
0BAE:  BSF    03.7
0BAF:  MOVF   00,F
0BB0:  BTFSS  03.2
0BB1:  GOTO   3B6
....................          return(0); 
0BB2:  MOVLW  00
0BB3:  MOVWF  78
0BB4:  MOVWF  79
0BB5:  GOTO   3BE
0BB6:  INCF   18,F
0BB7:  BTFSC  03.2
0BB8:  INCF   19,F
0BB9:  GOTO   39D
....................    return(s); 
0BBA:  MOVF   18,W
0BBB:  MOVWF  78
0BBC:  MOVF   19,W
0BBD:  MOVWF  79
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
*
09C4:  MOVF   23,W
09C5:  MOVWF  27
09C6:  MOVF   22,W
09C7:  MOVWF  26
09C8:  MOVF   27,W
09C9:  MOVWF  7A
09CA:  MOVF   26,W
09CB:  MOVWF  04
09CC:  BCF    03.7
09CD:  BTFSC  7A.0
09CE:  BSF    03.7
09CF:  MOVF   00,F
09D0:  BTFSC  03.2
09D1:  GOTO   201
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
09D2:  MOVF   25,W
09D3:  MOVWF  29
09D4:  MOVF   24,W
09D5:  MOVWF  28
09D6:  MOVF   29,W
09D7:  MOVWF  7A
09D8:  MOVF   28,W
09D9:  MOVWF  04
09DA:  BCF    03.7
09DB:  BTFSC  7A.0
09DC:  BSF    03.7
09DD:  MOVF   00,F
09DE:  BTFSC  03.2
09DF:  GOTO   1FD
....................          if (*sc1 == *sc2) 
09E0:  MOVF   27,W
09E1:  MOVWF  7A
09E2:  MOVF   26,W
09E3:  MOVWF  04
09E4:  BCF    03.7
09E5:  BTFSC  7A.0
09E6:  BSF    03.7
09E7:  MOVF   00,W
09E8:  MOVWF  2A
09E9:  MOVF   29,W
09EA:  MOVWF  7A
09EB:  MOVF   28,W
09EC:  MOVWF  04
09ED:  BCF    03.7
09EE:  BTFSC  7A.0
09EF:  BSF    03.7
09F0:  MOVF   00,W
09F1:  SUBWF  2A,W
09F2:  BTFSS  03.2
09F3:  GOTO   1F9
....................             return(sc1); 
09F4:  MOVF   26,W
09F5:  MOVWF  78
09F6:  MOVF   27,W
09F7:  MOVWF  79
09F8:  GOTO   204
09F9:  INCF   28,F
09FA:  BTFSC  03.2
09FB:  INCF   29,F
09FC:  GOTO   1D6
09FD:  INCF   26,F
09FE:  BTFSC  03.2
09FF:  INCF   27,F
0A00:  GOTO   1C8
....................    return(0); 
0A01:  MOVLW  00
0A02:  MOVWF  78
0A03:  MOVWF  79
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
*
0951:  MOVF   23,W
0952:  MOVWF  27
0953:  MOVF   22,W
0954:  MOVWF  26
0955:  MOVF   27,W
0956:  MOVWF  7A
0957:  MOVF   26,W
0958:  MOVWF  04
0959:  BCF    03.7
095A:  BTFSC  7A.0
095B:  BSF    03.7
095C:  MOVF   00,F
095D:  BTFSC  03.2
095E:  GOTO   196
....................       for (sc2 = s2; ; sc2++) 
095F:  MOVF   25,W
0960:  MOVWF  29
0961:  MOVF   24,W
0962:  MOVWF  28
....................     if (*sc2 == '\0') 
0963:  MOVF   29,W
0964:  MOVWF  7A
0965:  MOVF   28,W
0966:  MOVWF  04
0967:  BCF    03.7
0968:  BTFSC  7A.0
0969:  BSF    03.7
096A:  MOVF   00,F
096B:  BTFSS  03.2
096C:  GOTO   17A
....................        return(sc1 - s1); 
096D:  MOVF   22,W
096E:  SUBWF  26,W
096F:  MOVWF  77
0970:  MOVF   27,W
0971:  MOVWF  7A
0972:  MOVF   23,W
0973:  BTFSS  03.0
0974:  INCFSZ 23,W
0975:  SUBWF  7A,F
0976:  MOVF   77,W
0977:  MOVWF  78
0978:  GOTO   1A1
0979:  GOTO   18E
....................          else if (*sc1 == *sc2) 
097A:  MOVF   27,W
097B:  MOVWF  7A
097C:  MOVF   26,W
097D:  MOVWF  04
097E:  BCF    03.7
097F:  BTFSC  7A.0
0980:  BSF    03.7
0981:  MOVF   00,W
0982:  MOVWF  2A
0983:  MOVF   29,W
0984:  MOVWF  7A
0985:  MOVF   28,W
0986:  MOVWF  04
0987:  BCF    03.7
0988:  BTFSC  7A.0
0989:  BSF    03.7
098A:  MOVF   00,W
098B:  SUBWF  2A,W
098C:  BTFSC  03.2
....................             break; 
098D:  GOTO   192
098E:  INCF   28,F
098F:  BTFSC  03.2
0990:  INCF   29,F
0991:  GOTO   163
0992:  INCF   26,F
0993:  BTFSC  03.2
0994:  INCF   27,F
0995:  GOTO   155
....................    return(sc1 - s1); 
0996:  MOVF   22,W
0997:  SUBWF  26,W
0998:  MOVWF  77
0999:  MOVF   27,W
099A:  MOVWF  7A
099B:  MOVF   23,W
099C:  BTFSS  03.0
099D:  INCFSZ 23,W
099E:  SUBWF  7A,F
099F:  MOVF   77,W
09A0:  MOVWF  78
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
*
115D:  BCF    03.6
115E:  CLRF   2B
115F:  CLRF   2C
....................  
....................    beg = (s1)? s1: save; 
*
0938:  BSF    03.6
0939:  MOVF   1A,W
093A:  IORWF  1B,W
093B:  BTFSC  03.2
093C:  GOTO   141
093D:  MOVF   1B,W
093E:  MOVWF  7A
093F:  MOVF   1A,W
0940:  GOTO   146
0941:  BCF    03.6
0942:  MOVF   2C,W
0943:  MOVWF  7A
0944:  MOVF   2B,W
0945:  BSF    03.6
0946:  MOVWF  1E
0947:  MOVF   7A,W
0948:  MOVWF  1F
....................    beg += strspn(beg, s2); 
0949:  MOVF   1F,W
094A:  MOVWF  23
094B:  MOVF   1E,W
094C:  MOVWF  22
094D:  MOVF   1D,W
094E:  MOVWF  25
094F:  MOVF   1C,W
0950:  MOVWF  24
*
09A1:  MOVF   78,W
09A2:  ADDWF  1E,F
09A3:  BTFSC  03.0
09A4:  INCF   1F,F
....................    if (*beg == '\0') 
09A5:  MOVF   1F,W
09A6:  MOVWF  7A
09A7:  MOVF   1E,W
09A8:  MOVWF  04
09A9:  BCF    03.7
09AA:  BTFSC  7A.0
09AB:  BSF    03.7
09AC:  MOVF   00,F
09AD:  BTFSS  03.2
09AE:  GOTO   1BC
....................    { 
....................       *save = ' '; 
09AF:  BCF    03.6
09B0:  MOVF   2B,W
09B1:  MOVWF  04
09B2:  BCF    03.7
09B3:  BTFSC  2C.0
09B4:  BSF    03.7
09B5:  MOVLW  20
09B6:  MOVWF  00
....................       return(0); 
09B7:  MOVLW  00
09B8:  MOVWF  78
09B9:  MOVWF  79
09BA:  GOTO   228
09BB:  BSF    03.6
....................    } 
....................    end = strpbrk(beg, s2); 
09BC:  MOVF   1F,W
09BD:  MOVWF  23
09BE:  MOVF   1E,W
09BF:  MOVWF  22
09C0:  MOVF   1D,W
09C1:  MOVWF  25
09C2:  MOVF   1C,W
09C3:  MOVWF  24
*
0A04:  MOVF   79,W
0A05:  MOVWF  21
0A06:  MOVF   78,W
0A07:  MOVWF  20
....................    if (*end != '\0') 
0A08:  MOVF   21,W
0A09:  MOVWF  7A
0A0A:  MOVF   20,W
0A0B:  MOVWF  04
0A0C:  BCF    03.7
0A0D:  BTFSC  7A.0
0A0E:  BSF    03.7
0A0F:  MOVF   00,F
0A10:  BTFSC  03.2
0A11:  GOTO   21B
....................    { 
....................       *end = '\0'; 
0A12:  MOVF   20,W
0A13:  MOVWF  04
0A14:  BCF    03.7
0A15:  BTFSC  21.0
0A16:  BSF    03.7
0A17:  CLRF   00
....................       end++; 
0A18:  INCF   20,F
0A19:  BTFSC  03.2
0A1A:  INCF   21,F
....................    } 
....................    save = end; 
0A1B:  MOVF   21,W
0A1C:  BCF    03.6
0A1D:  MOVWF  2C
0A1E:  BSF    03.6
0A1F:  MOVF   20,W
0A20:  BCF    03.6
0A21:  MOVWF  2B
....................    return(beg); 
0A22:  BSF    03.6
0A23:  MOVF   1E,W
0A24:  MOVWF  78
0A25:  MOVF   1F,W
0A26:  MOVWF  79
0A27:  BCF    03.6
0A28:  RETURN
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
*
0BC6:  MOVF   19,W
0BC7:  MOVWF  1B
0BC8:  MOVF   18,W
0BC9:  MOVWF  1A
0BCA:  MOVF   1B,W
0BCB:  MOVWF  7A
0BCC:  MOVF   1A,W
0BCD:  MOVWF  04
0BCE:  BCF    03.7
0BCF:  BTFSC  7A.0
0BD0:  BSF    03.7
0BD1:  MOVF   00,F
0BD2:  BTFSC  03.2
0BD3:  GOTO   3D8
0BD4:  INCF   1A,F
0BD5:  BTFSC  03.2
0BD6:  INCF   1B,F
0BD7:  GOTO   3CA
....................    return(sc - s); 
0BD8:  MOVF   18,W
0BD9:  SUBWF  1A,W
0BDA:  MOVWF  77
0BDB:  MOVF   1B,W
0BDC:  MOVWF  7A
0BDD:  MOVF   19,W
0BDE:  BTFSS  03.0
0BDF:  INCFSZ 19,W
0BE0:  SUBWF  7A,F
0BE1:  MOVF   77,W
0BE2:  MOVWF  78
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #INCLUDE <STDLIB.H> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... /* Standart template: float strtof(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... float strtof(char *s,char *endptr); 
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s,char *endptr); 
.................... float64 strtod(char *s,char *endptr); 
.................... #else 
.................... //provided for compatibility 
.................... #define strtof48(s, e) strtof(s, e) 
.................... #define strtod(s, e) strtof(s, e) 
.................... #endif 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof(s)   strtof(s, 0) 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof48(s) strtof48(s, 0) 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof64(s) strtod(s, 0) 
.................... #endif 
....................  
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float atoe(char * s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s); 
.................... #endif 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... unsigned int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................  
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
*
0A29:  BSF    03.6
0A2A:  CLRF   1F
....................    sign = 0; 
0A2B:  CLRF   1D
....................    base = 10; 
0A2C:  MOVLW  0A
0A2D:  MOVWF  1E
....................    result = 0; 
0A2E:  CLRF   1C
....................  
....................    if (!s) 
0A2F:  MOVF   1A,W
0A30:  IORWF  1B,W
0A31:  BTFSS  03.2
0A32:  GOTO   236
....................       return 0; 
0A33:  MOVLW  00
0A34:  MOVWF  78
0A35:  GOTO   329
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
0A36:  MOVF   1F,W
0A37:  INCF   1F,F
0A38:  ADDWF  1A,W
0A39:  MOVWF  04
0A3A:  BCF    03.7
0A3B:  BTFSC  1B.0
0A3C:  BSF    03.7
0A3D:  MOVF   00,W
0A3E:  MOVWF  20
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
0A3F:  MOVF   20,W
0A40:  SUBLW  2D
0A41:  BTFSS  03.2
0A42:  GOTO   24F
....................    { 
....................       sign = 1;         // Set the sign to negative 
0A43:  MOVLW  01
0A44:  MOVWF  1D
....................       c = s[index++]; 
0A45:  MOVF   1F,W
0A46:  INCF   1F,F
0A47:  ADDWF  1A,W
0A48:  MOVWF  04
0A49:  BCF    03.7
0A4A:  BTFSC  1B.0
0A4B:  BSF    03.7
0A4C:  MOVF   00,W
0A4D:  MOVWF  20
....................    } 
0A4E:  GOTO   25C
....................    else if (c == '+') 
0A4F:  MOVF   20,W
0A50:  SUBLW  2B
0A51:  BTFSS  03.2
0A52:  GOTO   25C
....................    { 
....................       c = s[index++]; 
0A53:  MOVF   1F,W
0A54:  INCF   1F,F
0A55:  ADDWF  1A,W
0A56:  MOVWF  04
0A57:  BCF    03.7
0A58:  BTFSC  1B.0
0A59:  BSF    03.7
0A5A:  MOVF   00,W
0A5B:  MOVWF  20
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
0A5C:  MOVF   20,W
0A5D:  SUBLW  2F
0A5E:  BTFSC  03.0
0A5F:  GOTO   31F
0A60:  MOVF   20,W
0A61:  SUBLW  39
0A62:  BTFSS  03.0
0A63:  GOTO   31F
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
0A64:  MOVF   20,W
0A65:  SUBLW  30
0A66:  BTFSS  03.2
0A67:  GOTO   288
0A68:  MOVF   1F,W
0A69:  ADDWF  1A,W
0A6A:  MOVWF  04
0A6B:  BCF    03.7
0A6C:  BTFSC  1B.0
0A6D:  BSF    03.7
0A6E:  MOVF   00,W
0A6F:  SUBLW  78
0A70:  BTFSC  03.2
0A71:  GOTO   27C
0A72:  MOVF   1F,W
0A73:  ADDWF  1A,W
0A74:  MOVWF  04
0A75:  BCF    03.7
0A76:  BTFSC  1B.0
0A77:  BSF    03.7
0A78:  MOVF   00,W
0A79:  SUBLW  58
0A7A:  BTFSS  03.2
0A7B:  GOTO   288
....................       { 
....................          base = 16; 
0A7C:  MOVLW  10
0A7D:  MOVWF  1E
....................          index++; 
0A7E:  INCF   1F,F
....................          c = s[index++]; 
0A7F:  MOVF   1F,W
0A80:  INCF   1F,F
0A81:  ADDWF  1A,W
0A82:  MOVWF  04
0A83:  BCF    03.7
0A84:  BTFSC  1B.0
0A85:  BSF    03.7
0A86:  MOVF   00,W
0A87:  MOVWF  20
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
0A88:  MOVF   1E,W
0A89:  SUBLW  0A
0A8A:  BTFSS  03.2
0A8B:  GOTO   2CD
....................       { 
....................          while (c >= '0' && c <= '9') 
0A8C:  MOVF   20,W
0A8D:  SUBLW  2F
0A8E:  BTFSC  03.0
0A8F:  GOTO   2CC
0A90:  MOVF   20,W
0A91:  SUBLW  39
0A92:  BTFSS  03.0
0A93:  GOTO   2CC
....................          { 
....................             result = 10*result + (c - '0'); 
0A94:  MOVLW  0A
0A95:  MOVWF  21
0A96:  MOVF   1C,W
0A97:  MOVWF  22
*
0ABC:  MOVF   78,W
0ABD:  MOVWF  21
0ABE:  MOVLW  30
0ABF:  SUBWF  20,W
0AC0:  ADDWF  21,W
0AC1:  MOVWF  1C
....................             c = s[index++]; 
0AC2:  MOVF   1F,W
0AC3:  INCF   1F,F
0AC4:  ADDWF  1A,W
0AC5:  MOVWF  04
0AC6:  BCF    03.7
0AC7:  BTFSC  1B.0
0AC8:  BSF    03.7
0AC9:  MOVF   00,W
0ACA:  MOVWF  20
0ACB:  GOTO   28C
....................          } 
....................       } 
0ACC:  GOTO   31F
....................       else if (base == 16)    // The number is a hexa number 
0ACD:  MOVF   1E,W
0ACE:  SUBLW  10
0ACF:  BTFSS  03.2
0AD0:  GOTO   31F
....................       { 
....................          c = toupper(c); 
0AD1:  MOVF   20,W
0AD2:  SUBLW  60
0AD3:  BTFSC  03.0
0AD4:  GOTO   2DC
0AD5:  MOVF   20,W
0AD6:  SUBLW  7A
0AD7:  BTFSS  03.0
0AD8:  GOTO   2DC
0AD9:  MOVF   20,W
0ADA:  ANDLW  DF
0ADB:  GOTO   2DD
0ADC:  MOVF   20,W
0ADD:  MOVWF  20
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
0ADE:  MOVF   20,W
0ADF:  SUBLW  2F
0AE0:  BTFSC  03.0
0AE1:  GOTO   2E6
0AE2:  MOVF   20,W
0AE3:  SUBLW  39
0AE4:  BTFSC  03.0
0AE5:  GOTO   2EE
0AE6:  MOVF   20,W
0AE7:  SUBLW  40
0AE8:  BTFSC  03.0
0AE9:  GOTO   31F
0AEA:  MOVF   20,W
0AEB:  SUBLW  46
0AEC:  BTFSS  03.0
0AED:  GOTO   31F
....................          { 
....................             if (c >= '0' && c <= '9') 
0AEE:  MOVF   20,W
0AEF:  SUBLW  2F
0AF0:  BTFSC  03.0
0AF1:  GOTO   2FF
0AF2:  MOVF   20,W
0AF3:  SUBLW  39
0AF4:  BTFSS  03.0
0AF5:  GOTO   2FF
....................                result = (result << 4) + (c - '0'); 
0AF6:  SWAPF  1C,W
0AF7:  MOVWF  21
0AF8:  MOVLW  F0
0AF9:  ANDWF  21,F
0AFA:  MOVLW  30
0AFB:  SUBWF  20,W
0AFC:  ADDWF  21,W
0AFD:  MOVWF  1C
0AFE:  GOTO   308
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
0AFF:  SWAPF  1C,W
0B00:  MOVWF  21
0B01:  MOVLW  F0
0B02:  ANDWF  21,F
0B03:  MOVLW  41
0B04:  SUBWF  20,W
0B05:  ADDLW  0A
0B06:  ADDWF  21,W
0B07:  MOVWF  1C
....................  
....................             c = s[index++]; 
0B08:  MOVF   1F,W
0B09:  INCF   1F,F
0B0A:  ADDWF  1A,W
0B0B:  MOVWF  04
0B0C:  BCF    03.7
0B0D:  BTFSC  1B.0
0B0E:  BSF    03.7
0B0F:  MOVF   00,W
0B10:  MOVWF  20
....................             c = toupper(c); 
0B11:  MOVF   20,W
0B12:  SUBLW  60
0B13:  BTFSC  03.0
0B14:  GOTO   31C
0B15:  MOVF   20,W
0B16:  SUBLW  7A
0B17:  BTFSS  03.0
0B18:  GOTO   31C
0B19:  MOVF   20,W
0B1A:  ANDLW  DF
0B1B:  GOTO   31D
0B1C:  MOVF   20,W
0B1D:  MOVWF  20
0B1E:  GOTO   2DE
....................          } 
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
0B1F:  DECFSZ 1D,W
0B20:  GOTO   327
0B21:  MOVF   1E,W
0B22:  SUBLW  0A
0B23:  BTFSS  03.2
0B24:  GOTO   327
....................        result = -result; 
0B25:  COMF   1C,F
0B26:  INCF   1C,F
....................  
....................    return(result); 
0B27:  MOVF   1C,W
0B28:  MOVWF  78
0B29:  BCF    03.6
0B2A:  RETURN
.................... } 
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
*
042A:  BSF    03.6
042B:  CLRF   4B
042C:  CLRF   4A
042D:  CLRF   49
042E:  MOVLW  01
042F:  MOVWF  48
0430:  CLRF   4D
0431:  CLRF   4E
.................... { 
....................      unsigned int32 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
0432:  BTFSS  44.7
0433:  GOTO   474
....................          sign=1;        // Check for negative number 
0434:  MOVLW  01
0435:  MOVWF  4D
....................          num*=-1; 
0436:  MOVF   44,W
0437:  MOVWF  53
0438:  MOVF   43,W
0439:  MOVWF  52
043A:  MOVF   42,W
043B:  MOVWF  51
043C:  MOVF   41,W
043D:  MOVWF  50
043E:  MOVLW  FF
043F:  MOVWF  57
0440:  MOVWF  56
0441:  MOVWF  55
0442:  MOVWF  54
*
046C:  MOVF   7A,W
046D:  MOVWF  44
046E:  MOVF   79,W
046F:  MOVWF  43
0470:  MOVF   78,W
0471:  MOVWF  42
0472:  MOVF   77,W
0473:  MOVWF  41
....................      } 
....................  
....................      while(temp>0) { 
0474:  MOVF   48,F
0475:  BTFSS  03.2
0476:  GOTO   480
0477:  MOVF   49,F
0478:  BTFSS  03.2
0479:  GOTO   480
047A:  MOVF   4A,F
047B:  BTFSS  03.2
047C:  GOTO   480
047D:  MOVF   4B,F
047E:  BTFSC  03.2
047F:  GOTO   4FC
....................          temp=(num/base); 
0480:  BCF    03.1
0481:  MOVF   44,W
0482:  MOVWF  5B
0483:  MOVF   43,W
0484:  MOVWF  5A
0485:  MOVF   42,W
0486:  MOVWF  59
0487:  MOVF   41,W
0488:  MOVWF  58
0489:  CLRF   5F
048A:  CLRF   5E
048B:  CLRF   5D
048C:  MOVF   45,W
048D:  MOVWF  5C
048E:  BCF    03.6
048F:  CALL   3AE
0490:  MOVF   7A,W
0491:  BSF    03.6
0492:  MOVWF  4B
0493:  MOVF   79,W
0494:  MOVWF  4A
0495:  MOVF   78,W
0496:  MOVWF  49
0497:  MOVF   77,W
0498:  MOVWF  48
....................          s[cnt]=(num%base)+'0';    // Conversion 
0499:  MOVF   4E,W
049A:  ADDWF  46,W
049B:  MOVWF  78
049C:  MOVF   47,W
049D:  MOVWF  7A
049E:  BTFSC  03.0
049F:  INCF   7A,F
04A0:  MOVF   78,W
04A1:  MOVWF  50
04A2:  MOVF   7A,W
04A3:  MOVWF  51
04A4:  CLRF   53
04A5:  MOVF   04,W
04A6:  MOVWF  52
04A7:  BCF    53.0
04A8:  BTFSC  03.7
04A9:  BSF    53.0
04AA:  BSF    03.1
04AB:  MOVLW  54
04AC:  MOVWF  04
04AD:  BSF    03.7
04AE:  MOVF   44,W
04AF:  MOVWF  5B
04B0:  MOVF   43,W
04B1:  MOVWF  5A
04B2:  MOVF   42,W
04B3:  MOVWF  59
04B4:  MOVF   41,W
04B5:  MOVWF  58
04B6:  CLRF   5F
04B7:  CLRF   5E
04B8:  CLRF   5D
04B9:  MOVF   45,W
04BA:  MOVWF  5C
04BB:  BCF    03.6
04BC:  CALL   3AE
04BD:  BSF    03.6
04BE:  MOVF   52,W
04BF:  MOVWF  04
04C0:  BCF    03.7
04C1:  BTFSC  53.0
04C2:  BSF    03.7
04C3:  MOVLW  30
04C4:  ADDWF  54,W
04C5:  MOVWF  77
04C6:  MOVF   55,W
04C7:  MOVWF  78
04C8:  MOVLW  00
04C9:  BTFSC  03.0
04CA:  MOVLW  01
04CB:  ADDWF  78,F
04CC:  MOVF   56,W
04CD:  MOVWF  79
04CE:  MOVLW  00
04CF:  BTFSC  03.0
04D0:  MOVLW  01
04D1:  ADDWF  79,F
04D2:  MOVF   57,W
04D3:  MOVWF  7A
04D4:  MOVLW  00
04D5:  BTFSC  03.0
04D6:  MOVLW  01
04D7:  ADDWF  7A,F
04D8:  MOVF   50,W
04D9:  MOVWF  04
04DA:  BCF    03.7
04DB:  BTFSC  51.0
04DC:  BSF    03.7
04DD:  MOVF   77,W
04DE:  MOVWF  00
....................  
....................          if(s[cnt]>0x39) 
04DF:  MOVF   4E,W
04E0:  ADDWF  46,W
04E1:  MOVWF  04
04E2:  BCF    03.7
04E3:  BTFSC  47.0
04E4:  BSF    03.7
04E5:  MOVF   00,W
04E6:  SUBLW  39
04E7:  BTFSC  03.0
04E8:  GOTO   4F2
....................             s[cnt]+=0x7; 
04E9:  MOVF   4E,W
04EA:  ADDWF  46,W
04EB:  MOVWF  04
04EC:  BCF    03.7
04ED:  BTFSC  47.0
04EE:  BSF    03.7
04EF:  MOVLW  07
04F0:  ADDWF  00,W
04F1:  MOVWF  00
....................  
....................          cnt++; 
04F2:  INCF   4E,F
....................          num=temp; 
04F3:  MOVF   4B,W
04F4:  MOVWF  44
04F5:  MOVF   4A,W
04F6:  MOVWF  43
04F7:  MOVF   49,W
04F8:  MOVWF  42
04F9:  MOVF   48,W
04FA:  MOVWF  41
04FB:  GOTO   474
....................      } 
....................  
....................      if(sign==1) { 
04FC:  DECFSZ 4D,W
04FD:  GOTO   507
....................          s[cnt]=0x2D;      // Negative sign 
04FE:  MOVF   4E,W
04FF:  ADDWF  46,W
0500:  MOVWF  04
0501:  BCF    03.7
0502:  BTFSC  47.0
0503:  BSF    03.7
0504:  MOVLW  2D
0505:  MOVWF  00
....................          cnt++; 
0506:  INCF   4E,F
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
0507:  CLRF   4C
0508:  BCF    03.0
0509:  RRF    4E,W
050A:  SUBWF  4C,W
050B:  BTFSC  03.0
050C:  GOTO   53D
....................  
....................          c=s[i]; 
050D:  MOVF   4C,W
050E:  ADDWF  46,W
050F:  MOVWF  04
0510:  BCF    03.7
0511:  BTFSC  47.0
0512:  BSF    03.7
0513:  MOVF   00,W
0514:  MOVWF  4F
....................          s[i]=s[cnt-i-1];        // Reverse the number 
0515:  MOVF   4C,W
0516:  ADDWF  46,W
0517:  MOVWF  78
0518:  MOVF   47,W
0519:  MOVWF  7A
051A:  BTFSC  03.0
051B:  INCF   7A,F
051C:  MOVF   78,W
051D:  MOVWF  50
051E:  MOVF   7A,W
051F:  MOVWF  51
0520:  MOVF   4C,W
0521:  SUBWF  4E,W
0522:  ADDLW  FF
0523:  ADDWF  46,W
0524:  MOVWF  04
0525:  BCF    03.7
0526:  BTFSC  47.0
0527:  BSF    03.7
0528:  MOVF   00,W
0529:  MOVWF  52
052A:  MOVF   50,W
052B:  MOVWF  04
052C:  BCF    03.7
052D:  BTFSC  51.0
052E:  BSF    03.7
052F:  MOVF   52,W
0530:  MOVWF  00
....................          s[cnt-i-1]=c; 
0531:  MOVF   4C,W
0532:  SUBWF  4E,W
0533:  ADDLW  FF
0534:  ADDWF  46,W
0535:  MOVWF  04
0536:  BCF    03.7
0537:  BTFSC  47.0
0538:  BSF    03.7
0539:  MOVF   4F,W
053A:  MOVWF  00
053B:  INCF   4C,F
053C:  GOTO   508
....................      } 
....................      s[cnt]='\0';     // End the string 
053D:  MOVF   4E,W
053E:  ADDWF  46,W
053F:  MOVWF  04
0540:  BCF    03.7
0541:  BTFSC  47.0
0542:  BSF    03.7
0543:  CLRF   00
....................      return s; 
0544:  MOVF   46,W
0545:  MOVWF  78
0546:  MOVF   47,W
0547:  MOVWF  79
0548:  BCF    03.6
0549:  RETURN
.................... } 
....................  
.................... #if defined(__PCD__) 
....................  
.................... char * itoa(signed int48 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int48 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... char * itoa(signed int64 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int64 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................       
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1;         
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................              
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #endif 
....................  
.................... float strtof(char *s, char *endptr) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s, char *endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float48)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float48)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s, char *endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float64)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float64)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtoulGO; 
....................  
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................    { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... int8 mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #if !defined(__PCD__) 
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2);  
.................... #else  
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2);  
.................... #endif 
....................  
....................  
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    unsigned int8 t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=1; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = 0; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
.................... #INCLUDE <STDIO.H> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDIO 
.................... #define _STDIO 
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #ifndef getc 
.................... #define getc getch 
.................... #define getchar getch 
.................... #define puts(s) {printf(s); putchar(13); putchar(10);} 
.................... #define putc putchar 
.................... #endif 
.................... /* maps error number to an error message. Writes a sequence of characters to 
.................... stderr stream thus: if s is not null then string pointed to by s follwed by 
.................... a colon (:) and a space and the appropriate error message returned by strerror 
.................... function with argument errno 
....................  
.................... Returns: no value 
.................... */ 
....................  
.................... #ifdef _ERRNO 
.................... void perror(char *s) 
.................... { 
....................   if(s) 
....................   fprintf(STDERR,"%s: ",s); 
....................   fprintf(STDERR,"%s\r\n",strerror(errno)); 
.................... } 
.................... #endif 
.................... #endif 
....................  
.................... #INCLUDE <MATH.H> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2011 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                    //// 
.................... //// History:                                                           //// 
.................... ////  * 9/20/2001 :  Improvments are made to sin/cos code.              //// 
.................... ////                 The code now is small, much faster,                //// 
.................... ////                 and more accurate.                                 //// 
.................... ////  * 2/21/2007 :  Compiler handles & operator differently and does   //// 
.................... ////                 not return generic (int8 *) so type cast is done   //// 
.................... ////  * 6/19/2010 :  Divisions by constants converted to multiplication //// 
.................... ////                 by its inverse to improve computation speed        //// 
.................... ////  * 1/21/2011 :  Constants used for double precision math updated   //// 
.................... ////                 Updated routines include 64 bit versions of cos,   //// 
.................... ////                 asin,atan,exp,log and dependant functions          //// 
.................... ////  * 1/31/2011 :  Optimized current 32-bit float routines for cos    //// 
.................... ////                 and log function                                   //// 
.................... ////  * 6/13/2011 :  Fixed PCD overload CEIL_FLOOR functions for values //// 
.................... ////                 greater then 10000000 and less then -10000000      //// 
.................... ////                                                                    //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef MATH_H 
.................... #define MATH_H 
....................  
.................... #ifdef PI 
.................... #undef  PI 
.................... #endif 
.................... #define PI     3.1415926535897932 
....................  
....................  
.................... #define SQRT2  1.4142135623730950 
....................  
.................... //float const ps[4] = {5.9304945, 21.125224, 8.9403076, 0.29730279}; 
.................... //float const qs[4] = {1.0000000, 15.035723, 17.764134, 2.4934718}; 
....................  
.................... ///////////////////////////// Round Functions ////////////////////////////// 
....................  
.................... float32 CEIL_FLOOR(float32 x, unsigned int8 n) 
.................... { 
....................    float32 y, res; 
....................    unsigned int16 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................       res = (float32)(unsigned int16)y; 
....................  
....................  else if (y < 10000000.0) 
....................    {  
....................       l = (unsigned int16)(y*0.000030517578125); 
....................       y = 32768.0*(y*0.000030517578125 - (float32)l); 
....................       res = 32768.0*(float32)l; 
....................       res += (float32)(unsigned int16)y; 
....................    } 
....................  
....................  else 
....................   res = y; 
....................  
....................  y = y - (float32)(unsigned int16)y; 
....................  
....................  if (s) 
....................   res = -res; 
....................  
....................  if (y != 0) 
....................  { 
....................   if (s == 1 && n == 0) 
....................    res -= 1.0; 
....................  
....................   if (s == 0 && n == 1) 
....................    res += 1.0; 
....................  } 
....................  if (x == 0) 
....................     res = 0; 
....................  
....................  return (res); 
.................... } 
....................  
.................... // Overloaded Functions to take care for new Data types in PCD 
.................... // Overloaded function CEIL_FLOOR() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 CEIL_FLOOR(float48 x, unsigned int8 n) 
.................... { 
....................    float48 y, res; 
....................    unsigned int32 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................       res = (float48)(unsigned int16)y; 
....................  
....................    else if (y < 549755813888.0) 
....................    { 
....................       l = (unsigned int32)(y*0.000030517578125); 
....................       y = 32768.0*(y*0.000030517578125 - (float48)l); 
....................       res = 32768.0*(float48)l; 
....................       res += (float48)(unsigned int16)y; 
....................    } 
....................    else 
....................    {   
....................       res = y; 
....................       y = 0.0; 
....................    } 
....................     
....................    if(y != 0) 
....................       y = y - (float48)(unsigned int16)y; 
....................  
....................    if (s) 
....................       res = -res; 
....................  
....................    if (y != 0) 
....................    { 
....................       if (s == 1 && n == 0) 
....................          res -= 1.0; 
....................  
....................       if (s == 0 && n == 1) 
....................          res += 1.0; 
....................    } 
....................    if (x == 0) 
....................       res = 0; 
....................  
....................    return (res); 
.................... } 
....................  
....................  
.................... // Overloaded function CEIL_FLOOR() for data type - Float64 
.................... float64 CEIL_FLOOR(float64 x, unsigned int8 n) 
.................... { 
....................    float64 y, res; 
....................    int64 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................       res = (float64)(unsigned int16)y; 
....................    else if (y < 4503599627370496.0) 
....................    { 
....................       l = (int64)(y*0.000030517578125); 
....................       y = 32768.0*(y*0.000030517578125 - (float64)l); 
....................       res = 32768.0*(float64)l; 
....................       res += (float64)(unsigned int16)y; 
....................    } 
....................    else 
....................    { 
....................       res = y; 
....................       y = 0.0; 
....................    } 
....................     
....................    if(y != 0) 
....................       y = y - (float64)(unsigned int16)y; 
....................  
....................    if (s) 
....................       res = -res; 
....................  
....................    if (y != 0) 
....................    { 
....................       if (s == 1 && n == 0) 
....................          res -= 1.0; 
....................  
....................       if (s == 0 && n == 1) 
....................          res += 1.0; 
....................    } 
....................     
....................    if (x == 0) 
....................       res = 0; 
....................  
....................    return (res); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float floor(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : rounds down the number x. 
.................... // Date : N/A 
.................... // 
.................... float32 floor(float32 x) 
.................... { 
....................    return CEIL_FLOOR(x,0); 
.................... } 
.................... // Following 2 functions are overloaded functions of floor() for PCD 
.................... // Overloaded function floor() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 floor(float48 x) 
.................... { 
....................    return CEIL_FLOOR(x, 0); 
.................... } 
....................  
.................... // Overloaded function floor() for data type - Float64 
.................... float64 floor(float64 x) 
.................... { 
....................    return CEIL_FLOOR(x, 0); 
.................... } 
.................... #endif 
....................  
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float ceil(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : rounds up the number x. 
.................... // Date : N/A 
.................... // 
.................... float32 ceil(float32 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
.................... // Following 2 functions are overloaded functions of ceil() for PCD 
.................... // Overloaded function ceil() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 ceil(float48 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
....................  
.................... // Overloaded function ceil() for data type - Float64 
.................... float64 ceil(float64 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
.................... #endif 
....................  
....................  //////////////////////////////////////////////////////////////////////////// 
.................... //   float fabs(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the absolute value of floating point number x 
.................... // Returns : returns the absolute value of x 
.................... // Date : N/A 
.................... // 
.................... #define fabs abs 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float fmod(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the floating point remainder of x/y 
.................... // Returns : returns the value of x= i*y, for some integer i such that, if y 
.................... // is non zero, the result has the same isgn of x na dmagnitude less than the 
.................... // magnitude of y. If y is zero then a domain error occurs. 
.................... // Date : N/A 
.................... // 
....................  
.................... float fmod(float32 x,float32 y) 
.................... { 
....................    float32 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... //Overloaded function for fmod() for PCD 
.................... // Overloaded function fmod() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 fmod(float48 x,float48 y) 
.................... { 
....................    float48 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... // Overloaded function fmod() for data type - Float64 
.................... float64 fmod(float64 x,float64 y) 
.................... { 
....................    float64 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... #endif 
.................... //////////////////// Exponential and logarithmic functions //////////////////// 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float exp(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (e^x) 
.................... // Date : N/A 
.................... // 
.................... #define LN2 0.6931471805599453 
.................... #define LN2_INV 1.4426950408889634073 
....................  
.................... float const pe[6] = {0.000207455774, 0.00127100575, 0.00965065093, 
....................                      0.0554965651,  0.240227138,  0.693147172}; 
....................  
....................  
.................... float32 exp(float32 x) 
.................... { 
....................    float32 y, res, r; 
....................    #if defined(__PCD__) 
....................    int8 data1; 
....................    #endif 
....................    signed int8 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 88.722838) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    n = (signed int16)(x*LN2_INV); 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
.................... #if !defined(__PCD__) 
....................    *((unsigned int8 *)(&res)) = n + 0x7F; 
.................... #endif 
....................  
.................... #if defined(__PCD__)  // Takes care of IEEE format for PCD 
....................    data1 = n+0x7F; 
....................    if(bit_test(data1,0)) 
....................    bit_set(*(((unsigned int8 *)(&res)+2)),7); 
....................    rotate_right(&data1,1); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&res)+3)) = data1; 
.................... #endif 
....................  
....................    y = y*LN2_INV - (float32)n; 
....................  
....................    r = pe[0]*y + pe[1]; 
....................    r = r*y + pe[2]; 
....................    r = r*y + pe[3]; 
....................    r = r*y + pe[4]; 
....................    r = r*y + pe[5]; 
....................  
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
....................  
....................  
.................... //Overloaded function for exp() for PCD 
.................... // Overloaded function exp() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 exp(float48 x) 
.................... { 
....................    float48 y, res, r; 
....................    int8 data1; 
....................    signed int8 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 88.722838) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    n = (signed int16)(x*LN2_INV); 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
....................  
....................    data1 = n+0x7F; 
....................    if(bit_test(data1,0)) 
....................    bit_set(*(((unsigned int8 *)(&res)+4)),7); 
....................    rotate_right(&data1,1); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&res)+5)) = data1; 
....................  
....................    y = y*LN2_INV - (float48)n; 
....................  
....................    r = pe[0]*y + pe[1]; 
....................    r = r*y + pe[2]; 
....................    r = r*y + pe[3]; 
....................    r = r*y + pe[4]; 
....................    r = r*y + pe[5]; 
....................  
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function exp() for data type - Float64 
.................... float64 const pe_64[12] ={9.30741400474913e-011,-4.28655416283316e-011, 
....................                           8.71486547014137e-009,9.84458531538385e-008, 
....................                           1.32588296983536e-006,1.52489283823016e-005, 
....................                           0.000154037598423921,0.00133335487036216, 
....................                           0.00961812936407326,0.0555041086222122, 
....................                           0.240226506962827,0.693147180559823}; 
....................  
.................... float64 exp(float64 x) 
.................... { 
....................    float64 y, res, r; 
....................    unsigned int16 data1, data2; 
....................    unsigned int16 *p; 
....................    signed int16 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 709.7827128) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x*LN2_INV; 
....................    n = (signed int16)y; 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
....................  
.................... #if !defined(__PCD__) 
....................    *((unsigned int16 *)(&res)) = n + 0x7F; 
.................... #endif 
....................    p= (((unsigned int16 *)(&res))+3); 
....................    data1 = *p; 
....................    data2 = *p;    
....................    data1 = n + 0x3FF; 
....................    data1 = data1 <<4; 
....................    if(bit_test(data2,15)) 
....................    bit_set(data1,15); 
....................    data2 = data2 & 0x000F; 
....................    data1 ^= data2; 
....................  
....................    *(((unsigned int16 *)(&res)+3)) = data1; 
....................  
....................  
....................    y = y*LN2_INV - (float64)n; 
....................  
....................    r = pe_64[0]*y + pe_64[1]; 
....................    r = r*y + pe_64[2]; 
....................    r = r*y + pe_64[3]; 
....................    r = r*y + pe_64[4]; 
....................    r = r*y + pe_64[5]; 
....................    r = r*y + pe_64[6]; 
....................    r = r*y + pe_64[7]; 
....................    r = r*y + pe_64[8]; 
....................    r = r*y + pe_64[9]; 
....................    r = r*y + pe_64[10]; 
....................    r = r*y + pe_64[11]; 
....................     
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
.................... #ENDIF 
....................  
....................  
.................... /************************************************************/ 
....................  
.................... float32 const pl[4] = {-1.080310025160955, 1.999999947089217}; 
.................... float32 const ql[4] = {0.091284365719509, -0.873491916557671}; 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float log(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the the natural log of x 
.................... // Date : N/A 
.................... // 
.................... float32 log(float32 x) 
.................... { 
....................    float32 y, res, r, y2; 
....................    #if defined(__PCD__) 
....................    unsigned int8  data1,data2; 
....................    #endif 
....................    signed int8 n; 
....................    #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
.................... #if !defined(__PCD__) 
....................     *((unsigned int8 *)(&y)) = 0x7E;  
.................... #endif 
....................  
.................... #if defined(__PCD__) // Takes care of IEEE format 
....................    data2 = *(((unsigned int8 *)(&y))+3); 
....................    *(((unsigned int8 *)(&y))+3) = 0x3F; 
....................    data1 = *(((unsigned int8 *)(&y))+2); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&y))+2) = data1; 
....................    if(bit_test(data2,7)) 
....................      bit_set(*(((unsigned int8 *)(&y))+3),7); 
.................... #endif 
....................  
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl[0]*y2 + pl[1]; 
....................  
....................       r = ql[0]*y2 + ql[1]; 
....................       r = r*y2 + 1.0; 
....................  
....................       res = y*res/r; 
.................... #if !defined(__PCD__) 
....................       n = *((unsigned int8 *)(&x)) - 0x7E; 
.................... #endif 
.................... #if defined(__PCD__)  
....................     data1 = *(((unsigned int8 *)(&x)+3)); 
....................     rotate_left(&data1,1); 
....................     data2 = *(((unsigned int8 *)(&x)+2)); 
....................     if(bit_test (data2,7)) 
....................       bit_set(data1,0); 
....................     n = data1 - 0x7E; 
.................... #endif 
....................  
....................       if (n<0)  
....................          r = -(float32)-n; 
....................       else 
....................          r = (float32)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................       res = 0.0; 
....................  
....................    return(res); 
.................... } 
....................  
.................... //Overloaded function for log() for PCD 
.................... // Overloaded function log() for data type - Float48 
.................... #if defined(__PCD__) 
.................... // Overloaded function log() for data type - float64 
.................... float64 const pl_64[4] = {-0.145694052150681, 1.365485300000370, 
....................                           -3.120535668274329, 2.000000000000000}; 
....................  
.................... float64 const ql_64[4] = {0.006047500465908, -0.208298281937234, 
....................                           1.113943039156721, -1.893601167470470}; 
....................  
.................... float48 log(float48 x) 
.................... { 
....................    float48 y, res, r, y2; 
....................    unsigned int8  data1,data2; 
....................    signed int8 n; 
.................... #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
.................... #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
....................  
.................... #if !defined(__PCD__) 
....................       *((unsigned int8 *)(&y)) = 0x7E;  
.................... #endif 
....................       data2 = *(((unsigned int8 *)(&y))+5); 
....................       *(((unsigned int8 *)(&y))+5) = 0x3F; 
....................       data1 = *(((unsigned int8 *)(&y))+4); 
....................       bit_clear(data1,7); 
....................       *(((unsigned int8 *)(&y))+4) = data1; 
....................  
....................       if(bit_test(data2,7)) 
....................       bit_set(*(((unsigned int8 *)(&y))+4),7); 
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl_64[0]*y2 + pl_64[1]; 
....................       res = res*y2 + pl_64[2]; 
....................       res = res*y2 + pl_64[3]; 
....................  
....................       r = ql_64[0]*y2 + ql_64[1]; 
....................       r = r*y2 + ql_64[2]; 
....................       r = r*y2 + ql_64[3]; 
....................       r = r*y2 + 1.0;  
....................       res = y*res/r; 
....................  
....................       data1 = *(((unsigned int8 *)(&x)+5)); 
....................       rotate_left(&data1,1); 
....................       data2 = *(((unsigned int8 *)(&x)+4)); 
....................       if(bit_test (data2,7)) 
....................       bit_set(data1,0); 
....................        
....................       n = data1 - 0x7E; 
....................  
....................       if (n<0) 
....................       r = -(float48)-n; 
....................       else 
....................       r = (float48)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................    res = 0.0; 
....................  
....................    return(res); 
.................... } 
....................  
.................... float64 log(float64 x) 
.................... { 
....................    float64 y, res, r, y2; 
....................    unsigned int16  data1,data2; 
....................    unsigned int16 *p; 
....................    signed int16 n; 
....................    #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
....................    #if !defined(__PCD__) 
....................        *((unsigned int8 *)(&y)) = 0x7E;  
....................    #endif 
....................       p= (((unsigned int16 *)(&y))+3); 
....................       data1 = *p; 
....................       data2 = *p; 
....................       data1 = 0x3FE; 
....................       data1 = data1 <<4; 
....................       if(bit_test (data2,15)) 
....................          bit_set(data1,15); 
....................       data2 = data2 & 0x000F; 
....................       data1 ^=data2; 
....................  
....................       *p = data1; 
....................  
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl_64[0]*y2 + pl_64[1]; 
....................       res = res*y2 + pl_64[2]; 
....................       res = res*y2 + pl_64[3]; 
....................  
....................       r = ql_64[0]*y2 + ql_64[1]; 
....................       r = r*y2 + ql_64[2]; 
....................       r = r*y2 + ql_64[3]; 
....................       r = r*y2 + 1.0; 
....................  
....................       res = y*res/r; 
....................   
....................       p= (((unsigned int16 *)(&x))+3); 
....................       data1 = *p; 
....................       bit_clear(data1,15); 
....................       data1 = data1 >>4;     
....................       n = data1 - 0x3FE; 
....................  
....................  
....................       if (n<0) 
....................          r = -(float64)-n; 
....................       else 
....................          r = (float64)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................       res = 0.0; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
....................  
.................... #define LN10 2.3025850929940456 
.................... #define LN10_INV 0.4342944819032518276 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float log10(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the the log base 10 of x 
.................... // Date : N/A 
.................... // 
.................... float32 log10(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = log(x); 
....................    r = r*LN10_INV; 
....................    return(r); 
.................... } 
....................  
.................... //Overloaded functions for log10() for PCD 
.................... // Overloaded function log10() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 log10(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = log(x); 
....................    r = r*LN10_INV; 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function log10() for data type - Float64 
.................... float64 log10(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = log(x); 
....................    r = r*LN10_INV; 
....................    return(r); 
.................... } 
.................... #endif 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float modf(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description :breaks the argument value int integral and fractional parts, 
.................... // ach of which have the same sign as the argument.  It stores the integral part 
.................... // as a float in the object pointed to by the iptr 
.................... // Returns : returns the signed fractional part of value. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 modf(float32 value,float32 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... //Overloaded functions for modf() for PCD 
.................... // Overloaded function modf() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 modf(float48 value,float48 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... // Overloaded function modf() for data type - Float64 
.................... float64 modf(float64 value,float64 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float pwr(float x,float y) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (x^y) 
.................... // Date : N/A 
.................... // Note : 0 is returned when the function will generate an imaginary number 
.................... // 
.................... float32 pwr(float32 x,float32 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... //Overloaded functions for pwr() for PCD 
.................... // Overloaded function pwr() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 pwr(float48 x,float48 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... // Overloaded function pwr() for data type - Float64 
.................... float64 pwr(float64 x,float64 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////// Power functions //////////////////// 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float pow(float x,float y) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (x^y) 
.................... // Date : N/A 
.................... // Note : 0 is returned when the function will generate an imaginary number 
.................... // 
.................... float32 pow(float32 x,float32 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... //Overloaded functions for pow() for PCD 
.................... // Overloaded function for pow() data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 pow(float48 x,float48 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
....................  
.................... // Overloaded function pow() for data type - Float64 
.................... float64 pow(float64 x,float64 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sqrt(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the square root of x 
.................... // Date : N/A 
.................... // 
.................... float32 sqrt(float32 x) 
.................... { 
....................    float32 y, res; 
....................    #if defined(__PCD__) 
....................    unsigned int16 data1,data2; 
....................    #endif 
....................    unsigned int8 *p; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................     
....................    #if !defined(__PCD__) 
....................     p=&y; 
....................    (*p)=(unsigned int8)((((unsigned int16)(*p)) + 127) >> 1); 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     p = (((unsigned int8 *)(&y))+3); 
....................     data1 = *(((unsigned int8 *)(&y))+3); 
....................     data2 = *(((unsigned int8 *)(&y))+2); 
....................     rotate_left(&data1,1);     
....................     if(bit_test(data2,7))     
....................        bit_set(data1,0);     
....................     data1 = ((data1+127) >>1); 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+3) = data1; 
....................     *(((unsigned int8 *)(&y))+2) = data2; 
....................      
....................   #endif 
....................  
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................  
....................       #if !defined(__PCD__) 
....................      (*p)--; 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     data1 = *(((unsigned int8 *)(&y))+3); 
....................     data2 = *(((unsigned int8 *)(&y))+2); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................        bit_set(data1,0);     
....................     data1--; 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+3) = data1; 
....................     *(((unsigned int8 *)(&y))+2) = data2; 
....................      
....................   #endif 
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
.................... //Overloaded functions for sqrt() for PCD 
.................... // Overloaded function sqrt() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sqrt(float48 x) 
.................... { 
....................    float48 y, res; 
....................    unsigned int16 data1,data2; 
....................    unsigned int8 *p; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................     
....................    #if !defined(__PCD__) 
....................     p=&y; 
....................    (*p)=(unsigned int8)((((unsigned int16)(*p)) + 127) >> 1); 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     p = (((unsigned int8 *)(&y))+5); 
....................     data1 = *(((unsigned int8 *)(&y))+5); 
....................     data2 = *(((unsigned int8 *)(&y))+4); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................        bit_set(data1,0);     
....................     data1 = ((data1+127) >>1); 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+5) = data1; 
....................     *(((unsigned int8 *)(&y))+4) = data2; 
....................      
....................   #endif 
....................  
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................  
....................       #if !defined(__PCD__) 
....................      (*p)--; 
....................    #endif 
....................     
....................     data1 = *(((unsigned int8 *)(&y))+5); 
....................     data2 = *(((unsigned int8 *)(&y))+4); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................        bit_set(data1,0);     
....................     data1--; 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+5) = data1; 
....................     *(((unsigned int8 *)(&y))+4) = data2; 
....................      
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function sqrt() for data type - Float64 
.................... float64 sqrt(float64 x) 
.................... { 
....................    float64 y, res; 
....................    unsigned int16 *p; 
....................    unsigned int16 temp1,temp2; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................    p= (((unsigned int16 *)(&y))+3); 
....................    temp1 = *p; 
....................    temp2 = *p; 
....................    bit_clear(temp1,15); 
....................    temp1 = (temp1>>4)+1023; 
....................    temp1 = temp1 >> 1; 
....................    temp1 = (temp1<<4) & 0xFFF0; 
....................    if(bit_test(temp2,15)) 
....................       bit_set(temp1,15); 
....................    temp2 = temp2 & 0x000F; 
....................    temp1 ^= temp2; 
....................     
....................    (*p) = temp1; 
....................     
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................      temp1 = *p; 
....................      temp2 = *p; 
....................      bit_clear(temp1,15); 
....................      temp1 = (temp1>>4); 
....................      temp1--; 
....................      temp1 = (temp1<<4) & 0xFFF0; 
....................      if(bit_test(temp2,15)) 
....................         bit_set(temp1,15); 
....................      temp2 = temp2 & 0x000F; 
....................      temp1 ^= temp2; 
....................      (*p) = temp1; 
....................  
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... ////////////////////////////// Trig Functions ////////////////////////////// 
.................... #ifdef PI_DIV_BY_TWO_INV 
.................... #undef PI_DIV_BY_TWO_INV 
.................... #endif 
.................... #define PI_DIV_BY_TWO_INV 0.63661977236758134 
.................... #ifdef PI_DIV_BY_TWO 
.................... #undef PI_DIV_BY_TWO 
.................... #endif 
.................... #define PI_DIV_BY_TWO   1.5707963267948966 
.................... #ifdef TWOBYPI 
.................... #undef TWOBYPI 
.................... #endif 
.................... #define TWOBYPI          0.6366197723675813 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float cos(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the cosine value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 cos(float32 x) 
.................... { 
....................    float32 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float32 frac; 
....................    float32 p[5] = {                    //by the series definition for cosine 
....................       -0.49999999456337096,            // sum ( ( (-1)^n * x^2n )/(2n)! ) 
....................        0.04166663896921267, 
....................       -0.00138883894522527, 
....................        0.00002476138231734, 
....................       -0.00000026070414770 
....................       //-0.00000000001147, 
....................       // 0.00000000000005 
....................    }; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant 
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 1.0; 
....................    t = t * t; 
....................    for (i = 0; i <= 4; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
....................  
.................... //Overloaded functions for cos() for PCD 
.................... // Overloaded function cos() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 cos(float48 x) 
.................... { 
....................    float48 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float48 frac; 
....................    float48 p[6] = {                    //by the series definition for cosine 
....................       -0.5,                            // sum ( ( (-1)^n * x^2n )/(2n)! ) 
....................        0.04166666666667, 
....................       -0.00138888888889, 
....................        0.00002480158730, 
....................       -0.00000027557319, 
....................        0.00000000208767, 
....................       //-0.00000000001147, 
....................       // 0.00000000000005 
....................    }; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant 
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 0.999999999781; 
....................    t = t * t; 
....................    for (i = 0; i <= 5; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
.................... // Overloaded function cos() for data type - Float64 
.................... float64 cos(float64 x) 
.................... { 
....................    float64 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float64 frac; 
....................    float64 p_64[9] = {               //by the series definition for cosine 
....................      -0.49999999999998740,           // sum ( ( (-1)^n * x^2n )/(2n)! )              
....................       0.04166666666656518, 
....................      -0.00138888888851691, 
....................       0.00002480158658490, 
....................      -0.00000027557239796, 
....................       0.00000000208715031, 
....................      -0.00000000001126577, 
....................       0.00000000000000427, 
....................       0.00000000000000372}; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant 
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 1.0; 
....................    t = t * t; 
....................    for (i = 0; i <= 8; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p_64[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sin(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the sine value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 sin(float32 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
....................  
.................... //Overloaded functions for sin() for PCD 
.................... // Overloaded function sin() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sin(float48 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
....................  
.................... // Overloaded function sin() for data type - Float48 
.................... float64 sin(float64 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float tan(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the tangent value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 tan(float32 x) 
.................... { 
....................    float32 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
.................... //Overloaded functions for tan() for PCD 
.................... // Overloaded function tan() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 tan(float48 x) 
.................... { 
....................    float48 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
....................  
.................... // Overloaded function tan() for data type - Float48 
.................... float64 tan(float64 x) 
.................... { 
....................    float64 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
.................... #endif 
....................  
.................... float32 const pas[3] = {0.49559947, -4.6145309, 5.6036290}; 
.................... float32 const qas[3] = {1.0000000,  -5.5484666, 5.6036290}; 
....................  
.................... float32 ASIN_COS(float32 x, unsigned int8 n) 
.................... { 
....................    float32 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)*0.5); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas[0]*y2 + pas[1]; 
....................    res = res*y2 + pas[2]; 
....................  
....................    r = qas[0]*y2 + qas[1]; 
....................    r = r*y2 + qas[2]; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
....................  
....................  
.................... //Overloaded functions for ASIN_COS() for PCD 
.................... // Overloaded function ASIN_COS() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 ASIN_COS(float48 x, unsigned int8 n) 
.................... { 
....................    float48 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)*0.5); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas[0]*y2 + pas[1]; 
....................    res = res*y2 + pas[2]; 
....................  
....................    r = qas[0]*y2 + qas[1]; 
....................    r = r*y2 + qas[2]; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function ASIN_COS() for data type - Float64 
.................... double pas_64[5]={1.000000000000000,-2.069938587724477,1.421444580548907, 
....................                  -0.360690137621842,0.024929451660228}; 
....................  
.................... double qas_64[5]={-2.236605254391134,1.719212122946451,-0.524122954476133, 
....................                    0.052808872045749,-0.000662536036570}; 
....................                     
.................... float64 ASIN_COS(float64 x, unsigned int8 n) 
.................... { 
....................    float64 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)*0.5); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas_64[4]*y2 + pas_64[3]; 
....................    res = res*y2 + pas_64[2]; 
....................    res = res*y2 + pas_64[1]; 
....................    res = res*y2 + pas_64[0]; 
....................  
....................    r = qas_64[4]*y2 + qas_64[3]; 
....................    r = r*y2 + qas_64[2]; 
....................    r = r*y2 + qas_64[1]; 
....................    r = r*y2 + qas_64[0]; 
....................    r = r*y2 + 1.0; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float asin(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arcsine value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 asin(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
.................... //Overloaded functions for asin() for PCD 
.................... // Overloaded function asin() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 asin(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function asin() for data type - Float64 
.................... float64 asin(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float acos(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arccosine value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 acos(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
.................... //Overloaded functions for acos() for PCD 
.................... // Overloaded function acos() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 acos(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function acos() for data type - Float64 
.................... float64 acos(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
.................... #endif 
....................  
.................... float32 const pat[4] = {0.17630401, 5.6710795, 22.376096, 19.818457}; 
.................... float32 const qat[4] = {1.0000000,  11.368190, 28.982246, 19.818457}; 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float atan(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arctangent value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 atan(float32 x) 
.................... { 
....................    float32 y, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................  
....................    res = pat[0]*y*y + pat[1]; 
....................    res = res*y*y + pat[2]; 
....................    res = res*y*y + pat[3]; 
....................  
....................    r = qat[0]*y*y + qat[1]; 
....................    r = r*y*y + qat[2]; 
....................    r = r*y*y + qat[3]; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
.................... //Overloaded functions for atan() for PCD 
.................... // Overloaded function atan() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 atan(float48 x) 
.................... { 
....................    float48 y, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................  
....................    res = pat[0]*y*y + pat[1]; 
....................    res = res*y*y + pat[2]; 
....................    res = res*y*y + pat[3]; 
....................  
....................    r = qat[0]*y*y + qat[1]; 
....................    r = r*y*y + qat[2]; 
....................    r = r*y*y + qat[3]; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
....................  
.................... float64 pat_64[6]={0.999999999999999,2.249923645595566,1.771541617806449, 
....................                    0.579678874003185,0.072162702162882,0.002281100141660}; 
....................  
.................... float64 qat_64[6]={2.583256978928510,2.432627277466967,1.016760379885393, 
....................                    0.182482977188688,0.011155377971690,0.000100013019160}; 
.................... // Overloaded function atan() for data type - Float64 
.................... float64 atan(float64 x) 
.................... { 
....................    float64 y,y2, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................    y2 = y*y; 
....................    res = pat_64[5]*y2 + pat_64[4]; 
....................    res = res*y2 + pat_64[3]; 
....................    res = res*y2 + pat_64[2]; 
....................    res = res*y2 + pat_64[1]; 
....................    res = res*y2 + pat_64[0]; 
....................  
....................    r = qat_64[5]*y2 + qat_64[4]; 
....................    r = r*y2 + qat_64[3]; 
....................    r = r*y2 + qat_64[2]; 
....................    r = r*y2 + qat_64[1]; 
....................    r = r*y2 + qat_64[0]; 
....................    r = r*y2 + 1.0; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... ///////////////////////////////////////////////////////////////////////////// 
.................... //   float atan2(float y, float x) 
.................... ///////////////////////////////////////////////////////////////////////////// 
.................... // Description :computes the principal value of arc tangent of y/x, using the 
.................... // signs of both the arguments to determine the quadrant of the return value 
.................... // Returns : returns the arc tangent of y/x. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 atan2(float32 y,float32 x) 
.................... { 
....................    float32 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
....................  
.................... //Overloaded functions for atan2() for PCD 
.................... // Overloaded function atan2() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 atan2(float48 y,float48 x) 
.................... { 
....................    float48 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
....................  
.................... // Overloaded function atan2() for data type - Float64 
.................... float64 atan2(float64 y,float64 x) 
.................... { 
....................    float64 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////// Hyperbolic functions //////////////////// 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float cosh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic cosine value of x 
.................... // Returns : returns the hyperbolic cosine value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 cosh(float32 x) 
.................... { 
....................    return ((exp(x)+exp(-x))*0.5); 
.................... } 
.................... //Overloaded functions for cosh() for PCD 
.................... // Overloaded function cosh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 cosh(float48 x) 
.................... { 
....................    return ((exp(x)+exp(-x))*0.5); 
.................... } 
....................  
.................... // Overloaded function cosh() for data type - Float64 
.................... float64 cosh(float64 x) 
.................... { 
....................    return ((exp(x)+exp(-x))*0.5); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sinh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic sine value of x 
.................... // Returns : returns the hyperbolic sine value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 sinh(float32 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))*0.5); 
.................... } 
.................... //Overloaded functions for sinh() for PCD 
.................... // Overloaded function sinh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sinh(float48 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))*0.5); 
.................... } 
....................  
.................... // Overloaded function sinh() for data type - Float48 
.................... float64 sinh(float64 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))*0.5); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float tanh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic tangent value of x 
.................... // Returns : returns the hyperbolic tangent value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 tanh(float32 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
.................... //Overloaded functions for tanh() for PCD 
.................... // Overloaded function tanh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 tanh(float48 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
....................  
.................... // Overloaded function tanh() for data type - Float64 
.................... float64 tanh(float64 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float frexp(float x, signed int *exp) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : breaks a floating point number into a normalized fraction and an integral 
.................... // power of 2. It stores the integer in the signed int object pointed to by exp. 
.................... // Returns : returns the value x, such that x is a double with magnitude in the interval 
.................... // [1/2,1) or zero, and value equals x times 2 raised to the power *exp.If value is zero, 
.................... // both parts of the result are zero. 
.................... // Date : N/A 
.................... // 
....................  
.................... #define LOG2 .30102999566398119521 
.................... #define LOG2_INV 3.32192809488736234787 
.................... float32 frexp(float32 x, signed int8 *exp) 
.................... { 
....................    float32 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)*LOG2_INV)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
....................  
.................... //Overloaded functions for frexp() for PCD 
.................... // Overloaded function frexp() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 frexp(float48 x, signed int8 *exp) 
.................... { 
....................    float48 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)*LOG2_INV)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
....................  
.................... // Overloaded function frexp() for data type - Float64 
.................... float64 frexp(float64 x, signed int8 *exp) 
.................... { 
....................    float64 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)*LOG2_INV)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
.................... #endif 
....................  
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... //   float ldexp(float x, signed int *exp) 
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... // Description : multiplies a floating point number by an integral power of 2. 
.................... // Returns : returns the value of x times 2 raised to the power exp. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 ldexp(float32 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... //Overloaded functions for ldexp() for PCD 
.................... // Overloaded function ldexp() for data type - Float48 
....................  
.................... #if defined(__PCD__) 
.................... float48 ldexp(float48 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... // Overloaded function ldexp() for data type - Float64 
.................... float64 ldexp(float64 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... #endif 
....................  
.................... #endif 
....................  
.................... #INCLUDE <xuatbyte74595.c> 
....................  
.................... #DEFINE      DS               PIN_D1 
.................... #DEFINE      SH_CP            PIN_D0   
.................... #DEFINE      STCP             PIN_D2 
.................... VOID XUATTRANGTHAI(UNSIGNED INT8 BYTEXUAT) 
.................... { 
....................    UNSIGNED INT8   SB;    
....................    #BIT BSERI  = BYTEXUAT.7 
....................     
....................    FOR (SB=0;SB<8;SB++) 
*
0D79:  CLRF   19
0D7A:  MOVF   19,W
0D7B:  SUBLW  07
0D7C:  BTFSS  03.0
0D7D:  GOTO   594
....................       {                                                  
....................          OUTPUT_BIT(DS,BSERI);     
0D7E:  BTFSC  18.7
0D7F:  GOTO   584
0D80:  BCF    03.6
0D81:  BCF    08.1
0D82:  GOTO   586
0D83:  BSF    03.6
0D84:  BCF    03.6
0D85:  BSF    08.1
0D86:  BSF    03.5
0D87:  BCF    08.1
....................          OUTPUT_LOW(SH_CP); OUTPUT_HIGH(SH_CP); 
0D88:  BCF    08.0
0D89:  BCF    03.5
0D8A:  BCF    08.0
0D8B:  BSF    03.5
0D8C:  BCF    08.0
0D8D:  BCF    03.5
0D8E:  BSF    08.0
....................          BYTEXUAT=BYTEXUAT<<1; //10010010->00100100   
0D8F:  BCF    03.0
0D90:  BSF    03.6
0D91:  RLF    18,F
0D92:  INCF   19,F
0D93:  GOTO   57A
....................      } 
....................       OUTPUT_LOW(STCP); OUTPUT_HIGH(STCP); 
0D94:  BSF    03.5
0D95:  BCF    03.6
0D96:  BCF    08.2
0D97:  BCF    03.5
0D98:  BCF    08.2
0D99:  BSF    03.5
0D9A:  BCF    08.2
0D9B:  BCF    03.5
0D9C:  BSF    08.2
.................... } 
....................  
....................  
.................... #FUSES NOWDT, PUT, HS 
.................... #USE DELAY(CLOCK=20M) 
*
0155:  MOVLW  43
0156:  MOVWF  04
0157:  BSF    03.7
0158:  MOVF   00,W
0159:  BTFSC  03.2
015A:  GOTO   168
015B:  MOVLW  06
015C:  MOVWF  78
015D:  CLRF   77
015E:  DECFSZ 77,F
015F:  GOTO   15E
0160:  DECFSZ 78,F
0161:  GOTO   15D
0162:  MOVLW  7B
0163:  MOVWF  77
0164:  DECFSZ 77,F
0165:  GOTO   164
0166:  DECFSZ 00,F
0167:  GOTO   15B
0168:  RETURN
.................... #USE RS232(BAUD=9600,XMIT=PIN_C6,RCV=PIN_C7) 
.................... #DEFINE BT1_PIN PIN_B1 
.................... #DEFINE BT2_PIN PIN_B2 
.................... #DEFINE BT3_PIN PIN_B3 
.................... #DEFINE LCD_ENABLE_PIN  PIN_E0                                    
.................... #DEFINE LCD_RS_PIN      PIN_E1                                 
.................... #DEFINE LCD_RW_PIN      PIN_E2   
.................... #DEFINE LCD_DATA4       PIN_C0                                
.................... #DEFINE LCD_DATA5       PIN_C1                                  
.................... #DEFINE LCD_DATA6       PIN_C2                                    
.................... #DEFINE LCD_DATA7       PIN_C3   
.................... #INCLUDE <LCD.C> 
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... ////                             LCD.C                                     //// 
.................... ////                 Driver for common LCD modules                         //// 
.................... ////                                                                       //// 
.................... ////  lcd_init()   Must be called before any other function.               //// 
.................... ////                                                                       //// 
.................... ////  lcd_putc(c)  Will display c on the next position of the LCD.         //// 
.................... ////                 \a  Set cursor position to upper left                 //// 
.................... ////                 \f  Clear display, set cursor to upper left           //// 
.................... ////                 \n  Go to start of second line                        //// 
.................... ////                 \b  Move back one position                            //// 
.................... ////              If LCD_EXTENDED_NEWLINE is defined, the \n character     //// 
.................... ////              will erase all remanining characters on the current      //// 
.................... ////              line, and move the cursor to the beginning of the next   //// 
.................... ////              line.                                                    //// 
.................... ////              If LCD_EXTENDED_NEWLINE is defined, the \r character     //// 
.................... ////              will move the cursor to the start of the current         //// 
.................... ////              line.                                                    //// 
.................... ////                                                                       //// 
.................... ////  lcd_gotoxy(x,y) Set write position on LCD (upper left is 1,1)        //// 
.................... ////                                                                       //// 
.................... ////  lcd_getc(x,y)   Returns character at position x,y on LCD             //// 
.................... ////                                                                       //// 
.................... ////  lcd_cursor_on(int1 on)   Turn the cursor on (on=TRUE) or off         //// 
.................... ////              (on=FALSE).                                              //// 
.................... ////                                                                       //// 
.................... ////  lcd_set_cgram_char(w, *p)   Write a custom character to the CGRAM.   //// 
.................... ////                                                                       //// 
.................... ////                                                                       //// 
.................... ////  CONFIGURATION                                                        //// 
.................... ////  The LCD can be configured in one of two ways: a.) port access or     //// 
.................... ////  b.) pin access.  Port access requires the entire 7 bit interface     //// 
.................... ////  connected to one GPIO port, and the data bits (D4:D7 of the LCD)     //// 
.................... ////  connected to sequential pins on the GPIO.  Pin access                //// 
.................... ////  has no requirements, all 7 bits of the control interface can         //// 
.................... ////  can be connected to any GPIO using several ports.                    //// 
.................... ////                                                                       //// 
.................... ////  To use port access, #define LCD_DATA_PORT to the SFR location of     //// 
.................... ////  of the GPIO port that holds the interface, -AND- edit LCD_PIN_MAP    //// 
.................... ////  of this file to configure the pin order.  If you are using a         //// 
.................... ////  baseline PIC (PCB), then LCD_OUTPUT_MAP and LCD_INPUT_MAP also must  //// 
.................... ////  be defined.                                                          //// 
.................... ////                                                                       //// 
.................... ////  Example of port access:                                              //// 
.................... ////     #define LCD_DATA_PORT getenv("SFR:PORTD")                         //// 
.................... ////                                                                       //// 
.................... ////  To use pin access, the following pins must be defined:               //// 
.................... ////     LCD_ENABLE_PIN                                                    //// 
.................... ////     LCD_RS_PIN                                                        //// 
.................... ////     LCD_RW_PIN                                                        //// 
.................... ////     LCD_DATA4                                                         //// 
.................... ////     LCD_DATA5                                                         //// 
.................... ////     LCD_DATA6                                                         //// 
.................... ////     LCD_DATA7                                                         //// 
.................... ////                                                                       //// 
.................... ////  Example of pin access:                                               //// 
.................... ////     #define LCD_ENABLE_PIN  PIN_E0                                    //// 
.................... ////     #define LCD_RS_PIN      PIN_E1                                    //// 
.................... ////     #define LCD_RW_PIN      PIN_E2                                    //// 
.................... ////     #define LCD_DATA4       PIN_D4                                    //// 
.................... ////     #define LCD_DATA5       PIN_D5                                    //// 
.................... ////     #define LCD_DATA6       PIN_D6                                    //// 
.................... ////     #define LCD_DATA7       PIN_D7                                    //// 
.................... ////                                                                       //// 
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2010 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef __LCD_C__ 
.................... #define __LCD_C__ 
....................  
.................... // define the pinout. 
.................... // only required if port access is being used. 
.................... typedef struct   
.................... {                            // This structure is overlayed 
....................    int1 enable;           // on to an I/O port to gain 
....................    int1 rs;               // access to the LCD pins. 
....................    int1 rw;               // The bits are allocated from 
....................    int1 unused;           // low order up.  ENABLE will 
....................    unsigned int     data : 4;         // be LSB pin of that port. 
....................   #if defined(__PCD__)       // The port used will be LCD_DATA_PORT. 
....................    unsigned int    reserved: 8; 
....................   #endif 
.................... } LCD_PIN_MAP; 
....................  
.................... // this is to improve compatability with previous LCD drivers that accepted 
.................... // a define labeled 'use_portb_lcd' that configured the LCD onto port B. 
.................... #if ((defined(use_portb_lcd)) && (use_portb_lcd==TRUE)) 
....................  #define LCD_DATA_PORT getenv("SFR:PORTB") 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
....................    // these definitions only need to be modified for baseline PICs. 
....................    // all other PICs use LCD_PIN_MAP or individual LCD_xxx pin definitions. 
.................... /*                                    EN, RS,   RW,   UNUSED,  DATA  */ 
....................  const LCD_PIN_MAP LCD_OUTPUT_MAP =  {0,  0,    0,    0,       0}; 
....................  const LCD_PIN_MAP LCD_INPUT_MAP =   {0,  0,    0,    0,       0xF}; 
.................... #endif 
....................  
.................... ////////////////////// END CONFIGURATION /////////////////////////////////// 
....................  
.................... #ifndef LCD_ENABLE_PIN 
....................    #define lcd_output_enable(x) lcdlat.enable=x 
....................    #define lcd_enable_tris()   lcdtris.enable=0 
.................... #else 
....................    #define lcd_output_enable(x) output_bit(LCD_ENABLE_PIN, x) 
....................    #define lcd_enable_tris()  output_drive(LCD_ENABLE_PIN) 
.................... #endif 
....................  
.................... #ifndef LCD_RS_PIN 
....................    #define lcd_output_rs(x) lcdlat.rs=x 
....................    #define lcd_rs_tris()   lcdtris.rs=0 
.................... #else 
....................    #define lcd_output_rs(x) output_bit(LCD_RS_PIN, x) 
....................    #define lcd_rs_tris()  output_drive(LCD_RS_PIN) 
.................... #endif 
....................  
.................... #ifndef LCD_RW_PIN 
....................    #define lcd_output_rw(x) lcdlat.rw=x 
....................    #define lcd_rw_tris()   lcdtris.rw=0 
.................... #else 
....................    #define lcd_output_rw(x) output_bit(LCD_RW_PIN, x) 
....................    #define lcd_rw_tris()  output_drive(LCD_RW_PIN) 
.................... #endif 
....................  
.................... // original version of this library incorrectly labeled LCD_DATA0 as LCD_DATA4, 
.................... // LCD_DATA1 as LCD_DATA5, and so on.  this block of code makes the driver 
.................... // compatible with any code written for the original library 
.................... #if (defined(LCD_DATA0) && defined(LCD_DATA1) && defined(LCD_DATA2) && defined(LCD_DATA3) && !defined(LCD_DATA4) && !defined(LCD_DATA5) && !defined(LCD_DATA6) && !defined(LCD_DATA7)) 
....................    #define  LCD_DATA4    LCD_DATA0 
....................    #define  LCD_DATA5    LCD_DATA1 
....................    #define  LCD_DATA6    LCD_DATA2 
....................    #define  LCD_DATA7    LCD_DATA3 
.................... #endif 
....................  
.................... #ifndef LCD_DATA4 
.................... #ifndef LCD_DATA_PORT 
....................    #if defined(__PCB__) 
....................       #define LCD_DATA_PORT      0x06     //portb 
....................       #define set_tris_lcd(x)   set_tris_b(x) 
....................    #else 
....................      #if defined(PIN_D0) 
....................       #define LCD_DATA_PORT      getenv("SFR:PORTD")     //portd 
....................      #else 
....................       #define LCD_DATA_PORT      getenv("SFR:PORTB")     //portb 
....................      #endif 
....................    #endif    
.................... #endif 
....................  
.................... #if defined(__PCB__) 
....................    LCD_PIN_MAP lcd, lcdlat; 
....................    #byte lcd = LCD_DATA_PORT 
....................    #byte lcdlat = LCD_DATA_PORT 
.................... #elif defined(__PCM__) 
....................    LCD_PIN_MAP lcd, lcdlat, lcdtris; 
....................    #byte lcd = LCD_DATA_PORT 
....................    #byte lcdlat = LCD_DATA_PORT 
....................    #byte lcdtris = LCD_DATA_PORT+0x80 
.................... #elif defined(__PCH__) 
....................    LCD_PIN_MAP lcd, lcdlat, lcdtris; 
....................    #byte lcd = LCD_DATA_PORT 
....................    #byte lcdlat = LCD_DATA_PORT+9 
....................    #byte lcdtris = LCD_DATA_PORT+0x12 
.................... #elif defined(__PCD__) 
....................    LCD_PIN_MAP lcd, lcdlat, lcdtris; 
....................    #word lcd = LCD_DATA_PORT 
....................    #word lcdlat = LCD_DATA_PORT+2 
....................    #word lcdtris = LCD_DATA_PORT-0x02 
.................... #endif 
.................... #endif   //LCD_DATA4 not defined 
....................  
.................... #ifndef LCD_TYPE 
....................    #define LCD_TYPE 2           // 0=5x7, 1=5x10, 2=2 lines 
.................... #endif 
....................  
.................... #ifndef LCD_LINE_TWO 
....................    #define LCD_LINE_TWO 0x40    // LCD RAM address for the second line 
.................... #endif 
....................  
.................... #ifndef LCD_LINE_LENGTH 
....................    #define LCD_LINE_LENGTH 20 
.................... #endif 
....................  
.................... unsigned int8 lcd_read_nibble(void); 
....................  
.................... unsigned int8 lcd_read_byte(void) 
.................... { 
....................    unsigned int8 low,high; 
....................  
....................  #if defined(__PCB__) 
....................    set_tris_lcd(LCD_INPUT_MAP); 
....................  #else 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    output_float(LCD_DATA4); 
*
01FC:  BSF    07.0
....................    output_float(LCD_DATA5); 
01FD:  BSF    07.1
....................    output_float(LCD_DATA6); 
01FE:  BSF    07.2
....................    output_float(LCD_DATA7); 
01FF:  BSF    07.3
....................   #else 
....................    lcdtris.data = 0xF; 
....................   #endif 
....................  #endif 
....................          
....................    lcd_output_rw(1); 
0200:  BCF    03.5
0201:  BSF    09.2
0202:  BSF    03.5
0203:  BCF    09.2
....................    delay_cycles(1); 
0204:  NOP
....................    lcd_output_enable(1); 
0205:  BCF    03.5
0206:  BSF    09.0
0207:  BSF    03.5
0208:  BCF    09.0
....................    delay_cycles(1); 
0209:  NOP
....................    high = lcd_read_nibble(); 
020A:  BCF    03.5
020B:  CALL   1B1
020C:  MOVF   78,W
020D:  BSF    03.6
020E:  MOVWF  4A
....................        
....................    lcd_output_enable(0); 
020F:  BCF    03.6
0210:  BCF    09.0
0211:  BSF    03.5
0212:  BCF    09.0
....................    delay_cycles(1); 
0213:  NOP
....................    lcd_output_enable(1); 
0214:  BCF    03.5
0215:  BSF    09.0
0216:  BSF    03.5
0217:  BCF    09.0
....................    delay_us(1); 
0218:  GOTO   219
0219:  GOTO   21A
021A:  NOP
....................    low = lcd_read_nibble(); 
021B:  BCF    03.5
021C:  CALL   1B1
021D:  MOVF   78,W
021E:  BSF    03.6
021F:  MOVWF  49
....................        
....................    lcd_output_enable(0); 
0220:  BCF    03.6
0221:  BCF    09.0
0222:  BSF    03.5
0223:  BCF    09.0
....................  
....................  #if defined(__PCB__) 
....................    set_tris_lcd(LCD_OUTPUT_MAP); 
....................  #else 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    output_drive(LCD_DATA4); 
0224:  BCF    03.5
0225:  BCF    31.0
0226:  MOVF   31,W
0227:  BSF    03.5
0228:  MOVWF  07
....................    output_drive(LCD_DATA5); 
0229:  BCF    03.5
022A:  BCF    31.1
022B:  MOVF   31,W
022C:  BSF    03.5
022D:  MOVWF  07
....................    output_drive(LCD_DATA6); 
022E:  BCF    03.5
022F:  BCF    31.2
0230:  MOVF   31,W
0231:  BSF    03.5
0232:  MOVWF  07
....................    output_drive(LCD_DATA7); 
0233:  BCF    03.5
0234:  BCF    31.3
0235:  MOVF   31,W
0236:  BSF    03.5
0237:  MOVWF  07
....................   #else 
....................    lcdtris.data = 0x0; 
....................   #endif 
....................  #endif 
....................  
....................    return( (high<<4) | low); 
0238:  BCF    03.5
0239:  BSF    03.6
023A:  SWAPF  4A,W
023B:  MOVWF  77
023C:  MOVLW  F0
023D:  ANDWF  77,F
023E:  MOVF   77,W
023F:  IORWF  49,W
0240:  MOVWF  78
.................... } 
....................  
.................... unsigned int8 lcd_read_nibble(void) 
.................... { 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
*
01B1:  BSF    03.6
01B2:  CLRF   4B
....................    unsigned int8 n = 0x00; 
....................  
....................    /* Read the data port */ 
....................    n |= input(LCD_DATA4); 
01B3:  BCF    03.6
01B4:  BSF    31.0
01B5:  MOVF   31,W
01B6:  BSF    03.5
01B7:  MOVWF  07
01B8:  MOVLW  00
01B9:  BCF    03.5
01BA:  BTFSC  07.0
01BB:  MOVLW  01
01BC:  BSF    03.6
01BD:  IORWF  4B,F
....................    n |= input(LCD_DATA5) << 1; 
01BE:  BCF    03.6
01BF:  BSF    31.1
01C0:  MOVF   31,W
01C1:  BSF    03.5
01C2:  MOVWF  07
01C3:  MOVLW  00
01C4:  BCF    03.5
01C5:  BTFSC  07.1
01C6:  MOVLW  01
01C7:  MOVWF  77
01C8:  BCF    03.0
01C9:  RLF    77,F
01CA:  MOVF   77,W
01CB:  BSF    03.6
01CC:  IORWF  4B,F
....................    n |= input(LCD_DATA6) << 2; 
01CD:  BCF    03.6
01CE:  BSF    31.2
01CF:  MOVF   31,W
01D0:  BSF    03.5
01D1:  MOVWF  07
01D2:  MOVLW  00
01D3:  BCF    03.5
01D4:  BTFSC  07.2
01D5:  MOVLW  01
01D6:  MOVWF  77
01D7:  RLF    77,F
01D8:  RLF    77,F
01D9:  MOVLW  FC
01DA:  ANDWF  77,F
01DB:  MOVF   77,W
01DC:  BSF    03.6
01DD:  IORWF  4B,F
....................    n |= input(LCD_DATA7) << 3; 
01DE:  BCF    03.6
01DF:  BSF    31.3
01E0:  MOVF   31,W
01E1:  BSF    03.5
01E2:  MOVWF  07
01E3:  MOVLW  00
01E4:  BCF    03.5
01E5:  BTFSC  07.3
01E6:  MOVLW  01
01E7:  MOVWF  77
01E8:  RLF    77,F
01E9:  RLF    77,F
01EA:  RLF    77,F
01EB:  MOVLW  F8
01EC:  ANDWF  77,F
01ED:  MOVF   77,W
01EE:  BSF    03.6
01EF:  IORWF  4B,F
....................     
....................    return(n); 
01F0:  MOVF   4B,W
01F1:  MOVWF  78
....................   #else 
01F2:  BCF    03.6
01F3:  RETURN
....................    return(lcd.data); 
....................   #endif 
.................... } 
....................  
.................... void lcd_send_nibble(unsigned int8 n) 
.................... { 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    /* Write to the data port */ 
....................    output_bit(LCD_DATA4, bit_test(n, 0)); 
*
0169:  BSF    03.6
016A:  BTFSC  4A.0
016B:  GOTO   170
016C:  BCF    03.6
016D:  BCF    07.0
016E:  GOTO   172
016F:  BSF    03.6
0170:  BCF    03.6
0171:  BSF    07.0
0172:  BCF    31.0
0173:  MOVF   31,W
0174:  BSF    03.5
0175:  MOVWF  07
....................    output_bit(LCD_DATA5, bit_test(n, 1)); 
0176:  BCF    03.5
0177:  BSF    03.6
0178:  BTFSC  4A.1
0179:  GOTO   17E
017A:  BCF    03.6
017B:  BCF    07.1
017C:  GOTO   180
017D:  BSF    03.6
017E:  BCF    03.6
017F:  BSF    07.1
0180:  BCF    31.1
0181:  MOVF   31,W
0182:  BSF    03.5
0183:  MOVWF  07
....................    output_bit(LCD_DATA6, bit_test(n, 2)); 
0184:  BCF    03.5
0185:  BSF    03.6
0186:  BTFSC  4A.2
0187:  GOTO   18C
0188:  BCF    03.6
0189:  BCF    07.2
018A:  GOTO   18E
018B:  BSF    03.6
018C:  BCF    03.6
018D:  BSF    07.2
018E:  BCF    31.2
018F:  MOVF   31,W
0190:  BSF    03.5
0191:  MOVWF  07
....................    output_bit(LCD_DATA7, bit_test(n, 3)); 
0192:  BCF    03.5
0193:  BSF    03.6
0194:  BTFSC  4A.3
0195:  GOTO   19A
0196:  BCF    03.6
0197:  BCF    07.3
0198:  GOTO   19C
0199:  BSF    03.6
019A:  BCF    03.6
019B:  BSF    07.3
019C:  BCF    31.3
019D:  MOVF   31,W
019E:  BSF    03.5
019F:  MOVWF  07
....................   #else       
....................    lcdlat.data = n; 
....................   #endif 
....................        
....................    delay_cycles(1); 
01A0:  NOP
....................    lcd_output_enable(1); 
01A1:  BCF    03.5
01A2:  BSF    09.0
01A3:  BSF    03.5
01A4:  BCF    09.0
....................    delay_us(2); 
01A5:  MOVLW  02
01A6:  MOVWF  77
01A7:  DECFSZ 77,F
01A8:  GOTO   1A7
01A9:  GOTO   1AA
01AA:  NOP
....................    lcd_output_enable(0); 
01AB:  BCF    03.5
01AC:  BCF    09.0
01AD:  BSF    03.5
01AE:  BCF    09.0
01AF:  BCF    03.5
01B0:  RETURN
.................... } 
....................  
.................... void lcd_send_byte(unsigned int8 address, unsigned int8 n) 
.................... { 
....................   #if defined(__PCB__) 
....................    set_tris_lcd(LCD_OUTPUT_MAP); 
....................   #else 
....................    lcd_enable_tris(); 
*
01F4:  BSF    03.5
01F5:  BCF    09.0
....................    lcd_rs_tris(); 
01F6:  BCF    09.1
....................    lcd_rw_tris(); 
01F7:  BCF    09.2
....................   #endif 
....................  
....................    lcd_output_rs(0); 
01F8:  BCF    03.5
01F9:  BCF    09.1
01FA:  BSF    03.5
01FB:  BCF    09.1
....................    while ( bit_test(lcd_read_byte(),7) ) ; 
*
0241:  MOVF   78,W
0242:  MOVWF  49
0243:  BTFSS  49.7
0244:  GOTO   248
0245:  BSF    03.5
0246:  BCF    03.6
0247:  GOTO   1FC
....................    lcd_output_rs(address); 
0248:  MOVF   47,F
0249:  BTFSS  03.2
024A:  GOTO   24F
024B:  BCF    03.6
024C:  BCF    09.1
024D:  GOTO   251
024E:  BSF    03.6
024F:  BCF    03.6
0250:  BSF    09.1
0251:  BSF    03.5
0252:  BCF    09.1
....................    delay_cycles(1); 
0253:  NOP
....................    lcd_output_rw(0); 
0254:  BCF    03.5
0255:  BCF    09.2
0256:  BSF    03.5
0257:  BCF    09.2
....................    delay_cycles(1); 
0258:  NOP
....................    lcd_output_enable(0); 
0259:  BCF    03.5
025A:  BCF    09.0
025B:  BSF    03.5
025C:  BCF    09.0
....................    lcd_send_nibble(n >> 4); 
025D:  BCF    03.5
025E:  BSF    03.6
025F:  SWAPF  48,W
0260:  MOVWF  49
0261:  MOVLW  0F
0262:  ANDWF  49,F
0263:  MOVF   49,W
0264:  MOVWF  4A
0265:  BCF    03.6
0266:  CALL   169
....................    lcd_send_nibble(n & 0xf); 
0267:  BSF    03.6
0268:  MOVF   48,W
0269:  ANDLW  0F
026A:  MOVWF  49
026B:  MOVWF  4A
026C:  BCF    03.6
026D:  CALL   169
026E:  RETURN
.................... } 
....................  
.................... #if defined(LCD_EXTENDED_NEWLINE) 
.................... unsigned int8 g_LcdX, g_LcdY; 
.................... #endif 
....................  
.................... void lcd_init(void)  
.................... { 
....................    unsigned int8 i; 
....................    unsigned int8 LCD_INIT_STRING[4] = {0x20 | (LCD_TYPE << 2), 0xc, 1, 6}; 
026F:  MOVLW  28
0270:  BSF    03.6
0271:  MOVWF  13
0272:  MOVLW  0C
0273:  MOVWF  14
0274:  MOVLW  01
0275:  MOVWF  15
0276:  MOVLW  06
0277:  MOVWF  16
....................                              // These bytes need to be sent to the LCD 
....................                              // to start it up. 
....................     
....................  
....................    lcd_output_enable(0); 
0278:  BCF    03.6
0279:  BCF    09.0
027A:  BSF    03.5
027B:  BCF    09.0
....................    lcd_output_rs(0); 
027C:  BCF    03.5
027D:  BCF    09.1
027E:  BSF    03.5
027F:  BCF    09.1
....................    lcd_output_rw(0); 
0280:  BCF    03.5
0281:  BCF    09.2
0282:  BSF    03.5
0283:  BCF    09.2
....................  
....................  #if defined(__PCB__) 
....................    set_tris_lcd(LCD_OUTPUT_MAP); 
....................  #else 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    output_drive(LCD_DATA4); 
0284:  BCF    03.5
0285:  BCF    31.0
0286:  MOVF   31,W
0287:  BSF    03.5
0288:  MOVWF  07
....................    output_drive(LCD_DATA5); 
0289:  BCF    03.5
028A:  BCF    31.1
028B:  MOVF   31,W
028C:  BSF    03.5
028D:  MOVWF  07
....................    output_drive(LCD_DATA6); 
028E:  BCF    03.5
028F:  BCF    31.2
0290:  MOVF   31,W
0291:  BSF    03.5
0292:  MOVWF  07
....................    output_drive(LCD_DATA7); 
0293:  BCF    03.5
0294:  BCF    31.3
0295:  MOVF   31,W
0296:  BSF    03.5
0297:  MOVWF  07
....................   #else 
....................    lcdtris.data = 0x0; 
....................   #endif 
....................    lcd_enable_tris(); 
0298:  BCF    09.0
....................    lcd_rs_tris(); 
0299:  BCF    09.1
....................    lcd_rw_tris(); 
029A:  BCF    09.2
....................  #endif 
....................      
....................    delay_ms(15); 
029B:  MOVLW  0F
029C:  BCF    03.5
029D:  BSF    03.6
029E:  MOVWF  43
029F:  BCF    03.6
02A0:  CALL   155
....................    for(i=1;i<=3;++i) 
02A1:  MOVLW  01
02A2:  BSF    03.6
02A3:  MOVWF  12
02A4:  MOVF   12,W
02A5:  SUBLW  03
02A6:  BTFSS  03.0
02A7:  GOTO   2B4
....................    { 
....................        lcd_send_nibble(3); 
02A8:  MOVLW  03
02A9:  MOVWF  4A
02AA:  BCF    03.6
02AB:  CALL   169
....................        delay_ms(5); 
02AC:  MOVLW  05
02AD:  BSF    03.6
02AE:  MOVWF  43
02AF:  BCF    03.6
02B0:  CALL   155
02B1:  BSF    03.6
02B2:  INCF   12,F
02B3:  GOTO   2A4
....................    } 
....................     
....................    lcd_send_nibble(2); 
02B4:  MOVLW  02
02B5:  MOVWF  4A
02B6:  BCF    03.6
02B7:  CALL   169
....................    delay_ms(5); 
02B8:  MOVLW  05
02B9:  BSF    03.6
02BA:  MOVWF  43
02BB:  BCF    03.6
02BC:  CALL   155
....................    for(i=0;i<=3;++i) 
02BD:  BSF    03.6
02BE:  CLRF   12
02BF:  MOVF   12,W
02C0:  SUBLW  03
02C1:  BTFSS  03.0
02C2:  GOTO   2D1
....................       lcd_send_byte(0,LCD_INIT_STRING[i]); 
02C3:  MOVLW  13
02C4:  ADDWF  12,W
02C5:  MOVWF  04
02C6:  BSF    03.7
02C7:  MOVF   00,W
02C8:  MOVWF  17
02C9:  CLRF   47
02CA:  MOVF   17,W
02CB:  MOVWF  48
02CC:  BCF    03.6
02CD:  CALL   1F4
....................  
....................   #if defined(LCD_EXTENDED_NEWLINE) 
02CE:  BSF    03.6
02CF:  INCF   12,F
02D0:  GOTO   2BF
02D1:  BCF    03.6
02D2:  BCF    0A.3
02D3:  BSF    0A.4
02D4:  GOTO   1F5 (RETURN)
....................    g_LcdX = 0; 
....................    g_LcdY = 0; 
....................   #endif 
.................... } 
....................  
.................... void lcd_gotoxy(unsigned int8 x, unsigned int8 y) 
.................... { 
....................    unsigned int8 address; 
....................     
....................    if(y!=1) 
*
0310:  BSF    03.6
0311:  DECFSZ 44,W
0312:  GOTO   314
0313:  GOTO   317
....................       address=LCD_LINE_TWO; 
0314:  MOVLW  40
0315:  MOVWF  45
0316:  GOTO   318
....................    else 
....................       address=0; 
0317:  CLRF   45
....................       
....................    address+=x-1; 
0318:  MOVLW  01
0319:  SUBWF  43,W
031A:  ADDWF  45,F
....................    lcd_send_byte(0,0x80|address); 
031B:  MOVF   45,W
031C:  IORLW  80
031D:  MOVWF  46
031E:  CLRF   47
031F:  MOVF   46,W
0320:  MOVWF  48
0321:  BCF    03.6
0322:  CALL   1F4
....................  
....................   #if defined(LCD_EXTENDED_NEWLINE) 
0323:  RETURN
....................    g_LcdX = x - 1; 
....................    g_LcdY = y - 1; 
....................   #endif 
.................... } 
....................  
.................... void lcd_putc(char c) 
.................... { 
....................    switch (c) 
0324:  BSF    03.6
0325:  MOVF   42,W
0326:  XORLW  07
0327:  BCF    03.6
0328:  BTFSC  03.2
0329:  GOTO   334
032A:  XORLW  0B
032B:  BTFSC  03.2
032C:  GOTO   33B
032D:  XORLW  06
032E:  BTFSC  03.2
032F:  GOTO   347
0330:  XORLW  02
0331:  BTFSC  03.2
0332:  GOTO   34F
0333:  GOTO   356
....................    { 
....................       case '\a'   :  lcd_gotoxy(1,1);     break; 
0334:  MOVLW  01
0335:  BSF    03.6
0336:  MOVWF  43
0337:  MOVWF  44
0338:  BCF    03.6
0339:  CALL   310
033A:  GOTO   35D
....................  
....................       case '\f'   :  lcd_send_byte(0,1); 
033B:  BSF    03.6
033C:  CLRF   47
033D:  MOVLW  01
033E:  MOVWF  48
033F:  BCF    03.6
0340:  CALL   1F4
....................                      delay_ms(2); 
0341:  MOVLW  02
0342:  BSF    03.6
0343:  MOVWF  43
0344:  BCF    03.6
0345:  CALL   155
....................                     #if defined(LCD_EXTENDED_NEWLINE) 
....................                      g_LcdX = 0; 
....................                      g_LcdY = 0; 
....................                     #endif 
....................                      break; 
0346:  GOTO   35D
....................  
....................      #if defined(LCD_EXTENDED_NEWLINE) 
....................       case '\r'   :  lcd_gotoxy(1, g_LcdY+1);   break; 
....................       case '\n'   : 
....................          while (g_LcdX++ < LCD_LINE_LENGTH) 
....................          { 
....................             lcd_send_byte(1, ' '); 
....................          } 
....................          lcd_gotoxy(1, g_LcdY+2); 
....................          break; 
....................      #else 
....................       case '\n'   : lcd_gotoxy(1,2);        break; 
0347:  MOVLW  01
0348:  BSF    03.6
0349:  MOVWF  43
034A:  MOVLW  02
034B:  MOVWF  44
034C:  BCF    03.6
034D:  CALL   310
034E:  GOTO   35D
....................      #endif 
....................       
....................       case '\b'   : lcd_send_byte(0,0x10);  break; 
034F:  BSF    03.6
0350:  CLRF   47
0351:  MOVLW  10
0352:  MOVWF  48
0353:  BCF    03.6
0354:  CALL   1F4
0355:  GOTO   35D
....................       
....................      #if defined(LCD_EXTENDED_NEWLINE) 
....................       default     :  
....................          if (g_LcdX < LCD_LINE_LENGTH) 
....................          { 
....................             lcd_send_byte(1, c); 
....................             g_LcdX++; 
....................          } 
....................          break; 
....................      #else 
....................       default     : lcd_send_byte(1,c);     break; 
0356:  MOVLW  01
0357:  BSF    03.6
0358:  MOVWF  47
0359:  MOVF   42,W
035A:  MOVWF  48
035B:  BCF    03.6
035C:  CALL   1F4
....................      #endif 
....................    } 
035D:  RETURN
.................... } 
....................   
.................... char lcd_getc(unsigned int8 x, unsigned int8 y) 
.................... { 
....................    char value; 
....................  
....................    lcd_gotoxy(x,y); 
....................    while ( bit_test(lcd_read_byte(),7) ); // wait until busy flag is low 
....................    lcd_output_rs(1); 
....................    value = lcd_read_byte(); 
....................    lcd_output_rs(0); 
....................     
....................    return(value); 
.................... } 
....................  
.................... // write a custom character to the ram 
.................... // which is 0-7 and specifies which character array we are modifying. 
.................... // ptr points to an array of 8 bytes, where each byte is the next row of 
.................... //    pixels.  only bits 0-4 are used.  the last row is the cursor row, and 
.................... //    usually you will want to leave this byte 0x00. 
.................... void lcd_set_cgram_char(unsigned int8 which, unsigned int8 *ptr) 
.................... { 
....................    unsigned int i; 
....................  
....................    which <<= 3; 
....................    which &= 0x38; 
....................  
....................    lcd_send_byte(0, 0x40 | which);  //set cgram address 
....................  
....................    for(i=0; i<8; i++) 
....................    { 
....................       lcd_send_byte(1, *ptr++); 
....................    } 
....................    
....................    #if defined(LCD_EXTENDED_NEWLINE) 
....................     lcd_gotoxy(g_LcdX+1, g_LcdY+1);  //set ddram address 
....................    #endif 
.................... } 
....................  
.................... void lcd_cursor_on(int1 on) 
.................... { 
....................    if (on) 
....................    { 
....................       lcd_send_byte(0,0x0F);           //turn LCD cursor ON 
....................    } 
....................    else 
....................    { 
....................       lcd_send_byte(0,0x0C);           //turn LCD cursor OFF 
....................    } 
.................... } 
....................  
.................... #endif 
....................  
.................... #BIT TMR1IF = 0x0C.0 //bit thu 0 (TMR1IF) cua PIR1 
....................  
.................... #INCLUDE <khaibaobien.c> // VARIABLE. 
.................... UNSIGNED INT16 KQADC; 
.................... UNSIGNED INT8 KET_QUA_ANALOG[]={0,0,0,0}; 
*
1160:  CLRF   34
1161:  CLRF   35
1162:  CLRF   36
1163:  CLRF   37
.................... UNSIGNED INT8 CONFIG_FUN=0; 
.................... UNSIGNED INT8 VT=0, KYTU=0;// KYTU[30],  
.................... UNSIGNED INT8 LENH_DIEU_KHIEN = 0; 
.................... UNSIGNED INT8 ID_GATEWAY[6] = {3,8,6,9,0,7}; 
1164:  MOVLW  03
1165:  MOVWF  3C
1166:  MOVLW  08
1167:  MOVWF  3D
1168:  MOVLW  06
1169:  MOVWF  3E
116A:  MOVLW  09
116B:  MOVWF  3F
116C:  CLRF   40
116D:  MOVLW  07
116E:  MOVWF  41
.................... UNSIGNED INT8 ID_NODE[4] = {1,8,1,0}; 
116F:  MOVLW  01
1170:  MOVWF  42
1171:  MOVLW  08
1172:  MOVWF  43
1173:  MOVLW  01
1174:  MOVWF  44
1175:  CLRF   45
.................... UNSIGNED INT8 LEN_PACKAGES = 0; 
.................... UNSIGNED INT8 LENHDIEUKHIEN =0, DODAI_DATA_NHAN =0; 
.................... UNSIGNED INT8 SOLUONGTHIETBI_CONFIG=0, SOLUONGCAMBIEN_CONFIG = 3; 
.................... SIGNED INT8 SOSANH_IDNODE=0, SOSANH_IDGW=0; 
.................... //INT1 TT_THIETBI [8]={0,0,0,0,0,0,0,0}; 
.................... INT1 TT_THIETBI_TEMP [8]={0,0,0,0,0,0,0,0}; 
1176:  CLRF   4D
.................... INT1 TTNHAN = 0, TT_CONFIG=0, TT_CONTROL=0,TT_CONFIG_DONE=0, TT_FUN=0, TT_STT=0 , TT_CONFIG_OKE_UART = 0, TT_SW = 0; 
....................  
.................... CHAR *ID_NODE_CHAR[]= "0589"; 
1177:  MOVLW  30
1178:  MOVWF  51
1179:  MOVLW  35
117A:  MOVWF  52
117B:  MOVLW  38
117C:  MOVWF  53
117D:  MOVLW  39
117E:  MOVWF  54
117F:  CLRF   55
1180:  CLRF   50
1181:  MOVLW  51
1182:  MOVWF  4F
.................... CHAR *ID_GATEWAY_CHAR[]= "127102"; 
1183:  MOVLW  31
1184:  MOVWF  58
1185:  MOVLW  32
1186:  MOVWF  59
1187:  MOVLW  37
1188:  MOVWF  5A
1189:  MOVLW  31
118A:  MOVWF  5B
118B:  MOVLW  30
118C:  MOVWF  5C
118D:  MOVLW  32
118E:  MOVWF  5D
118F:  CLRF   5E
1190:  CLRF   57
1191:  MOVLW  58
1192:  MOVWF  56
.................... CHAR *ID_NODE_NHAN[]= "0000"; 
1193:  MOVLW  30
1194:  MOVWF  61
1195:  MOVWF  62
1196:  MOVWF  63
1197:  MOVWF  64
1198:  CLRF   65
1199:  CLRF   60
119A:  MOVLW  61
119B:  MOVWF  5F
.................... CHAR *ID_GW_NHAN[]= "000000"; 
119C:  MOVLW  30
119D:  MOVWF  68
119E:  MOVWF  69
119F:  MOVWF  6A
11A0:  MOVWF  6B
11A1:  MOVWF  6C
11A2:  MOVWF  6D
11A3:  CLRF   6E
11A4:  CLRF   67
11A5:  MOVLW  68
11A6:  MOVWF  66
.................... CHAR KYTUCHAR[50]="HIHI"; 
11A7:  MOVLW  48
11A8:  BSF    03.5
11A9:  MOVWF  20
11AA:  MOVLW  49
11AB:  MOVWF  21
11AC:  MOVLW  48
11AD:  MOVWF  22
11AE:  MOVLW  49
11AF:  MOVWF  23
11B0:  CLRF   24
.................... CHAR KYTUCHAR2[25]="HIHI"; 
11B1:  MOVLW  48
11B2:  MOVWF  52
11B3:  MOVLW  49
11B4:  MOVWF  53
11B5:  MOVLW  48
11B6:  MOVWF  54
11B7:  MOVLW  49
11B8:  MOVWF  55
11B9:  CLRF   56
.................... //CHAR *DATA_NHANDUOC[]={"IDGW","IDNODE","COMMAN","DATA"}; 
.................... CHAR *TEMP_CHAR[]="0000";   
11BA:  MOVLW  30
11BB:  MOVWF  71
11BC:  MOVWF  72
11BD:  MOVWF  73
11BE:  MOVWF  74
11BF:  CLRF   75
11C0:  CLRF   70
11C1:  MOVLW  71
11C2:  BCF    03.5
11C3:  MOVWF  6F
.................... CHAR *TEMP_CHAR2[]="2700";  
11C4:  MOVLW  32
11C5:  BSF    03.5
11C6:  MOVWF  6B
11C7:  MOVLW  37
11C8:  MOVWF  6C
11C9:  MOVLW  30
11CA:  MOVWF  6D
11CB:  MOVWF  6E
11CC:  CLRF   6F
11CD:  CLRF   7C
11CE:  MOVLW  EB
11CF:  MOVWF  7B
.................... //CHAR *TEMP_CHAR3[]="000000";  
....................  
....................  
....................  
.................... //#INCLUDE <CONFIG_NODE.C> // CU HINH NODE. 
.................... #INCLUDE <config_1.C> // CU HINH NODE. 
....................  
.................... //--------------------------------------------------------------------// 
.................... VOID CHON_ID() 
.................... { 
....................    // TT_CONFIG_DONE; 
....................    TT_CONFIG_DONE = 0; 
*
05F7:  BCF    4E.3
....................    TT_STT = 1; 
05F8:  BSF    4E.5
....................    UNSIGNED INT8 NUM = 0; 
05F9:  BSF    03.6
05FA:  CLRF   12
....................    TEMP_CHAR = "0"; 
05FB:  CLRF   13
05FC:  CLRF   14
05FD:  MOVLW  6F
05FE:  MOVWF  04
05FF:  BCF    03.7
0600:  MOVF   13,W
0601:  ADDWF  04,F
0602:  MOVF   14,W
0603:  BCF    03.6
0604:  CALL   058
0605:  MOVWF  00
0606:  IORLW  00
0607:  BTFSC  03.2
0608:  GOTO   60E
0609:  BSF    03.6
060A:  INCF   14,F
060B:  INCF   13,F
060C:  GOTO   5FD
060D:  BCF    03.6
....................    LCD_GOTOXY (1, 2) ; 
060E:  MOVLW  01
060F:  BSF    03.6
0610:  MOVWF  43
0611:  MOVLW  02
0612:  MOVWF  44
0613:  BCF    03.6
0614:  CALL   310
....................    DELAY_MS (10); 
0615:  MOVLW  0A
0616:  BSF    03.6
0617:  MOVWF  43
0618:  BCF    03.6
0619:  CALL   155
....................    PRINTF (LCD_PUTC, "NODE: "); 
061A:  MOVLW  6F
061B:  BSF    03.6
061C:  MOVWF  0D
061D:  MOVLW  00
061E:  MOVWF  0F
061F:  BCF    03.6
0620:  CALL   35E
....................    PRINTF (LCD_PUTC, "0000          "); 
0621:  MOVLW  73
0622:  BSF    03.6
0623:  MOVWF  0D
0624:  MOVLW  00
0625:  MOVWF  0F
0626:  BCF    03.6
0627:  CALL   35E
....................    LCD_GOTOXY (1, 1) ; 
0628:  MOVLW  01
0629:  BSF    03.6
062A:  MOVWF  43
062B:  MOVWF  44
062C:  BCF    03.6
062D:  CALL   310
....................    PRINTF (LCD_PUTC, "      _              ");//6 SPACE PHIA TRUOC "_" 
062E:  MOVLW  7B
062F:  BSF    03.6
0630:  MOVWF  0D
0631:  MOVLW  00
0632:  MOVWF  0F
0633:  BCF    03.6
0634:  CALL   35E
....................    //ID_GW = "1234";     
....................  
....................    WHILE (TT_STT) 
0635:  BTFSS  4E.5
0636:  GOTO   6B3
....................    { 
....................       IF (!INPUT (BT2_PIN)) //NEU NUT BAM DUOC BAM 
0637:  BSF    03.5
0638:  BSF    06.2
0639:  BCF    03.5
063A:  BTFSC  06.2
063B:  GOTO   65A
....................       { 
....................           
....................          NUM++; 
063C:  BSF    03.6
063D:  INCF   12,F
....................          NUM = NUM % 4; 
063E:  MOVLW  03
063F:  ANDWF  12,F
....................          LCD_GOTOXY (3 + NUM, 1); 
0640:  ADDWF  12,W
0641:  MOVWF  13
0642:  MOVWF  43
0643:  MOVLW  01
0644:  MOVWF  44
0645:  BCF    03.6
0646:  CALL   310
....................          PRINTF (LCD_PUTC, "    _    ");//4SPACE 
0647:  MOVLW  86
0648:  BSF    03.6
0649:  MOVWF  0D
064A:  MOVLW  00
064B:  MOVWF  0F
064C:  BCF    03.6
064D:  CALL   35E
....................          DELAY_MS (300);  
064E:  MOVLW  02
064F:  BSF    03.6
0650:  MOVWF  13
0651:  MOVLW  96
0652:  MOVWF  43
0653:  BCF    03.6
0654:  CALL   155
0655:  BSF    03.6
0656:  DECFSZ 13,F
0657:  GOTO   651
....................       } 
0658:  GOTO   6B1
0659:  BCF    03.6
....................  
....................       ELSE IF (!INPUT (BT3_PIN)) 
065A:  BSF    03.5
065B:  BSF    06.3
065C:  BCF    03.5
065D:  BTFSC  06.3
065E:  GOTO   6B2
....................       { 
....................          ID_NODE[NUM]++; 
065F:  MOVLW  42
0660:  BSF    03.6
0661:  ADDWF  12,W
0662:  MOVWF  04
0663:  BCF    03.7
0664:  INCF   00,F
....................          ID_NODE[NUM] = ID_NODE[NUM] % 10; 
0665:  MOVLW  42
0666:  ADDWF  12,W
0667:  MOVWF  78
0668:  CLRF   7A
0669:  BTFSC  03.0
066A:  INCF   7A,F
066B:  MOVF   78,W
066C:  MOVWF  13
066D:  MOVF   7A,W
066E:  MOVWF  14
066F:  MOVLW  42
0670:  ADDWF  12,W
0671:  MOVWF  04
0672:  BCF    03.7
0673:  MOVF   00,W
0674:  MOVWF  16
0675:  MOVLW  0A
0676:  MOVWF  17
0677:  BCF    03.6
0678:  CALL   567
0679:  MOVF   77,W
067A:  BSF    03.6
067B:  MOVWF  15
067C:  MOVF   13,W
067D:  MOVWF  04
067E:  BCF    03.7
067F:  BTFSC  14.0
0680:  BSF    03.7
0681:  MOVF   15,W
0682:  MOVWF  00
....................          ITOA (ID_NODE[NUM], 10, TEMP_CHAR); 
0683:  MOVLW  42
0684:  ADDWF  12,W
0685:  MOVWF  04
0686:  BCF    03.7
0687:  MOVF   00,W
0688:  MOVWF  13
0689:  CLRF   44
068A:  CLRF   43
068B:  CLRF   42
068C:  MOVF   13,W
068D:  MOVWF  41
068E:  MOVLW  0A
068F:  MOVWF  45
0690:  CLRF   47
0691:  MOVLW  6F
0692:  MOVWF  46
0693:  BCF    03.6
0694:  CALL   42A
....................          LCD_GOTOXY (7 + NUM, 2); 
0695:  MOVLW  07
0696:  BSF    03.6
0697:  ADDWF  12,W
0698:  MOVWF  13
0699:  MOVWF  43
069A:  MOVLW  02
069B:  MOVWF  44
069C:  BCF    03.6
069D:  CALL   310
....................          DELAY_MS (10); 
069E:  MOVLW  0A
069F:  BSF    03.6
06A0:  MOVWF  43
06A1:  BCF    03.6
06A2:  CALL   155
....................          PRINTF (LCD_PUTC, TEMP_CHAR); 
06A3:  MOVLW  6F
06A4:  MOVWF  04
06A5:  BCF    03.7
06A6:  CALL   54A
....................          DELAY_MS (300); 
06A7:  MOVLW  02
06A8:  BSF    03.6
06A9:  MOVWF  13
06AA:  MOVLW  96
06AB:  MOVWF  43
06AC:  BCF    03.6
06AD:  CALL   155
06AE:  BSF    03.6
06AF:  DECFSZ 13,F
06B0:  GOTO   6AA
06B1:  BCF    03.6
....................       } 
06B2:  GOTO   635
....................    } 
.................... } 
....................  
.................... VOID NHAPID_GW() 
*
06B4:  BSF    03.6
06B5:  CLRF   12
.................... { 
....................    UNSIGNED INT8 NUM = 0; 
....................    TEMP_CHAR = "0"; 
06B6:  CLRF   13
06B7:  CLRF   14
06B8:  MOVLW  6F
06B9:  MOVWF  04
06BA:  BCF    03.7
06BB:  MOVF   13,W
06BC:  ADDWF  04,F
06BD:  MOVF   14,W
06BE:  BCF    03.6
06BF:  CALL   058
06C0:  MOVWF  00
06C1:  IORLW  00
06C2:  BTFSC  03.2
06C3:  GOTO   6C9
06C4:  BSF    03.6
06C5:  INCF   14,F
06C6:  INCF   13,F
06C7:  GOTO   6B8
06C8:  BCF    03.6
....................    TT_CONFIG_DONE = 0; 
06C9:  BCF    4E.3
....................    TT_STT = 1; 
06CA:  BSF    4E.5
....................    LCD_GOTOXY (1, 2) ; 
06CB:  MOVLW  01
06CC:  BSF    03.6
06CD:  MOVWF  43
06CE:  MOVLW  02
06CF:  MOVWF  44
06D0:  BCF    03.6
06D1:  CALL   310
....................    DELAY_MS (10); 
06D2:  MOVLW  0A
06D3:  BSF    03.6
06D4:  MOVWF  43
06D5:  BCF    03.6
06D6:  CALL   155
....................    PRINTF (LCD_PUTC, "ID_GW:"); 
06D7:  MOVLW  8B
06D8:  BSF    03.6
06D9:  MOVWF  0D
06DA:  MOVLW  00
06DB:  MOVWF  0F
06DC:  BCF    03.6
06DD:  CALL   35E
....................    PRINTF (LCD_PUTC, "000000        "); 
06DE:  MOVLW  8F
06DF:  BSF    03.6
06E0:  MOVWF  0D
06E1:  MOVLW  00
06E2:  MOVWF  0F
06E3:  BCF    03.6
06E4:  CALL   35E
....................    LCD_GOTOXY (1, 1) ; 
06E5:  MOVLW  01
06E6:  BSF    03.6
06E7:  MOVWF  43
06E8:  MOVWF  44
06E9:  BCF    03.6
06EA:  CALL   310
....................    PRINTF (LCD_PUTC, "      _                ");//6 SPACE PHIA TRUOC "_" 
06EB:  MOVLW  97
06EC:  BSF    03.6
06ED:  MOVWF  0D
06EE:  MOVLW  00
06EF:  MOVWF  0F
06F0:  BCF    03.6
06F1:  CALL   35E
....................    //ID_GW = "1234";     
....................  
....................    WHILE (TT_STT) 
06F2:  BTFSS  4E.5
06F3:  GOTO   778
....................    { 
....................       IF (!INPUT (BT2_PIN)) //NEU NUT BAM DUOC BAM 
06F4:  BSF    03.5
06F5:  BSF    06.2
06F6:  BCF    03.5
06F7:  BTFSC  06.2
06F8:  GOTO   71F
....................       { 
....................           
....................          NUM++; 
06F9:  BSF    03.6
06FA:  INCF   12,F
....................          NUM = NUM % 6; 
06FB:  MOVF   12,W
06FC:  MOVWF  16
06FD:  MOVLW  06
06FE:  MOVWF  17
06FF:  BCF    03.6
0700:  CALL   567
0701:  MOVF   77,W
0702:  BSF    03.6
0703:  MOVWF  12
....................          LCD_GOTOXY (3 + NUM, 1); 
0704:  MOVLW  03
0705:  ADDWF  12,W
0706:  MOVWF  13
0707:  MOVWF  43
0708:  MOVLW  01
0709:  MOVWF  44
070A:  BCF    03.6
070B:  CALL   310
....................          PRINTF (LCD_PUTC, "    _        ");//4SPACE 
070C:  MOVLW  A3
070D:  BSF    03.6
070E:  MOVWF  0D
070F:  MOVLW  00
0710:  MOVWF  0F
0711:  BCF    03.6
0712:  CALL   35E
....................          DELAY_MS (300);  
0713:  MOVLW  02
0714:  BSF    03.6
0715:  MOVWF  13
0716:  MOVLW  96
0717:  MOVWF  43
0718:  BCF    03.6
0719:  CALL   155
071A:  BSF    03.6
071B:  DECFSZ 13,F
071C:  GOTO   716
....................       } 
071D:  GOTO   776
071E:  BCF    03.6
....................  
....................       ELSE IF (!INPUT (BT3_PIN)) 
071F:  BSF    03.5
0720:  BSF    06.3
0721:  BCF    03.5
0722:  BTFSC  06.3
0723:  GOTO   777
....................       { 
....................          ID_GATEWAY[NUM]++; 
0724:  MOVLW  3C
0725:  BSF    03.6
0726:  ADDWF  12,W
0727:  MOVWF  04
0728:  BCF    03.7
0729:  INCF   00,F
....................          ID_GATEWAY[NUM] = ID_GATEWAY[NUM] % 10; 
072A:  MOVLW  3C
072B:  ADDWF  12,W
072C:  MOVWF  78
072D:  CLRF   7A
072E:  BTFSC  03.0
072F:  INCF   7A,F
0730:  MOVF   78,W
0731:  MOVWF  13
0732:  MOVF   7A,W
0733:  MOVWF  14
0734:  MOVLW  3C
0735:  ADDWF  12,W
0736:  MOVWF  04
0737:  BCF    03.7
0738:  MOVF   00,W
0739:  MOVWF  16
073A:  MOVLW  0A
073B:  MOVWF  17
073C:  BCF    03.6
073D:  CALL   567
073E:  MOVF   77,W
073F:  BSF    03.6
0740:  MOVWF  15
0741:  MOVF   13,W
0742:  MOVWF  04
0743:  BCF    03.7
0744:  BTFSC  14.0
0745:  BSF    03.7
0746:  MOVF   15,W
0747:  MOVWF  00
....................          ITOA (ID_GATEWAY[NUM], 10, TEMP_CHAR); 
0748:  MOVLW  3C
0749:  ADDWF  12,W
074A:  MOVWF  04
074B:  BCF    03.7
074C:  MOVF   00,W
074D:  MOVWF  13
074E:  CLRF   44
074F:  CLRF   43
0750:  CLRF   42
0751:  MOVF   13,W
0752:  MOVWF  41
0753:  MOVLW  0A
0754:  MOVWF  45
0755:  CLRF   47
0756:  MOVLW  6F
0757:  MOVWF  46
0758:  BCF    03.6
0759:  CALL   42A
....................          LCD_GOTOXY (7 + NUM, 2); 
075A:  MOVLW  07
075B:  BSF    03.6
075C:  ADDWF  12,W
075D:  MOVWF  13
075E:  MOVWF  43
075F:  MOVLW  02
0760:  MOVWF  44
0761:  BCF    03.6
0762:  CALL   310
....................          DELAY_MS (10); 
0763:  MOVLW  0A
0764:  BSF    03.6
0765:  MOVWF  43
0766:  BCF    03.6
0767:  CALL   155
....................          PRINTF (LCD_PUTC, TEMP_CHAR); 
0768:  MOVLW  6F
0769:  MOVWF  04
076A:  BCF    03.7
076B:  CALL   54A
....................          DELAY_MS (300); 
076C:  MOVLW  02
076D:  BSF    03.6
076E:  MOVWF  13
076F:  MOVLW  96
0770:  MOVWF  43
0771:  BCF    03.6
0772:  CALL   155
0773:  BSF    03.6
0774:  DECFSZ 13,F
0775:  GOTO   76F
0776:  BCF    03.6
....................       } 
0777:  GOTO   6F2
....................    } 
.................... } 
....................  
.................... VOID BUTT_OKE() 
.................... { 
....................    TT_CONFIG_DONE = 0; 
*
0122:  BCF    03.6
0123:  BCF    4E.3
....................    TT_FUN = 0;//BREAK WHILE BUTT_FUN 
0124:  BCF    4E.4
....................    TT_STT = 0;// BREAK WHILE CHONID/NHAPID_GW 
0125:  BCF    4E.5
.................... } 
....................  
.................... VOID SELLECT_FUN() 
.................... { 
....................    TT_CONFIG_DONE = 0; 
*
05EF:  BCF    4E.3
....................  
....................    SWITCH (CONFIG_FUN) 
05F0:  MOVF   38,W
05F1:  BTFSC  03.2
05F2:  GOTO   5F7
05F3:  XORLW  01
05F4:  BTFSC  03.2
05F5:  GOTO   6B4
05F6:  GOTO   778
....................    { 
....................       CASE 0: 
....................       CHON_ID (); 
....................       BREAK; 
*
06B3:  GOTO   778
....................  
....................       CASE 1:     
....................       NHAPID_GW (); 
....................       BREAK; 
....................    } 
.................... } 
....................  
.................... VOID BUTT_FUN() 
.................... { 
....................    TT_FUN = 1; 
*
057E:  BSF    4E.4
....................    LCD_GOTOXY (1, 1) ; 
057F:  MOVLW  01
0580:  BSF    03.6
0581:  MOVWF  43
0582:  MOVWF  44
0583:  BCF    03.6
0584:  CALL   310
....................    DELAY_MS (10); 
0585:  MOVLW  0A
0586:  BSF    03.6
0587:  MOVWF  43
0588:  BCF    03.6
0589:  CALL   155
....................    PRINTF (LCD_PUTC, "CONFIG:        "); 
058A:  MOVLW  AA
058B:  BSF    03.6
058C:  MOVWF  0D
058D:  MOVLW  00
058E:  MOVWF  0F
058F:  BCF    03.6
0590:  CALL   35E
....................  
....................    // HIEN THI LCD 
....................    LCD_GOTOXY (1, 2) ; 
0591:  MOVLW  01
0592:  BSF    03.6
0593:  MOVWF  43
0594:  MOVLW  02
0595:  MOVWF  44
0596:  BCF    03.6
0597:  CALL   310
....................    DELAY_MS (10); 
0598:  MOVLW  0A
0599:  BSF    03.6
059A:  MOVWF  43
059B:  BCF    03.6
059C:  CALL   155
....................    PRINTF (LCD_PUTC, "CASE:          ") ; 
059D:  MOVLW  B2
059E:  BSF    03.6
059F:  MOVWF  0D
05A0:  MOVLW  00
05A1:  MOVWF  0F
05A2:  BCF    03.6
05A3:  CALL   35E
....................  
....................    WHILE (TT_FUN) 
05A4:  BTFSS  4E.4
05A5:  GOTO   5ED
....................    { 
....................       IF (INPUT (BT2_PIN) == 0) //NEU NUT BAM DUOC BAM 
05A6:  BSF    03.5
05A7:  BSF    06.2
05A8:  BCF    03.5
05A9:  BTFSC  06.2
05AA:  GOTO   5EC
....................       { 
....................          CONFIG_FUN ++; 
05AB:  INCF   38,F
....................          CONFIG_FUN = CONFIG_FUN % 2; 
05AC:  MOVLW  01
05AD:  ANDWF  38,F
....................          DELAY_MS (300); 
05AE:  MOVLW  02
05AF:  BSF    03.6
05B0:  MOVWF  12
05B1:  MOVLW  96
05B2:  MOVWF  43
05B3:  BCF    03.6
05B4:  CALL   155
05B5:  BSF    03.6
05B6:  DECFSZ 12,F
05B7:  GOTO   5B1
....................          //HIEN THI 
....................          LCD_GOTOXY (6, 2) ; 
05B8:  MOVLW  06
05B9:  MOVWF  43
05BA:  MOVLW  02
05BB:  MOVWF  44
05BC:  BCF    03.6
05BD:  CALL   310
....................          ITOA (CONFIG_FUN, 10, TEMP_CHAR); 
05BE:  BSF    03.6
05BF:  CLRF   44
05C0:  CLRF   43
05C1:  CLRF   42
05C2:  BCF    03.6
05C3:  MOVF   38,W
05C4:  BSF    03.6
05C5:  MOVWF  41
05C6:  MOVLW  0A
05C7:  MOVWF  45
05C8:  CLRF   47
05C9:  MOVLW  6F
05CA:  MOVWF  46
05CB:  BCF    03.6
05CC:  CALL   42A
....................          DELAY_MS (10); 
05CD:  MOVLW  0A
05CE:  BSF    03.6
05CF:  MOVWF  43
05D0:  BCF    03.6
05D1:  CALL   155
....................          PRINTF (LCD_PUTC, TEMP_CHAR); 
05D2:  MOVLW  6F
05D3:  MOVWF  04
05D4:  BCF    03.7
05D5:  CALL   54A
....................  
....................          SWITCH (CONFIG_FUN) 
05D6:  MOVF   38,W
05D7:  BTFSC  03.2
05D8:  GOTO   5DD
05D9:  XORLW  01
05DA:  BTFSC  03.2
05DB:  GOTO   5E5
05DC:  GOTO   5EC
....................          { 
....................             CASE 0: 
....................             PRINTF (LCD_PUTC, " - ID-NODE      "); 
05DD:  MOVLW  BA
05DE:  BSF    03.6
05DF:  MOVWF  0D
05E0:  MOVLW  00
05E1:  MOVWF  0F
05E2:  BCF    03.6
05E3:  CALL   35E
....................             BREAK; 
05E4:  GOTO   5EC
....................  
....................             CASE 1: 
....................             PRINTF (LCD_PUTC, " - ID-GW       "); 
05E5:  MOVLW  C3
05E6:  BSF    03.6
05E7:  MOVWF  0D
05E8:  MOVLW  00
05E9:  MOVWF  0F
05EA:  BCF    03.6
05EB:  CALL   35E
....................             BREAK;             
....................          } 
....................       } 
05EC:  GOTO   5A4
....................    } 
....................  
....................    ////// 
....................    IF (!TT_CONFIG_DONE) 
05ED:  BTFSC  4E.3
05EE:  GOTO   778
....................    { 
....................       SELLECT_FUN (); 
....................    } 
*
0778:  BCF    0A.3
0779:  BSF    0A.4
077A:  GOTO   263 (RETURN)
.................... } 
.................... VOID XULY_IDNODE_NHAP(){ 
....................    //*TEMP_CHAR3 = "\0"; 
....................    *ID_NODE_CHAR = "\0"; 
*
0891:  CLRF   7A
0892:  MOVLW  4F
0893:  MOVWF  40
0894:  MOVF   7A,W
0895:  MOVWF  41
0896:  MOVF   40,W
0897:  MOVWF  04
0898:  BCF    03.7
0899:  BTFSC  41.0
089A:  BSF    03.7
089B:  CLRF   00
....................    FOR (int j = 0; j < 4; j++) 
089C:  CLRF   3F
089D:  MOVF   3F,W
089E:  SUBLW  03
089F:  BTFSS  03.0
08A0:  GOTO   0CA
....................    { 
....................       ITOA (ID_NODE[j], 10, TEMP_CHAR); 
08A1:  MOVLW  42
08A2:  ADDWF  3F,W
08A3:  MOVWF  04
08A4:  BCF    03.7
08A5:  MOVF   00,W
08A6:  MOVWF  40
08A7:  CLRF   44
08A8:  CLRF   43
08A9:  CLRF   42
08AA:  MOVF   40,W
08AB:  MOVWF  41
08AC:  MOVLW  0A
08AD:  MOVWF  45
08AE:  CLRF   47
08AF:  MOVLW  6F
08B0:  MOVWF  46
08B1:  BCF    0A.3
08B2:  BCF    03.6
08B3:  CALL   42A
08B4:  BSF    0A.3
....................       DELAY_MS (1); 
08B5:  MOVLW  01
08B6:  BSF    03.6
08B7:  MOVWF  43
08B8:  BCF    0A.3
08B9:  BCF    03.6
08BA:  CALL   155
08BB:  BSF    0A.3
....................       STRCAT (ID_NODE_CHAR, TEMP_CHAR); 
08BC:  BSF    03.6
08BD:  CLRF   41
08BE:  MOVLW  4F
08BF:  MOVWF  40
08C0:  CLRF   43
08C1:  MOVLW  6F
08C2:  MOVWF  42
08C3:  BCF    0A.3
08C4:  BCF    03.6
08C5:  CALL   77B
08C6:  BSF    0A.3
08C7:  BSF    03.6
08C8:  INCF   3F,F
08C9:  GOTO   09D
....................    }   
....................    //ID_NODE_CHAR = TEMP_CHAR3;    
....................    //STRCPY(ID_NODE_CHAR,TEMP_CHAR3); 
....................    //strcpy 
.................... } 
.................... VOID XULY_IDGW_NHAP(){ 
....................  
....................    *ID_GATEWAY_CHAR = "\0"; 
*
0855:  CLRF   7A
0856:  MOVLW  56
0857:  MOVWF  40
0858:  MOVF   7A,W
0859:  MOVWF  41
085A:  MOVF   40,W
085B:  MOVWF  04
085C:  BCF    03.7
085D:  BTFSC  41.0
085E:  BSF    03.7
085F:  CLRF   00
....................    FOR (int j = 0; j < 6; j++) 
0860:  CLRF   3F
0861:  MOVF   3F,W
0862:  SUBLW  05
0863:  BTFSS  03.0
0864:  GOTO   08E
....................    { 
....................       ITOA (ID_GATEWAY[j], 10, TEMP_CHAR); 
0865:  MOVLW  3C
0866:  ADDWF  3F,W
0867:  MOVWF  04
0868:  BCF    03.7
0869:  MOVF   00,W
086A:  MOVWF  40
086B:  CLRF   44
086C:  CLRF   43
086D:  CLRF   42
086E:  MOVF   40,W
086F:  MOVWF  41
0870:  MOVLW  0A
0871:  MOVWF  45
0872:  CLRF   47
0873:  MOVLW  6F
0874:  MOVWF  46
0875:  BCF    0A.3
0876:  BCF    03.6
0877:  CALL   42A
0878:  BSF    0A.3
....................       DELAY_MS (1); 
0879:  MOVLW  01
087A:  BSF    03.6
087B:  MOVWF  43
087C:  BCF    0A.3
087D:  BCF    03.6
087E:  CALL   155
087F:  BSF    0A.3
....................       STRCAT (ID_GATEWAY_CHAR, TEMP_CHAR); 
0880:  BSF    03.6
0881:  CLRF   41
0882:  MOVLW  56
0883:  MOVWF  40
0884:  CLRF   43
0885:  MOVLW  6F
0886:  MOVWF  42
0887:  BCF    0A.3
0888:  BCF    03.6
0889:  CALL   77B
088A:  BSF    0A.3
088B:  BSF    03.6
088C:  INCF   3F,F
088D:  GOTO   061
....................    }   
.................... } 
....................  
....................  
.................... VOID CONFIG_DONE() 
.................... { 
....................    TT_FUN = 0; 
*
0800:  BCF    4E.4
....................    TT_STT = 0; 
0801:  BCF    4E.5
....................    CHAR *PACKAGE_CONFIG[]={"*", "LENGHT","CF", "ID_GW1234" ,"ID_NODE","#"}; 
0802:  MOVLW  2A
0803:  BSF    03.6
0804:  MOVWF  1E
0805:  CLRF   1F
0806:  MOVLW  4C
0807:  MOVWF  20
0808:  MOVLW  45
0809:  MOVWF  21
080A:  MOVLW  4E
080B:  MOVWF  22
080C:  MOVLW  47
080D:  MOVWF  23
080E:  MOVLW  48
080F:  MOVWF  24
0810:  MOVLW  54
0811:  MOVWF  25
0812:  CLRF   26
0813:  MOVLW  43
0814:  MOVWF  27
0815:  MOVLW  46
0816:  MOVWF  28
0817:  CLRF   29
0818:  MOVLW  49
0819:  MOVWF  2A
081A:  MOVLW  44
081B:  MOVWF  2B
081C:  MOVLW  5F
081D:  MOVWF  2C
081E:  MOVLW  47
081F:  MOVWF  2D
0820:  MOVLW  57
0821:  MOVWF  2E
0822:  MOVLW  31
0823:  MOVWF  2F
0824:  MOVLW  32
0825:  MOVWF  30
0826:  MOVLW  33
0827:  MOVWF  31
0828:  MOVLW  34
0829:  MOVWF  32
082A:  CLRF   33
082B:  MOVLW  49
082C:  MOVWF  34
082D:  MOVLW  44
082E:  MOVWF  35
082F:  MOVLW  5F
0830:  MOVWF  36
0831:  MOVLW  4E
0832:  MOVWF  37
0833:  MOVLW  4F
0834:  MOVWF  38
0835:  MOVLW  44
0836:  MOVWF  39
0837:  MOVLW  45
0838:  MOVWF  3A
0839:  CLRF   3B
083A:  MOVLW  23
083B:  MOVWF  3C
083C:  CLRF   3D
083D:  MOVLW  01
083E:  MOVWF  13
083F:  MOVLW  1E
0840:  MOVWF  12
0841:  MOVLW  01
0842:  MOVWF  15
0843:  MOVLW  20
0844:  MOVWF  14
0845:  MOVLW  01
0846:  MOVWF  17
0847:  MOVLW  27
0848:  MOVWF  16
0849:  MOVLW  01
084A:  MOVWF  19
084B:  MOVLW  2A
084C:  MOVWF  18
084D:  MOVLW  01
084E:  MOVWF  1B
084F:  MOVLW  34
0850:  MOVWF  1A
0851:  MOVLW  01
0852:  MOVWF  1D
0853:  MOVLW  3C
0854:  MOVWF  1C
....................    XULY_IDGW_NHAP(); 
....................    PACKAGE_CONFIG[3] = ID_GATEWAY_CHAR; 
*
088E:  CLRF   19
088F:  MOVLW  56
0890:  MOVWF  18
....................     
....................     
....................    XULY_IDNODE_NHAP(); 
....................  
....................    PACKAGE_CONFIG[4] = ID_NODE_CHAR;     
*
08CA:  CLRF   1B
08CB:  MOVLW  4F
08CC:  MOVWF  1A
....................       /*     
....................    LEN_PACKAGES = 0; 
....................    PACKAGE_CONFIG[1] = "12"; //DO DAI CUA LENGHT CO DO DAI = 2 
....................    FOR (int J = 0; J < 5; J++) 
....................    { 
....................       LEN_PACKAGES += strlen(PACKAGE_CONFIG[J]); 
....................    }    
....................    */ 
....................    LEN_PACKAGES = 20; //5 @ 
08CD:  MOVLW  14
08CE:  BCF    03.6
08CF:  MOVWF  46
....................    ITOA (LEN_PACKAGES, 10, TEMP_CHAR); 
08D0:  BSF    03.6
08D1:  CLRF   44
08D2:  CLRF   43
08D3:  CLRF   42
08D4:  BCF    03.6
08D5:  MOVF   46,W
08D6:  BSF    03.6
08D7:  MOVWF  41
08D8:  MOVLW  0A
08D9:  MOVWF  45
08DA:  CLRF   47
08DB:  MOVLW  6F
08DC:  MOVWF  46
08DD:  BCF    0A.3
08DE:  BCF    03.6
08DF:  CALL   42A
08E0:  BSF    0A.3
....................     
....................    PACKAGE_CONFIG[1] = TEMP_CHAR; 
08E1:  BSF    03.6
08E2:  CLRF   15
08E3:  MOVLW  6F
08E4:  MOVWF  14
....................     
....................    FOR (INT J = 0; J < 6; J++) 
08E5:  CLRF   3E
08E6:  MOVF   3E,W
08E7:  SUBLW  05
08E8:  BTFSS  03.0
08E9:  GOTO   104
....................    { 
....................       PRINTF (PACKAGE_CONFIG[J]); 
08EA:  BCF    03.0
08EB:  RLF    3E,W
08EC:  ADDLW  12
08ED:  MOVWF  04
08EE:  BSF    03.7
08EF:  INCF   04,F
08F0:  MOVF   00,W
08F1:  MOVWF  40
08F2:  DECF   04,F
08F3:  MOVF   00,W
08F4:  MOVWF  3F
08F5:  MOVWF  04
08F6:  BCF    03.7
08F7:  BTFSC  40.0
08F8:  BSF    03.7
08F9:  BCF    0A.3
08FA:  BCF    03.6
08FB:  CALL   7B9
08FC:  BSF    0A.3
....................       PRINTF ("@"); 
08FD:  MOVLW  40
08FE:  BTFSS  0C.4
08FF:  GOTO   0FE
0900:  MOVWF  19
0901:  BSF    03.6
0902:  INCF   3E,F
0903:  GOTO   0E6
....................    } 
....................  
....................  
....................    LCD_GOTOXY (1, 1) ; 
0904:  MOVLW  01
0905:  MOVWF  43
0906:  MOVWF  44
0907:  BCF    0A.3
0908:  BCF    03.6
0909:  CALL   310
090A:  BSF    0A.3
....................    DELAY_MS (10); 
090B:  MOVLW  0A
090C:  BSF    03.6
090D:  MOVWF  43
090E:  BCF    0A.3
090F:  BCF    03.6
0910:  CALL   155
0911:  BSF    0A.3
....................    PRINTF (LCD_PUTC, "WAITING ....        ") ; 
0912:  MOVLW  CB
0913:  BSF    03.6
0914:  MOVWF  0D
0915:  MOVLW  00
0916:  MOVWF  0F
0917:  BCF    0A.3
0918:  BCF    03.6
0919:  CALL   35E
091A:  BSF    0A.3
....................    LCD_GOTOXY (1, 2) ; 
091B:  MOVLW  01
091C:  BSF    03.6
091D:  MOVWF  43
091E:  MOVLW  02
091F:  MOVWF  44
0920:  BCF    0A.3
0921:  BCF    03.6
0922:  CALL   310
0923:  BSF    0A.3
....................    DELAY_MS (10); 
0924:  MOVLW  0A
0925:  BSF    03.6
0926:  MOVWF  43
0927:  BCF    0A.3
0928:  BCF    03.6
0929:  CALL   155
092A:  BSF    0A.3
....................    PRINTF (LCD_PUTC, "WAITING ....        ") ;    
092B:  MOVLW  D6
092C:  BSF    03.6
092D:  MOVWF  0D
092E:  MOVLW  00
092F:  MOVWF  0F
0930:  BCF    0A.3
0931:  BCF    03.6
0932:  CALL   35E
0933:  BSF    0A.3
....................    TT_CONFIG_DONE = 0; 
0934:  BCF    4E.3
0935:  BCF    0A.3
0936:  BSF    0A.4
0937:  GOTO   26A (RETURN)
.................... } 
....................  
....................  
....................  VOID XACNHANCONFIG() 
....................  {    
....................    KYTU=0;          
*
0C92:  CLRF   3A
....................    LCD_GOTOXY (1, 1) ; 
0C93:  MOVLW  01
0C94:  BSF    03.6
0C95:  MOVWF  43
0C96:  MOVWF  44
0C97:  BCF    0A.3
0C98:  BCF    03.6
0C99:  CALL   310
0C9A:  BSF    0A.3
....................    DELAY_MS (10); 
0C9B:  MOVLW  0A
0C9C:  BSF    03.6
0C9D:  MOVWF  43
0C9E:  BCF    0A.3
0C9F:  BCF    03.6
0CA0:  CALL   155
0CA1:  BSF    0A.3
....................    TEMP_CHAR = "_"; 
0CA2:  BSF    03.6
0CA3:  CLRF   1A
0CA4:  CLRF   1B
0CA5:  MOVLW  6F
0CA6:  MOVWF  04
0CA7:  BCF    03.7
0CA8:  MOVF   1A,W
0CA9:  ADDWF  04,F
0CAA:  MOVF   1B,W
0CAB:  BCF    0A.3
0CAC:  BCF    03.6
0CAD:  CALL   05E
0CAE:  BSF    0A.3
0CAF:  MOVWF  00
0CB0:  IORLW  00
0CB1:  BTFSC  03.2
0CB2:  GOTO   4B8
0CB3:  BSF    03.6
0CB4:  INCF   1B,F
0CB5:  INCF   1A,F
0CB6:  GOTO   4A5
0CB7:  BCF    03.6
....................    CHAR * TOKEN; 
....................    TOKEN = STRTOK (KYTUCHAR2, TEMP_CHAR);    
0CB8:  BSF    03.6
0CB9:  CLRF   1B
0CBA:  MOVLW  D2
0CBB:  MOVWF  1A
0CBC:  CLRF   1D
0CBD:  MOVLW  6F
0CBE:  MOVWF  1C
0CBF:  BCF    03.6
0CC0:  CALL   138
0CC1:  MOVF   79,W
0CC2:  BSF    03.6
0CC3:  MOVWF  19
0CC4:  MOVF   78,W
0CC5:  MOVWF  18
....................     WHILE (TOKEN != NULL) 
0CC6:  MOVF   18,F
0CC7:  BTFSS  03.2
0CC8:  GOTO   4CC
0CC9:  MOVF   19,F
0CCA:  BTFSC  03.2
0CCB:  GOTO   515
....................     {                 
....................        SWITCH(KYTU) 
0CCC:  BCF    03.6
0CCD:  MOVF   3A,W
0CCE:  BTFSC  03.2
0CCF:  GOTO   4D7
0CD0:  XORLW  01
0CD1:  BTFSC  03.2
0CD2:  GOTO   4F1
0CD3:  XORLW  03
0CD4:  BTFSC  03.2
0CD5:  GOTO   4FB
0CD6:  GOTO   504
....................        { 
....................          CASE 0: 
....................          DELAY_MS (1); 
0CD7:  MOVLW  01
0CD8:  BSF    03.6
0CD9:  MOVWF  43
0CDA:  BCF    0A.3
0CDB:  BCF    03.6
0CDC:  CALL   155
0CDD:  BSF    0A.3
....................          PRINTF (LCD_PUTC,TOKEN); 
0CDE:  BSF    03.6
0CDF:  MOVF   18,W
0CE0:  MOVWF  04
0CE1:  BCF    03.7
0CE2:  BTFSC  19.0
0CE3:  BSF    03.7
0CE4:  BCF    0A.3
0CE5:  BCF    03.6
0CE6:  CALL   54A
0CE7:  BSF    0A.3
....................          PRINTF (LCD_PUTC,"            "); 
0CE8:  MOVLW  E1
0CE9:  BSF    03.6
0CEA:  MOVWF  0D
0CEB:  MOVLW  00
0CEC:  MOVWF  0F
0CED:  BCF    0A.3
0CEE:  BCF    03.6
0CEF:  CALL   35E
0CF0:  BSF    0A.3
....................          CASE 1:  
....................          SOLUONGTHIETBI_CONFIG = ATOI(TOKEN); 
0CF1:  BSF    03.6
0CF2:  MOVF   19,W
0CF3:  MOVWF  1B
0CF4:  MOVF   18,W
0CF5:  MOVWF  1A
0CF6:  BCF    03.6
0CF7:  CALL   229
0CF8:  MOVF   78,W
0CF9:  MOVWF  49
....................          BREAK;                      
0CFA:  GOTO   504
....................          CASE 2: 
....................          SOLUONGCAMBIEN_CONFIG = ATOI(TOKEN); 
0CFB:  BSF    03.6
0CFC:  MOVF   19,W
0CFD:  MOVWF  1B
0CFE:  MOVF   18,W
0CFF:  MOVWF  1A
0D00:  BCF    03.6
0D01:  CALL   229
0D02:  MOVF   78,W
0D03:  MOVWF  4A
....................          BREAK;               
....................        }  
....................       TOKEN = STRTOK(NULL, TEMP_CHAR); 
0D04:  BSF    03.6
0D05:  CLRF   1B
0D06:  CLRF   1A
0D07:  CLRF   1D
0D08:  MOVLW  6F
0D09:  MOVWF  1C
0D0A:  BCF    03.6
0D0B:  CALL   138
0D0C:  MOVF   79,W
0D0D:  BSF    03.6
0D0E:  MOVWF  19
0D0F:  MOVF   78,W
0D10:  MOVWF  18
....................       KYTU++;         
0D11:  BCF    03.6
0D12:  INCF   3A,F
0D13:  BSF    03.6
0D14:  GOTO   4C6
....................     }           
....................    DELAY_MS (1);       
0D15:  MOVLW  01
0D16:  MOVWF  43
0D17:  BCF    0A.3
0D18:  BCF    03.6
0D19:  CALL   155
0D1A:  BSF    0A.3
....................    LCD_GOTOXY (1, 2) ; 
0D1B:  MOVLW  01
0D1C:  BSF    03.6
0D1D:  MOVWF  43
0D1E:  MOVLW  02
0D1F:  MOVWF  44
0D20:  BCF    0A.3
0D21:  BCF    03.6
0D22:  CALL   310
0D23:  BSF    0A.3
....................    DELAY_MS (10); 
0D24:  MOVLW  0A
0D25:  BSF    03.6
0D26:  MOVWF  43
0D27:  BCF    0A.3
0D28:  BCF    03.6
0D29:  CALL   155
0D2A:  BSF    0A.3
....................    PRINTF (LCD_PUTC,"TB: ");    
0D2B:  MOVLW  E8
0D2C:  BSF    03.6
0D2D:  MOVWF  0D
0D2E:  MOVLW  00
0D2F:  MOVWF  0F
0D30:  BCF    0A.3
0D31:  BCF    03.6
0D32:  CALL   35E
0D33:  BSF    0A.3
....................    ITOA (SOLUONGTHIETBI_CONFIG, 10, TEMP_CHAR);    
0D34:  BSF    03.6
0D35:  CLRF   44
0D36:  CLRF   43
0D37:  CLRF   42
0D38:  BCF    03.6
0D39:  MOVF   49,W
0D3A:  BSF    03.6
0D3B:  MOVWF  41
0D3C:  MOVLW  0A
0D3D:  MOVWF  45
0D3E:  CLRF   47
0D3F:  MOVLW  6F
0D40:  MOVWF  46
0D41:  BCF    0A.3
0D42:  BCF    03.6
0D43:  CALL   42A
0D44:  BSF    0A.3
....................    PRINTF (LCD_PUTC,TEMP_CHAR);    
0D45:  MOVLW  6F
0D46:  MOVWF  04
0D47:  BCF    03.7
0D48:  BCF    0A.3
0D49:  CALL   54A
0D4A:  BSF    0A.3
....................    PRINTF (LCD_PUTC,"    CB:");    
0D4B:  MOVLW  EB
0D4C:  BSF    03.6
0D4D:  MOVWF  0D
0D4E:  MOVLW  00
0D4F:  MOVWF  0F
0D50:  BCF    0A.3
0D51:  BCF    03.6
0D52:  CALL   35E
0D53:  BSF    0A.3
....................    ITOA (SOLUONGCAMBIEN_CONFIG, 10, TEMP_CHAR);    
0D54:  BSF    03.6
0D55:  CLRF   44
0D56:  CLRF   43
0D57:  CLRF   42
0D58:  BCF    03.6
0D59:  MOVF   4A,W
0D5A:  BSF    03.6
0D5B:  MOVWF  41
0D5C:  MOVLW  0A
0D5D:  MOVWF  45
0D5E:  CLRF   47
0D5F:  MOVLW  6F
0D60:  MOVWF  46
0D61:  BCF    0A.3
0D62:  BCF    03.6
0D63:  CALL   42A
0D64:  BSF    0A.3
....................    PRINTF (LCD_PUTC,TEMP_CHAR);       
0D65:  MOVLW  6F
0D66:  MOVWF  04
0D67:  BCF    03.7
0D68:  BCF    0A.3
0D69:  CALL   54A
0D6A:  BSF    0A.3
....................    TT_CONFIG_OKE_UART = 1; 
0D6B:  BSF    4E.6
....................     
....................  }  
.................... //--------------------------------------------------------------------// 
....................  
....................  
....................  
....................  
....................  
.................... VOID QUET_PHIM() 
*
00EF:  BSF    03.6
00F0:  CLRF   66
.................... { 
....................    INT BDT = 0; 
....................  
....................    WHILE (!INPUT (BT1_PIN)) //NEU NUT BAM DUOC BAM 
00F1:  BSF    03.5
00F2:  BCF    03.6
00F3:  BSF    06.1
00F4:  BCF    03.5
00F5:  BTFSC  06.1
00F6:  GOTO   10C
....................    { 
....................       IF (TMR1IF) 
00F7:  BTFSS  0C.0
00F8:  GOTO   109
....................       { 
....................          OUTPUT_TOGGLE (PIN_C4); 
00F9:  BCF    31.4
00FA:  MOVF   31,W
00FB:  BSF    03.5
00FC:  MOVWF  07
00FD:  MOVLW  10
00FE:  BCF    03.5
00FF:  XORWF  07,F
....................          TMR1IF = 0; SET_TIMER1 (3036); BDT++; 
0100:  BCF    0C.0
0101:  CLRF   0E
0102:  MOVLW  0B
0103:  MOVWF  0F
0104:  MOVLW  DC
0105:  MOVWF  0E
0106:  BSF    03.6
0107:  INCF   66,F
0108:  BCF    03.6
....................       } 
0109:  BSF    03.6
010A:  GOTO   0F1
010B:  BCF    03.6
....................    } 
....................  
....................    IF (BDT > 20) 
010C:  BSF    03.6
010D:  MOVF   66,W
010E:  SUBLW  14
010F:  BTFSC  03.0
0110:  GOTO   11A
....................    { 
....................       //CONFIG NODE 
....................       TT_CONFIG = ~TT_CONFIG; // VAO TRANG THAI CONFIG 
0111:  MOVLW  02
0112:  BCF    03.6
0113:  XORWF  4E,F
....................       TT_CONTROL = ~TT_CONTROL; 
0114:  MOVLW  04
0115:  XORWF  4E,F
....................       //CONFIG_DONE (); 
....................       TT_CONFIG_DONE = 1; 
0116:  BSF    4E.3
....................       TT_FUN = 0; 
0117:  BCF    4E.4
....................    } 
0118:  GOTO   12E
0119:  BSF    03.6
....................  
....................    ELSE IF (BDT >1 && BDT <20) 
011A:  MOVF   66,W
011B:  SUBLW  01
011C:  BTFSC  03.0
011D:  GOTO   128
011E:  MOVF   66,W
011F:  SUBLW  13
0120:  BTFSS  03.0
0121:  GOTO   128
....................    { 
....................       BUTT_OKE (); //OKE 
....................    } 
*
0126:  GOTO   12E
0127:  BSF    03.6
....................    ELSE { 
....................       TT_SW = 1; 
0128:  BCF    03.6
0129:  BSF    4E.7
....................       OUTPUT_HIGH(PIN_D3); 
012A:  BSF    03.5
012B:  BCF    08.3
012C:  BCF    03.5
012D:  BSF    08.3
....................  
....................  
....................    } 
.................... } 
....................  
.................... #INT_EXT 
....................  
....................  VOID NGAT_NGOAI () 
....................  { 
....................     QUET_PHIM (); 
....................  } 
....................  
012E:  BCF    0B.1
012F:  BCF    0A.3
0130:  BCF    0A.4
0131:  GOTO   031
....................  #INT_RDA 
....................  VOID NGAT () 
....................  { 
....................     KYTUCHAR[VT] = GETCH (); 
0132:  MOVLW  A0
0133:  ADDWF  39,W
0134:  MOVWF  04
0135:  BCF    03.7
0136:  BTFSS  0C.5
0137:  GOTO   136
0138:  MOVF   1A,W
0139:  MOVWF  00
....................  
....................     IF (KYTUCHAR[VT] == '.') 
013A:  MOVLW  A0
013B:  ADDWF  39,W
013C:  MOVWF  04
013D:  BCF    03.7
013E:  MOVF   00,W
013F:  SUBLW  2E
0140:  BTFSS  03.2
0141:  GOTO   14A
....................     { 
....................        KYTUCHAR[VT] = '\0'; 
0142:  MOVLW  A0
0143:  ADDWF  39,W
0144:  MOVWF  04
0145:  BCF    03.7
0146:  CLRF   00
....................        VT = 0; 
0147:  CLRF   39
....................        TTNHAN = 1; 
0148:  BSF    4E.0
....................     } 
0149:  GOTO   14B
....................     ELSE 
....................     VT++; 
014A:  INCF   39,F
014B:  BCF    0C.5
014C:  BCF    0A.3
014D:  BCF    0A.4
014E:  GOTO   031
....................  } 
....................   INT ADC_READ (INT KENH) 
....................  { 
....................     UNSIGNED INT8 ANALOG_PORT[] = {1,2,4,8,16,32,64};  
*
0DC6:  MOVLW  01
0DC7:  MOVWF  16
0DC8:  MOVLW  02
0DC9:  MOVWF  17
0DCA:  MOVLW  04
0DCB:  MOVWF  18
0DCC:  MOVLW  08
0DCD:  MOVWF  19
0DCE:  MOVLW  10
0DCF:  MOVWF  1A
0DD0:  MOVLW  20
0DD1:  MOVWF  1B
0DD2:  MOVLW  40
0DD3:  MOVWF  1C
....................     SETUP_ADC_PORTS (ANALOG_PORT[KENH]); 
0DD4:  MOVLW  16
0DD5:  ADDWF  15,W
0DD6:  MOVWF  04
0DD7:  BSF    03.7
0DD8:  MOVF   00,W
0DD9:  MOVWF  1E
0DDA:  MOVWF  1F
0DDB:  CLRF   20
0DDC:  CLRF   21
0DDD:  CLRF   22
0DDE:  MOVLW  89
0DDF:  MOVWF  04
0DE0:  BSF    03.7
0DE1:  MOVLW  C0
0DE2:  ANDWF  00,F
0DE3:  MOVF   21,W
0DE4:  IORWF  00,F
0DE5:  MOVLW  9F
0DE6:  MOVWF  04
0DE7:  BCF    03.7
0DE8:  MOVLW  CF
0DE9:  ANDWF  00,F
0DEA:  MOVF   20,W
0DEB:  IORWF  00,F
0DEC:  MOVLW  88
0DED:  MOVWF  04
0DEE:  BSF    03.7
0DEF:  MOVF   1F,W
0DF0:  MOVWF  00
....................     DELAY_MS(3); 
0DF1:  MOVLW  03
0DF2:  MOVWF  43
0DF3:  BCF    0A.3
0DF4:  BCF    03.6
0DF5:  CALL   155
0DF6:  BSF    0A.3
....................     SET_ADC_CHANNEL (KENH); 
0DF7:  BSF    03.6
0DF8:  RLF    15,W
0DF9:  MOVWF  77
0DFA:  RLF    77,F
0DFB:  MOVLW  FC
0DFC:  ANDWF  77,F
0DFD:  BCF    03.6
0DFE:  MOVF   1F,W
0DFF:  ANDLW  C3
0E00:  IORWF  77,W
0E01:  MOVWF  1F
....................     DELAY_MS(3); 
0E02:  MOVLW  03
0E03:  BSF    03.6
0E04:  MOVWF  43
0E05:  BCF    0A.3
0E06:  BCF    03.6
0E07:  CALL   155
0E08:  BSF    0A.3
....................     KQADC = 0; 
0E09:  CLRF   33
0E0A:  CLRF   32
....................     FOR (INT I = 0; I < 100; I++) 
0E0B:  BSF    03.6
0E0C:  CLRF   1D
0E0D:  MOVF   1D,W
0E0E:  SUBLW  63
0E0F:  BTFSS  03.0
0E10:  GOTO   627
....................     { 
....................        KQADC = KQADC + READ_ADC () ; 
0E11:  BCF    03.6
0E12:  BSF    1F.1
0E13:  BTFSC  1F.1
0E14:  GOTO   613
0E15:  BSF    03.5
0E16:  MOVF   1E,W
0E17:  BCF    03.5
0E18:  ADDWF  32,F
0E19:  MOVF   1E,W
0E1A:  BTFSC  03.0
0E1B:  INCFSZ 1E,W
0E1C:  ADDWF  33,F
....................        DELAY_MS (1); 
0E1D:  MOVLW  01
0E1E:  BSF    03.6
0E1F:  MOVWF  43
0E20:  BCF    0A.3
0E21:  BCF    03.6
0E22:  CALL   155
0E23:  BSF    0A.3
0E24:  BSF    03.6
0E25:  INCF   1D,F
0E26:  GOTO   60D
....................     } 
....................  
....................     KQADC = KQADC / (100 * 2.046); 
0E27:  BCF    03.6
0E28:  MOVF   33,W
0E29:  BSF    03.6
0E2A:  MOVWF  1F
0E2B:  BCF    03.6
0E2C:  MOVF   32,W
0E2D:  BSF    03.6
0E2E:  MOVWF  1E
*
0E4B:  MOVF   7A,W
0E4C:  MOVWF  21
0E4D:  MOVF   79,W
0E4E:  MOVWF  20
0E4F:  MOVF   78,W
0E50:  MOVWF  1F
0E51:  MOVF   77,W
0E52:  MOVWF  1E
0E53:  MOVLW  9A
0E54:  MOVWF  25
0E55:  MOVLW  99
0E56:  MOVWF  24
0E57:  MOVLW  4C
0E58:  MOVWF  23
0E59:  MOVLW  86
0E5A:  MOVWF  22
*
0F24:  MOVF   7A,W
0F25:  MOVWF  21
0F26:  MOVF   79,W
0F27:  MOVWF  20
0F28:  MOVF   78,W
0F29:  MOVWF  1F
0F2A:  MOVF   77,W
0F2B:  MOVWF  1E
*
0F4A:  MOVF   79,W
0F4B:  BCF    03.6
0F4C:  MOVWF  33
0F4D:  MOVF   78,W
0F4E:  MOVWF  32
....................     RETURN KQADC; 
0F4F:  MOVF   32,W
0F50:  MOVWF  78
....................  } 
....................  
....................  
....................  VOID READ_ANALOG ( ) 
....................  { 
....................    FOR(INT K = 0; K<SOLUONGCAMBIEN_CONFIG; K++){ 
*
0DB2:  BSF    03.6
0DB3:  CLRF   12
0DB4:  BCF    03.6
0DB5:  MOVF   4A,W
0DB6:  BSF    03.6
0DB7:  SUBWF  12,W
0DB8:  BTFSC  03.0
0DB9:  GOTO   75B
....................       KET_QUA_ANALOG[K] = ADC_READ (K);   
0DBA:  MOVLW  34
0DBB:  ADDWF  12,W
0DBC:  MOVWF  78
0DBD:  CLRF   7A
0DBE:  BTFSC  03.0
0DBF:  INCF   7A,F
0DC0:  MOVF   78,W
0DC1:  MOVWF  13
0DC2:  MOVF   7A,W
0DC3:  MOVWF  14
0DC4:  MOVF   12,W
0DC5:  MOVWF  15
*
0F51:  BSF    03.6
0F52:  MOVF   13,W
0F53:  MOVWF  04
0F54:  BCF    03.7
0F55:  BTFSC  14.0
0F56:  BSF    03.7
0F57:  MOVF   78,W
0F58:  MOVWF  00
0F59:  INCF   12,F
0F5A:  GOTO   5B4
....................    } 
0F5B:  BCF    03.6
0F5C:  BCF    0A.3
0F5D:  BSF    0A.4
0F5E:  GOTO   391 (RETURN)
....................  } 
....................  
....................  VOID SEND_ANALOG_UART() 
....................  { 
....................    OUTPUT_TOGGLE(PIN_C4); 
*
1000:  BCF    31.4
1001:  MOVF   31,W
1002:  BSF    03.5
1003:  MOVWF  07
1004:  MOVLW  10
1005:  BCF    03.5
1006:  XORWF  07,F
....................    //CHAR *PACKAGE_SS[]={"*", "26","SS", "IDGW12" ,"NODE","ZZ","AA","VV","CC","SS"}; 
....................    CHAR *PACKAGE_SS[]={"IDGW12" ,"NODE","ZZ","AA","VV","CC","SS"};    
1007:  MOVLW  49
1008:  BSF    03.6
1009:  MOVWF  20
100A:  MOVLW  44
100B:  MOVWF  21
100C:  MOVLW  47
100D:  MOVWF  22
100E:  MOVLW  57
100F:  MOVWF  23
1010:  MOVLW  31
1011:  MOVWF  24
1012:  MOVLW  32
1013:  MOVWF  25
1014:  CLRF   26
1015:  MOVLW  4E
1016:  MOVWF  27
1017:  MOVLW  4F
1018:  MOVWF  28
1019:  MOVLW  44
101A:  MOVWF  29
101B:  MOVLW  45
101C:  MOVWF  2A
101D:  CLRF   2B
101E:  MOVLW  5A
101F:  MOVWF  2C
1020:  MOVWF  2D
1021:  CLRF   2E
1022:  MOVLW  41
1023:  MOVWF  2F
1024:  MOVWF  30
1025:  CLRF   31
1026:  MOVLW  56
1027:  MOVWF  32
1028:  MOVWF  33
1029:  CLRF   34
102A:  MOVLW  43
102B:  MOVWF  35
102C:  MOVWF  36
102D:  CLRF   37
102E:  MOVLW  53
102F:  MOVWF  38
1030:  MOVWF  39
1031:  CLRF   3A
1032:  MOVLW  01
1033:  MOVWF  13
1034:  MOVLW  20
1035:  MOVWF  12
1036:  MOVLW  01
1037:  MOVWF  15
1038:  MOVLW  27
1039:  MOVWF  14
103A:  MOVLW  01
103B:  MOVWF  17
103C:  MOVLW  2C
103D:  MOVWF  16
103E:  MOVLW  01
103F:  MOVWF  19
1040:  MOVLW  2F
1041:  MOVWF  18
1042:  MOVLW  01
1043:  MOVWF  1B
1044:  MOVLW  32
1045:  MOVWF  1A
1046:  MOVLW  01
1047:  MOVWF  1D
1048:  MOVLW  35
1049:  MOVWF  1C
104A:  MOVLW  01
104B:  MOVWF  1F
104C:  MOVLW  38
104D:  MOVWF  1E
....................    PACKAGE_SS[0] = ID_GATEWAY_CHAR; 
104E:  CLRF   13
104F:  MOVLW  56
1050:  MOVWF  12
....................    PACKAGE_SS[1] = ID_NODE_CHAR; 
1051:  CLRF   15
1052:  MOVLW  4F
1053:  MOVWF  14
....................    UNSIGNED INT8 DO_DAI =20; 
1054:  MOVLW  14
1055:  MOVWF  3B
....................     
....................    FOR(INT I = 0; I<SOLUONGCAMBIEN_CONFIG; I++) 
1056:  CLRF   3C
1057:  BCF    03.6
1058:  MOVF   4A,W
1059:  BSF    03.6
105A:  SUBWF  3C,W
105B:  BTFSC  03.0
105C:  GOTO   086
....................    { 
....................       ITOA(KET_QUA_ANALOG[I],10,PACKAGE_SS[2+I]); 
105D:  MOVLW  34
105E:  ADDWF  3C,W
105F:  MOVWF  04
1060:  BCF    03.7
1061:  MOVF   00,W
1062:  MOVWF  3D
1063:  MOVLW  02
1064:  ADDWF  3C,W
1065:  MOVWF  77
1066:  BCF    03.0
1067:  RLF    77,F
1068:  MOVF   77,W
1069:  ADDLW  12
106A:  MOVWF  04
106B:  BSF    03.7
106C:  INCF   04,F
106D:  MOVF   00,W
106E:  MOVWF  3F
106F:  DECF   04,F
1070:  MOVF   00,W
1071:  MOVWF  3E
1072:  CLRF   44
1073:  CLRF   43
1074:  CLRF   42
1075:  MOVF   3D,W
1076:  MOVWF  41
1077:  MOVLW  0A
1078:  MOVWF  45
1079:  MOVF   3F,W
107A:  MOVWF  47
107B:  MOVF   3E,W
107C:  MOVWF  46
107D:  BCF    0A.4
107E:  BCF    03.6
107F:  CALL   42A
1080:  BSF    0A.4
....................       DO_DAI = DO_DAI + 3; 
1081:  MOVLW  03
1082:  BSF    03.6
1083:  ADDWF  3B,F
1084:  INCF   3C,F
1085:  GOTO   057
....................    }       
....................    ITOA(DO_DAI,10,TEMP_CHAR2); 
1086:  CLRF   44
1087:  CLRF   43
1088:  CLRF   42
1089:  MOVF   3B,W
108A:  MOVWF  41
108B:  MOVLW  0A
108C:  MOVWF  45
108D:  CLRF   47
108E:  MOVLW  7B
108F:  MOVWF  46
1090:  BCF    0A.4
1091:  BCF    03.6
1092:  CALL   42A
1093:  BSF    0A.4
....................    PRINTF ("*@");    
1094:  MOVLW  2A
1095:  BTFSS  0C.4
1096:  GOTO   095
1097:  MOVWF  19
1098:  MOVLW  40
1099:  BTFSS  0C.4
109A:  GOTO   099
109B:  MOVWF  19
....................    PRINTF (TEMP_CHAR2); 
109C:  MOVLW  7B
109D:  MOVWF  04
109E:  BCF    03.7
109F:  BCF    0A.4
10A0:  CALL   7B9
10A1:  BSF    0A.4
....................    PRINTF ("@SS@");    
10A2:  MOVLW  4F
10A3:  BSF    03.6
10A4:  MOVWF  0D
10A5:  MOVLW  01
10A6:  MOVWF  0F
....................    FOR ( I = 0; I < 2 + SOLUONGCAMBIEN_CONFIG; I++) 
*
10F6:  CLRF   3C
10F7:  MOVLW  02
10F8:  BCF    03.6
10F9:  ADDWF  4A,W
10FA:  BSF    03.6
10FB:  SUBWF  3C,W
10FC:  BTFSC  03.0
10FD:  GOTO   118
....................    { 
....................       PRINTF (PACKAGE_SS[I]); 
10FE:  BCF    03.0
10FF:  RLF    3C,W
1100:  ADDLW  12
1101:  MOVWF  04
1102:  BSF    03.7
1103:  INCF   04,F
1104:  MOVF   00,W
1105:  MOVWF  3E
1106:  DECF   04,F
1107:  MOVF   00,W
1108:  MOVWF  3D
1109:  MOVWF  04
110A:  BCF    03.7
110B:  BTFSC  3E.0
110C:  BSF    03.7
110D:  BCF    0A.4
110E:  BCF    03.6
110F:  CALL   7B9
1110:  BSF    0A.4
....................       PRINTF ("@"); 
1111:  MOVLW  40
1112:  BTFSS  0C.4
1113:  GOTO   112
1114:  MOVWF  19
1115:  BSF    03.6
1116:  INCF   3C,F
1117:  GOTO   0F7
....................    } 
....................    PRINTF ("#"); 
1118:  MOVLW  23
1119:  BCF    03.6
111A:  BTFSS  0C.4
111B:  GOTO   11A
111C:  MOVWF  19
....................    OUTPUT_TOGGLE(PIN_C4); 
111D:  BCF    31.4
111E:  MOVF   31,W
111F:  BSF    03.5
1120:  MOVWF  07
1121:  MOVLW  10
1122:  BCF    03.5
1123:  XORWF  07,F
1124:  BCF    0A.3
1125:  BSF    0A.4
1126:  GOTO   397 (RETURN)
....................     
....................  } 
....................  VOID DIEUKHIENTHIETBI() 
....................  { 
....................    LENH_DIEU_KHIEN = 0;   
*
0D6D:  CLRF   3B
....................    LENH_DIEU_KHIEN = ATOI(KYTUCHAR2); 
0D6E:  BSF    03.6
0D6F:  CLRF   1B
0D70:  MOVLW  D2
0D71:  MOVWF  1A
0D72:  BCF    03.6
0D73:  CALL   229
0D74:  MOVF   78,W
0D75:  MOVWF  3B
....................    XUATTRANGTHAI(LENH_DIEU_KHIEN); 
0D76:  MOVF   3B,W
0D77:  BSF    03.6
0D78:  MOVWF  18
....................  } 
....................  
....................  VOID XU_LY_UART() 
*
0B71:  MOVLW  2A
0B72:  BSF    03.6
0B73:  MOVWF  12
....................  { 
....................      //ID_NODE_NHAN = KYTU[1] - 48; 
....................     //ID_DEVICE_NHAN = KYTU[2] - 48 + 64; 
....................     //TT_DEVICE_NHAN = KYTU[3] - 48; // - 48 ASCII -- > S?. + 64 -- > PORT_D (D0 = 64)                
....................  
....................     /*TINH DO DAI*/ 
....................     CHAR CH = '*'; 
....................     CHAR *RET; 
....................     *ID_NODE_NHAN = '\0'; 
0B74:  CLRF   7A
0B75:  MOVLW  5F
0B76:  MOVWF  04
0B77:  BCF    03.7
0B78:  BTFSC  7A.0
0B79:  BSF    03.7
0B7A:  CLRF   00
....................     *ID_GW_NHAN = '\0'; 
0B7B:  CLRF   7A
0B7C:  MOVLW  66
0B7D:  MOVWF  04
0B7E:  BCF    03.7
0B7F:  BTFSC  7A.0
0B80:  BSF    03.7
0B81:  CLRF   00
....................     KYTUCHAR2 = ""; 
0B82:  CLRF   18
0B83:  CLRF   19
0B84:  MOVLW  D2
0B85:  MOVWF  04
0B86:  BCF    03.7
0B87:  MOVF   18,W
0B88:  ADDWF  04,F
0B89:  MOVF   19,W
0B8A:  BCF    0A.3
0B8B:  BCF    03.6
0B8C:  CALL   06A
0B8D:  BSF    0A.3
0B8E:  MOVWF  00
0B8F:  IORLW  00
0B90:  BTFSC  03.2
0B91:  GOTO   397
0B92:  BSF    03.6
0B93:  INCF   19,F
0B94:  INCF   18,F
0B95:  GOTO   384
0B96:  BCF    03.6
....................     UNSIGNED INT8 LEN_RET;     
....................     RET = STRCHR(KYTUCHAR,CH); 
0B97:  BSF    03.6
0B98:  CLRF   19
0B99:  MOVLW  A0
0B9A:  MOVWF  18
0B9B:  MOVF   12,W
0B9C:  MOVWF  1A
*
0BBE:  MOVF   79,W
0BBF:  MOVWF  14
0BC0:  MOVF   78,W
0BC1:  MOVWF  13
....................     LEN_RET = STRLEN(RET);  
0BC2:  MOVF   14,W
0BC3:  MOVWF  19
0BC4:  MOVF   13,W
0BC5:  MOVWF  18
*
0BE3:  MOVF   78,W
0BE4:  MOVWF  15
....................     /* LAY TOKEN DAU TIEN */     
....................     KYTU = 0; 
0BE5:  BCF    03.6
0BE6:  CLRF   3A
....................     TEMP_CHAR = "#"; 
0BE7:  BSF    03.6
0BE8:  CLRF   18
0BE9:  CLRF   19
0BEA:  MOVLW  6F
0BEB:  MOVWF  04
0BEC:  BCF    03.7
0BED:  MOVF   18,W
0BEE:  ADDWF  04,F
0BEF:  MOVF   19,W
0BF0:  BCF    0A.3
0BF1:  BCF    03.6
0BF2:  CALL   064
0BF3:  BSF    0A.3
0BF4:  MOVWF  00
0BF5:  IORLW  00
0BF6:  BTFSC  03.2
0BF7:  GOTO   3FD
0BF8:  BSF    03.6
0BF9:  INCF   19,F
0BFA:  INCF   18,F
0BFB:  GOTO   3EA
0BFC:  BCF    03.6
....................     CHAR * TOKEN; 
....................     TOKEN = STRTOK (KYTUCHAR, TEMP_CHAR);                 
0BFD:  BSF    03.6
0BFE:  CLRF   1B
0BFF:  MOVLW  A0
0C00:  MOVWF  1A
0C01:  CLRF   1D
0C02:  MOVLW  6F
0C03:  MOVWF  1C
0C04:  BCF    03.6
0C05:  CALL   138
0C06:  MOVF   79,W
0C07:  BSF    03.6
0C08:  MOVWF  17
0C09:  MOVF   78,W
0C0A:  MOVWF  16
....................     /* DUYET QUA CAC TOKEN CON LAI */                 
....................     WHILE (TOKEN != NULL) 
0C0B:  MOVF   16,F
0C0C:  BTFSS  03.2
0C0D:  GOTO   411
0C0E:  MOVF   17,F
0C0F:  BTFSC  03.2
0C10:  GOTO   464
....................     {                 
....................        SWITCH(KYTU) 
0C11:  BCF    03.6
0C12:  MOVF   3A,W
0C13:  ADDLW  FA
0C14:  BTFSC  03.0
0C15:  GOTO   453
0C16:  ADDLW  06
0C17:  GOTO   5A8
....................        { 
....................          CASE 0: 
....................          BREAK; 
0C18:  GOTO   453
....................          CASE 1:  
....................          STRCAT (ID_GW_NHAN, TOKEN); 
0C19:  BSF    03.6
0C1A:  CLRF   41
0C1B:  MOVLW  66
0C1C:  MOVWF  40
0C1D:  MOVF   17,W
0C1E:  MOVWF  43
0C1F:  MOVF   16,W
0C20:  MOVWF  42
0C21:  BCF    0A.3
0C22:  BCF    03.6
0C23:  CALL   77B
0C24:  BSF    0A.3
....................          BREAK;                      
0C25:  GOTO   453
....................          CASE 2: 
....................          STRCAT (ID_NODE_NHAN, TOKEN); 
0C26:  BSF    03.6
0C27:  CLRF   41
0C28:  MOVLW  5F
0C29:  MOVWF  40
0C2A:  MOVF   17,W
0C2B:  MOVWF  43
0C2C:  MOVF   16,W
0C2D:  MOVWF  42
0C2E:  BCF    0A.3
0C2F:  BCF    03.6
0C30:  CALL   77B
0C31:  BSF    0A.3
....................          BREAK;       
0C32:  GOTO   453
....................          CASE 3: 
....................          LENHDIEUKHIEN =  ATOI(TOKEN);                  
0C33:  BSF    03.6
0C34:  MOVF   17,W
0C35:  MOVWF  1B
0C36:  MOVF   16,W
0C37:  MOVWF  1A
0C38:  BCF    03.6
0C39:  CALL   229
0C3A:  MOVF   78,W
0C3B:  MOVWF  47
....................          BREAK;     
0C3C:  GOTO   453
....................          CASE 4: 
....................          DODAI_DATA_NHAN =  ATOI(TOKEN);                  
0C3D:  BSF    03.6
0C3E:  MOVF   17,W
0C3F:  MOVWF  1B
0C40:  MOVF   16,W
0C41:  MOVWF  1A
0C42:  BCF    03.6
0C43:  CALL   229
0C44:  MOVF   78,W
0C45:  MOVWF  48
....................          BREAK;   
0C46:  GOTO   453
....................          CASE 5:   
....................          STRCAT (KYTUCHAR2, TOKEN); 
0C47:  BSF    03.6
0C48:  CLRF   41
0C49:  MOVLW  D2
0C4A:  MOVWF  40
0C4B:  MOVF   17,W
0C4C:  MOVWF  43
0C4D:  MOVF   16,W
0C4E:  MOVWF  42
0C4F:  BCF    0A.3
0C50:  BCF    03.6
0C51:  CALL   77B
0C52:  BSF    0A.3
....................          BREAK;          
....................        }          
....................       TOKEN = STRTOK(NULL, TEMP_CHAR); 
0C53:  BSF    03.6
0C54:  CLRF   1B
0C55:  CLRF   1A
0C56:  CLRF   1D
0C57:  MOVLW  6F
0C58:  MOVWF  1C
0C59:  BCF    03.6
0C5A:  CALL   138
0C5B:  MOVF   79,W
0C5C:  BSF    03.6
0C5D:  MOVWF  17
0C5E:  MOVF   78,W
0C5F:  MOVWF  16
....................       KYTU++;         
0C60:  BCF    03.6
0C61:  INCF   3A,F
0C62:  BSF    03.6
0C63:  GOTO   40B
....................     }               
....................       /* SO SANH ID returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................       SOSANH_IDGW = STRCMP(ID_GW_NHAN,ID_GATEWAY_CHAR);       
0C64:  CLRF   19
0C65:  MOVLW  66
0C66:  MOVWF  18
0C67:  CLRF   1B
0C68:  MOVLW  56
0C69:  MOVWF  1A
0C6A:  BCF    03.6
0C6B:  CALL   32B
0C6C:  MOVF   78,W
0C6D:  MOVWF  4C
....................       SOSANH_IDNODE = STRCMP(ID_NODE_NHAN,ID_NODE_CHAR);     
0C6E:  BSF    03.6
0C6F:  CLRF   19
0C70:  MOVLW  5F
0C71:  MOVWF  18
0C72:  CLRF   1B
0C73:  MOVLW  4F
0C74:  MOVWF  1A
0C75:  BCF    03.6
0C76:  CALL   32B
0C77:  MOVF   78,W
0C78:  MOVWF  4B
....................        
....................     IF ( SOSANH_IDGW == 0 && SOSANH_IDNODE == 0 && LEN_RET == DODAI_DATA_NHAN) 
0C79:  MOVF   4C,F
0C7A:  BTFSS  03.2
0C7B:  GOTO   59E
0C7C:  MOVF   4B,F
0C7D:  BTFSS  03.2
0C7E:  GOTO   59E
0C7F:  MOVF   48,W
0C80:  BSF    03.6
0C81:  SUBWF  15,W
0C82:  BTFSC  03.2
0C83:  GOTO   486
0C84:  BCF    03.6
0C85:  GOTO   59E
....................     {                       
....................       SWITCH(LENHDIEUKHIEN) 
0C86:  BCF    03.6
0C87:  MOVF   47,W
0C88:  BTFSC  03.2
0C89:  GOTO   491
0C8A:  XORLW  01
0C8B:  BTFSC  03.2
0C8C:  GOTO   492
0C8D:  XORLW  03
0C8E:  BTFSC  03.2
0C8F:  GOTO   56D
0C90:  GOTO   59D
....................        { 
....................          CASE 0: 
....................          BREAK; 
0C91:  GOTO   59D
....................          CASE 1: 
....................          XACNHANCONFIG(); 
....................          BREAK;                      
*
0D6C:  GOTO   59D
....................          CASE 2: 
....................          DIEUKHIENTHIETBI(); 
....................          BREAK;               
....................        }  
....................     } 
*
0D9D:  GOTO   5A5
....................     ELSE{ 
....................       DELAY_MS (10); 
0D9E:  MOVLW  0A
0D9F:  BSF    03.6
0DA0:  MOVWF  43
0DA1:  BCF    0A.3
0DA2:  BCF    03.6
0DA3:  CALL   155
0DA4:  BSF    0A.3
....................       /*DATA RCV SAI ID NODE, ID GW HOAC LA SAI DO DAI*/ 
....................     } 
0DA5:  BCF    0A.3
0DA6:  BSF    0A.4
0DA7:  GOTO   275 (RETURN)
....................      
....................  } 
....................  
....................  
....................  VOID MAIN  () 
*
1127:  MOVF   03,W
1128:  ANDLW  1F
1129:  MOVWF  03
112A:  BSF    03.5
112B:  BSF    03.6
112C:  BSF    07.3
112D:  MOVLW  08
112E:  BCF    03.6
112F:  MOVWF  19
1130:  MOVLW  02
1131:  MOVWF  1A
1132:  MOVLW  A6
1133:  MOVWF  18
1134:  MOVLW  90
1135:  BCF    03.5
1136:  MOVWF  18
1137:  MOVLW  FF
1138:  MOVWF  31
1139:  CLRF   38
113A:  CLRF   39
113B:  CLRF   3A
113C:  CLRF   3B
113D:  CLRF   46
113E:  CLRF   47
113F:  CLRF   48
1140:  CLRF   49
1141:  MOVLW  03
1142:  MOVWF  4A
1143:  CLRF   4B
1144:  CLRF   4C
1145:  BCF    4E.0
1146:  BCF    4E.1
1147:  BCF    4E.2
1148:  BCF    4E.3
1149:  BCF    4E.4
114A:  BCF    4E.5
114B:  BCF    4E.6
114C:  BCF    4E.7
114D:  BSF    03.5
114E:  BSF    03.6
114F:  MOVF   09,W
1150:  ANDLW  C0
1151:  MOVWF  09
1152:  BCF    03.6
1153:  BCF    1F.4
1154:  BCF    1F.5
1155:  MOVLW  00
1156:  BSF    03.6
1157:  MOVWF  08
1158:  BCF    03.5
1159:  CLRF   07
115A:  CLRF   08
115B:  CLRF   09
115C:  BCF    03.7
....................  { 
....................     SET_TRIS_D (0XF0); 
*
11D0:  MOVLW  F0
11D1:  MOVWF  08
....................     SET_TRIS_B (0XFF); 
11D2:  MOVLW  FF
11D3:  MOVWF  06
....................     SET_TRIS_E (0); 
11D4:  BCF    09.0
11D5:  BCF    09.1
11D6:  BCF    09.2
11D7:  BCF    09.3
....................     SET_TRIS_C (0X80); 
11D8:  MOVLW  80
11D9:  MOVWF  07
11DA:  BCF    03.5
11DB:  MOVWF  31
....................     SETUP_ADC (ADC_CLOCK_DIV_8);        
11DC:  BSF    1F.6
11DD:  BCF    1F.7
11DE:  BSF    03.5
11DF:  BSF    1F.7
11E0:  BCF    03.5
11E1:  BSF    1F.0
....................     ENABLE_INTERRUPTS (INT_TIMER0); 
11E2:  BSF    0B.5
....................     ENABLE_INTERRUPTS (INT_EXT); //CHO PHEP NGAT NGOAI 
11E3:  BSF    0B.4
....................     ENABLE_INTERRUPTS (INT_EXT_H2L); //NGAT XAY RA KHI CO XUNG TU CAO XUONG THAP 
11E4:  BSF    0B.4
11E5:  BSF    03.5
11E6:  BCF    01.6
....................     ENABLE_INTERRUPTS (INT_RDA); 
11E7:  BSF    0C.5
....................     ENABLE_INTERRUPTS (GLOBAL); 
11E8:  MOVLW  C0
11E9:  BCF    03.5
11EA:  IORWF  0B,F
....................      
....................     SETUP_TIMER_1 (T1_INTERNAL|T1_DIV_BY_8); 
11EB:  MOVLW  35
11EC:  MOVWF  10
....................     //SET_TIMER1 (0); 
....................     SET_TIMER1 (3036); 
11ED:  CLRF   0E
11EE:  MOVLW  0B
11EF:  MOVWF  0F
11F0:  MOVLW  DC
11F1:  MOVWF  0E
....................     TMR1IF = 0; 
11F2:  BCF    0C.0
....................     LCD_INIT (); // KHOI TAO LCD 
11F3:  BCF    0A.4
11F4:  GOTO   26F
11F5:  BSF    0A.4
....................  
....................     TT_CONFIG = 0; 
11F6:  BCF    4E.1
....................     TT_CONFIG_DONE = 0; 
11F7:  BCF    4E.3
....................     TT_CONTROL = 1; 
11F8:  BSF    4E.2
....................     OUTPUT_HIGH(PIN_D3); 
11F9:  BSF    03.5
11FA:  BCF    08.3
11FB:  BCF    03.5
11FC:  BSF    08.3
....................     TTNHAN = 0;     
11FD:  BCF    4E.0
....................  
....................     FOR (INT TB = 0; TB<4; TB++)              
11FE:  BSF    03.6
11FF:  CLRF   10
1200:  MOVF   10,W
1201:  SUBLW  03
1202:  BTFSS  03.0
1203:  GOTO   22D
....................     { 
....................        TT_THIETBI_TEMP[TB]=INPUT(52+TB)  ; 
1204:  MOVLW  34
1205:  ADDWF  10,W
1206:  MOVWF  12
1207:  MOVWF  14
1208:  MOVLW  01
1209:  MOVWF  15
120A:  CLRF   17
120B:  MOVLW  80
120C:  MOVWF  16
120D:  BCF    0A.4
120E:  BCF    03.6
120F:  CALL   2D5
1210:  BSF    0A.4
1211:  BSF    03.6
1212:  MOVF   12,W
1213:  MOVWF  14
1214:  CLRF   16
1215:  CLRF   15
1216:  BCF    0A.4
1217:  BCF    03.6
1218:  CALL   2F7
1219:  BSF    0A.4
121A:  MOVLW  00
121B:  BTFSC  78.0
121C:  MOVLW  01
121D:  BSF    03.6
121E:  MOVWF  12
121F:  MOVF   10,W
1220:  MOVWF  14
1221:  MOVF   12,W
1222:  MOVWF  15
1223:  CLRF   17
1224:  MOVLW  4D
1225:  MOVWF  16
1226:  BCF    0A.4
1227:  BCF    03.6
1228:  CALL   2D5
1229:  BSF    0A.4
122A:  BSF    03.6
122B:  INCF   10,F
122C:  GOTO   200
....................     }           
....................     FOR ( TB = 0; TB<4; TB++)              
122D:  CLRF   10
122E:  MOVF   10,W
122F:  SUBLW  03
1230:  BTFSS  03.0
1231:  GOTO   25E
....................     { 
....................        TT_THIETBI_TEMP[TB+4]=INPUT(68+TB); 
1232:  MOVLW  04
1233:  ADDWF  10,W
1234:  MOVWF  12
1235:  MOVLW  44
1236:  ADDWF  10,W
1237:  MOVWF  13
1238:  MOVWF  14
1239:  MOVLW  01
123A:  MOVWF  15
123B:  CLRF   17
123C:  MOVLW  80
123D:  MOVWF  16
123E:  BCF    0A.4
123F:  BCF    03.6
1240:  CALL   2D5
1241:  BSF    0A.4
1242:  BSF    03.6
1243:  MOVF   13,W
1244:  MOVWF  14
1245:  CLRF   16
1246:  CLRF   15
1247:  BCF    0A.4
1248:  BCF    03.6
1249:  CALL   2F7
124A:  BSF    0A.4
124B:  MOVLW  00
124C:  BTFSC  78.0
124D:  MOVLW  01
124E:  BSF    03.6
124F:  MOVWF  13
1250:  MOVF   12,W
1251:  MOVWF  14
1252:  MOVF   13,W
1253:  MOVWF  15
1254:  CLRF   17
1255:  MOVLW  4D
1256:  MOVWF  16
1257:  BCF    0A.4
1258:  BCF    03.6
1259:  CALL   2D5
125A:  BSF    0A.4
125B:  BSF    03.6
125C:  INCF   10,F
125D:  GOTO   22E
....................     }  
....................      
....................     WHILE (TRUE) 
....................     { 
....................        IF (TT_CONFIG)             {BUTT_FUN (); } // GOI HAM CHON LENH (SWITCH CASE) 
125E:  BCF    03.6
125F:  BTFSS  4E.1
1260:  GOTO   265
1261:  BCF    0A.4
1262:  GOTO   57E
1263:  BSF    0A.4
1264:  GOTO   398
....................        ELSE IF (TT_CONFIG_DONE)   { CONFIG_DONE ();}        
1265:  BTFSS  4E.3
1266:  GOTO   26D
1267:  BCF    0A.4
1268:  BSF    0A.3
1269:  GOTO   000
126A:  BSF    0A.4
126B:  BCF    0A.3
126C:  GOTO   398
....................        ELSE 
....................        { 
....................           WHILE (!TT_CONFIG) 
126D:  BTFSC  4E.1
126E:  GOTO   398
....................           {                          
....................              IF (TTNHAN == 1) 
126F:  BTFSS  4E.0
1270:  GOTO   277
....................              { 
....................                 TTNHAN = 0; 
1271:  BCF    4E.0
....................                 XU_LY_UART(); 
1272:  BCF    0A.4
1273:  BSF    0A.3
1274:  GOTO   371
1275:  BSF    0A.4
1276:  BCF    0A.3
....................              }  
....................              IF (TT_CONFIG_OKE_UART == 1) 
1277:  BTFSS  4E.6
1278:  GOTO   397
....................              { 
....................                 FOR (TB = 0; TB<4; TB++)              
1279:  BSF    03.6
127A:  CLRF   10
127B:  MOVF   10,W
127C:  SUBLW  03
127D:  BTFSS  03.0
127E:  GOTO   2D7
....................                 { 
....................                    IF(INPUT (52+TB) != TT_THIETBI_TEMP[TB] ) 
127F:  MOVLW  34
1280:  ADDWF  10,W
1281:  MOVWF  12
1282:  MOVWF  14
1283:  MOVLW  01
1284:  MOVWF  15
1285:  CLRF   17
1286:  MOVLW  80
1287:  MOVWF  16
1288:  BCF    0A.4
1289:  BCF    03.6
128A:  CALL   2D5
128B:  BSF    0A.4
128C:  BSF    03.6
128D:  MOVF   12,W
128E:  MOVWF  14
128F:  CLRF   16
1290:  CLRF   15
1291:  BCF    0A.4
1292:  BCF    03.6
1293:  CALL   2F7
1294:  BSF    0A.4
1295:  MOVLW  00
1296:  BTFSC  78.0
1297:  MOVLW  01
1298:  BSF    03.6
1299:  MOVWF  12
129A:  MOVF   10,W
129B:  MOVWF  14
129C:  CLRF   16
129D:  MOVLW  4D
129E:  MOVWF  15
129F:  BCF    0A.4
12A0:  BCF    03.6
12A1:  CALL   2F7
12A2:  BSF    0A.4
12A3:  MOVLW  00
12A4:  BTFSC  78.0
12A5:  MOVLW  01
12A6:  BSF    03.6
12A7:  SUBWF  12,W
12A8:  BTFSC  03.2
12A9:  GOTO   2D5
....................                       { 
....................                           TT_THIETBI_TEMP[TB]=INPUT(52+TB)  ; 
12AA:  MOVLW  34
12AB:  ADDWF  10,W
12AC:  MOVWF  12
12AD:  MOVWF  14
12AE:  MOVLW  01
12AF:  MOVWF  15
12B0:  CLRF   17
12B1:  MOVLW  80
12B2:  MOVWF  16
12B3:  BCF    0A.4
12B4:  BCF    03.6
12B5:  CALL   2D5
12B6:  BSF    0A.4
12B7:  BSF    03.6
12B8:  MOVF   12,W
12B9:  MOVWF  14
12BA:  CLRF   16
12BB:  CLRF   15
12BC:  BCF    0A.4
12BD:  BCF    03.6
12BE:  CALL   2F7
12BF:  BSF    0A.4
12C0:  MOVLW  00
12C1:  BTFSC  78.0
12C2:  MOVLW  01
12C3:  BSF    03.6
12C4:  MOVWF  12
12C5:  MOVF   10,W
12C6:  MOVWF  14
12C7:  MOVF   12,W
12C8:  MOVWF  15
12C9:  CLRF   17
12CA:  MOVLW  4D
12CB:  MOVWF  16
12CC:  BCF    0A.4
12CD:  BCF    03.6
12CE:  CALL   2D5
12CF:  BSF    0A.4
....................                           OUTPUT_LOW(PIN_D3); 
12D0:  BSF    03.5
12D1:  BCF    08.3
12D2:  BCF    03.5
12D3:  BCF    08.3
12D4:  BSF    03.6
....................                       } 
12D5:  INCF   10,F
12D6:  GOTO   27B
....................                 }           
....................                 FOR ( TB = 0; TB<4; TB++)              
12D7:  CLRF   10
12D8:  MOVF   10,W
12D9:  SUBLW  03
12DA:  BTFSS  03.0
12DB:  GOTO   338
....................                 { 
....................                    IF(INPUT (68+TB) != TT_THIETBI_TEMP[TB+4] ) 
12DC:  MOVLW  44
12DD:  ADDWF  10,W
12DE:  MOVWF  12
12DF:  MOVWF  14
12E0:  MOVLW  01
12E1:  MOVWF  15
12E2:  CLRF   17
12E3:  MOVLW  80
12E4:  MOVWF  16
12E5:  BCF    0A.4
12E6:  BCF    03.6
12E7:  CALL   2D5
12E8:  BSF    0A.4
12E9:  BSF    03.6
12EA:  MOVF   12,W
12EB:  MOVWF  14
12EC:  CLRF   16
12ED:  CLRF   15
12EE:  BCF    0A.4
12EF:  BCF    03.6
12F0:  CALL   2F7
12F1:  BSF    0A.4
12F2:  MOVLW  00
12F3:  BTFSC  78.0
12F4:  MOVLW  01
12F5:  BSF    03.6
12F6:  MOVWF  12
12F7:  MOVLW  04
12F8:  ADDWF  10,W
12F9:  MOVWF  14
12FA:  CLRF   16
12FB:  MOVLW  4D
12FC:  MOVWF  15
12FD:  BCF    0A.4
12FE:  BCF    03.6
12FF:  CALL   2F7
1300:  BSF    0A.4
1301:  MOVLW  00
1302:  BTFSC  78.0
1303:  MOVLW  01
1304:  BSF    03.6
1305:  SUBWF  12,W
1306:  BTFSC  03.2
1307:  GOTO   336
....................                       { 
....................                           TT_THIETBI_TEMP[TB+4]=INPUT(68+TB)  ; 
1308:  MOVLW  04
1309:  ADDWF  10,W
130A:  MOVWF  12
130B:  MOVLW  44
130C:  ADDWF  10,W
130D:  MOVWF  13
130E:  MOVWF  14
130F:  MOVLW  01
1310:  MOVWF  15
1311:  CLRF   17
1312:  MOVLW  80
1313:  MOVWF  16
1314:  BCF    0A.4
1315:  BCF    03.6
1316:  CALL   2D5
1317:  BSF    0A.4
1318:  BSF    03.6
1319:  MOVF   13,W
131A:  MOVWF  14
131B:  CLRF   16
131C:  CLRF   15
131D:  BCF    0A.4
131E:  BCF    03.6
131F:  CALL   2F7
1320:  BSF    0A.4
1321:  MOVLW  00
1322:  BTFSC  78.0
1323:  MOVLW  01
1324:  BSF    03.6
1325:  MOVWF  13
1326:  MOVF   12,W
1327:  MOVWF  14
1328:  MOVF   13,W
1329:  MOVWF  15
132A:  CLRF   17
132B:  MOVLW  4D
132C:  MOVWF  16
132D:  BCF    0A.4
132E:  BCF    03.6
132F:  CALL   2D5
1330:  BSF    0A.4
....................                           OUTPUT_LOW(PIN_D3); 
1331:  BSF    03.5
1332:  BCF    08.3
1333:  BCF    03.5
1334:  BCF    08.3
1335:  BSF    03.6
....................                       } 
1336:  INCF   10,F
1337:  GOTO   2D8
....................                 }              
....................                 IF (TT_SW == 1) 
1338:  BCF    03.6
1339:  BTFSS  4E.7
133A:  GOTO   381
....................                 { 
....................                   TT_SW = 0 ; 
133B:  BCF    4E.7
....................                   LCD_GOTOXY (1, 2) ; 
133C:  MOVLW  01
133D:  BSF    03.6
133E:  MOVWF  43
133F:  MOVLW  02
1340:  MOVWF  44
1341:  BCF    0A.4
1342:  BCF    03.6
1343:  CALL   310
1344:  BSF    0A.4
....................                   DELAY_MS (10); 
1345:  MOVLW  0A
1346:  BSF    03.6
1347:  MOVWF  43
1348:  BCF    0A.4
1349:  BCF    03.6
134A:  CALL   155
134B:  BSF    0A.4
....................                   PRINTF (LCD_PUTC, "SW: ");       
134C:  MOVLW  52
134D:  BSF    03.6
134E:  MOVWF  0D
134F:  MOVLW  01
1350:  MOVWF  0F
1351:  BCF    0A.4
1352:  BCF    03.6
1353:  CALL   35E
1354:  BSF    0A.4
....................                   FOR (INT SW = 0 ;  SW<8; SW++) 
1355:  BSF    03.6
1356:  CLRF   11
1357:  MOVF   11,W
1358:  SUBLW  07
1359:  BTFSS  03.0
135A:  GOTO   380
....................                   { 
....................                      ITOA(TT_THIETBI_TEMP[SW],10,TEMP_CHAR); 
135B:  MOVF   11,W
135C:  MOVWF  14
135D:  CLRF   16
135E:  MOVLW  4D
135F:  MOVWF  15
1360:  BCF    0A.4
1361:  BCF    03.6
1362:  CALL   2F7
1363:  BSF    0A.4
1364:  MOVLW  00
1365:  BTFSC  78.0
1366:  MOVLW  01
1367:  BSF    03.6
1368:  MOVWF  12
1369:  CLRF   44
136A:  CLRF   43
136B:  CLRF   42
136C:  MOVF   12,W
136D:  MOVWF  41
136E:  MOVLW  0A
136F:  MOVWF  45
1370:  CLRF   47
1371:  MOVLW  6F
1372:  MOVWF  46
1373:  BCF    0A.4
1374:  BCF    03.6
1375:  CALL   42A
1376:  BSF    0A.4
....................                      PRINTF (TEMP_CHAR); 
1377:  MOVLW  6F
1378:  MOVWF  04
1379:  BCF    03.7
137A:  BCF    0A.4
137B:  CALL   7B9
137C:  BSF    0A.4
137D:  BSF    03.6
137E:  INCF   11,F
137F:  GOTO   357
1380:  BCF    03.6
....................                   }         
....................                 }              
....................                DELAY_MS(2000); 
1381:  MOVLW  08
1382:  BSF    03.6
1383:  MOVWF  12
1384:  MOVLW  FA
1385:  MOVWF  43
1386:  BCF    0A.4
1387:  BCF    03.6
1388:  CALL   155
1389:  BSF    0A.4
138A:  BSF    03.6
138B:  DECFSZ 12,F
138C:  GOTO   384
....................                READ_ANALOG(); 
138D:  BCF    0A.4
138E:  BSF    0A.3
138F:  BCF    03.6
1390:  GOTO   5B2
1391:  BSF    0A.4
1392:  BCF    0A.3
....................                IF (KET_QUA_ANALOG[0]>28) 
1393:  MOVF   34,W
1394:  SUBLW  1C
1395:  BTFSS  03.0
....................                {                
....................                SEND_ANALOG_UART(); 
1396:  GOTO   000
....................                } 
....................              } 
1397:  GOTO   26D
....................  
....................           } 
....................        } 
1398:  GOTO   25F
....................     } 
....................  } 
....................  
1399:  SLEEP

Configuration Fuses:
   Word  1: 2FE2   HS NOWDT PUT MCLR NOPROTECT NOCPD BROWNOUT IESO FCMEN NOLVP NODEBUG
   Word  2: 3FFF   BORV40 NOWRT
