CCS PCM C Compiler, Version 5.015, 5967               14-Nov-21 22:40

               Filename:   E:\DATN_V2\NODE\pic\pic16f887\hellopic.lst

               ROM used:   5366 words (66%)
                           Largest free fragment is 2048
               RAM used:   181 (49%) at main() level
                           266 (72%) worst case
               Stack used: 8 locations (7 in main + 1 for interrupts)
               Stack size: 8

*
0000:  MOVLW  14
0001:  MOVWF  0A
0002:  GOTO   4A6
0003:  NOP
0004:  MOVWF  7F
0005:  SWAPF  03,W
0006:  CLRF   03
0007:  MOVWF  21
0008:  MOVF   0A,W
0009:  MOVWF  20
000A:  CLRF   0A
000B:  MOVF   04,W
000C:  MOVWF  22
000D:  MOVF   77,W
000E:  MOVWF  23
000F:  MOVF   78,W
0010:  MOVWF  24
0011:  MOVF   79,W
0012:  MOVWF  25
0013:  MOVF   7A,W
0014:  MOVWF  26
0015:  BSF    03.6
0016:  MOVF   0D,W
0017:  BCF    03.6
0018:  MOVWF  27
0019:  BSF    03.6
001A:  MOVF   0F,W
001B:  BCF    03.6
001C:  MOVWF  28
001D:  BSF    03.6
001E:  MOVF   0C,W
001F:  BCF    03.6
0020:  MOVWF  29
0021:  BSF    03.6
0022:  MOVF   0E,W
0023:  BCF    03.6
0024:  MOVWF  2A
0025:  BCF    03.7
0026:  BCF    03.5
0027:  BTFSS  0B.4
0028:  GOTO   02B
0029:  BTFSC  0B.1
002A:  GOTO   052
002B:  MOVLW  8C
002C:  MOVWF  04
002D:  BTFSS  00.5
002E:  GOTO   031
002F:  BTFSC  0C.5
0030:  GOTO   055
0031:  MOVF   22,W
0032:  MOVWF  04
0033:  MOVF   23,W
0034:  MOVWF  77
0035:  MOVF   24,W
0036:  MOVWF  78
0037:  MOVF   25,W
0038:  MOVWF  79
0039:  MOVF   26,W
003A:  MOVWF  7A
003B:  MOVF   27,W
003C:  BSF    03.6
003D:  MOVWF  0D
003E:  BCF    03.6
003F:  MOVF   28,W
0040:  BSF    03.6
0041:  MOVWF  0F
0042:  BCF    03.6
0043:  MOVF   29,W
0044:  BSF    03.6
0045:  MOVWF  0C
0046:  BCF    03.6
0047:  MOVF   2A,W
0048:  BSF    03.6
0049:  MOVWF  0E
004A:  BCF    03.6
004B:  MOVF   20,W
004C:  MOVWF  0A
004D:  SWAPF  21,W
004E:  MOVWF  03
004F:  SWAPF  7F,F
0050:  SWAPF  7F,W
0051:  RETFIE
0052:  BCF    0A.3
0053:  BCF    0A.4
0054:  GOTO   109
0055:  BCF    0A.3
0056:  BCF    0A.4
0057:  GOTO   14F
....................  
.................... #INCLUDE <thuvien.c> 
.................... #INCLUDE <16F887.H> 
.................... //////////// Standard Header file for the PIC16F887 device //////////////// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2013 Custom Computer Services          //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... #device PIC16F887 
0058:  BCF    0A.0
0059:  BCF    0A.1
005A:  BCF    0A.2
005B:  ADDWF  02,F
005C:  RETLW  30
005D:  RETLW  00
005E:  BCF    0A.0
005F:  BCF    0A.1
0060:  BCF    0A.2
0061:  ADDWF  02,F
0062:  RETLW  5F
0063:  RETLW  00
0064:  BCF    0A.0
0065:  BCF    0A.1
0066:  BCF    0A.2
0067:  ADDWF  02,F
0068:  RETLW  32
0069:  RETLW  32
006A:  RETLW  00
006B:  BCF    0A.0
006C:  BCF    0A.1
006D:  BCF    0A.2
006E:  ADDWF  02,F
006F:  RETLW  32
0070:  RETLW  33
0071:  RETLW  00
0072:  BCF    0A.0
0073:  BCF    0A.1
0074:  BCF    0A.2
0075:  ADDWF  02,F
0076:  RETLW  32
0077:  RETLW  34
0078:  RETLW  00
0079:  BCF    0A.0
007A:  BCF    0A.1
007B:  BCF    0A.2
007C:  ADDWF  02,F
007D:  RETLW  23
007E:  RETLW  00
007F:  BCF    0A.0
0080:  BCF    0A.1
0081:  BCF    0A.2
0082:  ADDWF  02,F
0083:  RETLW  00
0084:  DATA CE,27
0085:  DATA C4,22
0086:  DATA 3A,10
0087:  DATA 00,00
0088:  DATA 20,10
0089:  DATA 20,10
008A:  DATA 20,10
008B:  DATA 20,10
008C:  DATA 20,10
008D:  DATA 00,01
008E:  DATA 20,10
008F:  DATA 20,10
0090:  DATA 20,10
0091:  DATA 5F,10
0092:  DATA 20,10
0093:  DATA 20,10
0094:  DATA 20,10
0095:  DATA 20,10
0096:  DATA 20,10
0097:  DATA 20,10
0098:  DATA 20,00
0099:  DATA 20,10
009A:  DATA 20,10
009B:  DATA 5F,10
009C:  DATA 20,10
009D:  DATA 20,00
009E:  DATA 49,22
009F:  DATA DF,23
00A0:  DATA 57,1D
00A1:  DATA 00,01
00A2:  DATA 20,10
00A3:  DATA 20,10
00A4:  DATA 20,10
00A5:  DATA 20,10
00A6:  DATA 20,10
00A7:  DATA 00,01
00A8:  DATA 20,10
00A9:  DATA 20,10
00AA:  DATA 20,10
00AB:  DATA 5F,10
00AC:  DATA 20,10
00AD:  DATA 20,10
00AE:  DATA 20,10
00AF:  DATA 20,10
00B0:  DATA 20,10
00B1:  DATA 20,10
00B2:  DATA 20,10
00B3:  DATA 20,00
00B4:  DATA 20,10
00B5:  DATA 20,10
00B6:  DATA 5F,10
00B7:  DATA 20,10
00B8:  DATA 20,10
00B9:  DATA 20,10
00BA:  DATA 20,00
00BB:  DATA C3,27
00BC:  DATA 4E,23
00BD:  DATA C9,23
00BE:  DATA 3A,10
00BF:  DATA 20,10
00C0:  DATA 20,10
00C1:  DATA 20,10
00C2:  DATA 20,00
00C3:  DATA C3,20
00C4:  DATA D3,22
00C5:  DATA 3A,10
00C6:  DATA 20,10
00C7:  DATA 20,10
00C8:  DATA 20,10
00C9:  DATA 20,10
00CA:  DATA 20,00
00CB:  DATA A0,16
00CC:  DATA A0,24
00CD:  DATA C4,16
00CE:  DATA CE,27
00CF:  DATA C4,22
00D0:  DATA 20,10
00D1:  DATA 20,10
00D2:  DATA 20,10
00D3:  DATA 00,01
00D4:  DATA A0,16
00D5:  DATA A0,24
00D6:  DATA C4,16
00D7:  DATA C7,2B
00D8:  DATA 20,10
00D9:  DATA 20,10
00DA:  DATA 20,10
00DB:  DATA 20,00
00DC:  DATA D7,20
00DD:  DATA 49,2A
00DE:  DATA 49,27
00DF:  DATA 47,10
00E0:  DATA 2E,17
00E1:  DATA 2E,17
00E2:  DATA 20,10
00E3:  DATA 20,10
00E4:  DATA 20,10
00E5:  DATA 20,10
00E6:  DATA 00,01
00E7:  DATA D7,20
00E8:  DATA 49,2A
00E9:  DATA 49,27
00EA:  DATA 47,10
00EB:  DATA 2E,17
00EC:  DATA 2E,17
00ED:  DATA 20,10
00EE:  DATA 20,10
00EF:  DATA 20,10
00F0:  DATA 20,10
00F1:  DATA 00,00
00F2:  DATA 20,10
00F3:  DATA 20,10
00F4:  DATA 20,10
00F5:  DATA 20,10
00F6:  DATA 20,10
00F7:  DATA 20,10
00F8:  DATA 00,01
00F9:  DATA 54,21
00FA:  DATA 3A,10
00FB:  DATA 00,01
00FC:  DATA 20,10
00FD:  DATA 20,10
00FE:  DATA 43,21
00FF:  DATA 3A,00
0100:  DATA 40,22
0101:  DATA 4B,20
0102:  DATA 00,00
0103:  DATA D3,2B
0104:  DATA 3A,10
0105:  DATA 00,01
0106:  DATA C0,29
0107:  DATA 53,20
0108:  DATA 00,01
*
031D:  BTFSC  03.1
031E:  GOTO   322
031F:  MOVLW  63
0320:  MOVWF  04
0321:  BSF    03.7
0322:  BSF    03.6
0323:  MOVF   5E,W
0324:  XORWF  62,W
0325:  ANDLW  80
0326:  MOVWF  68
0327:  BTFSS  5E.7
0328:  GOTO   334
0329:  COMF   5B,F
032A:  COMF   5C,F
032B:  COMF   5D,F
032C:  COMF   5E,F
032D:  INCF   5B,F
032E:  BTFSC  03.2
032F:  INCF   5C,F
0330:  BTFSC  03.2
0331:  INCF   5D,F
0332:  BTFSC  03.2
0333:  INCF   5E,F
0334:  BTFSS  62.7
0335:  GOTO   341
0336:  COMF   5F,F
0337:  COMF   60,F
0338:  COMF   61,F
0339:  COMF   62,F
033A:  INCF   5F,F
033B:  BTFSC  03.2
033C:  INCF   60,F
033D:  BTFSC  03.2
033E:  INCF   61,F
033F:  BTFSC  03.2
0340:  INCF   62,F
0341:  CLRF   77
0342:  CLRF   78
0343:  CLRF   79
0344:  CLRF   7A
0345:  CLRF   63
0346:  CLRF   64
0347:  CLRF   65
0348:  CLRF   66
0349:  MOVF   62,W
034A:  IORWF  61,W
034B:  IORWF  60,W
034C:  IORWF  5F,W
034D:  BTFSC  03.2
034E:  GOTO   37F
034F:  MOVLW  20
0350:  MOVWF  67
0351:  BCF    03.0
0352:  RLF    5B,F
0353:  RLF    5C,F
0354:  RLF    5D,F
0355:  RLF    5E,F
0356:  RLF    63,F
0357:  RLF    64,F
0358:  RLF    65,F
0359:  RLF    66,F
035A:  MOVF   62,W
035B:  SUBWF  66,W
035C:  BTFSS  03.2
035D:  GOTO   368
035E:  MOVF   61,W
035F:  SUBWF  65,W
0360:  BTFSS  03.2
0361:  GOTO   368
0362:  MOVF   60,W
0363:  SUBWF  64,W
0364:  BTFSS  03.2
0365:  GOTO   368
0366:  MOVF   5F,W
0367:  SUBWF  63,W
0368:  BTFSS  03.0
0369:  GOTO   379
036A:  MOVF   5F,W
036B:  SUBWF  63,F
036C:  MOVF   60,W
036D:  BTFSS  03.0
036E:  INCFSZ 60,W
036F:  SUBWF  64,F
0370:  MOVF   61,W
0371:  BTFSS  03.0
0372:  INCFSZ 61,W
0373:  SUBWF  65,F
0374:  MOVF   62,W
0375:  BTFSS  03.0
0376:  INCFSZ 62,W
0377:  SUBWF  66,F
0378:  BSF    03.0
0379:  RLF    77,F
037A:  RLF    78,F
037B:  RLF    79,F
037C:  RLF    7A,F
037D:  DECFSZ 67,F
037E:  GOTO   351
037F:  BTFSS  68.7
0380:  GOTO   38C
0381:  COMF   77,F
0382:  COMF   78,F
0383:  COMF   79,F
0384:  COMF   7A,F
0385:  INCF   77,F
0386:  BTFSC  03.2
0387:  INCF   78,F
0388:  BTFSC  03.2
0389:  INCF   79,F
038A:  BTFSC  03.2
038B:  INCF   7A,F
038C:  MOVF   63,W
038D:  MOVWF  00
038E:  INCF   04,F
038F:  MOVF   64,W
0390:  MOVWF  00
0391:  INCF   04,F
0392:  MOVF   65,W
0393:  MOVWF  00
0394:  INCF   04,F
0395:  MOVF   66,W
0396:  MOVWF  00
0397:  BCF    03.6
0398:  RETURN
*
03B2:  MOVLW  20
03B3:  MOVWF  5F
03B4:  CLRF   5B
03B5:  CLRF   5C
03B6:  CLRF   5D
03B7:  CLRF   5E
03B8:  MOVF   56,W
03B9:  MOVWF  7A
03BA:  MOVF   55,W
03BB:  MOVWF  79
03BC:  MOVF   54,W
03BD:  MOVWF  78
03BE:  MOVF   53,W
03BF:  MOVWF  77
03C0:  BCF    03.0
03C1:  BTFSS  77.0
03C2:  GOTO   3D1
03C3:  MOVF   57,W
03C4:  ADDWF  5B,F
03C5:  MOVF   58,W
03C6:  BTFSC  03.0
03C7:  INCFSZ 58,W
03C8:  ADDWF  5C,F
03C9:  MOVF   59,W
03CA:  BTFSC  03.0
03CB:  INCFSZ 59,W
03CC:  ADDWF  5D,F
03CD:  MOVF   5A,W
03CE:  BTFSC  03.0
03CF:  INCFSZ 5A,W
03D0:  ADDWF  5E,F
03D1:  RRF    5E,F
03D2:  RRF    5D,F
03D3:  RRF    5C,F
03D4:  RRF    5B,F
03D5:  RRF    7A,F
03D6:  RRF    79,F
03D7:  RRF    78,F
03D8:  RRF    77,F
03D9:  DECFSZ 5F,F
03DA:  GOTO   3C0
*
04F7:  MOVF   00,F
04F8:  BTFSC  03.2
04F9:  GOTO   514
04FA:  BSF    03.6
04FB:  CLRF   45
04FC:  MOVF   04,W
04FD:  MOVWF  44
04FE:  BCF    45.0
04FF:  BTFSC  03.7
0500:  BSF    45.0
0501:  MOVF   00,W
0502:  BCF    03.6
0503:  BTFSS  0C.4
0504:  GOTO   503
0505:  MOVWF  19
0506:  BSF    03.6
0507:  MOVF   44,W
0508:  MOVWF  04
0509:  BCF    03.7
050A:  BTFSC  45.0
050B:  BSF    03.7
050C:  INCF   04,F
050D:  BTFSS  03.2
050E:  GOTO   512
050F:  BCF    03.6
0510:  INCF   05,F
0511:  BSF    03.6
0512:  BCF    03.6
0513:  GOTO   4F7
0514:  RETURN
*
0563:  MOVF   0B,W
0564:  BSF    03.6
0565:  MOVWF  42
0566:  BCF    03.6
0567:  BCF    0B.7
0568:  BSF    03.5
0569:  BSF    03.6
056A:  BSF    0C.7
056B:  BSF    0C.0
056C:  NOP
056D:  NOP
056E:  BCF    03.5
056F:  BTFSS  42.7
0570:  GOTO   574
0571:  BCF    03.6
0572:  BSF    0B.7
0573:  BSF    03.6
0574:  MOVF   0C,W
0575:  ANDLW  7F
0576:  BTFSC  03.2
0577:  GOTO   5B1
0578:  MOVWF  42
0579:  MOVF   0D,W
057A:  MOVWF  43
057B:  MOVF   0F,W
057C:  MOVWF  44
057D:  MOVF   42,W
057E:  MOVWF  45
057F:  BCF    03.6
0580:  CALL   529
0581:  BSF    03.6
0582:  MOVF   43,W
0583:  MOVWF  0D
0584:  MOVF   44,W
0585:  MOVWF  0F
0586:  BCF    03.6
0587:  MOVF   0B,W
0588:  BSF    03.6
0589:  MOVWF  45
058A:  BCF    03.6
058B:  BCF    0B.7
058C:  BSF    03.5
058D:  BSF    03.6
058E:  BSF    0C.7
058F:  BSF    0C.0
0590:  NOP
0591:  NOP
0592:  BCF    03.5
0593:  BTFSS  45.7
0594:  GOTO   598
0595:  BCF    03.6
0596:  BSF    0B.7
0597:  BSF    03.6
0598:  RLF    0C,W
0599:  RLF    0E,W
059A:  ANDLW  7F
059B:  BTFSC  03.2
059C:  GOTO   5B1
059D:  MOVWF  42
059E:  MOVF   0D,W
059F:  MOVWF  43
05A0:  MOVF   0F,W
05A1:  MOVWF  44
05A2:  MOVF   42,W
05A3:  MOVWF  45
05A4:  BCF    03.6
05A5:  CALL   529
05A6:  BSF    03.6
05A7:  MOVF   43,W
05A8:  MOVWF  0D
05A9:  MOVF   44,W
05AA:  MOVWF  0F
05AB:  INCF   0D,F
05AC:  BTFSC  03.2
05AD:  INCF   0F,F
05AE:  BCF    03.6
05AF:  GOTO   563
05B0:  BSF    03.6
05B1:  BCF    03.6
05B2:  RETURN
*
0711:  MOVF   00,F
0712:  BTFSC  03.2
0713:  GOTO   72D
0714:  BSF    03.6
0715:  CLRF   1F
0716:  MOVF   04,W
0717:  MOVWF  1E
0718:  BCF    1F.0
0719:  BTFSC  03.7
071A:  BSF    1F.0
071B:  MOVF   00,W
071C:  MOVWF  45
071D:  BCF    03.6
071E:  CALL   529
071F:  BSF    03.6
0720:  MOVF   1E,W
0721:  MOVWF  04
0722:  BCF    03.7
0723:  BTFSC  1F.0
0724:  BSF    03.7
0725:  INCF   04,F
0726:  BTFSS  03.2
0727:  GOTO   72B
0728:  BCF    03.6
0729:  INCF   05,F
072A:  BSF    03.6
072B:  BCF    03.6
072C:  GOTO   711
072D:  RETURN
072E:  BSF    03.6
072F:  MOVF   1A,W
0730:  CLRF   78
0731:  SUBWF  19,W
0732:  BTFSC  03.0
0733:  GOTO   737
0734:  MOVF   19,W
0735:  MOVWF  77
0736:  GOTO   743
0737:  CLRF   77
0738:  MOVLW  08
0739:  MOVWF  1B
073A:  RLF    19,F
073B:  RLF    77,F
073C:  MOVF   1A,W
073D:  SUBWF  77,W
073E:  BTFSC  03.0
073F:  MOVWF  77
0740:  RLF    78,F
0741:  DECFSZ 1B,F
0742:  GOTO   73A
0743:  BCF    03.6
0744:  RETURN
0745:  CLRF   77
0746:  CLRF   78
0747:  BSF    03.6
0748:  MOVF   24,W
0749:  BCF    03.0
074A:  BTFSC  25.0
074B:  ADDWF  77,F
074C:  RRF    77,F
074D:  RRF    78,F
074E:  BTFSC  25.1
074F:  ADDWF  77,F
0750:  RRF    77,F
0751:  RRF    78,F
0752:  BTFSC  25.2
0753:  ADDWF  77,F
0754:  RRF    77,F
0755:  RRF    78,F
0756:  BTFSC  25.3
0757:  ADDWF  77,F
0758:  RRF    77,F
0759:  RRF    78,F
075A:  BTFSC  25.4
075B:  ADDWF  77,F
075C:  RRF    77,F
075D:  RRF    78,F
075E:  BTFSC  25.5
075F:  ADDWF  77,F
0760:  RRF    77,F
0761:  RRF    78,F
0762:  BTFSC  25.6
0763:  ADDWF  77,F
0764:  RRF    77,F
0765:  RRF    78,F
0766:  BTFSC  25.7
0767:  ADDWF  77,F
0768:  RRF    77,F
0769:  RRF    78,F
076A:  BCF    03.6
076B:  RETURN
*
07B2:  BSF    03.6
07B3:  MOVF   1E,W
07B4:  ANDLW  07
07B5:  MOVWF  77
07B6:  RRF    1E,W
07B7:  MOVWF  78
07B8:  RRF    78,F
07B9:  RRF    78,F
07BA:  MOVLW  1F
07BB:  ANDWF  78,F
07BC:  MOVF   78,W
07BD:  ADDWF  20,W
07BE:  MOVWF  04
07BF:  BCF    03.7
07C0:  BTFSC  21.0
07C1:  BSF    03.7
07C2:  CLRF   78
07C3:  INCF   78,F
07C4:  INCF   77,F
07C5:  GOTO   7C7
07C6:  RLF    78,F
07C7:  DECFSZ 77,F
07C8:  GOTO   7C6
07C9:  MOVF   1F,F
07CA:  BTFSC  03.2
07CB:  GOTO   7CF
07CC:  MOVF   78,W
07CD:  IORWF  00,F
07CE:  GOTO   7D2
07CF:  COMF   78,F
07D0:  MOVF   78,W
07D1:  ANDWF  00,F
07D2:  BCF    03.6
07D3:  RETURN
07D4:  BSF    03.6
07D5:  MOVF   21,W
07D6:  ANDLW  07
07D7:  MOVWF  77
07D8:  RRF    21,W
07D9:  MOVWF  78
07DA:  RRF    78,F
07DB:  RRF    78,F
07DC:  MOVLW  1F
07DD:  ANDWF  78,F
07DE:  MOVF   78,W
07DF:  ADDWF  22,W
07E0:  MOVWF  04
07E1:  BCF    03.7
07E2:  BTFSC  23.0
07E3:  BSF    03.7
07E4:  MOVF   00,W
07E5:  MOVWF  78
07E6:  INCF   77,F
07E7:  GOTO   7E9
07E8:  RRF    78,F
07E9:  DECFSZ 77,F
07EA:  GOTO   7E8
07EB:  BCF    03.6
07EC:  RETURN
*
0C39:  MOVF   0B,W
0C3A:  BSF    03.6
0C3B:  MOVWF  40
0C3C:  BCF    03.6
0C3D:  BCF    0B.7
0C3E:  BSF    03.5
0C3F:  BSF    03.6
0C40:  BSF    0C.7
0C41:  BSF    0C.0
0C42:  NOP
0C43:  NOP
0C44:  BCF    03.5
0C45:  BTFSS  40.7
0C46:  GOTO   44A
0C47:  BCF    03.6
0C48:  BSF    0B.7
0C49:  BSF    03.6
0C4A:  MOVF   0C,W
0C4B:  ANDLW  7F
0C4C:  BTFSC  03.2
0C4D:  GOTO   489
0C4E:  MOVWF  40
0C4F:  MOVF   0D,W
0C50:  MOVWF  41
0C51:  MOVF   0F,W
0C52:  MOVWF  42
0C53:  MOVF   40,W
0C54:  BCF    03.6
0C55:  BTFSS  0C.4
0C56:  GOTO   455
0C57:  MOVWF  19
0C58:  BSF    03.6
0C59:  MOVF   41,W
0C5A:  MOVWF  0D
0C5B:  MOVF   42,W
0C5C:  MOVWF  0F
0C5D:  BCF    03.6
0C5E:  MOVF   0B,W
0C5F:  BSF    03.6
0C60:  MOVWF  43
0C61:  BCF    03.6
0C62:  BCF    0B.7
0C63:  BSF    03.5
0C64:  BSF    03.6
0C65:  BSF    0C.7
0C66:  BSF    0C.0
0C67:  NOP
0C68:  NOP
0C69:  BCF    03.5
0C6A:  BTFSS  43.7
0C6B:  GOTO   46F
0C6C:  BCF    03.6
0C6D:  BSF    0B.7
0C6E:  BSF    03.6
0C6F:  RLF    0C,W
0C70:  RLF    0E,W
0C71:  ANDLW  7F
0C72:  BTFSC  03.2
0C73:  GOTO   489
0C74:  MOVWF  40
0C75:  MOVF   0D,W
0C76:  MOVWF  41
0C77:  MOVF   0F,W
0C78:  MOVWF  42
0C79:  MOVF   40,W
0C7A:  BCF    03.6
0C7B:  BTFSS  0C.4
0C7C:  GOTO   47B
0C7D:  MOVWF  19
0C7E:  BSF    03.6
0C7F:  MOVF   41,W
0C80:  MOVWF  0D
0C81:  MOVF   42,W
0C82:  MOVWF  0F
0C83:  INCF   0D,F
0C84:  BTFSC  03.2
0C85:  INCF   0F,F
0C86:  BCF    03.6
0C87:  GOTO   439
0C88:  BSF    03.6
0C89:  BCF    03.6
0C8A:  RETURN
*
1258:  BCF    0A.0
1259:  BSF    0A.1
125A:  BCF    0A.2
125B:  ADDWF  02,F
125C:  GOTO   0AB
125D:  GOTO   0AC
125E:  GOTO   0B9
125F:  GOTO   0C6
1260:  GOTO   0D4
1261:  GOTO   0E2
*
12DC:  MOVLW  8E
12DD:  MOVWF  77
12DE:  MOVF   23,W
12DF:  MOVWF  78
12E0:  MOVF   22,W
12E1:  MOVWF  79
12E2:  CLRF   7A
12E3:  MOVF   78,F
12E4:  BTFSS  03.2
12E5:  GOTO   2F0
12E6:  MOVF   79,W
12E7:  MOVWF  78
12E8:  CLRF   79
12E9:  MOVLW  08
12EA:  SUBWF  77,F
12EB:  MOVF   78,F
12EC:  BTFSS  03.2
12ED:  GOTO   2F0
12EE:  CLRF   77
12EF:  GOTO   2F8
12F0:  BCF    03.0
12F1:  BTFSC  78.7
12F2:  GOTO   2F7
12F3:  RLF    79,F
12F4:  RLF    78,F
12F5:  DECF   77,F
12F6:  GOTO   2F0
12F7:  BCF    78.7
*
1308:  MOVF   22,W
1309:  BTFSC  03.2
130A:  GOTO   3CD
130B:  MOVWF  2E
130C:  MOVF   26,W
130D:  BTFSC  03.2
130E:  GOTO   3CD
130F:  SUBWF  2E,F
1310:  BTFSS  03.0
1311:  GOTO   317
1312:  MOVLW  7F
1313:  ADDWF  2E,F
1314:  BTFSC  03.0
1315:  GOTO   3CD
1316:  GOTO   31D
1317:  MOVLW  81
1318:  SUBWF  2E,F
1319:  BTFSS  03.0
131A:  GOTO   3CD
131B:  BTFSC  03.2
131C:  GOTO   3CD
131D:  MOVF   2E,W
131E:  MOVWF  77
131F:  CLRF   78
1320:  CLRF   79
1321:  CLRF   7A
1322:  CLRF   2D
1323:  MOVF   23,W
1324:  MOVWF  2C
1325:  BSF    2C.7
1326:  MOVF   24,W
1327:  MOVWF  2B
1328:  MOVF   25,W
1329:  MOVWF  2A
132A:  MOVLW  19
132B:  MOVWF  2E
132C:  MOVF   29,W
132D:  SUBWF  2A,F
132E:  BTFSC  03.0
132F:  GOTO   340
1330:  MOVLW  01
1331:  SUBWF  2B,F
1332:  BTFSC  03.0
1333:  GOTO   340
1334:  SUBWF  2C,F
1335:  BTFSC  03.0
1336:  GOTO   340
1337:  SUBWF  2D,F
1338:  BTFSC  03.0
1339:  GOTO   340
133A:  INCF   2D,F
133B:  INCF   2C,F
133C:  INCF   2B,F
133D:  MOVF   29,W
133E:  ADDWF  2A,F
133F:  GOTO   372
1340:  MOVF   28,W
1341:  SUBWF  2B,F
1342:  BTFSC  03.0
1343:  GOTO   35B
1344:  MOVLW  01
1345:  SUBWF  2C,F
1346:  BTFSC  03.0
1347:  GOTO   35B
1348:  SUBWF  2D,F
1349:  BTFSC  03.0
134A:  GOTO   35B
134B:  INCF   2D,F
134C:  INCF   2C,F
134D:  MOVF   28,W
134E:  ADDWF  2B,F
134F:  MOVF   29,W
1350:  ADDWF  2A,F
1351:  BTFSS  03.0
1352:  GOTO   372
1353:  INCF   2B,F
1354:  BTFSS  03.2
1355:  GOTO   372
1356:  INCF   2C,F
1357:  BTFSS  03.2
1358:  GOTO   372
1359:  INCF   2D,F
135A:  GOTO   372
135B:  MOVF   27,W
135C:  IORLW  80
135D:  SUBWF  2C,F
135E:  BTFSC  03.0
135F:  GOTO   371
1360:  MOVLW  01
1361:  SUBWF  2D,F
1362:  BTFSC  03.0
1363:  GOTO   371
1364:  INCF   2D,F
1365:  MOVF   27,W
1366:  IORLW  80
1367:  ADDWF  2C,F
1368:  MOVF   28,W
1369:  ADDWF  2B,F
136A:  BTFSS  03.0
136B:  GOTO   34F
136C:  INCF   2C,F
136D:  BTFSS  03.2
136E:  GOTO   34F
136F:  INCF   2D,F
1370:  GOTO   34F
1371:  BSF    7A.0
1372:  DECFSZ 2E,F
1373:  GOTO   375
1374:  GOTO   380
1375:  BCF    03.0
1376:  RLF    2A,F
1377:  RLF    2B,F
1378:  RLF    2C,F
1379:  RLF    2D,F
137A:  BCF    03.0
137B:  RLF    7A,F
137C:  RLF    79,F
137D:  RLF    78,F
137E:  RLF    2F,F
137F:  GOTO   32C
1380:  BTFSS  2F.0
1381:  GOTO   388
1382:  BCF    03.0
1383:  RRF    78,F
1384:  RRF    79,F
1385:  RRF    7A,F
1386:  RRF    2F,F
1387:  GOTO   38B
1388:  DECF   77,F
1389:  BTFSC  03.2
138A:  GOTO   3CD
138B:  BTFSC  2F.7
138C:  GOTO   3B4
138D:  BCF    03.0
138E:  RLF    2A,F
138F:  RLF    2B,F
1390:  RLF    2C,F
1391:  RLF    2D,F
1392:  MOVF   29,W
1393:  SUBWF  2A,F
1394:  BTFSC  03.0
1395:  GOTO   3A0
1396:  MOVLW  01
1397:  SUBWF  2B,F
1398:  BTFSC  03.0
1399:  GOTO   3A0
139A:  SUBWF  2C,F
139B:  BTFSC  03.0
139C:  GOTO   3A0
139D:  SUBWF  2D,F
139E:  BTFSS  03.0
139F:  GOTO   3C3
13A0:  MOVF   28,W
13A1:  SUBWF  2B,F
13A2:  BTFSC  03.0
13A3:  GOTO   3AB
13A4:  MOVLW  01
13A5:  SUBWF  2C,F
13A6:  BTFSC  03.0
13A7:  GOTO   3AB
13A8:  SUBWF  2D,F
13A9:  BTFSS  03.0
13AA:  GOTO   3C3
13AB:  MOVF   27,W
13AC:  IORLW  80
13AD:  SUBWF  2C,F
13AE:  BTFSC  03.0
13AF:  GOTO   3B4
13B0:  MOVLW  01
13B1:  SUBWF  2D,F
13B2:  BTFSS  03.0
13B3:  GOTO   3C3
13B4:  INCF   7A,F
13B5:  BTFSS  03.2
13B6:  GOTO   3C3
13B7:  INCF   79,F
13B8:  BTFSS  03.2
13B9:  GOTO   3C3
13BA:  INCF   78,F
13BB:  BTFSS  03.2
13BC:  GOTO   3C3
13BD:  INCF   77,F
13BE:  BTFSC  03.2
13BF:  GOTO   3CD
13C0:  RRF    78,F
13C1:  RRF    79,F
13C2:  RRF    7A,F
13C3:  MOVF   23,W
13C4:  MOVWF  2E
13C5:  MOVF   27,W
13C6:  XORWF  2E,F
13C7:  BTFSS  2E.7
13C8:  GOTO   3CB
13C9:  BSF    78.7
13CA:  GOTO   3D1
13CB:  BCF    78.7
13CC:  GOTO   3D1
13CD:  CLRF   77
13CE:  CLRF   78
13CF:  CLRF   79
13D0:  CLRF   7A
*
13D9:  MOVLW  8E
13DA:  MOVWF  77
13DB:  MOVF   22,W
13DC:  SUBWF  77,F
13DD:  MOVF   23,W
13DE:  MOVWF  79
13DF:  MOVF   24,W
13E0:  MOVWF  78
13E1:  BSF    79.7
13E2:  MOVF   77,F
13E3:  BTFSC  03.2
13E4:  GOTO   3F0
13E5:  BCF    03.0
13E6:  MOVF   79,F
13E7:  BTFSS  03.2
13E8:  GOTO   3EC
13E9:  MOVF   78,F
13EA:  BTFSC  03.2
13EB:  GOTO   3F0
13EC:  RRF    79,F
13ED:  RRF    78,F
13EE:  DECFSZ 77,F
13EF:  GOTO   3E5
13F0:  BTFSS  23.7
13F1:  GOTO   3F7
13F2:  COMF   78,F
13F3:  COMF   79,F
13F4:  INCF   78,F
13F5:  BTFSC  03.2
13F6:  INCF   79,F
*
1419:  MOVLW  8E
141A:  MOVWF  77
141B:  MOVF   18,W
141C:  MOVWF  78
141D:  MOVF   17,W
141E:  MOVWF  79
141F:  CLRF   7A
1420:  BTFSS  18.7
1421:  GOTO   427
1422:  COMF   78,F
1423:  COMF   79,F
1424:  INCF   79,F
1425:  BTFSC  03.2
1426:  INCF   78,F
1427:  MOVF   78,F
1428:  BTFSS  03.2
1429:  GOTO   434
142A:  MOVF   79,W
142B:  MOVWF  78
142C:  CLRF   79
142D:  MOVLW  08
142E:  SUBWF  77,F
142F:  MOVF   78,F
1430:  BTFSS  03.2
1431:  GOTO   434
1432:  CLRF   77
1433:  GOTO   43D
1434:  BCF    03.0
1435:  BTFSC  78.7
1436:  GOTO   43B
1437:  RLF    79,F
1438:  RLF    78,F
1439:  DECF   77,F
143A:  GOTO   434
143B:  BTFSS  18.7
143C:  BCF    78.7
*
144A:  MOVF   18,W
144B:  MOVWF  1F
144C:  MOVF   1C,W
144D:  XORWF  1F,F
144E:  BTFSS  1F.7
144F:  GOTO   455
1450:  BCF    03.2
1451:  BCF    03.0
1452:  BTFSC  18.7
1453:  BSF    03.0
1454:  GOTO   488
1455:  MOVF   18,W
1456:  MOVWF  1F
1457:  MOVF   1B,W
1458:  MOVWF  20
1459:  MOVF   17,W
145A:  SUBWF  20,F
145B:  BTFSC  03.2
145C:  GOTO   463
145D:  BTFSS  1F.7
145E:  GOTO   488
145F:  MOVF   03,W
1460:  XORLW  01
1461:  MOVWF  03
1462:  GOTO   488
1463:  MOVF   1C,W
1464:  MOVWF  20
1465:  MOVF   18,W
1466:  SUBWF  20,F
1467:  BTFSC  03.2
1468:  GOTO   46F
1469:  BTFSS  1F.7
146A:  GOTO   488
146B:  MOVF   03,W
146C:  XORLW  01
146D:  MOVWF  03
146E:  GOTO   488
146F:  MOVF   1D,W
1470:  MOVWF  20
1471:  MOVF   19,W
1472:  SUBWF  20,F
1473:  BTFSC  03.2
1474:  GOTO   47B
1475:  BTFSS  1F.7
1476:  GOTO   488
1477:  MOVF   03,W
1478:  XORLW  01
1479:  MOVWF  03
147A:  GOTO   488
147B:  MOVF   1E,W
147C:  MOVWF  20
147D:  MOVF   1A,W
147E:  SUBWF  20,F
147F:  BTFSC  03.2
1480:  GOTO   487
1481:  BTFSS  1F.7
1482:  GOTO   488
1483:  MOVF   03,W
1484:  XORLW  01
1485:  MOVWF  03
1486:  GOTO   488
1487:  BCF    03.0
....................  
.................... #list 
....................  
.................... #DEVICE ADC=10 
.................... #INCLUDE <STRING.H> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
*
04B9:  BSF    03.6
04BA:  MOVF   44,W
04BB:  MOVWF  48
04BC:  MOVF   43,W
04BD:  MOVWF  47
04BE:  MOVF   48,W
04BF:  MOVWF  7A
04C0:  MOVF   47,W
04C1:  MOVWF  04
04C2:  BCF    03.7
04C3:  BTFSC  7A.0
04C4:  BSF    03.7
04C5:  MOVF   00,F
04C6:  BTFSC  03.2
04C7:  GOTO   4CC
04C8:  INCF   47,F
04C9:  BTFSC  03.2
04CA:  INCF   48,F
04CB:  GOTO   4BE
....................    while(*s2 != '\0') 
04CC:  MOVF   46,W
04CD:  MOVWF  7A
04CE:  MOVF   45,W
04CF:  MOVWF  04
04D0:  BCF    03.7
04D1:  BTFSC  7A.0
04D2:  BSF    03.7
04D3:  MOVF   00,F
04D4:  BTFSC  03.2
04D5:  GOTO   4EB
....................    { 
....................       *s = *s2; 
04D6:  MOVF   45,W
04D7:  MOVWF  04
04D8:  BCF    03.7
04D9:  BTFSC  46.0
04DA:  BSF    03.7
04DB:  MOVF   00,W
04DC:  MOVWF  4B
04DD:  MOVF   47,W
04DE:  MOVWF  04
04DF:  BCF    03.7
04E0:  BTFSC  48.0
04E1:  BSF    03.7
04E2:  MOVF   4B,W
04E3:  MOVWF  00
....................       ++s; 
04E4:  INCF   47,F
04E5:  BTFSC  03.2
04E6:  INCF   48,F
....................       ++s2; 
04E7:  INCF   45,F
04E8:  BTFSC  03.2
04E9:  INCF   46,F
04EA:  GOTO   4CC
....................    } 
....................  
....................    *s = '\0'; 
04EB:  MOVF   47,W
04EC:  MOVWF  04
04ED:  BCF    03.7
04EE:  BTFSC  48.0
04EF:  BSF    03.7
04F0:  CLRF   00
....................    return(s1); 
04F1:  MOVF   43,W
04F2:  MOVWF  78
04F3:  MOVF   44,W
04F4:  MOVWF  79
04F5:  BCF    03.6
04F6:  RETURN
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
*
076C:  BSF    03.6
076D:  MOVF   1C,W
076E:  MOVWF  7A
076F:  MOVF   1B,W
0770:  MOVWF  04
0771:  BCF    03.7
0772:  BTFSC  7A.0
0773:  BSF    03.7
0774:  MOVF   00,W
0775:  MOVWF  1F
0776:  MOVF   1E,W
0777:  MOVWF  7A
0778:  MOVF   1D,W
0779:  MOVWF  04
077A:  BCF    03.7
077B:  BTFSC  7A.0
077C:  BSF    03.7
077D:  MOVF   00,W
077E:  SUBWF  1F,W
077F:  BTFSS  03.2
0780:  GOTO   798
....................       if (*s1 == '\0') 
0781:  MOVF   1C,W
0782:  MOVWF  7A
0783:  MOVF   1B,W
0784:  MOVWF  04
0785:  BCF    03.7
0786:  BTFSC  7A.0
0787:  BSF    03.7
0788:  MOVF   00,F
0789:  BTFSS  03.2
078A:  GOTO   78E
....................          return(0); 
078B:  MOVLW  00
078C:  MOVWF  78
078D:  GOTO   7B0
078E:  MOVF   1C,W
078F:  MOVWF  7A
0790:  MOVF   1B,W
0791:  INCF   1B,F
0792:  BTFSC  03.2
0793:  INCF   1C,F
0794:  INCF   1D,F
0795:  BTFSC  03.2
0796:  INCF   1E,F
0797:  GOTO   76D
....................    return((*s1 < *s2) ? -1: 1); 
0798:  MOVF   1C,W
0799:  MOVWF  7A
079A:  MOVF   1B,W
079B:  MOVWF  04
079C:  BCF    03.7
079D:  BTFSC  1C.0
079E:  BSF    03.7
079F:  MOVF   00,W
07A0:  MOVWF  1F
07A1:  MOVF   1E,W
07A2:  MOVWF  7A
07A3:  MOVF   1D,W
07A4:  MOVWF  04
07A5:  BCF    03.7
07A6:  BTFSC  1E.0
07A7:  BSF    03.7
07A8:  MOVF   00,W
07A9:  SUBWF  1F,W
07AA:  BTFSC  03.0
07AB:  GOTO   7AE
07AC:  MOVLW  FF
07AD:  GOTO   7AF
07AE:  MOVLW  01
07AF:  MOVWF  78
07B0:  BCF    03.6
07B1:  RETURN
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
*
102C:  MOVF   1C,W
102D:  MOVWF  7A
102E:  MOVF   1B,W
102F:  MOVWF  04
1030:  BCF    03.7
1031:  BTFSC  7A.0
1032:  BSF    03.7
1033:  MOVF   1D,W
1034:  SUBWF  00,W
1035:  BTFSC  03.2
1036:  GOTO   049
....................       if (*s == '\0') 
1037:  MOVF   1C,W
1038:  MOVWF  7A
1039:  MOVF   1B,W
103A:  MOVWF  04
103B:  BCF    03.7
103C:  BTFSC  7A.0
103D:  BSF    03.7
103E:  MOVF   00,F
103F:  BTFSS  03.2
1040:  GOTO   045
....................          return(0); 
1041:  MOVLW  00
1042:  MOVWF  78
1043:  MOVWF  79
1044:  GOTO   04D
1045:  INCF   1B,F
1046:  BTFSC  03.2
1047:  INCF   1C,F
1048:  GOTO   02C
....................    return(s); 
1049:  MOVF   1B,W
104A:  MOVWF  78
104B:  MOVF   1C,W
104C:  MOVWF  79
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
*
0AF1:  MOVF   26,W
0AF2:  MOVWF  2A
0AF3:  MOVF   25,W
0AF4:  MOVWF  29
0AF5:  MOVF   2A,W
0AF6:  MOVWF  7A
0AF7:  MOVF   29,W
0AF8:  MOVWF  04
0AF9:  BCF    03.7
0AFA:  BTFSC  7A.0
0AFB:  BSF    03.7
0AFC:  MOVF   00,F
0AFD:  BTFSC  03.2
0AFE:  GOTO   32E
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
0AFF:  MOVF   28,W
0B00:  MOVWF  2C
0B01:  MOVF   27,W
0B02:  MOVWF  2B
0B03:  MOVF   2C,W
0B04:  MOVWF  7A
0B05:  MOVF   2B,W
0B06:  MOVWF  04
0B07:  BCF    03.7
0B08:  BTFSC  7A.0
0B09:  BSF    03.7
0B0A:  MOVF   00,F
0B0B:  BTFSC  03.2
0B0C:  GOTO   32A
....................          if (*sc1 == *sc2) 
0B0D:  MOVF   2A,W
0B0E:  MOVWF  7A
0B0F:  MOVF   29,W
0B10:  MOVWF  04
0B11:  BCF    03.7
0B12:  BTFSC  7A.0
0B13:  BSF    03.7
0B14:  MOVF   00,W
0B15:  MOVWF  2D
0B16:  MOVF   2C,W
0B17:  MOVWF  7A
0B18:  MOVF   2B,W
0B19:  MOVWF  04
0B1A:  BCF    03.7
0B1B:  BTFSC  7A.0
0B1C:  BSF    03.7
0B1D:  MOVF   00,W
0B1E:  SUBWF  2D,W
0B1F:  BTFSS  03.2
0B20:  GOTO   326
....................             return(sc1); 
0B21:  MOVF   29,W
0B22:  MOVWF  78
0B23:  MOVF   2A,W
0B24:  MOVWF  79
0B25:  GOTO   331
0B26:  INCF   2B,F
0B27:  BTFSC  03.2
0B28:  INCF   2C,F
0B29:  GOTO   303
0B2A:  INCF   29,F
0B2B:  BTFSC  03.2
0B2C:  INCF   2A,F
0B2D:  GOTO   2F5
....................    return(0); 
0B2E:  MOVLW  00
0B2F:  MOVWF  78
0B30:  MOVWF  79
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
*
0A7E:  MOVF   26,W
0A7F:  MOVWF  2A
0A80:  MOVF   25,W
0A81:  MOVWF  29
0A82:  MOVF   2A,W
0A83:  MOVWF  7A
0A84:  MOVF   29,W
0A85:  MOVWF  04
0A86:  BCF    03.7
0A87:  BTFSC  7A.0
0A88:  BSF    03.7
0A89:  MOVF   00,F
0A8A:  BTFSC  03.2
0A8B:  GOTO   2C3
....................       for (sc2 = s2; ; sc2++) 
0A8C:  MOVF   28,W
0A8D:  MOVWF  2C
0A8E:  MOVF   27,W
0A8F:  MOVWF  2B
....................     if (*sc2 == '\0') 
0A90:  MOVF   2C,W
0A91:  MOVWF  7A
0A92:  MOVF   2B,W
0A93:  MOVWF  04
0A94:  BCF    03.7
0A95:  BTFSC  7A.0
0A96:  BSF    03.7
0A97:  MOVF   00,F
0A98:  BTFSS  03.2
0A99:  GOTO   2A7
....................        return(sc1 - s1); 
0A9A:  MOVF   25,W
0A9B:  SUBWF  29,W
0A9C:  MOVWF  77
0A9D:  MOVF   2A,W
0A9E:  MOVWF  7A
0A9F:  MOVF   26,W
0AA0:  BTFSS  03.0
0AA1:  INCFSZ 26,W
0AA2:  SUBWF  7A,F
0AA3:  MOVF   77,W
0AA4:  MOVWF  78
0AA5:  GOTO   2CE
0AA6:  GOTO   2BB
....................          else if (*sc1 == *sc2) 
0AA7:  MOVF   2A,W
0AA8:  MOVWF  7A
0AA9:  MOVF   29,W
0AAA:  MOVWF  04
0AAB:  BCF    03.7
0AAC:  BTFSC  7A.0
0AAD:  BSF    03.7
0AAE:  MOVF   00,W
0AAF:  MOVWF  2D
0AB0:  MOVF   2C,W
0AB1:  MOVWF  7A
0AB2:  MOVF   2B,W
0AB3:  MOVWF  04
0AB4:  BCF    03.7
0AB5:  BTFSC  7A.0
0AB6:  BSF    03.7
0AB7:  MOVF   00,W
0AB8:  SUBWF  2D,W
0AB9:  BTFSC  03.2
....................             break; 
0ABA:  GOTO   2BF
0ABB:  INCF   2B,F
0ABC:  BTFSC  03.2
0ABD:  INCF   2C,F
0ABE:  GOTO   290
0ABF:  INCF   29,F
0AC0:  BTFSC  03.2
0AC1:  INCF   2A,F
0AC2:  GOTO   282
....................    return(sc1 - s1); 
0AC3:  MOVF   25,W
0AC4:  SUBWF  29,W
0AC5:  MOVWF  77
0AC6:  MOVF   2A,W
0AC7:  MOVWF  7A
0AC8:  MOVF   26,W
0AC9:  BTFSS  03.0
0ACA:  INCFSZ 26,W
0ACB:  SUBWF  7A,F
0ACC:  MOVF   77,W
0ACD:  MOVWF  78
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
*
14DD:  BCF    03.6
14DE:  CLRF   2B
14DF:  CLRF   2C
....................  
....................    beg = (s1)? s1: save; 
*
0A65:  BSF    03.6
0A66:  MOVF   1D,W
0A67:  IORWF  1E,W
0A68:  BTFSC  03.2
0A69:  GOTO   26E
0A6A:  MOVF   1E,W
0A6B:  MOVWF  7A
0A6C:  MOVF   1D,W
0A6D:  GOTO   273
0A6E:  BCF    03.6
0A6F:  MOVF   2C,W
0A70:  MOVWF  7A
0A71:  MOVF   2B,W
0A72:  BSF    03.6
0A73:  MOVWF  21
0A74:  MOVF   7A,W
0A75:  MOVWF  22
....................    beg += strspn(beg, s2); 
0A76:  MOVF   22,W
0A77:  MOVWF  26
0A78:  MOVF   21,W
0A79:  MOVWF  25
0A7A:  MOVF   20,W
0A7B:  MOVWF  28
0A7C:  MOVF   1F,W
0A7D:  MOVWF  27
*
0ACE:  MOVF   78,W
0ACF:  ADDWF  21,F
0AD0:  BTFSC  03.0
0AD1:  INCF   22,F
....................    if (*beg == '\0') 
0AD2:  MOVF   22,W
0AD3:  MOVWF  7A
0AD4:  MOVF   21,W
0AD5:  MOVWF  04
0AD6:  BCF    03.7
0AD7:  BTFSC  7A.0
0AD8:  BSF    03.7
0AD9:  MOVF   00,F
0ADA:  BTFSS  03.2
0ADB:  GOTO   2E9
....................    { 
....................       *save = ' '; 
0ADC:  BCF    03.6
0ADD:  MOVF   2B,W
0ADE:  MOVWF  04
0ADF:  BCF    03.7
0AE0:  BTFSC  2C.0
0AE1:  BSF    03.7
0AE2:  MOVLW  20
0AE3:  MOVWF  00
....................       return(0); 
0AE4:  MOVLW  00
0AE5:  MOVWF  78
0AE6:  MOVWF  79
0AE7:  GOTO   355
0AE8:  BSF    03.6
....................    } 
....................    end = strpbrk(beg, s2); 
0AE9:  MOVF   22,W
0AEA:  MOVWF  26
0AEB:  MOVF   21,W
0AEC:  MOVWF  25
0AED:  MOVF   20,W
0AEE:  MOVWF  28
0AEF:  MOVF   1F,W
0AF0:  MOVWF  27
*
0B31:  MOVF   79,W
0B32:  MOVWF  24
0B33:  MOVF   78,W
0B34:  MOVWF  23
....................    if (*end != '\0') 
0B35:  MOVF   24,W
0B36:  MOVWF  7A
0B37:  MOVF   23,W
0B38:  MOVWF  04
0B39:  BCF    03.7
0B3A:  BTFSC  7A.0
0B3B:  BSF    03.7
0B3C:  MOVF   00,F
0B3D:  BTFSC  03.2
0B3E:  GOTO   348
....................    { 
....................       *end = '\0'; 
0B3F:  MOVF   23,W
0B40:  MOVWF  04
0B41:  BCF    03.7
0B42:  BTFSC  24.0
0B43:  BSF    03.7
0B44:  CLRF   00
....................       end++; 
0B45:  INCF   23,F
0B46:  BTFSC  03.2
0B47:  INCF   24,F
....................    } 
....................    save = end; 
0B48:  MOVF   24,W
0B49:  BCF    03.6
0B4A:  MOVWF  2C
0B4B:  BSF    03.6
0B4C:  MOVF   23,W
0B4D:  BCF    03.6
0B4E:  MOVWF  2B
....................    return(beg); 
0B4F:  BSF    03.6
0B50:  MOVF   21,W
0B51:  MOVWF  78
0B52:  MOVF   22,W
0B53:  MOVWF  79
0B54:  BCF    03.6
0B55:  RETURN
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
*
1055:  MOVF   1C,W
1056:  MOVWF  1E
1057:  MOVF   1B,W
1058:  MOVWF  1D
1059:  MOVF   1E,W
105A:  MOVWF  7A
105B:  MOVF   1D,W
105C:  MOVWF  04
105D:  BCF    03.7
105E:  BTFSC  7A.0
105F:  BSF    03.7
1060:  MOVF   00,F
1061:  BTFSC  03.2
1062:  GOTO   067
1063:  INCF   1D,F
1064:  BTFSC  03.2
1065:  INCF   1E,F
1066:  GOTO   059
....................    return(sc - s); 
1067:  MOVF   1B,W
1068:  SUBWF  1D,W
1069:  MOVWF  77
106A:  MOVF   1E,W
106B:  MOVWF  7A
106C:  MOVF   1C,W
106D:  BTFSS  03.0
106E:  INCFSZ 1C,W
106F:  SUBWF  7A,F
1070:  MOVF   77,W
1071:  MOVWF  78
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #INCLUDE <STDLIB.H> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... /* Standart template: float strtof(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... float strtof(char *s,char *endptr); 
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s,char *endptr); 
.................... float64 strtod(char *s,char *endptr); 
.................... #else 
.................... //provided for compatibility 
.................... #define strtof48(s, e) strtof(s, e) 
.................... #define strtod(s, e) strtof(s, e) 
.................... #endif 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof(s)   strtof(s, 0) 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof48(s) strtof48(s, 0) 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof64(s) strtod(s, 0) 
.................... #endif 
....................  
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float atoe(char * s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s); 
.................... #endif 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... unsigned int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................  
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
*
0B56:  BSF    03.6
0B57:  CLRF   22
....................    sign = 0; 
0B58:  CLRF   20
....................    base = 10; 
0B59:  MOVLW  0A
0B5A:  MOVWF  21
....................    result = 0; 
0B5B:  CLRF   1F
....................  
....................    if (!s) 
0B5C:  MOVF   1D,W
0B5D:  IORWF  1E,W
0B5E:  BTFSS  03.2
0B5F:  GOTO   363
....................       return 0; 
0B60:  MOVLW  00
0B61:  MOVWF  78
0B62:  GOTO   437
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
0B63:  MOVF   22,W
0B64:  INCF   22,F
0B65:  ADDWF  1D,W
0B66:  MOVWF  04
0B67:  BCF    03.7
0B68:  BTFSC  1E.0
0B69:  BSF    03.7
0B6A:  MOVF   00,W
0B6B:  MOVWF  23
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
0B6C:  MOVF   23,W
0B6D:  SUBLW  2D
0B6E:  BTFSS  03.2
0B6F:  GOTO   37C
....................    { 
....................       sign = 1;         // Set the sign to negative 
0B70:  MOVLW  01
0B71:  MOVWF  20
....................       c = s[index++]; 
0B72:  MOVF   22,W
0B73:  INCF   22,F
0B74:  ADDWF  1D,W
0B75:  MOVWF  04
0B76:  BCF    03.7
0B77:  BTFSC  1E.0
0B78:  BSF    03.7
0B79:  MOVF   00,W
0B7A:  MOVWF  23
....................    } 
0B7B:  GOTO   389
....................    else if (c == '+') 
0B7C:  MOVF   23,W
0B7D:  SUBLW  2B
0B7E:  BTFSS  03.2
0B7F:  GOTO   389
....................    { 
....................       c = s[index++]; 
0B80:  MOVF   22,W
0B81:  INCF   22,F
0B82:  ADDWF  1D,W
0B83:  MOVWF  04
0B84:  BCF    03.7
0B85:  BTFSC  1E.0
0B86:  BSF    03.7
0B87:  MOVF   00,W
0B88:  MOVWF  23
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
0B89:  MOVF   23,W
0B8A:  SUBLW  2F
0B8B:  BTFSC  03.0
0B8C:  GOTO   42D
0B8D:  MOVF   23,W
0B8E:  SUBLW  39
0B8F:  BTFSS  03.0
0B90:  GOTO   42D
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
0B91:  MOVF   23,W
0B92:  SUBLW  30
0B93:  BTFSS  03.2
0B94:  GOTO   3B5
0B95:  MOVF   22,W
0B96:  ADDWF  1D,W
0B97:  MOVWF  04
0B98:  BCF    03.7
0B99:  BTFSC  1E.0
0B9A:  BSF    03.7
0B9B:  MOVF   00,W
0B9C:  SUBLW  78
0B9D:  BTFSC  03.2
0B9E:  GOTO   3A9
0B9F:  MOVF   22,W
0BA0:  ADDWF  1D,W
0BA1:  MOVWF  04
0BA2:  BCF    03.7
0BA3:  BTFSC  1E.0
0BA4:  BSF    03.7
0BA5:  MOVF   00,W
0BA6:  SUBLW  58
0BA7:  BTFSS  03.2
0BA8:  GOTO   3B5
....................       { 
....................          base = 16; 
0BA9:  MOVLW  10
0BAA:  MOVWF  21
....................          index++; 
0BAB:  INCF   22,F
....................          c = s[index++]; 
0BAC:  MOVF   22,W
0BAD:  INCF   22,F
0BAE:  ADDWF  1D,W
0BAF:  MOVWF  04
0BB0:  BCF    03.7
0BB1:  BTFSC  1E.0
0BB2:  BSF    03.7
0BB3:  MOVF   00,W
0BB4:  MOVWF  23
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
0BB5:  MOVF   21,W
0BB6:  SUBLW  0A
0BB7:  BTFSS  03.2
0BB8:  GOTO   3DB
....................       { 
....................          while (c >= '0' && c <= '9') 
0BB9:  MOVF   23,W
0BBA:  SUBLW  2F
0BBB:  BTFSC  03.0
0BBC:  GOTO   3DA
0BBD:  MOVF   23,W
0BBE:  SUBLW  39
0BBF:  BTFSS  03.0
0BC0:  GOTO   3DA
....................          { 
....................             result = 10*result + (c - '0'); 
0BC1:  MOVLW  0A
0BC2:  MOVWF  24
0BC3:  MOVF   1F,W
0BC4:  MOVWF  25
0BC5:  BCF    0A.3
0BC6:  BCF    03.6
0BC7:  CALL   745
0BC8:  BSF    0A.3
0BC9:  MOVF   78,W
0BCA:  BSF    03.6
0BCB:  MOVWF  24
0BCC:  MOVLW  30
0BCD:  SUBWF  23,W
0BCE:  ADDWF  24,W
0BCF:  MOVWF  1F
....................             c = s[index++]; 
0BD0:  MOVF   22,W
0BD1:  INCF   22,F
0BD2:  ADDWF  1D,W
0BD3:  MOVWF  04
0BD4:  BCF    03.7
0BD5:  BTFSC  1E.0
0BD6:  BSF    03.7
0BD7:  MOVF   00,W
0BD8:  MOVWF  23
0BD9:  GOTO   3B9
....................          } 
....................       } 
0BDA:  GOTO   42D
....................       else if (base == 16)    // The number is a hexa number 
0BDB:  MOVF   21,W
0BDC:  SUBLW  10
0BDD:  BTFSS  03.2
0BDE:  GOTO   42D
....................       { 
....................          c = toupper(c); 
0BDF:  MOVF   23,W
0BE0:  SUBLW  60
0BE1:  BTFSC  03.0
0BE2:  GOTO   3EA
0BE3:  MOVF   23,W
0BE4:  SUBLW  7A
0BE5:  BTFSS  03.0
0BE6:  GOTO   3EA
0BE7:  MOVF   23,W
0BE8:  ANDLW  DF
0BE9:  GOTO   3EB
0BEA:  MOVF   23,W
0BEB:  MOVWF  23
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
0BEC:  MOVF   23,W
0BED:  SUBLW  2F
0BEE:  BTFSC  03.0
0BEF:  GOTO   3F4
0BF0:  MOVF   23,W
0BF1:  SUBLW  39
0BF2:  BTFSC  03.0
0BF3:  GOTO   3FC
0BF4:  MOVF   23,W
0BF5:  SUBLW  40
0BF6:  BTFSC  03.0
0BF7:  GOTO   42D
0BF8:  MOVF   23,W
0BF9:  SUBLW  46
0BFA:  BTFSS  03.0
0BFB:  GOTO   42D
....................          { 
....................             if (c >= '0' && c <= '9') 
0BFC:  MOVF   23,W
0BFD:  SUBLW  2F
0BFE:  BTFSC  03.0
0BFF:  GOTO   40D
0C00:  MOVF   23,W
0C01:  SUBLW  39
0C02:  BTFSS  03.0
0C03:  GOTO   40D
....................                result = (result << 4) + (c - '0'); 
0C04:  SWAPF  1F,W
0C05:  MOVWF  24
0C06:  MOVLW  F0
0C07:  ANDWF  24,F
0C08:  MOVLW  30
0C09:  SUBWF  23,W
0C0A:  ADDWF  24,W
0C0B:  MOVWF  1F
0C0C:  GOTO   416
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
0C0D:  SWAPF  1F,W
0C0E:  MOVWF  24
0C0F:  MOVLW  F0
0C10:  ANDWF  24,F
0C11:  MOVLW  41
0C12:  SUBWF  23,W
0C13:  ADDLW  0A
0C14:  ADDWF  24,W
0C15:  MOVWF  1F
....................  
....................             c = s[index++]; 
0C16:  MOVF   22,W
0C17:  INCF   22,F
0C18:  ADDWF  1D,W
0C19:  MOVWF  04
0C1A:  BCF    03.7
0C1B:  BTFSC  1E.0
0C1C:  BSF    03.7
0C1D:  MOVF   00,W
0C1E:  MOVWF  23
....................             c = toupper(c); 
0C1F:  MOVF   23,W
0C20:  SUBLW  60
0C21:  BTFSC  03.0
0C22:  GOTO   42A
0C23:  MOVF   23,W
0C24:  SUBLW  7A
0C25:  BTFSS  03.0
0C26:  GOTO   42A
0C27:  MOVF   23,W
0C28:  ANDLW  DF
0C29:  GOTO   42B
0C2A:  MOVF   23,W
0C2B:  MOVWF  23
0C2C:  GOTO   3EC
....................          } 
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
0C2D:  DECFSZ 20,W
0C2E:  GOTO   435
0C2F:  MOVF   21,W
0C30:  SUBLW  0A
0C31:  BTFSS  03.2
0C32:  GOTO   435
....................        result = -result; 
0C33:  COMF   1F,F
0C34:  INCF   1F,F
....................  
....................    return(result); 
0C35:  MOVF   1F,W
0C36:  MOVWF  78
0C37:  BCF    03.6
0C38:  RETURN
.................... } 
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
*
0399:  BSF    03.6
039A:  CLRF   4E
039B:  CLRF   4D
039C:  CLRF   4C
039D:  MOVLW  01
039E:  MOVWF  4B
039F:  CLRF   50
03A0:  CLRF   51
.................... { 
....................      unsigned int32 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
03A1:  BTFSS  47.7
03A2:  GOTO   3E3
....................          sign=1;        // Check for negative number 
03A3:  MOVLW  01
03A4:  MOVWF  50
....................          num*=-1; 
03A5:  MOVF   47,W
03A6:  MOVWF  56
03A7:  MOVF   46,W
03A8:  MOVWF  55
03A9:  MOVF   45,W
03AA:  MOVWF  54
03AB:  MOVF   44,W
03AC:  MOVWF  53
03AD:  MOVLW  FF
03AE:  MOVWF  5A
03AF:  MOVWF  59
03B0:  MOVWF  58
03B1:  MOVWF  57
*
03DB:  MOVF   7A,W
03DC:  MOVWF  47
03DD:  MOVF   79,W
03DE:  MOVWF  46
03DF:  MOVF   78,W
03E0:  MOVWF  45
03E1:  MOVF   77,W
03E2:  MOVWF  44
....................      } 
....................  
....................      while(temp>0) { 
03E3:  MOVF   4B,F
03E4:  BTFSS  03.2
03E5:  GOTO   3EF
03E6:  MOVF   4C,F
03E7:  BTFSS  03.2
03E8:  GOTO   3EF
03E9:  MOVF   4D,F
03EA:  BTFSS  03.2
03EB:  GOTO   3EF
03EC:  MOVF   4E,F
03ED:  BTFSC  03.2
03EE:  GOTO   46B
....................          temp=(num/base); 
03EF:  BCF    03.1
03F0:  MOVF   47,W
03F1:  MOVWF  5E
03F2:  MOVF   46,W
03F3:  MOVWF  5D
03F4:  MOVF   45,W
03F5:  MOVWF  5C
03F6:  MOVF   44,W
03F7:  MOVWF  5B
03F8:  CLRF   62
03F9:  CLRF   61
03FA:  CLRF   60
03FB:  MOVF   48,W
03FC:  MOVWF  5F
03FD:  BCF    03.6
03FE:  CALL   31D
03FF:  MOVF   7A,W
0400:  BSF    03.6
0401:  MOVWF  4E
0402:  MOVF   79,W
0403:  MOVWF  4D
0404:  MOVF   78,W
0405:  MOVWF  4C
0406:  MOVF   77,W
0407:  MOVWF  4B
....................          s[cnt]=(num%base)+'0';    // Conversion 
0408:  MOVF   51,W
0409:  ADDWF  49,W
040A:  MOVWF  78
040B:  MOVF   4A,W
040C:  MOVWF  7A
040D:  BTFSC  03.0
040E:  INCF   7A,F
040F:  MOVF   78,W
0410:  MOVWF  53
0411:  MOVF   7A,W
0412:  MOVWF  54
0413:  CLRF   56
0414:  MOVF   04,W
0415:  MOVWF  55
0416:  BCF    56.0
0417:  BTFSC  03.7
0418:  BSF    56.0
0419:  BSF    03.1
041A:  MOVLW  57
041B:  MOVWF  04
041C:  BSF    03.7
041D:  MOVF   47,W
041E:  MOVWF  5E
041F:  MOVF   46,W
0420:  MOVWF  5D
0421:  MOVF   45,W
0422:  MOVWF  5C
0423:  MOVF   44,W
0424:  MOVWF  5B
0425:  CLRF   62
0426:  CLRF   61
0427:  CLRF   60
0428:  MOVF   48,W
0429:  MOVWF  5F
042A:  BCF    03.6
042B:  CALL   31D
042C:  BSF    03.6
042D:  MOVF   55,W
042E:  MOVWF  04
042F:  BCF    03.7
0430:  BTFSC  56.0
0431:  BSF    03.7
0432:  MOVLW  30
0433:  ADDWF  57,W
0434:  MOVWF  77
0435:  MOVF   58,W
0436:  MOVWF  78
0437:  MOVLW  00
0438:  BTFSC  03.0
0439:  MOVLW  01
043A:  ADDWF  78,F
043B:  MOVF   59,W
043C:  MOVWF  79
043D:  MOVLW  00
043E:  BTFSC  03.0
043F:  MOVLW  01
0440:  ADDWF  79,F
0441:  MOVF   5A,W
0442:  MOVWF  7A
0443:  MOVLW  00
0444:  BTFSC  03.0
0445:  MOVLW  01
0446:  ADDWF  7A,F
0447:  MOVF   53,W
0448:  MOVWF  04
0449:  BCF    03.7
044A:  BTFSC  54.0
044B:  BSF    03.7
044C:  MOVF   77,W
044D:  MOVWF  00
....................  
....................          if(s[cnt]>0x39) 
044E:  MOVF   51,W
044F:  ADDWF  49,W
0450:  MOVWF  04
0451:  BCF    03.7
0452:  BTFSC  4A.0
0453:  BSF    03.7
0454:  MOVF   00,W
0455:  SUBLW  39
0456:  BTFSC  03.0
0457:  GOTO   461
....................             s[cnt]+=0x7; 
0458:  MOVF   51,W
0459:  ADDWF  49,W
045A:  MOVWF  04
045B:  BCF    03.7
045C:  BTFSC  4A.0
045D:  BSF    03.7
045E:  MOVLW  07
045F:  ADDWF  00,W
0460:  MOVWF  00
....................  
....................          cnt++; 
0461:  INCF   51,F
....................          num=temp; 
0462:  MOVF   4E,W
0463:  MOVWF  47
0464:  MOVF   4D,W
0465:  MOVWF  46
0466:  MOVF   4C,W
0467:  MOVWF  45
0468:  MOVF   4B,W
0469:  MOVWF  44
046A:  GOTO   3E3
....................      } 
....................  
....................      if(sign==1) { 
046B:  DECFSZ 50,W
046C:  GOTO   476
....................          s[cnt]=0x2D;      // Negative sign 
046D:  MOVF   51,W
046E:  ADDWF  49,W
046F:  MOVWF  04
0470:  BCF    03.7
0471:  BTFSC  4A.0
0472:  BSF    03.7
0473:  MOVLW  2D
0474:  MOVWF  00
....................          cnt++; 
0475:  INCF   51,F
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
0476:  CLRF   4F
0477:  BCF    03.0
0478:  RRF    51,W
0479:  SUBWF  4F,W
047A:  BTFSC  03.0
047B:  GOTO   4AC
....................  
....................          c=s[i]; 
047C:  MOVF   4F,W
047D:  ADDWF  49,W
047E:  MOVWF  04
047F:  BCF    03.7
0480:  BTFSC  4A.0
0481:  BSF    03.7
0482:  MOVF   00,W
0483:  MOVWF  52
....................          s[i]=s[cnt-i-1];        // Reverse the number 
0484:  MOVF   4F,W
0485:  ADDWF  49,W
0486:  MOVWF  78
0487:  MOVF   4A,W
0488:  MOVWF  7A
0489:  BTFSC  03.0
048A:  INCF   7A,F
048B:  MOVF   78,W
048C:  MOVWF  53
048D:  MOVF   7A,W
048E:  MOVWF  54
048F:  MOVF   4F,W
0490:  SUBWF  51,W
0491:  ADDLW  FF
0492:  ADDWF  49,W
0493:  MOVWF  04
0494:  BCF    03.7
0495:  BTFSC  4A.0
0496:  BSF    03.7
0497:  MOVF   00,W
0498:  MOVWF  55
0499:  MOVF   53,W
049A:  MOVWF  04
049B:  BCF    03.7
049C:  BTFSC  54.0
049D:  BSF    03.7
049E:  MOVF   55,W
049F:  MOVWF  00
....................          s[cnt-i-1]=c; 
04A0:  MOVF   4F,W
04A1:  SUBWF  51,W
04A2:  ADDLW  FF
04A3:  ADDWF  49,W
04A4:  MOVWF  04
04A5:  BCF    03.7
04A6:  BTFSC  4A.0
04A7:  BSF    03.7
04A8:  MOVF   52,W
04A9:  MOVWF  00
04AA:  INCF   4F,F
04AB:  GOTO   477
....................      } 
....................      s[cnt]='\0';     // End the string 
04AC:  MOVF   51,W
04AD:  ADDWF  49,W
04AE:  MOVWF  04
04AF:  BCF    03.7
04B0:  BTFSC  4A.0
04B1:  BSF    03.7
04B2:  CLRF   00
....................      return s; 
04B3:  MOVF   49,W
04B4:  MOVWF  78
04B5:  MOVF   4A,W
04B6:  MOVWF  79
04B7:  BCF    03.6
04B8:  RETURN
.................... } 
....................  
.................... #if defined(__PCD__) 
....................  
.................... char * itoa(signed int48 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int48 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... char * itoa(signed int64 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int64 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................       
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1;         
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................              
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #endif 
....................  
.................... float strtof(char *s, char *endptr) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s, char *endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float48)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float48)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s, char *endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float64)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float64)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtoulGO; 
....................  
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................    { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... int8 mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #if !defined(__PCD__) 
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2);  
.................... #else  
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2);  
.................... #endif 
....................  
....................  
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    unsigned int8 t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=1; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = 0; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
.................... #INCLUDE <STDIO.H> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDIO 
.................... #define _STDIO 
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #ifndef getc 
.................... #define getc getch 
.................... #define getchar getch 
.................... #define puts(s) {printf(s); putchar(13); putchar(10);} 
.................... #define putc putchar 
.................... #endif 
.................... /* maps error number to an error message. Writes a sequence of characters to 
.................... stderr stream thus: if s is not null then string pointed to by s follwed by 
.................... a colon (:) and a space and the appropriate error message returned by strerror 
.................... function with argument errno 
....................  
.................... Returns: no value 
.................... */ 
....................  
.................... #ifdef _ERRNO 
.................... void perror(char *s) 
.................... { 
....................   if(s) 
....................   fprintf(STDERR,"%s: ",s); 
....................   fprintf(STDERR,"%s\r\n",strerror(errno)); 
.................... } 
.................... #endif 
.................... #endif 
....................  
.................... #INCLUDE <MATH.H> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2011 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                    //// 
.................... //// History:                                                           //// 
.................... ////  * 9/20/2001 :  Improvments are made to sin/cos code.              //// 
.................... ////                 The code now is small, much faster,                //// 
.................... ////                 and more accurate.                                 //// 
.................... ////  * 2/21/2007 :  Compiler handles & operator differently and does   //// 
.................... ////                 not return generic (int8 *) so type cast is done   //// 
.................... ////  * 6/19/2010 :  Divisions by constants converted to multiplication //// 
.................... ////                 by its inverse to improve computation speed        //// 
.................... ////  * 1/21/2011 :  Constants used for double precision math updated   //// 
.................... ////                 Updated routines include 64 bit versions of cos,   //// 
.................... ////                 asin,atan,exp,log and dependant functions          //// 
.................... ////  * 1/31/2011 :  Optimized current 32-bit float routines for cos    //// 
.................... ////                 and log function                                   //// 
.................... ////  * 6/13/2011 :  Fixed PCD overload CEIL_FLOOR functions for values //// 
.................... ////                 greater then 10000000 and less then -10000000      //// 
.................... ////                                                                    //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef MATH_H 
.................... #define MATH_H 
....................  
.................... #ifdef PI 
.................... #undef  PI 
.................... #endif 
.................... #define PI     3.1415926535897932 
....................  
....................  
.................... #define SQRT2  1.4142135623730950 
....................  
.................... //float const ps[4] = {5.9304945, 21.125224, 8.9403076, 0.29730279}; 
.................... //float const qs[4] = {1.0000000, 15.035723, 17.764134, 2.4934718}; 
....................  
.................... ///////////////////////////// Round Functions ////////////////////////////// 
....................  
.................... float32 CEIL_FLOOR(float32 x, unsigned int8 n) 
.................... { 
....................    float32 y, res; 
....................    unsigned int16 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................       res = (float32)(unsigned int16)y; 
....................  
....................  else if (y < 10000000.0) 
....................    {  
....................       l = (unsigned int16)(y*0.000030517578125); 
....................       y = 32768.0*(y*0.000030517578125 - (float32)l); 
....................       res = 32768.0*(float32)l; 
....................       res += (float32)(unsigned int16)y; 
....................    } 
....................  
....................  else 
....................   res = y; 
....................  
....................  y = y - (float32)(unsigned int16)y; 
....................  
....................  if (s) 
....................   res = -res; 
....................  
....................  if (y != 0) 
....................  { 
....................   if (s == 1 && n == 0) 
....................    res -= 1.0; 
....................  
....................   if (s == 0 && n == 1) 
....................    res += 1.0; 
....................  } 
....................  if (x == 0) 
....................     res = 0; 
....................  
....................  return (res); 
.................... } 
....................  
.................... // Overloaded Functions to take care for new Data types in PCD 
.................... // Overloaded function CEIL_FLOOR() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 CEIL_FLOOR(float48 x, unsigned int8 n) 
.................... { 
....................    float48 y, res; 
....................    unsigned int32 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................       res = (float48)(unsigned int16)y; 
....................  
....................    else if (y < 549755813888.0) 
....................    { 
....................       l = (unsigned int32)(y*0.000030517578125); 
....................       y = 32768.0*(y*0.000030517578125 - (float48)l); 
....................       res = 32768.0*(float48)l; 
....................       res += (float48)(unsigned int16)y; 
....................    } 
....................    else 
....................    {   
....................       res = y; 
....................       y = 0.0; 
....................    } 
....................     
....................    if(y != 0) 
....................       y = y - (float48)(unsigned int16)y; 
....................  
....................    if (s) 
....................       res = -res; 
....................  
....................    if (y != 0) 
....................    { 
....................       if (s == 1 && n == 0) 
....................          res -= 1.0; 
....................  
....................       if (s == 0 && n == 1) 
....................          res += 1.0; 
....................    } 
....................    if (x == 0) 
....................       res = 0; 
....................  
....................    return (res); 
.................... } 
....................  
....................  
.................... // Overloaded function CEIL_FLOOR() for data type - Float64 
.................... float64 CEIL_FLOOR(float64 x, unsigned int8 n) 
.................... { 
....................    float64 y, res; 
....................    int64 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................       res = (float64)(unsigned int16)y; 
....................    else if (y < 4503599627370496.0) 
....................    { 
....................       l = (int64)(y*0.000030517578125); 
....................       y = 32768.0*(y*0.000030517578125 - (float64)l); 
....................       res = 32768.0*(float64)l; 
....................       res += (float64)(unsigned int16)y; 
....................    } 
....................    else 
....................    { 
....................       res = y; 
....................       y = 0.0; 
....................    } 
....................     
....................    if(y != 0) 
....................       y = y - (float64)(unsigned int16)y; 
....................  
....................    if (s) 
....................       res = -res; 
....................  
....................    if (y != 0) 
....................    { 
....................       if (s == 1 && n == 0) 
....................          res -= 1.0; 
....................  
....................       if (s == 0 && n == 1) 
....................          res += 1.0; 
....................    } 
....................     
....................    if (x == 0) 
....................       res = 0; 
....................  
....................    return (res); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float floor(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : rounds down the number x. 
.................... // Date : N/A 
.................... // 
.................... float32 floor(float32 x) 
.................... { 
....................    return CEIL_FLOOR(x,0); 
.................... } 
.................... // Following 2 functions are overloaded functions of floor() for PCD 
.................... // Overloaded function floor() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 floor(float48 x) 
.................... { 
....................    return CEIL_FLOOR(x, 0); 
.................... } 
....................  
.................... // Overloaded function floor() for data type - Float64 
.................... float64 floor(float64 x) 
.................... { 
....................    return CEIL_FLOOR(x, 0); 
.................... } 
.................... #endif 
....................  
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float ceil(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : rounds up the number x. 
.................... // Date : N/A 
.................... // 
.................... float32 ceil(float32 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
.................... // Following 2 functions are overloaded functions of ceil() for PCD 
.................... // Overloaded function ceil() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 ceil(float48 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
....................  
.................... // Overloaded function ceil() for data type - Float64 
.................... float64 ceil(float64 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
.................... #endif 
....................  
....................  //////////////////////////////////////////////////////////////////////////// 
.................... //   float fabs(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the absolute value of floating point number x 
.................... // Returns : returns the absolute value of x 
.................... // Date : N/A 
.................... // 
.................... #define fabs abs 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float fmod(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the floating point remainder of x/y 
.................... // Returns : returns the value of x= i*y, for some integer i such that, if y 
.................... // is non zero, the result has the same isgn of x na dmagnitude less than the 
.................... // magnitude of y. If y is zero then a domain error occurs. 
.................... // Date : N/A 
.................... // 
....................  
.................... float fmod(float32 x,float32 y) 
.................... { 
....................    float32 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... //Overloaded function for fmod() for PCD 
.................... // Overloaded function fmod() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 fmod(float48 x,float48 y) 
.................... { 
....................    float48 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... // Overloaded function fmod() for data type - Float64 
.................... float64 fmod(float64 x,float64 y) 
.................... { 
....................    float64 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... #endif 
.................... //////////////////// Exponential and logarithmic functions //////////////////// 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float exp(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (e^x) 
.................... // Date : N/A 
.................... // 
.................... #define LN2 0.6931471805599453 
.................... #define LN2_INV 1.4426950408889634073 
....................  
.................... float const pe[6] = {0.000207455774, 0.00127100575, 0.00965065093, 
....................                      0.0554965651,  0.240227138,  0.693147172}; 
....................  
....................  
.................... float32 exp(float32 x) 
.................... { 
....................    float32 y, res, r; 
....................    #if defined(__PCD__) 
....................    int8 data1; 
....................    #endif 
....................    signed int8 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 88.722838) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    n = (signed int16)(x*LN2_INV); 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
.................... #if !defined(__PCD__) 
....................    *((unsigned int8 *)(&res)) = n + 0x7F; 
.................... #endif 
....................  
.................... #if defined(__PCD__)  // Takes care of IEEE format for PCD 
....................    data1 = n+0x7F; 
....................    if(bit_test(data1,0)) 
....................    bit_set(*(((unsigned int8 *)(&res)+2)),7); 
....................    rotate_right(&data1,1); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&res)+3)) = data1; 
.................... #endif 
....................  
....................    y = y*LN2_INV - (float32)n; 
....................  
....................    r = pe[0]*y + pe[1]; 
....................    r = r*y + pe[2]; 
....................    r = r*y + pe[3]; 
....................    r = r*y + pe[4]; 
....................    r = r*y + pe[5]; 
....................  
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
....................  
....................  
.................... //Overloaded function for exp() for PCD 
.................... // Overloaded function exp() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 exp(float48 x) 
.................... { 
....................    float48 y, res, r; 
....................    int8 data1; 
....................    signed int8 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 88.722838) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    n = (signed int16)(x*LN2_INV); 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
....................  
....................    data1 = n+0x7F; 
....................    if(bit_test(data1,0)) 
....................    bit_set(*(((unsigned int8 *)(&res)+4)),7); 
....................    rotate_right(&data1,1); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&res)+5)) = data1; 
....................  
....................    y = y*LN2_INV - (float48)n; 
....................  
....................    r = pe[0]*y + pe[1]; 
....................    r = r*y + pe[2]; 
....................    r = r*y + pe[3]; 
....................    r = r*y + pe[4]; 
....................    r = r*y + pe[5]; 
....................  
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function exp() for data type - Float64 
.................... float64 const pe_64[12] ={9.30741400474913e-011,-4.28655416283316e-011, 
....................                           8.71486547014137e-009,9.84458531538385e-008, 
....................                           1.32588296983536e-006,1.52489283823016e-005, 
....................                           0.000154037598423921,0.00133335487036216, 
....................                           0.00961812936407326,0.0555041086222122, 
....................                           0.240226506962827,0.693147180559823}; 
....................  
.................... float64 exp(float64 x) 
.................... { 
....................    float64 y, res, r; 
....................    unsigned int16 data1, data2; 
....................    unsigned int16 *p; 
....................    signed int16 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 709.7827128) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x*LN2_INV; 
....................    n = (signed int16)y; 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
....................  
.................... #if !defined(__PCD__) 
....................    *((unsigned int16 *)(&res)) = n + 0x7F; 
.................... #endif 
....................    p= (((unsigned int16 *)(&res))+3); 
....................    data1 = *p; 
....................    data2 = *p;    
....................    data1 = n + 0x3FF; 
....................    data1 = data1 <<4; 
....................    if(bit_test(data2,15)) 
....................    bit_set(data1,15); 
....................    data2 = data2 & 0x000F; 
....................    data1 ^= data2; 
....................  
....................    *(((unsigned int16 *)(&res)+3)) = data1; 
....................  
....................  
....................    y = y*LN2_INV - (float64)n; 
....................  
....................    r = pe_64[0]*y + pe_64[1]; 
....................    r = r*y + pe_64[2]; 
....................    r = r*y + pe_64[3]; 
....................    r = r*y + pe_64[4]; 
....................    r = r*y + pe_64[5]; 
....................    r = r*y + pe_64[6]; 
....................    r = r*y + pe_64[7]; 
....................    r = r*y + pe_64[8]; 
....................    r = r*y + pe_64[9]; 
....................    r = r*y + pe_64[10]; 
....................    r = r*y + pe_64[11]; 
....................     
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
.................... #ENDIF 
....................  
....................  
.................... /************************************************************/ 
....................  
.................... float32 const pl[4] = {-1.080310025160955, 1.999999947089217}; 
.................... float32 const ql[4] = {0.091284365719509, -0.873491916557671}; 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float log(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the the natural log of x 
.................... // Date : N/A 
.................... // 
.................... float32 log(float32 x) 
.................... { 
....................    float32 y, res, r, y2; 
....................    #if defined(__PCD__) 
....................    unsigned int8  data1,data2; 
....................    #endif 
....................    signed int8 n; 
....................    #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
.................... #if !defined(__PCD__) 
....................     *((unsigned int8 *)(&y)) = 0x7E;  
.................... #endif 
....................  
.................... #if defined(__PCD__) // Takes care of IEEE format 
....................    data2 = *(((unsigned int8 *)(&y))+3); 
....................    *(((unsigned int8 *)(&y))+3) = 0x3F; 
....................    data1 = *(((unsigned int8 *)(&y))+2); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&y))+2) = data1; 
....................    if(bit_test(data2,7)) 
....................      bit_set(*(((unsigned int8 *)(&y))+3),7); 
.................... #endif 
....................  
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl[0]*y2 + pl[1]; 
....................  
....................       r = ql[0]*y2 + ql[1]; 
....................       r = r*y2 + 1.0; 
....................  
....................       res = y*res/r; 
.................... #if !defined(__PCD__) 
....................       n = *((unsigned int8 *)(&x)) - 0x7E; 
.................... #endif 
.................... #if defined(__PCD__)  
....................     data1 = *(((unsigned int8 *)(&x)+3)); 
....................     rotate_left(&data1,1); 
....................     data2 = *(((unsigned int8 *)(&x)+2)); 
....................     if(bit_test (data2,7)) 
....................       bit_set(data1,0); 
....................     n = data1 - 0x7E; 
.................... #endif 
....................  
....................       if (n<0)  
....................          r = -(float32)-n; 
....................       else 
....................          r = (float32)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................       res = 0.0; 
....................  
....................    return(res); 
.................... } 
....................  
.................... //Overloaded function for log() for PCD 
.................... // Overloaded function log() for data type - Float48 
.................... #if defined(__PCD__) 
.................... // Overloaded function log() for data type - float64 
.................... float64 const pl_64[4] = {-0.145694052150681, 1.365485300000370, 
....................                           -3.120535668274329, 2.000000000000000}; 
....................  
.................... float64 const ql_64[4] = {0.006047500465908, -0.208298281937234, 
....................                           1.113943039156721, -1.893601167470470}; 
....................  
.................... float48 log(float48 x) 
.................... { 
....................    float48 y, res, r, y2; 
....................    unsigned int8  data1,data2; 
....................    signed int8 n; 
.................... #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
.................... #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
....................  
.................... #if !defined(__PCD__) 
....................       *((unsigned int8 *)(&y)) = 0x7E;  
.................... #endif 
....................       data2 = *(((unsigned int8 *)(&y))+5); 
....................       *(((unsigned int8 *)(&y))+5) = 0x3F; 
....................       data1 = *(((unsigned int8 *)(&y))+4); 
....................       bit_clear(data1,7); 
....................       *(((unsigned int8 *)(&y))+4) = data1; 
....................  
....................       if(bit_test(data2,7)) 
....................       bit_set(*(((unsigned int8 *)(&y))+4),7); 
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl_64[0]*y2 + pl_64[1]; 
....................       res = res*y2 + pl_64[2]; 
....................       res = res*y2 + pl_64[3]; 
....................  
....................       r = ql_64[0]*y2 + ql_64[1]; 
....................       r = r*y2 + ql_64[2]; 
....................       r = r*y2 + ql_64[3]; 
....................       r = r*y2 + 1.0;  
....................       res = y*res/r; 
....................  
....................       data1 = *(((unsigned int8 *)(&x)+5)); 
....................       rotate_left(&data1,1); 
....................       data2 = *(((unsigned int8 *)(&x)+4)); 
....................       if(bit_test (data2,7)) 
....................       bit_set(data1,0); 
....................        
....................       n = data1 - 0x7E; 
....................  
....................       if (n<0) 
....................       r = -(float48)-n; 
....................       else 
....................       r = (float48)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................    res = 0.0; 
....................  
....................    return(res); 
.................... } 
....................  
.................... float64 log(float64 x) 
.................... { 
....................    float64 y, res, r, y2; 
....................    unsigned int16  data1,data2; 
....................    unsigned int16 *p; 
....................    signed int16 n; 
....................    #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
....................    #if !defined(__PCD__) 
....................        *((unsigned int8 *)(&y)) = 0x7E;  
....................    #endif 
....................       p= (((unsigned int16 *)(&y))+3); 
....................       data1 = *p; 
....................       data2 = *p; 
....................       data1 = 0x3FE; 
....................       data1 = data1 <<4; 
....................       if(bit_test (data2,15)) 
....................          bit_set(data1,15); 
....................       data2 = data2 & 0x000F; 
....................       data1 ^=data2; 
....................  
....................       *p = data1; 
....................  
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl_64[0]*y2 + pl_64[1]; 
....................       res = res*y2 + pl_64[2]; 
....................       res = res*y2 + pl_64[3]; 
....................  
....................       r = ql_64[0]*y2 + ql_64[1]; 
....................       r = r*y2 + ql_64[2]; 
....................       r = r*y2 + ql_64[3]; 
....................       r = r*y2 + 1.0; 
....................  
....................       res = y*res/r; 
....................   
....................       p= (((unsigned int16 *)(&x))+3); 
....................       data1 = *p; 
....................       bit_clear(data1,15); 
....................       data1 = data1 >>4;     
....................       n = data1 - 0x3FE; 
....................  
....................  
....................       if (n<0) 
....................          r = -(float64)-n; 
....................       else 
....................          r = (float64)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................       res = 0.0; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
....................  
.................... #define LN10 2.3025850929940456 
.................... #define LN10_INV 0.4342944819032518276 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float log10(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the the log base 10 of x 
.................... // Date : N/A 
.................... // 
.................... float32 log10(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = log(x); 
....................    r = r*LN10_INV; 
....................    return(r); 
.................... } 
....................  
.................... //Overloaded functions for log10() for PCD 
.................... // Overloaded function log10() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 log10(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = log(x); 
....................    r = r*LN10_INV; 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function log10() for data type - Float64 
.................... float64 log10(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = log(x); 
....................    r = r*LN10_INV; 
....................    return(r); 
.................... } 
.................... #endif 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float modf(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description :breaks the argument value int integral and fractional parts, 
.................... // ach of which have the same sign as the argument.  It stores the integral part 
.................... // as a float in the object pointed to by the iptr 
.................... // Returns : returns the signed fractional part of value. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 modf(float32 value,float32 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... //Overloaded functions for modf() for PCD 
.................... // Overloaded function modf() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 modf(float48 value,float48 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... // Overloaded function modf() for data type - Float64 
.................... float64 modf(float64 value,float64 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float pwr(float x,float y) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (x^y) 
.................... // Date : N/A 
.................... // Note : 0 is returned when the function will generate an imaginary number 
.................... // 
.................... float32 pwr(float32 x,float32 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... //Overloaded functions for pwr() for PCD 
.................... // Overloaded function pwr() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 pwr(float48 x,float48 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... // Overloaded function pwr() for data type - Float64 
.................... float64 pwr(float64 x,float64 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////// Power functions //////////////////// 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float pow(float x,float y) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (x^y) 
.................... // Date : N/A 
.................... // Note : 0 is returned when the function will generate an imaginary number 
.................... // 
.................... float32 pow(float32 x,float32 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... //Overloaded functions for pow() for PCD 
.................... // Overloaded function for pow() data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 pow(float48 x,float48 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
....................  
.................... // Overloaded function pow() for data type - Float64 
.................... float64 pow(float64 x,float64 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sqrt(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the square root of x 
.................... // Date : N/A 
.................... // 
.................... float32 sqrt(float32 x) 
.................... { 
....................    float32 y, res; 
....................    #if defined(__PCD__) 
....................    unsigned int16 data1,data2; 
....................    #endif 
....................    unsigned int8 *p; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................     
....................    #if !defined(__PCD__) 
....................     p=&y; 
....................    (*p)=(unsigned int8)((((unsigned int16)(*p)) + 127) >> 1); 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     p = (((unsigned int8 *)(&y))+3); 
....................     data1 = *(((unsigned int8 *)(&y))+3); 
....................     data2 = *(((unsigned int8 *)(&y))+2); 
....................     rotate_left(&data1,1);     
....................     if(bit_test(data2,7))     
....................        bit_set(data1,0);     
....................     data1 = ((data1+127) >>1); 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+3) = data1; 
....................     *(((unsigned int8 *)(&y))+2) = data2; 
....................      
....................   #endif 
....................  
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................  
....................       #if !defined(__PCD__) 
....................      (*p)--; 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     data1 = *(((unsigned int8 *)(&y))+3); 
....................     data2 = *(((unsigned int8 *)(&y))+2); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................        bit_set(data1,0);     
....................     data1--; 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+3) = data1; 
....................     *(((unsigned int8 *)(&y))+2) = data2; 
....................      
....................   #endif 
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
.................... //Overloaded functions for sqrt() for PCD 
.................... // Overloaded function sqrt() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sqrt(float48 x) 
.................... { 
....................    float48 y, res; 
....................    unsigned int16 data1,data2; 
....................    unsigned int8 *p; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................     
....................    #if !defined(__PCD__) 
....................     p=&y; 
....................    (*p)=(unsigned int8)((((unsigned int16)(*p)) + 127) >> 1); 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     p = (((unsigned int8 *)(&y))+5); 
....................     data1 = *(((unsigned int8 *)(&y))+5); 
....................     data2 = *(((unsigned int8 *)(&y))+4); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................        bit_set(data1,0);     
....................     data1 = ((data1+127) >>1); 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+5) = data1; 
....................     *(((unsigned int8 *)(&y))+4) = data2; 
....................      
....................   #endif 
....................  
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................  
....................       #if !defined(__PCD__) 
....................      (*p)--; 
....................    #endif 
....................     
....................     data1 = *(((unsigned int8 *)(&y))+5); 
....................     data2 = *(((unsigned int8 *)(&y))+4); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................        bit_set(data1,0);     
....................     data1--; 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+5) = data1; 
....................     *(((unsigned int8 *)(&y))+4) = data2; 
....................      
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function sqrt() for data type - Float64 
.................... float64 sqrt(float64 x) 
.................... { 
....................    float64 y, res; 
....................    unsigned int16 *p; 
....................    unsigned int16 temp1,temp2; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................    p= (((unsigned int16 *)(&y))+3); 
....................    temp1 = *p; 
....................    temp2 = *p; 
....................    bit_clear(temp1,15); 
....................    temp1 = (temp1>>4)+1023; 
....................    temp1 = temp1 >> 1; 
....................    temp1 = (temp1<<4) & 0xFFF0; 
....................    if(bit_test(temp2,15)) 
....................       bit_set(temp1,15); 
....................    temp2 = temp2 & 0x000F; 
....................    temp1 ^= temp2; 
....................     
....................    (*p) = temp1; 
....................     
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................      temp1 = *p; 
....................      temp2 = *p; 
....................      bit_clear(temp1,15); 
....................      temp1 = (temp1>>4); 
....................      temp1--; 
....................      temp1 = (temp1<<4) & 0xFFF0; 
....................      if(bit_test(temp2,15)) 
....................         bit_set(temp1,15); 
....................      temp2 = temp2 & 0x000F; 
....................      temp1 ^= temp2; 
....................      (*p) = temp1; 
....................  
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... ////////////////////////////// Trig Functions ////////////////////////////// 
.................... #ifdef PI_DIV_BY_TWO_INV 
.................... #undef PI_DIV_BY_TWO_INV 
.................... #endif 
.................... #define PI_DIV_BY_TWO_INV 0.63661977236758134 
.................... #ifdef PI_DIV_BY_TWO 
.................... #undef PI_DIV_BY_TWO 
.................... #endif 
.................... #define PI_DIV_BY_TWO   1.5707963267948966 
.................... #ifdef TWOBYPI 
.................... #undef TWOBYPI 
.................... #endif 
.................... #define TWOBYPI          0.6366197723675813 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float cos(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the cosine value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 cos(float32 x) 
.................... { 
....................    float32 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float32 frac; 
....................    float32 p[5] = {                    //by the series definition for cosine 
....................       -0.49999999456337096,            // sum ( ( (-1)^n * x^2n )/(2n)! ) 
....................        0.04166663896921267, 
....................       -0.00138883894522527, 
....................        0.00002476138231734, 
....................       -0.00000026070414770 
....................       //-0.00000000001147, 
....................       // 0.00000000000005 
....................    }; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant 
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 1.0; 
....................    t = t * t; 
....................    for (i = 0; i <= 4; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
....................  
.................... //Overloaded functions for cos() for PCD 
.................... // Overloaded function cos() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 cos(float48 x) 
.................... { 
....................    float48 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float48 frac; 
....................    float48 p[6] = {                    //by the series definition for cosine 
....................       -0.5,                            // sum ( ( (-1)^n * x^2n )/(2n)! ) 
....................        0.04166666666667, 
....................       -0.00138888888889, 
....................        0.00002480158730, 
....................       -0.00000027557319, 
....................        0.00000000208767, 
....................       //-0.00000000001147, 
....................       // 0.00000000000005 
....................    }; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant 
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 0.999999999781; 
....................    t = t * t; 
....................    for (i = 0; i <= 5; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
.................... // Overloaded function cos() for data type - Float64 
.................... float64 cos(float64 x) 
.................... { 
....................    float64 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float64 frac; 
....................    float64 p_64[9] = {               //by the series definition for cosine 
....................      -0.49999999999998740,           // sum ( ( (-1)^n * x^2n )/(2n)! )              
....................       0.04166666666656518, 
....................      -0.00138888888851691, 
....................       0.00002480158658490, 
....................      -0.00000027557239796, 
....................       0.00000000208715031, 
....................      -0.00000000001126577, 
....................       0.00000000000000427, 
....................       0.00000000000000372}; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant 
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 1.0; 
....................    t = t * t; 
....................    for (i = 0; i <= 8; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p_64[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sin(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the sine value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 sin(float32 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
....................  
.................... //Overloaded functions for sin() for PCD 
.................... // Overloaded function sin() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sin(float48 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
....................  
.................... // Overloaded function sin() for data type - Float48 
.................... float64 sin(float64 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float tan(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the tangent value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 tan(float32 x) 
.................... { 
....................    float32 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
.................... //Overloaded functions for tan() for PCD 
.................... // Overloaded function tan() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 tan(float48 x) 
.................... { 
....................    float48 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
....................  
.................... // Overloaded function tan() for data type - Float48 
.................... float64 tan(float64 x) 
.................... { 
....................    float64 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
.................... #endif 
....................  
.................... float32 const pas[3] = {0.49559947, -4.6145309, 5.6036290}; 
.................... float32 const qas[3] = {1.0000000,  -5.5484666, 5.6036290}; 
....................  
.................... float32 ASIN_COS(float32 x, unsigned int8 n) 
.................... { 
....................    float32 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)*0.5); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas[0]*y2 + pas[1]; 
....................    res = res*y2 + pas[2]; 
....................  
....................    r = qas[0]*y2 + qas[1]; 
....................    r = r*y2 + qas[2]; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
....................  
....................  
.................... //Overloaded functions for ASIN_COS() for PCD 
.................... // Overloaded function ASIN_COS() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 ASIN_COS(float48 x, unsigned int8 n) 
.................... { 
....................    float48 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)*0.5); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas[0]*y2 + pas[1]; 
....................    res = res*y2 + pas[2]; 
....................  
....................    r = qas[0]*y2 + qas[1]; 
....................    r = r*y2 + qas[2]; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function ASIN_COS() for data type - Float64 
.................... double pas_64[5]={1.000000000000000,-2.069938587724477,1.421444580548907, 
....................                  -0.360690137621842,0.024929451660228}; 
....................  
.................... double qas_64[5]={-2.236605254391134,1.719212122946451,-0.524122954476133, 
....................                    0.052808872045749,-0.000662536036570}; 
....................                     
.................... float64 ASIN_COS(float64 x, unsigned int8 n) 
.................... { 
....................    float64 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)*0.5); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas_64[4]*y2 + pas_64[3]; 
....................    res = res*y2 + pas_64[2]; 
....................    res = res*y2 + pas_64[1]; 
....................    res = res*y2 + pas_64[0]; 
....................  
....................    r = qas_64[4]*y2 + qas_64[3]; 
....................    r = r*y2 + qas_64[2]; 
....................    r = r*y2 + qas_64[1]; 
....................    r = r*y2 + qas_64[0]; 
....................    r = r*y2 + 1.0; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float asin(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arcsine value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 asin(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
.................... //Overloaded functions for asin() for PCD 
.................... // Overloaded function asin() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 asin(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function asin() for data type - Float64 
.................... float64 asin(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float acos(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arccosine value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 acos(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
.................... //Overloaded functions for acos() for PCD 
.................... // Overloaded function acos() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 acos(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function acos() for data type - Float64 
.................... float64 acos(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
.................... #endif 
....................  
.................... float32 const pat[4] = {0.17630401, 5.6710795, 22.376096, 19.818457}; 
.................... float32 const qat[4] = {1.0000000,  11.368190, 28.982246, 19.818457}; 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float atan(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arctangent value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 atan(float32 x) 
.................... { 
....................    float32 y, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................  
....................    res = pat[0]*y*y + pat[1]; 
....................    res = res*y*y + pat[2]; 
....................    res = res*y*y + pat[3]; 
....................  
....................    r = qat[0]*y*y + qat[1]; 
....................    r = r*y*y + qat[2]; 
....................    r = r*y*y + qat[3]; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
.................... //Overloaded functions for atan() for PCD 
.................... // Overloaded function atan() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 atan(float48 x) 
.................... { 
....................    float48 y, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................  
....................    res = pat[0]*y*y + pat[1]; 
....................    res = res*y*y + pat[2]; 
....................    res = res*y*y + pat[3]; 
....................  
....................    r = qat[0]*y*y + qat[1]; 
....................    r = r*y*y + qat[2]; 
....................    r = r*y*y + qat[3]; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
....................  
.................... float64 pat_64[6]={0.999999999999999,2.249923645595566,1.771541617806449, 
....................                    0.579678874003185,0.072162702162882,0.002281100141660}; 
....................  
.................... float64 qat_64[6]={2.583256978928510,2.432627277466967,1.016760379885393, 
....................                    0.182482977188688,0.011155377971690,0.000100013019160}; 
.................... // Overloaded function atan() for data type - Float64 
.................... float64 atan(float64 x) 
.................... { 
....................    float64 y,y2, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................    y2 = y*y; 
....................    res = pat_64[5]*y2 + pat_64[4]; 
....................    res = res*y2 + pat_64[3]; 
....................    res = res*y2 + pat_64[2]; 
....................    res = res*y2 + pat_64[1]; 
....................    res = res*y2 + pat_64[0]; 
....................  
....................    r = qat_64[5]*y2 + qat_64[4]; 
....................    r = r*y2 + qat_64[3]; 
....................    r = r*y2 + qat_64[2]; 
....................    r = r*y2 + qat_64[1]; 
....................    r = r*y2 + qat_64[0]; 
....................    r = r*y2 + 1.0; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... ///////////////////////////////////////////////////////////////////////////// 
.................... //   float atan2(float y, float x) 
.................... ///////////////////////////////////////////////////////////////////////////// 
.................... // Description :computes the principal value of arc tangent of y/x, using the 
.................... // signs of both the arguments to determine the quadrant of the return value 
.................... // Returns : returns the arc tangent of y/x. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 atan2(float32 y,float32 x) 
.................... { 
....................    float32 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
....................  
.................... //Overloaded functions for atan2() for PCD 
.................... // Overloaded function atan2() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 atan2(float48 y,float48 x) 
.................... { 
....................    float48 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
....................  
.................... // Overloaded function atan2() for data type - Float64 
.................... float64 atan2(float64 y,float64 x) 
.................... { 
....................    float64 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////// Hyperbolic functions //////////////////// 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float cosh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic cosine value of x 
.................... // Returns : returns the hyperbolic cosine value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 cosh(float32 x) 
.................... { 
....................    return ((exp(x)+exp(-x))*0.5); 
.................... } 
.................... //Overloaded functions for cosh() for PCD 
.................... // Overloaded function cosh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 cosh(float48 x) 
.................... { 
....................    return ((exp(x)+exp(-x))*0.5); 
.................... } 
....................  
.................... // Overloaded function cosh() for data type - Float64 
.................... float64 cosh(float64 x) 
.................... { 
....................    return ((exp(x)+exp(-x))*0.5); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sinh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic sine value of x 
.................... // Returns : returns the hyperbolic sine value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 sinh(float32 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))*0.5); 
.................... } 
.................... //Overloaded functions for sinh() for PCD 
.................... // Overloaded function sinh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sinh(float48 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))*0.5); 
.................... } 
....................  
.................... // Overloaded function sinh() for data type - Float48 
.................... float64 sinh(float64 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))*0.5); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float tanh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic tangent value of x 
.................... // Returns : returns the hyperbolic tangent value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 tanh(float32 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
.................... //Overloaded functions for tanh() for PCD 
.................... // Overloaded function tanh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 tanh(float48 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
....................  
.................... // Overloaded function tanh() for data type - Float64 
.................... float64 tanh(float64 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float frexp(float x, signed int *exp) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : breaks a floating point number into a normalized fraction and an integral 
.................... // power of 2. It stores the integer in the signed int object pointed to by exp. 
.................... // Returns : returns the value x, such that x is a double with magnitude in the interval 
.................... // [1/2,1) or zero, and value equals x times 2 raised to the power *exp.If value is zero, 
.................... // both parts of the result are zero. 
.................... // Date : N/A 
.................... // 
....................  
.................... #define LOG2 .30102999566398119521 
.................... #define LOG2_INV 3.32192809488736234787 
.................... float32 frexp(float32 x, signed int8 *exp) 
.................... { 
....................    float32 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)*LOG2_INV)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
....................  
.................... //Overloaded functions for frexp() for PCD 
.................... // Overloaded function frexp() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 frexp(float48 x, signed int8 *exp) 
.................... { 
....................    float48 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)*LOG2_INV)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
....................  
.................... // Overloaded function frexp() for data type - Float64 
.................... float64 frexp(float64 x, signed int8 *exp) 
.................... { 
....................    float64 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)*LOG2_INV)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
.................... #endif 
....................  
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... //   float ldexp(float x, signed int *exp) 
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... // Description : multiplies a floating point number by an integral power of 2. 
.................... // Returns : returns the value of x times 2 raised to the power exp. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 ldexp(float32 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... //Overloaded functions for ldexp() for PCD 
.................... // Overloaded function ldexp() for data type - Float48 
....................  
.................... #if defined(__PCD__) 
.................... float48 ldexp(float48 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... // Overloaded function ldexp() for data type - Float64 
.................... float64 ldexp(float64 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... #endif 
....................  
.................... #endif 
....................  
.................... #INCLUDE <xuatbyte74595.c> 
....................  
.................... #DEFINE      DS               PIN_D1 
.................... #DEFINE      SH_CP            PIN_D0   
.................... #DEFINE      STCP             PIN_D2 
.................... VOID XUATTRANGTHAI(UNSIGNED INT8 BYTEXUAT) 
.................... { 
....................    UNSIGNED INT8   SB;    
....................    #BIT BSERI  = BYTEXUAT.7 
....................     
....................    FOR (SB=0;SB<8;SB++) 
*
0CB9:  CLRF   1F
0CBA:  MOVF   1F,W
0CBB:  SUBLW  07
0CBC:  BTFSS  03.0
0CBD:  GOTO   4D4
....................       {                                                  
....................          OUTPUT_BIT(DS,BSERI);     
0CBE:  BTFSC  1E.7
0CBF:  GOTO   4C4
0CC0:  BCF    03.6
0CC1:  BCF    08.1
0CC2:  GOTO   4C6
0CC3:  BSF    03.6
0CC4:  BCF    03.6
0CC5:  BSF    08.1
0CC6:  BSF    03.5
0CC7:  BCF    08.1
....................          OUTPUT_LOW(SH_CP); OUTPUT_HIGH(SH_CP); 
0CC8:  BCF    08.0
0CC9:  BCF    03.5
0CCA:  BCF    08.0
0CCB:  BSF    03.5
0CCC:  BCF    08.0
0CCD:  BCF    03.5
0CCE:  BSF    08.0
....................          BYTEXUAT=BYTEXUAT<<1; //10010010->00100100   
0CCF:  BCF    03.0
0CD0:  BSF    03.6
0CD1:  RLF    1E,F
0CD2:  INCF   1F,F
0CD3:  GOTO   4BA
....................      } 
....................       OUTPUT_LOW(STCP); OUTPUT_HIGH(STCP); 
0CD4:  BSF    03.5
0CD5:  BCF    03.6
0CD6:  BCF    08.2
0CD7:  BCF    03.5
0CD8:  BCF    08.2
0CD9:  BSF    03.5
0CDA:  BCF    08.2
0CDB:  BCF    03.5
0CDC:  BSF    08.2
.................... } 
....................  
....................  
.................... #FUSES NOWDT, PUT, HS 
.................... #USE DELAY(CLOCK=20M) 
*
016C:  MOVLW  46
016D:  MOVWF  04
016E:  BSF    03.7
016F:  MOVF   00,W
0170:  BTFSC  03.2
0171:  GOTO   17F
0172:  MOVLW  06
0173:  MOVWF  78
0174:  CLRF   77
0175:  DECFSZ 77,F
0176:  GOTO   175
0177:  DECFSZ 78,F
0178:  GOTO   174
0179:  MOVLW  7B
017A:  MOVWF  77
017B:  DECFSZ 77,F
017C:  GOTO   17B
017D:  DECFSZ 00,F
017E:  GOTO   172
017F:  RETURN
.................... #USE RS232(BAUD=9600,XMIT=PIN_C6,RCV=PIN_C7) 
.................... #DEFINE BT1_PIN PIN_B1 
.................... #DEFINE BT2_PIN PIN_B2 
.................... #DEFINE BT3_PIN PIN_B3 
.................... #DEFINE LCD_ENABLE_PIN  PIN_E0                                    
.................... #DEFINE LCD_RS_PIN      PIN_E1                                 
.................... #DEFINE LCD_RW_PIN      PIN_E2   
.................... #DEFINE LCD_DATA4       PIN_C0                                
.................... #DEFINE LCD_DATA5       PIN_C1                                  
.................... #DEFINE LCD_DATA6       PIN_C2                                    
.................... #DEFINE LCD_DATA7       PIN_C3   
.................... #INCLUDE <LCD.C> 
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... ////                             LCD.C                                     //// 
.................... ////                 Driver for common LCD modules                         //// 
.................... ////                                                                       //// 
.................... ////  lcd_init()   Must be called before any other function.               //// 
.................... ////                                                                       //// 
.................... ////  lcd_putc(c)  Will display c on the next position of the LCD.         //// 
.................... ////                 \a  Set cursor position to upper left                 //// 
.................... ////                 \f  Clear display, set cursor to upper left           //// 
.................... ////                 \n  Go to start of second line                        //// 
.................... ////                 \b  Move back one position                            //// 
.................... ////              If LCD_EXTENDED_NEWLINE is defined, the \n character     //// 
.................... ////              will erase all remanining characters on the current      //// 
.................... ////              line, and move the cursor to the beginning of the next   //// 
.................... ////              line.                                                    //// 
.................... ////              If LCD_EXTENDED_NEWLINE is defined, the \r character     //// 
.................... ////              will move the cursor to the start of the current         //// 
.................... ////              line.                                                    //// 
.................... ////                                                                       //// 
.................... ////  lcd_gotoxy(x,y) Set write position on LCD (upper left is 1,1)        //// 
.................... ////                                                                       //// 
.................... ////  lcd_getc(x,y)   Returns character at position x,y on LCD             //// 
.................... ////                                                                       //// 
.................... ////  lcd_cursor_on(int1 on)   Turn the cursor on (on=TRUE) or off         //// 
.................... ////              (on=FALSE).                                              //// 
.................... ////                                                                       //// 
.................... ////  lcd_set_cgram_char(w, *p)   Write a custom character to the CGRAM.   //// 
.................... ////                                                                       //// 
.................... ////                                                                       //// 
.................... ////  CONFIGURATION                                                        //// 
.................... ////  The LCD can be configured in one of two ways: a.) port access or     //// 
.................... ////  b.) pin access.  Port access requires the entire 7 bit interface     //// 
.................... ////  connected to one GPIO port, and the data bits (D4:D7 of the LCD)     //// 
.................... ////  connected to sequential pins on the GPIO.  Pin access                //// 
.................... ////  has no requirements, all 7 bits of the control interface can         //// 
.................... ////  can be connected to any GPIO using several ports.                    //// 
.................... ////                                                                       //// 
.................... ////  To use port access, #define LCD_DATA_PORT to the SFR location of     //// 
.................... ////  of the GPIO port that holds the interface, -AND- edit LCD_PIN_MAP    //// 
.................... ////  of this file to configure the pin order.  If you are using a         //// 
.................... ////  baseline PIC (PCB), then LCD_OUTPUT_MAP and LCD_INPUT_MAP also must  //// 
.................... ////  be defined.                                                          //// 
.................... ////                                                                       //// 
.................... ////  Example of port access:                                              //// 
.................... ////     #define LCD_DATA_PORT getenv("SFR:PORTD")                         //// 
.................... ////                                                                       //// 
.................... ////  To use pin access, the following pins must be defined:               //// 
.................... ////     LCD_ENABLE_PIN                                                    //// 
.................... ////     LCD_RS_PIN                                                        //// 
.................... ////     LCD_RW_PIN                                                        //// 
.................... ////     LCD_DATA4                                                         //// 
.................... ////     LCD_DATA5                                                         //// 
.................... ////     LCD_DATA6                                                         //// 
.................... ////     LCD_DATA7                                                         //// 
.................... ////                                                                       //// 
.................... ////  Example of pin access:                                               //// 
.................... ////     #define LCD_ENABLE_PIN  PIN_E0                                    //// 
.................... ////     #define LCD_RS_PIN      PIN_E1                                    //// 
.................... ////     #define LCD_RW_PIN      PIN_E2                                    //// 
.................... ////     #define LCD_DATA4       PIN_D4                                    //// 
.................... ////     #define LCD_DATA5       PIN_D5                                    //// 
.................... ////     #define LCD_DATA6       PIN_D6                                    //// 
.................... ////     #define LCD_DATA7       PIN_D7                                    //// 
.................... ////                                                                       //// 
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2010 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef __LCD_C__ 
.................... #define __LCD_C__ 
....................  
.................... // define the pinout. 
.................... // only required if port access is being used. 
.................... typedef struct   
.................... {                            // This structure is overlayed 
....................    int1 enable;           // on to an I/O port to gain 
....................    int1 rs;               // access to the LCD pins. 
....................    int1 rw;               // The bits are allocated from 
....................    int1 unused;           // low order up.  ENABLE will 
....................    unsigned int     data : 4;         // be LSB pin of that port. 
....................   #if defined(__PCD__)       // The port used will be LCD_DATA_PORT. 
....................    unsigned int    reserved: 8; 
....................   #endif 
.................... } LCD_PIN_MAP; 
....................  
.................... // this is to improve compatability with previous LCD drivers that accepted 
.................... // a define labeled 'use_portb_lcd' that configured the LCD onto port B. 
.................... #if ((defined(use_portb_lcd)) && (use_portb_lcd==TRUE)) 
....................  #define LCD_DATA_PORT getenv("SFR:PORTB") 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
....................    // these definitions only need to be modified for baseline PICs. 
....................    // all other PICs use LCD_PIN_MAP or individual LCD_xxx pin definitions. 
.................... /*                                    EN, RS,   RW,   UNUSED,  DATA  */ 
....................  const LCD_PIN_MAP LCD_OUTPUT_MAP =  {0,  0,    0,    0,       0}; 
....................  const LCD_PIN_MAP LCD_INPUT_MAP =   {0,  0,    0,    0,       0xF}; 
.................... #endif 
....................  
.................... ////////////////////// END CONFIGURATION /////////////////////////////////// 
....................  
.................... #ifndef LCD_ENABLE_PIN 
....................    #define lcd_output_enable(x) lcdlat.enable=x 
....................    #define lcd_enable_tris()   lcdtris.enable=0 
.................... #else 
....................    #define lcd_output_enable(x) output_bit(LCD_ENABLE_PIN, x) 
....................    #define lcd_enable_tris()  output_drive(LCD_ENABLE_PIN) 
.................... #endif 
....................  
.................... #ifndef LCD_RS_PIN 
....................    #define lcd_output_rs(x) lcdlat.rs=x 
....................    #define lcd_rs_tris()   lcdtris.rs=0 
.................... #else 
....................    #define lcd_output_rs(x) output_bit(LCD_RS_PIN, x) 
....................    #define lcd_rs_tris()  output_drive(LCD_RS_PIN) 
.................... #endif 
....................  
.................... #ifndef LCD_RW_PIN 
....................    #define lcd_output_rw(x) lcdlat.rw=x 
....................    #define lcd_rw_tris()   lcdtris.rw=0 
.................... #else 
....................    #define lcd_output_rw(x) output_bit(LCD_RW_PIN, x) 
....................    #define lcd_rw_tris()  output_drive(LCD_RW_PIN) 
.................... #endif 
....................  
.................... // original version of this library incorrectly labeled LCD_DATA0 as LCD_DATA4, 
.................... // LCD_DATA1 as LCD_DATA5, and so on.  this block of code makes the driver 
.................... // compatible with any code written for the original library 
.................... #if (defined(LCD_DATA0) && defined(LCD_DATA1) && defined(LCD_DATA2) && defined(LCD_DATA3) && !defined(LCD_DATA4) && !defined(LCD_DATA5) && !defined(LCD_DATA6) && !defined(LCD_DATA7)) 
....................    #define  LCD_DATA4    LCD_DATA0 
....................    #define  LCD_DATA5    LCD_DATA1 
....................    #define  LCD_DATA6    LCD_DATA2 
....................    #define  LCD_DATA7    LCD_DATA3 
.................... #endif 
....................  
.................... #ifndef LCD_DATA4 
.................... #ifndef LCD_DATA_PORT 
....................    #if defined(__PCB__) 
....................       #define LCD_DATA_PORT      0x06     //portb 
....................       #define set_tris_lcd(x)   set_tris_b(x) 
....................    #else 
....................      #if defined(PIN_D0) 
....................       #define LCD_DATA_PORT      getenv("SFR:PORTD")     //portd 
....................      #else 
....................       #define LCD_DATA_PORT      getenv("SFR:PORTB")     //portb 
....................      #endif 
....................    #endif    
.................... #endif 
....................  
.................... #if defined(__PCB__) 
....................    LCD_PIN_MAP lcd, lcdlat; 
....................    #byte lcd = LCD_DATA_PORT 
....................    #byte lcdlat = LCD_DATA_PORT 
.................... #elif defined(__PCM__) 
....................    LCD_PIN_MAP lcd, lcdlat, lcdtris; 
....................    #byte lcd = LCD_DATA_PORT 
....................    #byte lcdlat = LCD_DATA_PORT 
....................    #byte lcdtris = LCD_DATA_PORT+0x80 
.................... #elif defined(__PCH__) 
....................    LCD_PIN_MAP lcd, lcdlat, lcdtris; 
....................    #byte lcd = LCD_DATA_PORT 
....................    #byte lcdlat = LCD_DATA_PORT+9 
....................    #byte lcdtris = LCD_DATA_PORT+0x12 
.................... #elif defined(__PCD__) 
....................    LCD_PIN_MAP lcd, lcdlat, lcdtris; 
....................    #word lcd = LCD_DATA_PORT 
....................    #word lcdlat = LCD_DATA_PORT+2 
....................    #word lcdtris = LCD_DATA_PORT-0x02 
.................... #endif 
.................... #endif   //LCD_DATA4 not defined 
....................  
.................... #ifndef LCD_TYPE 
....................    #define LCD_TYPE 2           // 0=5x7, 1=5x10, 2=2 lines 
.................... #endif 
....................  
.................... #ifndef LCD_LINE_TWO 
....................    #define LCD_LINE_TWO 0x40    // LCD RAM address for the second line 
.................... #endif 
....................  
.................... #ifndef LCD_LINE_LENGTH 
....................    #define LCD_LINE_LENGTH 20 
.................... #endif 
....................  
.................... unsigned int8 lcd_read_nibble(void); 
....................  
.................... unsigned int8 lcd_read_byte(void) 
.................... { 
....................    unsigned int8 low,high; 
....................  
....................  #if defined(__PCB__) 
....................    set_tris_lcd(LCD_INPUT_MAP); 
....................  #else 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    output_float(LCD_DATA4); 
*
0213:  BSF    07.0
....................    output_float(LCD_DATA5); 
0214:  BSF    07.1
....................    output_float(LCD_DATA6); 
0215:  BSF    07.2
....................    output_float(LCD_DATA7); 
0216:  BSF    07.3
....................   #else 
....................    lcdtris.data = 0xF; 
....................   #endif 
....................  #endif 
....................          
....................    lcd_output_rw(1); 
0217:  BCF    03.5
0218:  BSF    09.2
0219:  BSF    03.5
021A:  BCF    09.2
....................    delay_cycles(1); 
021B:  NOP
....................    lcd_output_enable(1); 
021C:  BCF    03.5
021D:  BSF    09.0
021E:  BSF    03.5
021F:  BCF    09.0
....................    delay_cycles(1); 
0220:  NOP
....................    high = lcd_read_nibble(); 
0221:  BCF    03.5
0222:  CALL   1C8
0223:  MOVF   78,W
0224:  BSF    03.6
0225:  MOVWF  4D
....................        
....................    lcd_output_enable(0); 
0226:  BCF    03.6
0227:  BCF    09.0
0228:  BSF    03.5
0229:  BCF    09.0
....................    delay_cycles(1); 
022A:  NOP
....................    lcd_output_enable(1); 
022B:  BCF    03.5
022C:  BSF    09.0
022D:  BSF    03.5
022E:  BCF    09.0
....................    delay_us(1); 
022F:  GOTO   230
0230:  GOTO   231
0231:  NOP
....................    low = lcd_read_nibble(); 
0232:  BCF    03.5
0233:  CALL   1C8
0234:  MOVF   78,W
0235:  BSF    03.6
0236:  MOVWF  4C
....................        
....................    lcd_output_enable(0); 
0237:  BCF    03.6
0238:  BCF    09.0
0239:  BSF    03.5
023A:  BCF    09.0
....................  
....................  #if defined(__PCB__) 
....................    set_tris_lcd(LCD_OUTPUT_MAP); 
....................  #else 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    output_drive(LCD_DATA4); 
023B:  BCF    03.5
023C:  BCF    31.0
023D:  MOVF   31,W
023E:  BSF    03.5
023F:  MOVWF  07
....................    output_drive(LCD_DATA5); 
0240:  BCF    03.5
0241:  BCF    31.1
0242:  MOVF   31,W
0243:  BSF    03.5
0244:  MOVWF  07
....................    output_drive(LCD_DATA6); 
0245:  BCF    03.5
0246:  BCF    31.2
0247:  MOVF   31,W
0248:  BSF    03.5
0249:  MOVWF  07
....................    output_drive(LCD_DATA7); 
024A:  BCF    03.5
024B:  BCF    31.3
024C:  MOVF   31,W
024D:  BSF    03.5
024E:  MOVWF  07
....................   #else 
....................    lcdtris.data = 0x0; 
....................   #endif 
....................  #endif 
....................  
....................    return( (high<<4) | low); 
024F:  BCF    03.5
0250:  BSF    03.6
0251:  SWAPF  4D,W
0252:  MOVWF  77
0253:  MOVLW  F0
0254:  ANDWF  77,F
0255:  MOVF   77,W
0256:  IORWF  4C,W
0257:  MOVWF  78
.................... } 
....................  
.................... unsigned int8 lcd_read_nibble(void) 
.................... { 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
*
01C8:  BSF    03.6
01C9:  CLRF   4E
....................    unsigned int8 n = 0x00; 
....................  
....................    /* Read the data port */ 
....................    n |= input(LCD_DATA4); 
01CA:  BCF    03.6
01CB:  BSF    31.0
01CC:  MOVF   31,W
01CD:  BSF    03.5
01CE:  MOVWF  07
01CF:  MOVLW  00
01D0:  BCF    03.5
01D1:  BTFSC  07.0
01D2:  MOVLW  01
01D3:  BSF    03.6
01D4:  IORWF  4E,F
....................    n |= input(LCD_DATA5) << 1; 
01D5:  BCF    03.6
01D6:  BSF    31.1
01D7:  MOVF   31,W
01D8:  BSF    03.5
01D9:  MOVWF  07
01DA:  MOVLW  00
01DB:  BCF    03.5
01DC:  BTFSC  07.1
01DD:  MOVLW  01
01DE:  MOVWF  77
01DF:  BCF    03.0
01E0:  RLF    77,F
01E1:  MOVF   77,W
01E2:  BSF    03.6
01E3:  IORWF  4E,F
....................    n |= input(LCD_DATA6) << 2; 
01E4:  BCF    03.6
01E5:  BSF    31.2
01E6:  MOVF   31,W
01E7:  BSF    03.5
01E8:  MOVWF  07
01E9:  MOVLW  00
01EA:  BCF    03.5
01EB:  BTFSC  07.2
01EC:  MOVLW  01
01ED:  MOVWF  77
01EE:  RLF    77,F
01EF:  RLF    77,F
01F0:  MOVLW  FC
01F1:  ANDWF  77,F
01F2:  MOVF   77,W
01F3:  BSF    03.6
01F4:  IORWF  4E,F
....................    n |= input(LCD_DATA7) << 3; 
01F5:  BCF    03.6
01F6:  BSF    31.3
01F7:  MOVF   31,W
01F8:  BSF    03.5
01F9:  MOVWF  07
01FA:  MOVLW  00
01FB:  BCF    03.5
01FC:  BTFSC  07.3
01FD:  MOVLW  01
01FE:  MOVWF  77
01FF:  RLF    77,F
0200:  RLF    77,F
0201:  RLF    77,F
0202:  MOVLW  F8
0203:  ANDWF  77,F
0204:  MOVF   77,W
0205:  BSF    03.6
0206:  IORWF  4E,F
....................     
....................    return(n); 
0207:  MOVF   4E,W
0208:  MOVWF  78
....................   #else 
0209:  BCF    03.6
020A:  RETURN
....................    return(lcd.data); 
....................   #endif 
.................... } 
....................  
.................... void lcd_send_nibble(unsigned int8 n) 
.................... { 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    /* Write to the data port */ 
....................    output_bit(LCD_DATA4, bit_test(n, 0)); 
*
0180:  BSF    03.6
0181:  BTFSC  4D.0
0182:  GOTO   187
0183:  BCF    03.6
0184:  BCF    07.0
0185:  GOTO   189
0186:  BSF    03.6
0187:  BCF    03.6
0188:  BSF    07.0
0189:  BCF    31.0
018A:  MOVF   31,W
018B:  BSF    03.5
018C:  MOVWF  07
....................    output_bit(LCD_DATA5, bit_test(n, 1)); 
018D:  BCF    03.5
018E:  BSF    03.6
018F:  BTFSC  4D.1
0190:  GOTO   195
0191:  BCF    03.6
0192:  BCF    07.1
0193:  GOTO   197
0194:  BSF    03.6
0195:  BCF    03.6
0196:  BSF    07.1
0197:  BCF    31.1
0198:  MOVF   31,W
0199:  BSF    03.5
019A:  MOVWF  07
....................    output_bit(LCD_DATA6, bit_test(n, 2)); 
019B:  BCF    03.5
019C:  BSF    03.6
019D:  BTFSC  4D.2
019E:  GOTO   1A3
019F:  BCF    03.6
01A0:  BCF    07.2
01A1:  GOTO   1A5
01A2:  BSF    03.6
01A3:  BCF    03.6
01A4:  BSF    07.2
01A5:  BCF    31.2
01A6:  MOVF   31,W
01A7:  BSF    03.5
01A8:  MOVWF  07
....................    output_bit(LCD_DATA7, bit_test(n, 3)); 
01A9:  BCF    03.5
01AA:  BSF    03.6
01AB:  BTFSC  4D.3
01AC:  GOTO   1B1
01AD:  BCF    03.6
01AE:  BCF    07.3
01AF:  GOTO   1B3
01B0:  BSF    03.6
01B1:  BCF    03.6
01B2:  BSF    07.3
01B3:  BCF    31.3
01B4:  MOVF   31,W
01B5:  BSF    03.5
01B6:  MOVWF  07
....................   #else       
....................    lcdlat.data = n; 
....................   #endif 
....................        
....................    delay_cycles(1); 
01B7:  NOP
....................    lcd_output_enable(1); 
01B8:  BCF    03.5
01B9:  BSF    09.0
01BA:  BSF    03.5
01BB:  BCF    09.0
....................    delay_us(2); 
01BC:  MOVLW  02
01BD:  MOVWF  77
01BE:  DECFSZ 77,F
01BF:  GOTO   1BE
01C0:  GOTO   1C1
01C1:  NOP
....................    lcd_output_enable(0); 
01C2:  BCF    03.5
01C3:  BCF    09.0
01C4:  BSF    03.5
01C5:  BCF    09.0
01C6:  BCF    03.5
01C7:  RETURN
.................... } 
....................  
.................... void lcd_send_byte(unsigned int8 address, unsigned int8 n) 
.................... { 
....................   #if defined(__PCB__) 
....................    set_tris_lcd(LCD_OUTPUT_MAP); 
....................   #else 
....................    lcd_enable_tris(); 
*
020B:  BSF    03.5
020C:  BCF    09.0
....................    lcd_rs_tris(); 
020D:  BCF    09.1
....................    lcd_rw_tris(); 
020E:  BCF    09.2
....................   #endif 
....................  
....................    lcd_output_rs(0); 
020F:  BCF    03.5
0210:  BCF    09.1
0211:  BSF    03.5
0212:  BCF    09.1
....................    while ( bit_test(lcd_read_byte(),7) ) ; 
*
0258:  MOVF   78,W
0259:  MOVWF  4C
025A:  BTFSS  4C.7
025B:  GOTO   25F
025C:  BSF    03.5
025D:  BCF    03.6
025E:  GOTO   213
....................    lcd_output_rs(address); 
025F:  MOVF   4A,F
0260:  BTFSS  03.2
0261:  GOTO   266
0262:  BCF    03.6
0263:  BCF    09.1
0264:  GOTO   268
0265:  BSF    03.6
0266:  BCF    03.6
0267:  BSF    09.1
0268:  BSF    03.5
0269:  BCF    09.1
....................    delay_cycles(1); 
026A:  NOP
....................    lcd_output_rw(0); 
026B:  BCF    03.5
026C:  BCF    09.2
026D:  BSF    03.5
026E:  BCF    09.2
....................    delay_cycles(1); 
026F:  NOP
....................    lcd_output_enable(0); 
0270:  BCF    03.5
0271:  BCF    09.0
0272:  BSF    03.5
0273:  BCF    09.0
....................    lcd_send_nibble(n >> 4); 
0274:  BCF    03.5
0275:  BSF    03.6
0276:  SWAPF  4B,W
0277:  MOVWF  4C
0278:  MOVLW  0F
0279:  ANDWF  4C,F
027A:  MOVF   4C,W
027B:  MOVWF  4D
027C:  BCF    03.6
027D:  CALL   180
....................    lcd_send_nibble(n & 0xf); 
027E:  BSF    03.6
027F:  MOVF   4B,W
0280:  ANDLW  0F
0281:  MOVWF  4C
0282:  MOVWF  4D
0283:  BCF    03.6
0284:  CALL   180
0285:  RETURN
.................... } 
....................  
.................... #if defined(LCD_EXTENDED_NEWLINE) 
.................... unsigned int8 g_LcdX, g_LcdY; 
.................... #endif 
....................  
.................... void lcd_init(void)  
.................... { 
....................    unsigned int8 i; 
....................    unsigned int8 LCD_INIT_STRING[4] = {0x20 | (LCD_TYPE << 2), 0xc, 1, 6}; 
0286:  MOVLW  28
0287:  BSF    03.6
0288:  MOVWF  16
0289:  MOVLW  0C
028A:  MOVWF  17
028B:  MOVLW  01
028C:  MOVWF  18
028D:  MOVLW  06
028E:  MOVWF  19
....................                              // These bytes need to be sent to the LCD 
....................                              // to start it up. 
....................     
....................  
....................    lcd_output_enable(0); 
028F:  BCF    03.6
0290:  BCF    09.0
0291:  BSF    03.5
0292:  BCF    09.0
....................    lcd_output_rs(0); 
0293:  BCF    03.5
0294:  BCF    09.1
0295:  BSF    03.5
0296:  BCF    09.1
....................    lcd_output_rw(0); 
0297:  BCF    03.5
0298:  BCF    09.2
0299:  BSF    03.5
029A:  BCF    09.2
....................  
....................  #if defined(__PCB__) 
....................    set_tris_lcd(LCD_OUTPUT_MAP); 
....................  #else 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    output_drive(LCD_DATA4); 
029B:  BCF    03.5
029C:  BCF    31.0
029D:  MOVF   31,W
029E:  BSF    03.5
029F:  MOVWF  07
....................    output_drive(LCD_DATA5); 
02A0:  BCF    03.5
02A1:  BCF    31.1
02A2:  MOVF   31,W
02A3:  BSF    03.5
02A4:  MOVWF  07
....................    output_drive(LCD_DATA6); 
02A5:  BCF    03.5
02A6:  BCF    31.2
02A7:  MOVF   31,W
02A8:  BSF    03.5
02A9:  MOVWF  07
....................    output_drive(LCD_DATA7); 
02AA:  BCF    03.5
02AB:  BCF    31.3
02AC:  MOVF   31,W
02AD:  BSF    03.5
02AE:  MOVWF  07
....................   #else 
....................    lcdtris.data = 0x0; 
....................   #endif 
....................    lcd_enable_tris(); 
02AF:  BCF    09.0
....................    lcd_rs_tris(); 
02B0:  BCF    09.1
....................    lcd_rw_tris(); 
02B1:  BCF    09.2
....................  #endif 
....................      
....................    delay_ms(15); 
02B2:  MOVLW  0F
02B3:  BCF    03.5
02B4:  BSF    03.6
02B5:  MOVWF  46
02B6:  BCF    03.6
02B7:  CALL   16C
....................    for(i=1;i<=3;++i) 
02B8:  MOVLW  01
02B9:  BSF    03.6
02BA:  MOVWF  15
02BB:  MOVF   15,W
02BC:  SUBLW  03
02BD:  BTFSS  03.0
02BE:  GOTO   2CB
....................    { 
....................        lcd_send_nibble(3); 
02BF:  MOVLW  03
02C0:  MOVWF  4D
02C1:  BCF    03.6
02C2:  CALL   180
....................        delay_ms(5); 
02C3:  MOVLW  05
02C4:  BSF    03.6
02C5:  MOVWF  46
02C6:  BCF    03.6
02C7:  CALL   16C
02C8:  BSF    03.6
02C9:  INCF   15,F
02CA:  GOTO   2BB
....................    } 
....................     
....................    lcd_send_nibble(2); 
02CB:  MOVLW  02
02CC:  MOVWF  4D
02CD:  BCF    03.6
02CE:  CALL   180
....................    delay_ms(5); 
02CF:  MOVLW  05
02D0:  BSF    03.6
02D1:  MOVWF  46
02D2:  BCF    03.6
02D3:  CALL   16C
....................    for(i=0;i<=3;++i) 
02D4:  BSF    03.6
02D5:  CLRF   15
02D6:  MOVF   15,W
02D7:  SUBLW  03
02D8:  BTFSS  03.0
02D9:  GOTO   2E8
....................       lcd_send_byte(0,LCD_INIT_STRING[i]); 
02DA:  MOVLW  16
02DB:  ADDWF  15,W
02DC:  MOVWF  04
02DD:  BSF    03.7
02DE:  MOVF   00,W
02DF:  MOVWF  1A
02E0:  CLRF   4A
02E1:  MOVF   1A,W
02E2:  MOVWF  4B
02E3:  BCF    03.6
02E4:  CALL   20B
....................  
....................   #if defined(LCD_EXTENDED_NEWLINE) 
02E5:  BSF    03.6
02E6:  INCF   15,F
02E7:  GOTO   2D6
02E8:  BCF    03.6
02E9:  BCF    0A.3
02EA:  BSF    0A.4
02EB:  GOTO   57E (RETURN)
....................    g_LcdX = 0; 
....................    g_LcdY = 0; 
....................   #endif 
.................... } 
....................  
.................... void lcd_gotoxy(unsigned int8 x, unsigned int8 y) 
.................... { 
....................    unsigned int8 address; 
....................     
....................    if(y!=1) 
*
0515:  BSF    03.6
0516:  DECFSZ 47,W
0517:  GOTO   519
0518:  GOTO   51C
....................       address=LCD_LINE_TWO; 
0519:  MOVLW  40
051A:  MOVWF  48
051B:  GOTO   51D
....................    else 
....................       address=0; 
051C:  CLRF   48
....................       
....................    address+=x-1; 
051D:  MOVLW  01
051E:  SUBWF  46,W
051F:  ADDWF  48,F
....................    lcd_send_byte(0,0x80|address); 
0520:  MOVF   48,W
0521:  IORLW  80
0522:  MOVWF  49
0523:  CLRF   4A
0524:  MOVF   49,W
0525:  MOVWF  4B
0526:  BCF    03.6
0527:  CALL   20B
....................  
....................   #if defined(LCD_EXTENDED_NEWLINE) 
0528:  RETURN
....................    g_LcdX = x - 1; 
....................    g_LcdY = y - 1; 
....................   #endif 
.................... } 
....................  
.................... void lcd_putc(char c) 
.................... { 
....................    switch (c) 
0529:  BSF    03.6
052A:  MOVF   45,W
052B:  XORLW  07
052C:  BCF    03.6
052D:  BTFSC  03.2
052E:  GOTO   539
052F:  XORLW  0B
0530:  BTFSC  03.2
0531:  GOTO   540
0532:  XORLW  06
0533:  BTFSC  03.2
0534:  GOTO   54C
0535:  XORLW  02
0536:  BTFSC  03.2
0537:  GOTO   554
0538:  GOTO   55B
....................    { 
....................       case '\a'   :  lcd_gotoxy(1,1);     break; 
0539:  MOVLW  01
053A:  BSF    03.6
053B:  MOVWF  46
053C:  MOVWF  47
053D:  BCF    03.6
053E:  CALL   515
053F:  GOTO   562
....................  
....................       case '\f'   :  lcd_send_byte(0,1); 
0540:  BSF    03.6
0541:  CLRF   4A
0542:  MOVLW  01
0543:  MOVWF  4B
0544:  BCF    03.6
0545:  CALL   20B
....................                      delay_ms(2); 
0546:  MOVLW  02
0547:  BSF    03.6
0548:  MOVWF  46
0549:  BCF    03.6
054A:  CALL   16C
....................                     #if defined(LCD_EXTENDED_NEWLINE) 
....................                      g_LcdX = 0; 
....................                      g_LcdY = 0; 
....................                     #endif 
....................                      break; 
054B:  GOTO   562
....................  
....................      #if defined(LCD_EXTENDED_NEWLINE) 
....................       case '\r'   :  lcd_gotoxy(1, g_LcdY+1);   break; 
....................       case '\n'   : 
....................          while (g_LcdX++ < LCD_LINE_LENGTH) 
....................          { 
....................             lcd_send_byte(1, ' '); 
....................          } 
....................          lcd_gotoxy(1, g_LcdY+2); 
....................          break; 
....................      #else 
....................       case '\n'   : lcd_gotoxy(1,2);        break; 
054C:  MOVLW  01
054D:  BSF    03.6
054E:  MOVWF  46
054F:  MOVLW  02
0550:  MOVWF  47
0551:  BCF    03.6
0552:  CALL   515
0553:  GOTO   562
....................      #endif 
....................       
....................       case '\b'   : lcd_send_byte(0,0x10);  break; 
0554:  BSF    03.6
0555:  CLRF   4A
0556:  MOVLW  10
0557:  MOVWF  4B
0558:  BCF    03.6
0559:  CALL   20B
055A:  GOTO   562
....................       
....................      #if defined(LCD_EXTENDED_NEWLINE) 
....................       default     :  
....................          if (g_LcdX < LCD_LINE_LENGTH) 
....................          { 
....................             lcd_send_byte(1, c); 
....................             g_LcdX++; 
....................          } 
....................          break; 
....................      #else 
....................       default     : lcd_send_byte(1,c);     break; 
055B:  MOVLW  01
055C:  BSF    03.6
055D:  MOVWF  4A
055E:  MOVF   45,W
055F:  MOVWF  4B
0560:  BCF    03.6
0561:  CALL   20B
....................      #endif 
....................    } 
0562:  RETURN
.................... } 
....................   
.................... char lcd_getc(unsigned int8 x, unsigned int8 y) 
.................... { 
....................    char value; 
....................  
....................    lcd_gotoxy(x,y); 
....................    while ( bit_test(lcd_read_byte(),7) ); // wait until busy flag is low 
....................    lcd_output_rs(1); 
....................    value = lcd_read_byte(); 
....................    lcd_output_rs(0); 
....................     
....................    return(value); 
.................... } 
....................  
.................... // write a custom character to the ram 
.................... // which is 0-7 and specifies which character array we are modifying. 
.................... // ptr points to an array of 8 bytes, where each byte is the next row of 
.................... //    pixels.  only bits 0-4 are used.  the last row is the cursor row, and 
.................... //    usually you will want to leave this byte 0x00. 
.................... void lcd_set_cgram_char(unsigned int8 which, unsigned int8 *ptr) 
.................... { 
....................    unsigned int i; 
....................  
....................    which <<= 3; 
....................    which &= 0x38; 
....................  
....................    lcd_send_byte(0, 0x40 | which);  //set cgram address 
....................  
....................    for(i=0; i<8; i++) 
....................    { 
....................       lcd_send_byte(1, *ptr++); 
....................    } 
....................    
....................    #if defined(LCD_EXTENDED_NEWLINE) 
....................     lcd_gotoxy(g_LcdX+1, g_LcdY+1);  //set ddram address 
....................    #endif 
.................... } 
....................  
.................... void lcd_cursor_on(int1 on) 
.................... { 
....................    if (on) 
....................    { 
....................       lcd_send_byte(0,0x0F);           //turn LCD cursor ON 
....................    } 
....................    else 
....................    { 
....................       lcd_send_byte(0,0x0C);           //turn LCD cursor OFF 
....................    } 
.................... } 
....................  
.................... #endif 
....................  
.................... #BIT TMR1IF = 0x0C.0 //bit thu 0 (TMR1IF) cua PIR1 
....................  
.................... #INCLUDE <khaibaobien.c> // VARIABLE. 
.................... UNSIGNED INT16 KQADC; 
.................... UNSIGNED INT8 KET_QUA_ANALOG[]={0,0,0,0,0}; 
*
14E0:  CLRF   34
14E1:  CLRF   35
14E2:  CLRF   36
14E3:  CLRF   37
14E4:  CLRF   38
.................... UNSIGNED INT8 KET_QUA_ANALOG_TEMP[]={0,0,0,0,0}; 
14E5:  CLRF   39
14E6:  CLRF   3A
14E7:  CLRF   3B
14E8:  CLRF   3C
14E9:  CLRF   3D
.................... UNSIGNED INT8 CONFIG_FUN=0; 
.................... UNSIGNED INT8 VT=0, KYTU=0;// KYTU[30],  
.................... UNSIGNED INT8 LENH_DIEU_KHIEN = 0; 
.................... UNSIGNED INT8 ID_GATEWAY[6] = {3,8,6,9,0,7}; 
14EA:  MOVLW  03
14EB:  MOVWF  42
14EC:  MOVLW  08
14ED:  MOVWF  43
14EE:  MOVLW  06
14EF:  MOVWF  44
14F0:  MOVLW  09
14F1:  MOVWF  45
14F2:  CLRF   46
14F3:  MOVLW  07
14F4:  MOVWF  47
.................... UNSIGNED INT8 ID_NODE[4] = {0,1,5,2}; 
14F5:  CLRF   48
14F6:  MOVLW  01
14F7:  MOVWF  49
14F8:  MOVLW  05
14F9:  MOVWF  4A
14FA:  MOVLW  02
14FB:  MOVWF  4B
.................... UNSIGNED INT8 LEN_PACKAGES = 0; 
.................... UNSIGNED INT8 LENHDIEUKHIEN =0, DODAI_DATA_NHAN =0; 
.................... UNSIGNED INT8 SOLUONGTHIETBI_CONFIG=0, SOLUONGCAMBIEN_CONFIG = 3; 
.................... SIGNED INT8 SOSANH_IDNODE=0, SOSANH_IDGW=0; 
.................... //INT1 TT_THIETBI [8]={0,0,0,0,0,0,0,0}; 
.................... INT1 TT_THIETBI_TEMP [8]={0,0,0,0,0,0,0,0}; 
14FC:  CLRF   53
.................... INT1 TTNHAN = 0, TT_CONFIG=0, TT_CONTROL=0,TT_CONFIG_DONE=0, TT_FUN=0, TT_STT=0 , TT_CONFIG_OKE_UART = 0, TT_SW = 0,TT_SEND_ANALOG = 0; 
....................  
.................... CHAR *ID_NODE_CHAR[]= "0589"; 
14FD:  MOVLW  30
14FE:  MOVWF  58
14FF:  MOVLW  35
1500:  MOVWF  59
1501:  MOVLW  38
1502:  MOVWF  5A
1503:  MOVLW  39
1504:  MOVWF  5B
1505:  CLRF   5C
1506:  CLRF   57
1507:  MOVLW  58
1508:  MOVWF  56
.................... CHAR *ID_GATEWAY_CHAR[]= "127102"; 
1509:  MOVLW  31
150A:  MOVWF  5F
150B:  MOVLW  32
150C:  MOVWF  60
150D:  MOVLW  37
150E:  MOVWF  61
150F:  MOVLW  31
1510:  MOVWF  62
1511:  MOVLW  30
1512:  MOVWF  63
1513:  MOVLW  32
1514:  MOVWF  64
1515:  CLRF   65
1516:  CLRF   5E
1517:  MOVLW  5F
1518:  MOVWF  5D
.................... CHAR *ID_NODE_NHAN[]= "0000"; 
1519:  MOVLW  30
151A:  MOVWF  68
151B:  MOVWF  69
151C:  MOVWF  6A
151D:  MOVWF  6B
151E:  CLRF   6C
151F:  CLRF   67
1520:  MOVLW  68
1521:  MOVWF  66
.................... CHAR *ID_GW_NHAN[]= "000000"; 
1522:  MOVLW  30
1523:  MOVWF  6F
1524:  MOVWF  70
1525:  MOVWF  71
1526:  MOVWF  72
1527:  MOVWF  73
1528:  MOVWF  74
1529:  CLRF   75
152A:  CLRF   6E
152B:  MOVLW  6F
152C:  MOVWF  6D
.................... CHAR KYTUCHAR[50]="HIHI"; 
152D:  MOVLW  48
152E:  BSF    03.5
152F:  MOVWF  20
1530:  MOVLW  49
1531:  MOVWF  21
1532:  MOVLW  48
1533:  MOVWF  22
1534:  MOVLW  49
1535:  MOVWF  23
1536:  CLRF   24
.................... CHAR KYTUCHAR2[25]="HIHI"; 
1537:  MOVLW  48
1538:  MOVWF  52
1539:  MOVLW  49
153A:  MOVWF  53
153B:  MOVLW  48
153C:  MOVWF  54
153D:  MOVLW  49
153E:  MOVWF  55
153F:  CLRF   56
.................... //CHAR *DATA_NHANDUOC[]={"IDGW","IDNODE","COMMAN","DATA"}; 
.................... CHAR *TEMP_CHAR[]="0000";   
1540:  MOVLW  30
1541:  MOVWF  6B
1542:  MOVWF  6C
1543:  MOVWF  6D
1544:  MOVWF  6E
1545:  CLRF   6F
1546:  CLRF   7C
1547:  MOVLW  EB
1548:  MOVWF  7B
.................... CHAR *TEMP_CHAR2[]="2700";  
1549:  MOVLW  32
154A:  BCF    03.5
154B:  BSF    03.6
154C:  MOVWF  10
154D:  MOVLW  37
154E:  MOVWF  11
154F:  MOVLW  30
1550:  MOVWF  12
1551:  MOVWF  13
1552:  CLRF   14
1553:  MOVLW  01
1554:  MOVWF  7E
1555:  MOVLW  10
1556:  MOVWF  7D
.................... //CHAR *TEMP_CHAR3[]="000000";  
....................  
....................  
....................  
.................... //#INCLUDE <CONFIG_NODE.C> // CU HINH NODE. 
.................... #INCLUDE <config_1.C> // CU HINH NODE. 
.................... VOID READ_EEPROMP_DATA_NODE(){    
....................    FOR (int j = 0; j < 4; j++) 
*
02EC:  BSF    03.6
02ED:  CLRF   15
02EE:  MOVF   15,W
02EF:  SUBLW  03
02F0:  BTFSS  03.0
02F1:  GOTO   303
....................    { 
....................       ID_NODE[j] = read_eeprom(10+j); 
02F2:  MOVLW  48
02F3:  ADDWF  15,W
02F4:  MOVWF  04
02F5:  BCF    03.7
02F6:  MOVLW  0A
02F7:  ADDWF  15,W
02F8:  MOVWF  18
02F9:  MOVF   18,W
02FA:  MOVWF  0D
02FB:  BSF    03.5
02FC:  BCF    0C.7
02FD:  BSF    0C.0
02FE:  BCF    03.5
02FF:  MOVF   0C,W
0300:  MOVWF  00
0301:  INCF   15,F
0302:  GOTO   2EE
....................    }   
....................    FOR (j = 0; j < 6; j++) 
0303:  CLRF   15
0304:  MOVF   15,W
0305:  SUBLW  05
0306:  BTFSS  03.0
0307:  GOTO   319
....................    { 
....................       ID_GATEWAY[j] = read_eeprom(14+j); 
0308:  MOVLW  42
0309:  ADDWF  15,W
030A:  MOVWF  04
030B:  BCF    03.7
030C:  MOVLW  0E
030D:  ADDWF  15,W
030E:  MOVWF  18
030F:  MOVF   18,W
0310:  MOVWF  0D
0311:  BSF    03.5
0312:  BCF    0C.7
0313:  BSF    0C.0
0314:  BCF    03.5
0315:  MOVF   0C,W
0316:  MOVWF  00
0317:  INCF   15,F
0318:  GOTO   304
....................    }   
0319:  BCF    03.6
031A:  BCF    0A.3
031B:  BSF    0A.4
031C:  GOTO   589 (RETURN)
.................... } 
....................  
.................... //--------------------------------------------------------------------// 
.................... VOID CHON_ID() 
.................... { 
....................    // TT_CONFIG_DONE; 
....................    TT_CONFIG_DONE = 0; 
*
0893:  BCF    54.3
....................    TT_STT = 1; 
0894:  BSF    54.5
....................    UNSIGNED INT8 NUM = 0; 
0895:  BSF    03.6
0896:  CLRF   15
....................    TEMP_CHAR = "0"; 
0897:  CLRF   16
0898:  CLRF   17
0899:  MOVLW  7B
089A:  MOVWF  04
089B:  BCF    03.7
089C:  MOVF   16,W
089D:  ADDWF  04,F
089E:  MOVF   17,W
089F:  BCF    0A.3
08A0:  BCF    03.6
08A1:  CALL   058
08A2:  BSF    0A.3
08A3:  MOVWF  00
08A4:  IORLW  00
08A5:  BTFSC  03.2
08A6:  GOTO   0AC
08A7:  BSF    03.6
08A8:  INCF   17,F
08A9:  INCF   16,F
08AA:  GOTO   099
08AB:  BCF    03.6
....................    LCD_GOTOXY (1, 2) ; 
08AC:  MOVLW  01
08AD:  BSF    03.6
08AE:  MOVWF  46
08AF:  MOVLW  02
08B0:  MOVWF  47
08B1:  BCF    0A.3
08B2:  BCF    03.6
08B3:  CALL   515
08B4:  BSF    0A.3
....................    DELAY_MS (10); 
08B5:  MOVLW  0A
08B6:  BSF    03.6
08B7:  MOVWF  46
08B8:  BCF    0A.3
08B9:  BCF    03.6
08BA:  CALL   16C
08BB:  BSF    0A.3
....................    PRINTF (LCD_PUTC, "NODE: "); 
08BC:  MOVLW  84
08BD:  BSF    03.6
08BE:  MOVWF  0D
08BF:  MOVLW  00
08C0:  MOVWF  0F
08C1:  BCF    0A.3
08C2:  BCF    03.6
08C3:  CALL   563
08C4:  BSF    0A.3
....................    PRINTF (LCD_PUTC, ID_NODE_CHAR); 
08C5:  MOVLW  56
08C6:  MOVWF  04
08C7:  BCF    03.7
08C8:  BCF    0A.3
08C9:  CALL   711
08CA:  BSF    0A.3
....................    PRINTF (LCD_PUTC, "          "); 
08CB:  MOVLW  88
08CC:  BSF    03.6
08CD:  MOVWF  0D
08CE:  MOVLW  00
08CF:  MOVWF  0F
08D0:  BCF    0A.3
08D1:  BCF    03.6
08D2:  CALL   563
08D3:  BSF    0A.3
....................    LCD_GOTOXY (1, 1) ; 
08D4:  MOVLW  01
08D5:  BSF    03.6
08D6:  MOVWF  46
08D7:  MOVWF  47
08D8:  BCF    0A.3
08D9:  BCF    03.6
08DA:  CALL   515
08DB:  BSF    0A.3
....................    PRINTF (LCD_PUTC, "      _              ");//6 SPACE PHIA TRUOC "_" 
08DC:  MOVLW  8E
08DD:  BSF    03.6
08DE:  MOVWF  0D
08DF:  MOVLW  00
08E0:  MOVWF  0F
08E1:  BCF    0A.3
08E2:  BCF    03.6
08E3:  CALL   563
08E4:  BSF    0A.3
....................    //ID_GW = "1234";     
....................  
....................    WHILE (TT_STT) 
08E5:  BTFSS  54.5
08E6:  GOTO   175
....................    { 
....................       IF (!INPUT (BT2_PIN)) //NEU NUT BAM DUOC BAM 
08E7:  BSF    03.5
08E8:  BSF    06.2
08E9:  BCF    03.5
08EA:  BTFSC  06.2
08EB:  GOTO   110
....................       { 
....................           
....................          NUM++; 
08EC:  BSF    03.6
08ED:  INCF   15,F
....................          NUM = NUM % 4; 
08EE:  MOVLW  03
08EF:  ANDWF  15,F
....................          LCD_GOTOXY (3 + NUM, 1); 
08F0:  ADDWF  15,W
08F1:  MOVWF  16
08F2:  MOVWF  46
08F3:  MOVLW  01
08F4:  MOVWF  47
08F5:  BCF    0A.3
08F6:  BCF    03.6
08F7:  CALL   515
08F8:  BSF    0A.3
....................          PRINTF (LCD_PUTC, "    _    ");//4SPACE 
08F9:  MOVLW  99
08FA:  BSF    03.6
08FB:  MOVWF  0D
08FC:  MOVLW  00
08FD:  MOVWF  0F
08FE:  BCF    0A.3
08FF:  BCF    03.6
0900:  CALL   563
0901:  BSF    0A.3
....................          DELAY_MS (300);  
0902:  MOVLW  02
0903:  BSF    03.6
0904:  MOVWF  16
0905:  MOVLW  96
0906:  MOVWF  46
0907:  BCF    0A.3
0908:  BCF    03.6
0909:  CALL   16C
090A:  BSF    0A.3
090B:  BSF    03.6
090C:  DECFSZ 16,F
090D:  GOTO   105
....................       } 
090E:  GOTO   173
090F:  BCF    03.6
....................  
....................       ELSE IF (!INPUT (BT3_PIN)) 
0910:  BSF    03.5
0911:  BSF    06.3
0912:  BCF    03.5
0913:  BTFSC  06.3
0914:  GOTO   174
....................       { 
....................          ID_NODE[NUM]++; 
0915:  MOVLW  48
0916:  BSF    03.6
0917:  ADDWF  15,W
0918:  MOVWF  04
0919:  BCF    03.7
091A:  INCF   00,F
....................          ID_NODE[NUM] = ID_NODE[NUM] % 10; 
091B:  MOVLW  48
091C:  ADDWF  15,W
091D:  MOVWF  78
091E:  CLRF   7A
091F:  BTFSC  03.0
0920:  INCF   7A,F
0921:  MOVF   78,W
0922:  MOVWF  16
0923:  MOVF   7A,W
0924:  MOVWF  17
0925:  MOVLW  48
0926:  ADDWF  15,W
0927:  MOVWF  04
0928:  BCF    03.7
0929:  MOVF   00,W
092A:  MOVWF  19
092B:  MOVLW  0A
092C:  MOVWF  1A
092D:  BCF    0A.3
092E:  BCF    03.6
092F:  CALL   72E
0930:  BSF    0A.3
0931:  MOVF   77,W
0932:  BSF    03.6
0933:  MOVWF  18
0934:  MOVF   16,W
0935:  MOVWF  04
0936:  BCF    03.7
0937:  BTFSC  17.0
0938:  BSF    03.7
0939:  MOVF   18,W
093A:  MOVWF  00
....................          ITOA (ID_NODE[NUM], 10, TEMP_CHAR); 
093B:  MOVLW  48
093C:  ADDWF  15,W
093D:  MOVWF  04
093E:  BCF    03.7
093F:  MOVF   00,W
0940:  MOVWF  16
0941:  CLRF   47
0942:  CLRF   46
0943:  CLRF   45
0944:  MOVF   16,W
0945:  MOVWF  44
0946:  MOVLW  0A
0947:  MOVWF  48
0948:  CLRF   4A
0949:  MOVLW  7B
094A:  MOVWF  49
094B:  BCF    0A.3
094C:  BCF    03.6
094D:  CALL   399
094E:  BSF    0A.3
....................          LCD_GOTOXY (7 + NUM, 2); 
094F:  MOVLW  07
0950:  BSF    03.6
0951:  ADDWF  15,W
0952:  MOVWF  16
0953:  MOVWF  46
0954:  MOVLW  02
0955:  MOVWF  47
0956:  BCF    0A.3
0957:  BCF    03.6
0958:  CALL   515
0959:  BSF    0A.3
....................          DELAY_MS (10); 
095A:  MOVLW  0A
095B:  BSF    03.6
095C:  MOVWF  46
095D:  BCF    0A.3
095E:  BCF    03.6
095F:  CALL   16C
0960:  BSF    0A.3
....................          PRINTF (LCD_PUTC, TEMP_CHAR); 
0961:  MOVLW  7B
0962:  MOVWF  04
0963:  BCF    03.7
0964:  BCF    0A.3
0965:  CALL   711
0966:  BSF    0A.3
....................          DELAY_MS (300); 
0967:  MOVLW  02
0968:  BSF    03.6
0969:  MOVWF  16
096A:  MOVLW  96
096B:  MOVWF  46
096C:  BCF    0A.3
096D:  BCF    03.6
096E:  CALL   16C
096F:  BSF    0A.3
0970:  BSF    03.6
0971:  DECFSZ 16,F
0972:  GOTO   16A
0973:  BCF    03.6
....................       } 
0974:  GOTO   0E5
....................    } 
.................... } 
....................  
.................... VOID NHAPID_GW() 
*
0976:  BSF    03.6
0977:  CLRF   15
.................... { 
....................    UNSIGNED INT8 NUM = 0; 
....................    TEMP_CHAR = "0"; 
0978:  CLRF   16
0979:  CLRF   17
097A:  MOVLW  7B
097B:  MOVWF  04
097C:  BCF    03.7
097D:  MOVF   16,W
097E:  ADDWF  04,F
097F:  MOVF   17,W
0980:  BCF    0A.3
0981:  BCF    03.6
0982:  CALL   058
0983:  BSF    0A.3
0984:  MOVWF  00
0985:  IORLW  00
0986:  BTFSC  03.2
0987:  GOTO   18D
0988:  BSF    03.6
0989:  INCF   17,F
098A:  INCF   16,F
098B:  GOTO   17A
098C:  BCF    03.6
....................    TT_CONFIG_DONE = 0; 
098D:  BCF    54.3
....................    TT_STT = 1; 
098E:  BSF    54.5
....................    LCD_GOTOXY (1, 2) ; 
098F:  MOVLW  01
0990:  BSF    03.6
0991:  MOVWF  46
0992:  MOVLW  02
0993:  MOVWF  47
0994:  BCF    0A.3
0995:  BCF    03.6
0996:  CALL   515
0997:  BSF    0A.3
....................    DELAY_MS (10); 
0998:  MOVLW  0A
0999:  BSF    03.6
099A:  MOVWF  46
099B:  BCF    0A.3
099C:  BCF    03.6
099D:  CALL   16C
099E:  BSF    0A.3
....................    PRINTF (LCD_PUTC, "ID_GW:"); 
099F:  MOVLW  9E
09A0:  BSF    03.6
09A1:  MOVWF  0D
09A2:  MOVLW  00
09A3:  MOVWF  0F
09A4:  BCF    0A.3
09A5:  BCF    03.6
09A6:  CALL   563
09A7:  BSF    0A.3
....................    PRINTF (LCD_PUTC, ID_GATEWAY_CHAR); 
09A8:  MOVLW  5D
09A9:  MOVWF  04
09AA:  BCF    03.7
09AB:  BCF    0A.3
09AC:  CALL   711
09AD:  BSF    0A.3
....................    PRINTF (LCD_PUTC, "          "); 
09AE:  MOVLW  A2
09AF:  BSF    03.6
09B0:  MOVWF  0D
09B1:  MOVLW  00
09B2:  MOVWF  0F
09B3:  BCF    0A.3
09B4:  BCF    03.6
09B5:  CALL   563
09B6:  BSF    0A.3
....................    LCD_GOTOXY (1, 1) ; 
09B7:  MOVLW  01
09B8:  BSF    03.6
09B9:  MOVWF  46
09BA:  MOVWF  47
09BB:  BCF    0A.3
09BC:  BCF    03.6
09BD:  CALL   515
09BE:  BSF    0A.3
....................    PRINTF (LCD_PUTC, "      _                ");//6 SPACE PHIA TRUOC "_" 
09BF:  MOVLW  A8
09C0:  BSF    03.6
09C1:  MOVWF  0D
09C2:  MOVLW  00
09C3:  MOVWF  0F
09C4:  BCF    0A.3
09C5:  BCF    03.6
09C6:  CALL   563
09C7:  BSF    0A.3
....................    //ID_GW = "1234";     
....................  
....................    WHILE (TT_STT) 
09C8:  BTFSS  54.5
09C9:  GOTO   262
....................    { 
....................       IF (!INPUT (BT2_PIN)) //NEU NUT BAM DUOC BAM 
09CA:  BSF    03.5
09CB:  BSF    06.2
09CC:  BCF    03.5
09CD:  BTFSC  06.2
09CE:  GOTO   1FD
....................       { 
....................           
....................          NUM++; 
09CF:  BSF    03.6
09D0:  INCF   15,F
....................          NUM = NUM % 6; 
09D1:  MOVF   15,W
09D2:  MOVWF  19
09D3:  MOVLW  06
09D4:  MOVWF  1A
09D5:  BCF    0A.3
09D6:  BCF    03.6
09D7:  CALL   72E
09D8:  BSF    0A.3
09D9:  MOVF   77,W
09DA:  BSF    03.6
09DB:  MOVWF  15
....................          LCD_GOTOXY (3 + NUM, 1); 
09DC:  MOVLW  03
09DD:  ADDWF  15,W
09DE:  MOVWF  16
09DF:  MOVWF  46
09E0:  MOVLW  01
09E1:  MOVWF  47
09E2:  BCF    0A.3
09E3:  BCF    03.6
09E4:  CALL   515
09E5:  BSF    0A.3
....................          PRINTF (LCD_PUTC, "    _        ");//4SPACE 
09E6:  MOVLW  B4
09E7:  BSF    03.6
09E8:  MOVWF  0D
09E9:  MOVLW  00
09EA:  MOVWF  0F
09EB:  BCF    0A.3
09EC:  BCF    03.6
09ED:  CALL   563
09EE:  BSF    0A.3
....................          DELAY_MS (300);  
09EF:  MOVLW  02
09F0:  BSF    03.6
09F1:  MOVWF  16
09F2:  MOVLW  96
09F3:  MOVWF  46
09F4:  BCF    0A.3
09F5:  BCF    03.6
09F6:  CALL   16C
09F7:  BSF    0A.3
09F8:  BSF    03.6
09F9:  DECFSZ 16,F
09FA:  GOTO   1F2
....................       } 
09FB:  GOTO   260
09FC:  BCF    03.6
....................  
....................       ELSE IF (!INPUT (BT3_PIN)) 
09FD:  BSF    03.5
09FE:  BSF    06.3
09FF:  BCF    03.5
0A00:  BTFSC  06.3
0A01:  GOTO   261
....................       { 
....................          ID_GATEWAY[NUM]++; 
0A02:  MOVLW  42
0A03:  BSF    03.6
0A04:  ADDWF  15,W
0A05:  MOVWF  04
0A06:  BCF    03.7
0A07:  INCF   00,F
....................          ID_GATEWAY[NUM] = ID_GATEWAY[NUM] % 10; 
0A08:  MOVLW  42
0A09:  ADDWF  15,W
0A0A:  MOVWF  78
0A0B:  CLRF   7A
0A0C:  BTFSC  03.0
0A0D:  INCF   7A,F
0A0E:  MOVF   78,W
0A0F:  MOVWF  16
0A10:  MOVF   7A,W
0A11:  MOVWF  17
0A12:  MOVLW  42
0A13:  ADDWF  15,W
0A14:  MOVWF  04
0A15:  BCF    03.7
0A16:  MOVF   00,W
0A17:  MOVWF  19
0A18:  MOVLW  0A
0A19:  MOVWF  1A
0A1A:  BCF    0A.3
0A1B:  BCF    03.6
0A1C:  CALL   72E
0A1D:  BSF    0A.3
0A1E:  MOVF   77,W
0A1F:  BSF    03.6
0A20:  MOVWF  18
0A21:  MOVF   16,W
0A22:  MOVWF  04
0A23:  BCF    03.7
0A24:  BTFSC  17.0
0A25:  BSF    03.7
0A26:  MOVF   18,W
0A27:  MOVWF  00
....................          ITOA (ID_GATEWAY[NUM], 10, TEMP_CHAR); 
0A28:  MOVLW  42
0A29:  ADDWF  15,W
0A2A:  MOVWF  04
0A2B:  BCF    03.7
0A2C:  MOVF   00,W
0A2D:  MOVWF  16
0A2E:  CLRF   47
0A2F:  CLRF   46
0A30:  CLRF   45
0A31:  MOVF   16,W
0A32:  MOVWF  44
0A33:  MOVLW  0A
0A34:  MOVWF  48
0A35:  CLRF   4A
0A36:  MOVLW  7B
0A37:  MOVWF  49
0A38:  BCF    0A.3
0A39:  BCF    03.6
0A3A:  CALL   399
0A3B:  BSF    0A.3
....................          LCD_GOTOXY (7 + NUM, 2); 
0A3C:  MOVLW  07
0A3D:  BSF    03.6
0A3E:  ADDWF  15,W
0A3F:  MOVWF  16
0A40:  MOVWF  46
0A41:  MOVLW  02
0A42:  MOVWF  47
0A43:  BCF    0A.3
0A44:  BCF    03.6
0A45:  CALL   515
0A46:  BSF    0A.3
....................          DELAY_MS (10); 
0A47:  MOVLW  0A
0A48:  BSF    03.6
0A49:  MOVWF  46
0A4A:  BCF    0A.3
0A4B:  BCF    03.6
0A4C:  CALL   16C
0A4D:  BSF    0A.3
....................          PRINTF (LCD_PUTC, TEMP_CHAR); 
0A4E:  MOVLW  7B
0A4F:  MOVWF  04
0A50:  BCF    03.7
0A51:  BCF    0A.3
0A52:  CALL   711
0A53:  BSF    0A.3
....................          DELAY_MS (300); 
0A54:  MOVLW  02
0A55:  BSF    03.6
0A56:  MOVWF  16
0A57:  MOVLW  96
0A58:  MOVWF  46
0A59:  BCF    0A.3
0A5A:  BCF    03.6
0A5B:  CALL   16C
0A5C:  BSF    0A.3
0A5D:  BSF    03.6
0A5E:  DECFSZ 16,F
0A5F:  GOTO   257
0A60:  BCF    03.6
....................       } 
0A61:  GOTO   1C8
....................    } 
.................... } 
....................  
.................... VOID BUTT_OKE() 
.................... { 
....................    TT_CONFIG_DONE = 0; 
*
013C:  BCF    03.6
013D:  BCF    54.3
....................    TT_FUN = 0;//BREAK WHILE BUTT_FUN 
013E:  BCF    54.4
....................    TT_STT = 0;// BREAK WHILE CHONID/NHAPID_GW 
013F:  BCF    54.5
.................... } 
....................  
.................... VOID SELLECT_FUN() 
.................... { 
....................    TT_CONFIG_DONE = 0; 
*
088B:  BCF    54.3
....................  
....................    SWITCH (CONFIG_FUN) 
088C:  MOVF   3E,W
088D:  BTFSC  03.2
088E:  GOTO   093
088F:  XORLW  01
0890:  BTFSC  03.2
0891:  GOTO   176
0892:  GOTO   262
....................    { 
....................       CASE 0: 
....................       CHON_ID (); 
....................       BREAK; 
*
0975:  GOTO   262
....................  
....................       CASE 1:     
....................       NHAPID_GW (); 
....................       BREAK; 
....................    } 
.................... } 
....................  
.................... VOID BUTT_FUN() 
.................... { 
....................    TT_FUN = 1; 
*
0800:  BSF    54.4
....................    LCD_GOTOXY (1, 1) ; 
0801:  MOVLW  01
0802:  BSF    03.6
0803:  MOVWF  46
0804:  MOVWF  47
0805:  BCF    0A.3
0806:  BCF    03.6
0807:  CALL   515
0808:  BSF    0A.3
....................    DELAY_MS (10); 
0809:  MOVLW  0A
080A:  BSF    03.6
080B:  MOVWF  46
080C:  BCF    0A.3
080D:  BCF    03.6
080E:  CALL   16C
080F:  BSF    0A.3
....................    PRINTF (LCD_PUTC, "CONFIG:        "); 
0810:  MOVLW  BB
0811:  BSF    03.6
0812:  MOVWF  0D
0813:  MOVLW  00
0814:  MOVWF  0F
0815:  BCF    0A.3
0816:  BCF    03.6
0817:  CALL   563
0818:  BSF    0A.3
....................  
....................    // HIEN THI LCD 
....................    LCD_GOTOXY (1, 2) ; 
0819:  MOVLW  01
081A:  BSF    03.6
081B:  MOVWF  46
081C:  MOVLW  02
081D:  MOVWF  47
081E:  BCF    0A.3
081F:  BCF    03.6
0820:  CALL   515
0821:  BSF    0A.3
....................    DELAY_MS (10); 
0822:  MOVLW  0A
0823:  BSF    03.6
0824:  MOVWF  46
0825:  BCF    0A.3
0826:  BCF    03.6
0827:  CALL   16C
0828:  BSF    0A.3
....................    PRINTF (LCD_PUTC, "CASE:          ") ; 
0829:  MOVLW  C3
082A:  BSF    03.6
082B:  MOVWF  0D
082C:  MOVLW  00
082D:  MOVWF  0F
082E:  BCF    0A.3
082F:  BCF    03.6
0830:  CALL   563
0831:  BSF    0A.3
....................  
....................    WHILE (TT_FUN) 
0832:  BTFSS  54.4
0833:  GOTO   089
....................    { 
....................       IF (INPUT (BT2_PIN) == 0) //NEU NUT BAM DUOC BAM 
0834:  BSF    03.5
0835:  BSF    06.2
0836:  BCF    03.5
0837:  BTFSC  06.2
0838:  GOTO   088
....................       { 
....................          CONFIG_FUN ++; 
0839:  INCF   3E,F
....................          CONFIG_FUN = CONFIG_FUN % 2; 
083A:  MOVLW  01
083B:  ANDWF  3E,F
....................          DELAY_MS (300); 
083C:  MOVLW  02
083D:  BSF    03.6
083E:  MOVWF  15
083F:  MOVLW  96
0840:  MOVWF  46
0841:  BCF    0A.3
0842:  BCF    03.6
0843:  CALL   16C
0844:  BSF    0A.3
0845:  BSF    03.6
0846:  DECFSZ 15,F
0847:  GOTO   03F
....................          //HIEN THI 
....................          LCD_GOTOXY (6, 2) ; 
0848:  MOVLW  06
0849:  MOVWF  46
084A:  MOVLW  02
084B:  MOVWF  47
084C:  BCF    0A.3
084D:  BCF    03.6
084E:  CALL   515
084F:  BSF    0A.3
....................          ITOA (CONFIG_FUN, 10, TEMP_CHAR); 
0850:  BSF    03.6
0851:  CLRF   47
0852:  CLRF   46
0853:  CLRF   45
0854:  BCF    03.6
0855:  MOVF   3E,W
0856:  BSF    03.6
0857:  MOVWF  44
0858:  MOVLW  0A
0859:  MOVWF  48
085A:  CLRF   4A
085B:  MOVLW  7B
085C:  MOVWF  49
085D:  BCF    0A.3
085E:  BCF    03.6
085F:  CALL   399
0860:  BSF    0A.3
....................          DELAY_MS (10); 
0861:  MOVLW  0A
0862:  BSF    03.6
0863:  MOVWF  46
0864:  BCF    0A.3
0865:  BCF    03.6
0866:  CALL   16C
0867:  BSF    0A.3
....................          PRINTF (LCD_PUTC, TEMP_CHAR); 
0868:  MOVLW  7B
0869:  MOVWF  04
086A:  BCF    03.7
086B:  BCF    0A.3
086C:  CALL   711
086D:  BSF    0A.3
....................  
....................          SWITCH (CONFIG_FUN) 
086E:  MOVF   3E,W
086F:  BTFSC  03.2
0870:  GOTO   075
0871:  XORLW  01
0872:  BTFSC  03.2
0873:  GOTO   07F
0874:  GOTO   088
....................          { 
....................             CASE 0: 
....................             PRINTF (LCD_PUTC, " - ID-NODE      "); 
0875:  MOVLW  CB
0876:  BSF    03.6
0877:  MOVWF  0D
0878:  MOVLW  00
0879:  MOVWF  0F
087A:  BCF    0A.3
087B:  BCF    03.6
087C:  CALL   563
087D:  BSF    0A.3
....................             BREAK; 
087E:  GOTO   088
....................  
....................             CASE 1: 
....................             PRINTF (LCD_PUTC, " - ID-GW       "); 
087F:  MOVLW  D4
0880:  BSF    03.6
0881:  MOVWF  0D
0882:  MOVLW  00
0883:  MOVWF  0F
0884:  BCF    0A.3
0885:  BCF    03.6
0886:  CALL   563
0887:  BSF    0A.3
....................             BREAK;             
....................          } 
....................       } 
0888:  GOTO   032
....................    } 
....................  
....................    ////// 
....................    IF (!TT_CONFIG_DONE) 
0889:  BTFSC  54.3
088A:  GOTO   262
....................    { 
....................       SELLECT_FUN (); 
....................    } 
*
0A62:  BCF    0A.3
0A63:  BSF    0A.4
0A64:  GOTO   592 (RETURN)
.................... } 
.................... VOID XULY_IDNODE_NHAP(){ 
....................    //*TEMP_CHAR3 = "\0"; 
....................    *ID_NODE_CHAR = "\0"; 
*
0660:  CLRF   7A
0661:  MOVLW  56
0662:  MOVWF  43
0663:  MOVF   7A,W
0664:  MOVWF  44
0665:  MOVF   43,W
0666:  MOVWF  04
0667:  BCF    03.7
0668:  BTFSC  44.0
0669:  BSF    03.7
066A:  CLRF   00
....................    FOR (int j = 0; j < 4; j++) 
066B:  CLRF   42
066C:  MOVF   42,W
066D:  SUBLW  03
066E:  BTFSS  03.0
066F:  GOTO   6B5
....................    { 
....................       write_eeprom(10+j, ID_NODE[j]); 
0670:  MOVLW  0A
0671:  ADDWF  42,W
0672:  MOVWF  43
0673:  MOVLW  48
0674:  ADDWF  42,W
0675:  MOVWF  04
0676:  BCF    03.7
0677:  MOVF   00,W
0678:  MOVWF  44
0679:  BCF    03.6
067A:  MOVF   0B,W
067B:  MOVWF  77
067C:  BCF    0B.7
067D:  BSF    03.6
067E:  MOVF   43,W
067F:  MOVWF  0D
0680:  MOVF   44,W
0681:  MOVWF  0C
0682:  BSF    03.5
0683:  BCF    0C.7
0684:  BSF    0C.2
0685:  MOVLW  55
0686:  MOVWF  0D
0687:  MOVLW  AA
0688:  MOVWF  0D
0689:  BSF    0C.1
068A:  BTFSC  0C.1
068B:  GOTO   68A
068C:  BCF    0C.2
068D:  MOVF   77,W
068E:  BCF    03.5
068F:  BCF    03.6
0690:  IORWF  0B,F
....................       ITOA (ID_NODE[j], 10, TEMP_CHAR); 
0691:  MOVLW  48
0692:  BSF    03.6
0693:  ADDWF  42,W
0694:  MOVWF  04
0695:  BCF    03.7
0696:  MOVF   00,W
0697:  MOVWF  43
0698:  CLRF   47
0699:  CLRF   46
069A:  CLRF   45
069B:  MOVF   43,W
069C:  MOVWF  44
069D:  MOVLW  0A
069E:  MOVWF  48
069F:  CLRF   4A
06A0:  MOVLW  7B
06A1:  MOVWF  49
06A2:  BCF    03.6
06A3:  CALL   399
....................       DELAY_MS (1); 
06A4:  MOVLW  01
06A5:  BSF    03.6
06A6:  MOVWF  46
06A7:  BCF    03.6
06A8:  CALL   16C
....................       STRCAT (ID_NODE_CHAR, TEMP_CHAR); 
06A9:  BSF    03.6
06AA:  CLRF   44
06AB:  MOVLW  56
06AC:  MOVWF  43
06AD:  CLRF   46
06AE:  MOVLW  7B
06AF:  MOVWF  45
06B0:  BCF    03.6
06B1:  CALL   4B9
06B2:  BSF    03.6
06B3:  INCF   42,F
06B4:  GOTO   66C
....................    }   
....................    //ID_NODE_CHAR = TEMP_CHAR3;    
....................    //STRCPY(ID_NODE_CHAR,TEMP_CHAR3); 
....................    //strcpy 
.................... } 
.................... VOID XULY_IDGW_NHAP(){ 
....................  
....................    *ID_GATEWAY_CHAR = "\0"; 
*
0608:  CLRF   7A
0609:  MOVLW  5D
060A:  MOVWF  43
060B:  MOVF   7A,W
060C:  MOVWF  44
060D:  MOVF   43,W
060E:  MOVWF  04
060F:  BCF    03.7
0610:  BTFSC  44.0
0611:  BSF    03.7
0612:  CLRF   00
....................    FOR (int j = 0; j < 6; j++) 
0613:  CLRF   42
0614:  MOVF   42,W
0615:  SUBLW  05
0616:  BTFSS  03.0
0617:  GOTO   65D
....................    { 
....................       write_eeprom(14+j, ID_GATEWAY[j]); 
0618:  MOVLW  0E
0619:  ADDWF  42,W
061A:  MOVWF  43
061B:  MOVLW  42
061C:  ADDWF  42,W
061D:  MOVWF  04
061E:  BCF    03.7
061F:  MOVF   00,W
0620:  MOVWF  44
0621:  BCF    03.6
0622:  MOVF   0B,W
0623:  MOVWF  77
0624:  BCF    0B.7
0625:  BSF    03.6
0626:  MOVF   43,W
0627:  MOVWF  0D
0628:  MOVF   44,W
0629:  MOVWF  0C
062A:  BSF    03.5
062B:  BCF    0C.7
062C:  BSF    0C.2
062D:  MOVLW  55
062E:  MOVWF  0D
062F:  MOVLW  AA
0630:  MOVWF  0D
0631:  BSF    0C.1
0632:  BTFSC  0C.1
0633:  GOTO   632
0634:  BCF    0C.2
0635:  MOVF   77,W
0636:  BCF    03.5
0637:  BCF    03.6
0638:  IORWF  0B,F
....................       ITOA (ID_GATEWAY[j], 10, TEMP_CHAR); 
0639:  MOVLW  42
063A:  BSF    03.6
063B:  ADDWF  42,W
063C:  MOVWF  04
063D:  BCF    03.7
063E:  MOVF   00,W
063F:  MOVWF  43
0640:  CLRF   47
0641:  CLRF   46
0642:  CLRF   45
0643:  MOVF   43,W
0644:  MOVWF  44
0645:  MOVLW  0A
0646:  MOVWF  48
0647:  CLRF   4A
0648:  MOVLW  7B
0649:  MOVWF  49
064A:  BCF    03.6
064B:  CALL   399
....................       DELAY_MS (1); 
064C:  MOVLW  01
064D:  BSF    03.6
064E:  MOVWF  46
064F:  BCF    03.6
0650:  CALL   16C
....................       STRCAT (ID_GATEWAY_CHAR, TEMP_CHAR); 
0651:  BSF    03.6
0652:  CLRF   44
0653:  MOVLW  5D
0654:  MOVWF  43
0655:  CLRF   46
0656:  MOVLW  7B
0657:  MOVWF  45
0658:  BCF    03.6
0659:  CALL   4B9
065A:  BSF    03.6
065B:  INCF   42,F
065C:  GOTO   614
....................    }   
.................... } 
....................  
....................  
.................... VOID CONFIG_DONE() 
.................... { 
....................    TT_FUN = 0; 
*
05B3:  BCF    54.4
....................    TT_STT = 0; 
05B4:  BCF    54.5
....................    CHAR *PACKAGE_CONFIG[]={"*", "LENGHT","CF", "ID_GW1234" ,"ID_NODE","#"}; 
05B5:  MOVLW  2A
05B6:  BSF    03.6
05B7:  MOVWF  21
05B8:  CLRF   22
05B9:  MOVLW  4C
05BA:  MOVWF  23
05BB:  MOVLW  45
05BC:  MOVWF  24
05BD:  MOVLW  4E
05BE:  MOVWF  25
05BF:  MOVLW  47
05C0:  MOVWF  26
05C1:  MOVLW  48
05C2:  MOVWF  27
05C3:  MOVLW  54
05C4:  MOVWF  28
05C5:  CLRF   29
05C6:  MOVLW  43
05C7:  MOVWF  2A
05C8:  MOVLW  46
05C9:  MOVWF  2B
05CA:  CLRF   2C
05CB:  MOVLW  49
05CC:  MOVWF  2D
05CD:  MOVLW  44
05CE:  MOVWF  2E
05CF:  MOVLW  5F
05D0:  MOVWF  2F
05D1:  MOVLW  47
05D2:  MOVWF  30
05D3:  MOVLW  57
05D4:  MOVWF  31
05D5:  MOVLW  31
05D6:  MOVWF  32
05D7:  MOVLW  32
05D8:  MOVWF  33
05D9:  MOVLW  33
05DA:  MOVWF  34
05DB:  MOVLW  34
05DC:  MOVWF  35
05DD:  CLRF   36
05DE:  MOVLW  49
05DF:  MOVWF  37
05E0:  MOVLW  44
05E1:  MOVWF  38
05E2:  MOVLW  5F
05E3:  MOVWF  39
05E4:  MOVLW  4E
05E5:  MOVWF  3A
05E6:  MOVLW  4F
05E7:  MOVWF  3B
05E8:  MOVLW  44
05E9:  MOVWF  3C
05EA:  MOVLW  45
05EB:  MOVWF  3D
05EC:  CLRF   3E
05ED:  MOVLW  23
05EE:  MOVWF  3F
05EF:  CLRF   40
05F0:  MOVLW  01
05F1:  MOVWF  16
05F2:  MOVLW  21
05F3:  MOVWF  15
05F4:  MOVLW  01
05F5:  MOVWF  18
05F6:  MOVLW  23
05F7:  MOVWF  17
05F8:  MOVLW  01
05F9:  MOVWF  1A
05FA:  MOVLW  2A
05FB:  MOVWF  19
05FC:  MOVLW  01
05FD:  MOVWF  1C
05FE:  MOVLW  2D
05FF:  MOVWF  1B
0600:  MOVLW  01
0601:  MOVWF  1E
0602:  MOVLW  37
0603:  MOVWF  1D
0604:  MOVLW  01
0605:  MOVWF  20
0606:  MOVLW  3F
0607:  MOVWF  1F
....................    XULY_IDGW_NHAP(); 
....................    PACKAGE_CONFIG[3] = ID_GATEWAY_CHAR; 
*
065D:  CLRF   1C
065E:  MOVLW  5D
065F:  MOVWF  1B
....................     
....................     
....................    XULY_IDNODE_NHAP(); 
....................  
....................    PACKAGE_CONFIG[4] = ID_NODE_CHAR;     
*
06B5:  CLRF   1E
06B6:  MOVLW  56
06B7:  MOVWF  1D
....................       /*     
....................    LEN_PACKAGES = 0; 
....................    PACKAGE_CONFIG[1] = "12"; //DO DAI CUA LENGHT CO DO DAI = 2 
....................    FOR (int J = 0; J < 5; J++) 
....................    { 
....................       LEN_PACKAGES += strlen(PACKAGE_CONFIG[J]); 
....................    }    
....................    */ 
....................    LEN_PACKAGES = 20; //5 @ 
06B8:  MOVLW  14
06B9:  BCF    03.6
06BA:  MOVWF  4C
....................    ITOA (LEN_PACKAGES, 10, TEMP_CHAR); 
06BB:  BSF    03.6
06BC:  CLRF   47
06BD:  CLRF   46
06BE:  CLRF   45
06BF:  BCF    03.6
06C0:  MOVF   4C,W
06C1:  BSF    03.6
06C2:  MOVWF  44
06C3:  MOVLW  0A
06C4:  MOVWF  48
06C5:  CLRF   4A
06C6:  MOVLW  7B
06C7:  MOVWF  49
06C8:  BCF    03.6
06C9:  CALL   399
....................     
....................    PACKAGE_CONFIG[1] = TEMP_CHAR; 
06CA:  BSF    03.6
06CB:  CLRF   18
06CC:  MOVLW  7B
06CD:  MOVWF  17
....................     
....................    FOR (INT J = 0; J < 6; J++) 
06CE:  CLRF   41
06CF:  MOVF   41,W
06D0:  SUBLW  05
06D1:  BTFSS  03.0
06D2:  GOTO   6EB
....................    { 
....................       PRINTF (PACKAGE_CONFIG[J]); 
06D3:  BCF    03.0
06D4:  RLF    41,W
06D5:  ADDLW  15
06D6:  MOVWF  04
06D7:  BSF    03.7
06D8:  INCF   04,F
06D9:  MOVF   00,W
06DA:  MOVWF  43
06DB:  DECF   04,F
06DC:  MOVF   00,W
06DD:  MOVWF  42
06DE:  MOVWF  04
06DF:  BCF    03.7
06E0:  BTFSC  43.0
06E1:  BSF    03.7
06E2:  BCF    03.6
06E3:  CALL   4F7
....................       PRINTF ("@"); 
06E4:  MOVLW  40
06E5:  BTFSS  0C.4
06E6:  GOTO   6E5
06E7:  MOVWF  19
06E8:  BSF    03.6
06E9:  INCF   41,F
06EA:  GOTO   6CF
....................    } 
....................  
....................  
....................    LCD_GOTOXY (1, 1) ; 
06EB:  MOVLW  01
06EC:  MOVWF  46
06ED:  MOVWF  47
06EE:  BCF    03.6
06EF:  CALL   515
....................    DELAY_MS (10); 
06F0:  MOVLW  0A
06F1:  BSF    03.6
06F2:  MOVWF  46
06F3:  BCF    03.6
06F4:  CALL   16C
....................    PRINTF (LCD_PUTC, "WAITING ....        ") ; 
06F5:  MOVLW  DC
06F6:  BSF    03.6
06F7:  MOVWF  0D
06F8:  MOVLW  00
06F9:  MOVWF  0F
06FA:  BCF    03.6
06FB:  CALL   563
....................    LCD_GOTOXY (1, 2) ; 
06FC:  MOVLW  01
06FD:  BSF    03.6
06FE:  MOVWF  46
06FF:  MOVLW  02
0700:  MOVWF  47
0701:  BCF    03.6
0702:  CALL   515
....................    DELAY_MS (10); 
0703:  MOVLW  0A
0704:  BSF    03.6
0705:  MOVWF  46
0706:  BCF    03.6
0707:  CALL   16C
....................    PRINTF (LCD_PUTC, "WAITING ....        ") ;    
0708:  MOVLW  E7
0709:  BSF    03.6
070A:  MOVWF  0D
070B:  MOVLW  00
070C:  MOVWF  0F
070D:  BCF    03.6
070E:  CALL   563
....................    TT_CONFIG_DONE = 0; 
070F:  BCF    54.3
0710:  RETURN
.................... } 
....................  
....................  
....................  VOID XACNHANCONFIG() 
....................  {    
....................    KYTU=0;          
*
1135:  CLRF   40
....................    LCD_GOTOXY (1, 1) ; 
1136:  MOVLW  01
1137:  BSF    03.6
1138:  MOVWF  46
1139:  MOVWF  47
113A:  BCF    0A.4
113B:  BCF    03.6
113C:  CALL   515
113D:  BSF    0A.4
....................    DELAY_MS (10); 
113E:  MOVLW  0A
113F:  BSF    03.6
1140:  MOVWF  46
1141:  BCF    0A.4
1142:  BCF    03.6
1143:  CALL   16C
1144:  BSF    0A.4
....................    TEMP_CHAR = "_"; 
1145:  BSF    03.6
1146:  CLRF   1D
1147:  CLRF   1E
1148:  MOVLW  7B
1149:  MOVWF  04
114A:  BCF    03.7
114B:  MOVF   1D,W
114C:  ADDWF  04,F
114D:  MOVF   1E,W
114E:  BCF    0A.4
114F:  BCF    03.6
1150:  CALL   05E
1151:  BSF    0A.4
1152:  MOVWF  00
1153:  IORLW  00
1154:  BTFSC  03.2
1155:  GOTO   15B
1156:  BSF    03.6
1157:  INCF   1E,F
1158:  INCF   1D,F
1159:  GOTO   148
115A:  BCF    03.6
....................    CHAR * TOKEN; 
....................    TOKEN = STRTOK (KYTUCHAR2, TEMP_CHAR);    
115B:  BSF    03.6
115C:  CLRF   1E
115D:  MOVLW  D2
115E:  MOVWF  1D
115F:  CLRF   20
1160:  MOVLW  7B
1161:  MOVWF  1F
1162:  BCF    0A.4
1163:  BSF    0A.3
1164:  BCF    03.6
1165:  CALL   265
1166:  BSF    0A.4
1167:  BCF    0A.3
1168:  MOVF   79,W
1169:  BSF    03.6
116A:  MOVWF  1C
116B:  MOVF   78,W
116C:  MOVWF  1B
....................     WHILE (TOKEN != NULL) 
116D:  MOVF   1B,F
116E:  BTFSS  03.2
116F:  GOTO   173
1170:  MOVF   1C,F
1171:  BTFSC  03.2
1172:  GOTO   1C8
....................     {                 
....................        SWITCH(KYTU) 
1173:  BCF    03.6
1174:  MOVF   40,W
1175:  BTFSC  03.2
1176:  GOTO   17E
1177:  XORLW  01
1178:  BTFSC  03.2
1179:  GOTO   198
117A:  XORLW  03
117B:  BTFSC  03.2
117C:  GOTO   1A6
117D:  GOTO   1B3
....................        { 
....................          CASE 0: 
....................          DELAY_MS (1); 
117E:  MOVLW  01
117F:  BSF    03.6
1180:  MOVWF  46
1181:  BCF    0A.4
1182:  BCF    03.6
1183:  CALL   16C
1184:  BSF    0A.4
....................          PRINTF (LCD_PUTC,TOKEN); 
1185:  BSF    03.6
1186:  MOVF   1B,W
1187:  MOVWF  04
1188:  BCF    03.7
1189:  BTFSC  1C.0
118A:  BSF    03.7
118B:  BCF    0A.4
118C:  BCF    03.6
118D:  CALL   711
118E:  BSF    0A.4
....................          PRINTF (LCD_PUTC,"            "); 
118F:  MOVLW  F2
1190:  BSF    03.6
1191:  MOVWF  0D
1192:  MOVLW  00
1193:  MOVWF  0F
1194:  BCF    0A.4
1195:  BCF    03.6
1196:  CALL   563
1197:  BSF    0A.4
....................          CASE 1:  
....................          SOLUONGTHIETBI_CONFIG = ATOI(TOKEN); 
1198:  BSF    03.6
1199:  MOVF   1C,W
119A:  MOVWF  1E
119B:  MOVF   1B,W
119C:  MOVWF  1D
119D:  BCF    0A.4
119E:  BSF    0A.3
119F:  BCF    03.6
11A0:  CALL   356
11A1:  BSF    0A.4
11A2:  BCF    0A.3
11A3:  MOVF   78,W
11A4:  MOVWF  4F
....................          BREAK;                      
11A5:  GOTO   1B3
....................          CASE 2: 
....................          SOLUONGCAMBIEN_CONFIG = ATOI(TOKEN); 
11A6:  BSF    03.6
11A7:  MOVF   1C,W
11A8:  MOVWF  1E
11A9:  MOVF   1B,W
11AA:  MOVWF  1D
11AB:  BCF    0A.4
11AC:  BSF    0A.3
11AD:  BCF    03.6
11AE:  CALL   356
11AF:  BSF    0A.4
11B0:  BCF    0A.3
11B1:  MOVF   78,W
11B2:  MOVWF  50
....................          BREAK;               
....................        }  
....................       TOKEN = STRTOK(NULL, TEMP_CHAR); 
11B3:  BSF    03.6
11B4:  CLRF   1E
11B5:  CLRF   1D
11B6:  CLRF   20
11B7:  MOVLW  7B
11B8:  MOVWF  1F
11B9:  BCF    0A.4
11BA:  BSF    0A.3
11BB:  BCF    03.6
11BC:  CALL   265
11BD:  BSF    0A.4
11BE:  BCF    0A.3
11BF:  MOVF   79,W
11C0:  BSF    03.6
11C1:  MOVWF  1C
11C2:  MOVF   78,W
11C3:  MOVWF  1B
....................       KYTU++;         
11C4:  BCF    03.6
11C5:  INCF   40,F
11C6:  BSF    03.6
11C7:  GOTO   16D
....................     }           
....................    DELAY_MS (1);       
11C8:  MOVLW  01
11C9:  MOVWF  46
11CA:  BCF    0A.4
11CB:  BCF    03.6
11CC:  CALL   16C
11CD:  BSF    0A.4
....................    LCD_GOTOXY (1, 2) ; 
11CE:  MOVLW  01
11CF:  BSF    03.6
11D0:  MOVWF  46
11D1:  MOVLW  02
11D2:  MOVWF  47
11D3:  BCF    0A.4
11D4:  BCF    03.6
11D5:  CALL   515
11D6:  BSF    0A.4
....................    DELAY_MS (10); 
11D7:  MOVLW  0A
11D8:  BSF    03.6
11D9:  MOVWF  46
11DA:  BCF    0A.4
11DB:  BCF    03.6
11DC:  CALL   16C
11DD:  BSF    0A.4
....................    PRINTF (LCD_PUTC,"TB: ");    
11DE:  MOVLW  F9
11DF:  BSF    03.6
11E0:  MOVWF  0D
11E1:  MOVLW  00
11E2:  MOVWF  0F
11E3:  BCF    0A.4
11E4:  BCF    03.6
11E5:  CALL   563
11E6:  BSF    0A.4
....................    ITOA (SOLUONGTHIETBI_CONFIG, 10, TEMP_CHAR);    
11E7:  BSF    03.6
11E8:  CLRF   47
11E9:  CLRF   46
11EA:  CLRF   45
11EB:  BCF    03.6
11EC:  MOVF   4F,W
11ED:  BSF    03.6
11EE:  MOVWF  44
11EF:  MOVLW  0A
11F0:  MOVWF  48
11F1:  CLRF   4A
11F2:  MOVLW  7B
11F3:  MOVWF  49
11F4:  BCF    0A.4
11F5:  BCF    03.6
11F6:  CALL   399
11F7:  BSF    0A.4
....................    PRINTF (LCD_PUTC,TEMP_CHAR);    
11F8:  MOVLW  7B
11F9:  MOVWF  04
11FA:  BCF    03.7
11FB:  BCF    0A.4
11FC:  CALL   711
11FD:  BSF    0A.4
....................    PRINTF (LCD_PUTC,"    CB:");    
11FE:  MOVLW  FC
11FF:  BSF    03.6
1200:  MOVWF  0D
1201:  MOVLW  00
1202:  MOVWF  0F
1203:  BCF    0A.4
1204:  BCF    03.6
1205:  CALL   563
1206:  BSF    0A.4
....................    ITOA (SOLUONGCAMBIEN_CONFIG, 10, TEMP_CHAR);    
1207:  BSF    03.6
1208:  CLRF   47
1209:  CLRF   46
120A:  CLRF   45
120B:  BCF    03.6
120C:  MOVF   50,W
120D:  BSF    03.6
120E:  MOVWF  44
120F:  MOVLW  0A
1210:  MOVWF  48
1211:  CLRF   4A
1212:  MOVLW  7B
1213:  MOVWF  49
1214:  BCF    0A.4
1215:  BCF    03.6
1216:  CALL   399
1217:  BSF    0A.4
....................    PRINTF (LCD_PUTC,TEMP_CHAR);       
1218:  MOVLW  7B
1219:  MOVWF  04
121A:  BCF    03.7
121B:  BCF    0A.4
121C:  CALL   711
121D:  BSF    0A.4
....................    TT_CONFIG_OKE_UART = 1; 
121E:  BSF    54.6
....................     
....................  }  
.................... //--------------------------------------------------------------------// 
....................  
.................... #INCLUDE <DIEU_KHIEN.C> 
.................... VOID READ_BTN_STATE() 
*
0E13:  BSF    03.6
0E14:  CLRF   15
0E15:  MOVLW  34
0E16:  MOVWF  16
.................... { 
....................     
....................    INT TB = 0; 
....................    INT ID_TB =52; 
....................    FOR (TB = 0; TB < SOLUONGTHIETBI_CONFIG; TB++) 
0E17:  CLRF   15
0E18:  BCF    03.6
0E19:  MOVF   4F,W
0E1A:  BSF    03.6
0E1B:  SUBWF  15,W
0E1C:  BTFSC  03.0
0E1D:  GOTO   660
....................    {   IF (TB>3) ID_TB = 64; 
0E1E:  MOVF   15,W
0E1F:  SUBLW  03
0E20:  BTFSC  03.0
0E21:  GOTO   624
0E22:  MOVLW  40
0E23:  MOVWF  16
....................        IF (!INPUT (ID_TB + TB)) 
0E24:  MOVF   15,W
0E25:  ADDWF  16,W
0E26:  MOVWF  17
0E27:  MOVWF  1E
0E28:  MOVLW  01
0E29:  MOVWF  1F
0E2A:  CLRF   21
0E2B:  MOVLW  80
0E2C:  MOVWF  20
0E2D:  BCF    0A.3
0E2E:  BCF    03.6
0E2F:  CALL   7B2
0E30:  BSF    0A.3
0E31:  BSF    03.6
0E32:  MOVF   17,W
0E33:  MOVWF  21
0E34:  CLRF   23
0E35:  CLRF   22
0E36:  BCF    0A.3
0E37:  BCF    03.6
0E38:  CALL   7D4
0E39:  BSF    0A.3
0E3A:  BTFSC  78.0
0E3B:  GOTO   65D
....................       {   
....................          DELAY_MS(200); 
0E3C:  MOVLW  C8
0E3D:  BSF    03.6
0E3E:  MOVWF  46
0E3F:  BCF    0A.3
0E40:  BCF    03.6
0E41:  CALL   16C
0E42:  BSF    0A.3
....................          TT_THIETBI_TEMP[TB] = ~TT_THIETBI_TEMP[TB];          
0E43:  BSF    03.6
0E44:  MOVF   15,W
0E45:  MOVWF  21
0E46:  CLRF   23
0E47:  MOVLW  53
0E48:  MOVWF  22
0E49:  BCF    0A.3
0E4A:  BCF    03.6
0E4B:  CALL   7D4
0E4C:  BSF    0A.3
0E4D:  MOVLW  00
0E4E:  BTFSS  78.0
0E4F:  MOVLW  01
0E50:  BSF    03.6
0E51:  MOVWF  17
0E52:  MOVF   15,W
0E53:  MOVWF  1E
0E54:  MOVF   17,W
0E55:  MOVWF  1F
0E56:  CLRF   21
0E57:  MOVLW  53
0E58:  MOVWF  20
0E59:  BCF    0A.3
0E5A:  BCF    03.6
0E5B:  CALL   7B2
0E5C:  BSF    0A.3
....................       } 
0E5D:  BSF    03.6
0E5E:  INCF   15,F
0E5F:  GOTO   618
....................    } 
0E60:  BCF    03.6
0E61:  BCF    0A.3
0E62:  BSF    0A.4
0E63:  GOTO   5A8 (RETURN)
.................... /* 
....................    FOR (TB = 0; TB < 4; TB++) 
....................    { 
....................  
....................       IF (!INPUT (68 + TB)) 
....................       { 
....................           DELAY_MS(200); 
....................           TT_THIETBI_TEMP[TB + 4] = ~TT_THIETBI_TEMP[TB + 4];            
....................       } 
....................    } 
.................... */ 
.................... } 
.................... INT BIN_TO_DEC() 
*
0C8B:  BSF    03.6
0C8C:  CLRF   1E
0C8D:  MOVLW  01
0C8E:  MOVWF  1F
.................... { 
....................    INT8 DEC_VL = 0 ;  
....................    INT8 BASE = 1; 
....................    INT8 I; 
....................    FOR (I=0;I<8;I++) 
0C8F:  CLRF   20
0C90:  MOVF   20,W
0C91:  SUBLW  07
0C92:  BTFSS  03.0
0C93:  GOTO   4B1
....................    { 
....................    DEC_VL = DEC_VL+ BASE*TT_THIETBI_TEMP[I]; 
0C94:  MOVF   20,W
0C95:  MOVWF  21
0C96:  CLRF   23
0C97:  MOVLW  53
0C98:  MOVWF  22
0C99:  BCF    0A.3
0C9A:  BCF    03.6
0C9B:  CALL   7D4
0C9C:  BSF    0A.3
0C9D:  MOVLW  00
0C9E:  BTFSC  78.0
0C9F:  MOVLW  01
0CA0:  BSF    03.6
0CA1:  MOVWF  21
0CA2:  MOVF   1F,W
0CA3:  MOVWF  24
0CA4:  MOVF   21,W
0CA5:  MOVWF  25
0CA6:  BCF    0A.3
0CA7:  BCF    03.6
0CA8:  CALL   745
0CA9:  BSF    0A.3
0CAA:  MOVF   78,W
0CAB:  BSF    03.6
0CAC:  ADDWF  1E,F
....................    BASE = BASE*2; 
0CAD:  BCF    03.0
0CAE:  RLF    1F,F
0CAF:  INCF   20,F
0CB0:  GOTO   490
....................    } 
....................    RETURN DEC_VL; 
0CB1:  MOVF   1E,W
0CB2:  MOVWF  78
....................  
.................... } 
....................   
....................  VOID XUAT_DIEU_KHIEN() 
....................  { 
....................    LENH_DIEU_KHIEN = BIN_TO_DEC(); 
0CB3:  MOVF   78,W
0CB4:  BCF    03.6
0CB5:  MOVWF  41
....................    XUATTRANGTHAI (LENH_DIEU_KHIEN) ;   
0CB6:  MOVF   41,W
0CB7:  BSF    03.6
0CB8:  MOVWF  1E
....................    FOR (INT ST=0;ST<8;ST++){ 
*
0CDD:  BSF    03.6
0CDE:  CLRF   1D
0CDF:  MOVF   1D,W
0CE0:  SUBLW  07
0CE1:  BTFSS  03.0
0CE2:  GOTO   51E
....................       TEMP_CHAR = "0"; 
0CE3:  CLRF   1E
0CE4:  CLRF   1F
0CE5:  MOVLW  7B
0CE6:  MOVWF  04
0CE7:  BCF    03.7
0CE8:  MOVF   1E,W
0CE9:  ADDWF  04,F
0CEA:  MOVF   1F,W
0CEB:  BCF    0A.3
0CEC:  BCF    03.6
0CED:  CALL   058
0CEE:  BSF    0A.3
0CEF:  MOVWF  00
0CF0:  IORLW  00
0CF1:  BTFSC  03.2
0CF2:  GOTO   4F8
0CF3:  BSF    03.6
0CF4:  INCF   1F,F
0CF5:  INCF   1E,F
0CF6:  GOTO   4E5
0CF7:  BCF    03.6
....................       ITOA(TT_THIETBI_TEMP[ST],10,TEMP_CHAR); 
0CF8:  BSF    03.6
0CF9:  MOVF   1D,W
0CFA:  MOVWF  21
0CFB:  CLRF   23
0CFC:  MOVLW  53
0CFD:  MOVWF  22
0CFE:  BCF    0A.3
0CFF:  BCF    03.6
0D00:  CALL   7D4
0D01:  BSF    0A.3
0D02:  MOVLW  00
0D03:  BTFSC  78.0
0D04:  MOVLW  01
0D05:  BSF    03.6
0D06:  MOVWF  1E
0D07:  CLRF   47
0D08:  CLRF   46
0D09:  CLRF   45
0D0A:  MOVF   1E,W
0D0B:  MOVWF  44
0D0C:  MOVLW  0A
0D0D:  MOVWF  48
0D0E:  CLRF   4A
0D0F:  MOVLW  7B
0D10:  MOVWF  49
0D11:  BCF    0A.3
0D12:  BCF    03.6
0D13:  CALL   399
0D14:  BSF    0A.3
....................       PRINTF (LCD_PUTC, TEMP_CHAR); 
0D15:  MOVLW  7B
0D16:  MOVWF  04
0D17:  BCF    03.7
0D18:  BCF    0A.3
0D19:  CALL   711
0D1A:  BSF    0A.3
0D1B:  BSF    03.6
0D1C:  INCF   1D,F
0D1D:  GOTO   4DF
....................    } 
....................    //CHAR *PACKAGE_CONFIG[]={"*", "LENGHT","CF", "ID_GW1234" ,"ID_NODE","#"}; 
....................    IF(LENH_DIEU_KHIEN<10) TEMP_CHAR ="22"; 
0D1E:  BCF    03.6
0D1F:  MOVF   41,W
0D20:  SUBLW  09
0D21:  BTFSS  03.0
0D22:  GOTO   53A
0D23:  BSF    03.6
0D24:  CLRF   1E
0D25:  CLRF   1F
0D26:  MOVLW  7B
0D27:  MOVWF  04
0D28:  BCF    03.7
0D29:  MOVF   1E,W
0D2A:  ADDWF  04,F
0D2B:  MOVF   1F,W
0D2C:  BCF    0A.3
0D2D:  BCF    03.6
0D2E:  CALL   064
0D2F:  BSF    0A.3
0D30:  MOVWF  00
0D31:  IORLW  00
0D32:  BTFSC  03.2
0D33:  GOTO   539
0D34:  BSF    03.6
0D35:  INCF   1F,F
0D36:  INCF   1E,F
0D37:  GOTO   526
0D38:  BCF    03.6
0D39:  GOTO   56F
....................    ELSE IF(LENH_DIEU_KHIEN>=10 && LENH_DIEU_KHIEN <100) TEMP_CHAR ="23"; 
0D3A:  MOVF   41,W
0D3B:  SUBLW  09
0D3C:  BTFSC  03.0
0D3D:  GOTO   559
0D3E:  MOVF   41,W
0D3F:  SUBLW  63
0D40:  BTFSS  03.0
0D41:  GOTO   559
0D42:  BSF    03.6
0D43:  CLRF   1E
0D44:  CLRF   1F
0D45:  MOVLW  7B
0D46:  MOVWF  04
0D47:  BCF    03.7
0D48:  MOVF   1E,W
0D49:  ADDWF  04,F
0D4A:  MOVF   1F,W
0D4B:  BCF    0A.3
0D4C:  BCF    03.6
0D4D:  CALL   06B
0D4E:  BSF    0A.3
0D4F:  MOVWF  00
0D50:  IORLW  00
0D51:  BTFSC  03.2
0D52:  GOTO   558
0D53:  BSF    03.6
0D54:  INCF   1F,F
0D55:  INCF   1E,F
0D56:  GOTO   545
0D57:  BCF    03.6
0D58:  GOTO   56F
....................    ELSE TEMP_CHAR ="24";     
0D59:  BSF    03.6
0D5A:  CLRF   1E
0D5B:  CLRF   1F
0D5C:  MOVLW  7B
0D5D:  MOVWF  04
0D5E:  BCF    03.7
0D5F:  MOVF   1E,W
0D60:  ADDWF  04,F
0D61:  MOVF   1F,W
0D62:  BCF    0A.3
0D63:  BCF    03.6
0D64:  CALL   072
0D65:  BSF    0A.3
0D66:  MOVWF  00
0D67:  IORLW  00
0D68:  BTFSC  03.2
0D69:  GOTO   56F
0D6A:  BSF    03.6
0D6B:  INCF   1F,F
0D6C:  INCF   1E,F
0D6D:  GOTO   55C
0D6E:  BCF    03.6
....................    PRINTF ("*@"); 
0D6F:  MOVLW  2A
0D70:  BTFSS  0C.4
0D71:  GOTO   570
0D72:  MOVWF  19
0D73:  MOVLW  40
0D74:  BTFSS  0C.4
0D75:  GOTO   574
0D76:  MOVWF  19
....................    PRINTF (TEMP_CHAR); 
0D77:  MOVLW  7B
0D78:  MOVWF  04
0D79:  BCF    03.7
0D7A:  BCF    0A.3
0D7B:  CALL   4F7
0D7C:  BSF    0A.3
....................    PRINTF ("@DK@"); 
0D7D:  MOVLW  00
0D7E:  BSF    03.6
0D7F:  MOVWF  0D
0D80:  MOVLW  01
0D81:  MOVWF  0F
0D82:  BCF    03.6
0D83:  CALL   439
....................    PRINTF (ID_GATEWAY_CHAR); 
0D84:  MOVLW  5D
0D85:  MOVWF  04
0D86:  BCF    03.7
0D87:  BCF    0A.3
0D88:  CALL   4F7
0D89:  BSF    0A.3
....................    PRINTF ("@"); 
0D8A:  MOVLW  40
0D8B:  BTFSS  0C.4
0D8C:  GOTO   58B
0D8D:  MOVWF  19
....................    PRINTF (ID_NODE_CHAR); 
0D8E:  MOVLW  56
0D8F:  MOVWF  04
0D90:  BCF    03.7
0D91:  BCF    0A.3
0D92:  CALL   4F7
0D93:  BSF    0A.3
....................    PRINTF ("@"); 
0D94:  MOVLW  40
0D95:  BTFSS  0C.4
0D96:  GOTO   595
0D97:  MOVWF  19
....................    ITOA(LENH_DIEU_KHIEN,10,TEMP_CHAR); 
0D98:  BSF    03.6
0D99:  CLRF   47
0D9A:  CLRF   46
0D9B:  CLRF   45
0D9C:  BCF    03.6
0D9D:  MOVF   41,W
0D9E:  BSF    03.6
0D9F:  MOVWF  44
0DA0:  MOVLW  0A
0DA1:  MOVWF  48
0DA2:  CLRF   4A
0DA3:  MOVLW  7B
0DA4:  MOVWF  49
0DA5:  BCF    0A.3
0DA6:  BCF    03.6
0DA7:  CALL   399
0DA8:  BSF    0A.3
....................    PRINTF (TEMP_CHAR); 
0DA9:  MOVLW  7B
0DAA:  MOVWF  04
0DAB:  BCF    03.7
0DAC:  BCF    0A.3
0DAD:  CALL   4F7
0DAE:  BSF    0A.3
....................    PRINTF ("@#"); 
0DAF:  MOVLW  40
0DB0:  BTFSS  0C.4
0DB1:  GOTO   5B0
0DB2:  MOVWF  19
0DB3:  MOVLW  23
0DB4:  BTFSS  0C.4
0DB5:  GOTO   5B4
0DB6:  MOVWF  19
....................     
....................     
....................    LCD_GOTOXY (1, 2) ; 
0DB7:  MOVLW  01
0DB8:  BSF    03.6
0DB9:  MOVWF  46
0DBA:  MOVLW  02
0DBB:  MOVWF  47
0DBC:  BCF    0A.3
0DBD:  BCF    03.6
0DBE:  CALL   515
0DBF:  BSF    0A.3
....................    DELAY_MS (10); 
0DC0:  MOVLW  0A
0DC1:  BSF    03.6
0DC2:  MOVWF  46
0DC3:  BCF    0A.3
0DC4:  BCF    03.6
0DC5:  CALL   16C
0DC6:  BSF    0A.3
....................    PRINTF (LCD_PUTC, "SW: ");     
0DC7:  MOVLW  03
0DC8:  BSF    03.6
0DC9:  MOVWF  0D
0DCA:  MOVLW  01
0DCB:  MOVWF  0F
0DCC:  BCF    0A.3
0DCD:  BCF    03.6
0DCE:  CALL   563
0DCF:  BSF    0A.3
....................    FOR (ST=0;ST<8;ST++){ 
0DD0:  BSF    03.6
0DD1:  CLRF   1D
0DD2:  MOVF   1D,W
0DD3:  SUBLW  07
0DD4:  BTFSS  03.0
0DD5:  GOTO   611
....................       TEMP_CHAR = "0"; 
0DD6:  CLRF   1E
0DD7:  CLRF   1F
0DD8:  MOVLW  7B
0DD9:  MOVWF  04
0DDA:  BCF    03.7
0DDB:  MOVF   1E,W
0DDC:  ADDWF  04,F
0DDD:  MOVF   1F,W
0DDE:  BCF    0A.3
0DDF:  BCF    03.6
0DE0:  CALL   058
0DE1:  BSF    0A.3
0DE2:  MOVWF  00
0DE3:  IORLW  00
0DE4:  BTFSC  03.2
0DE5:  GOTO   5EB
0DE6:  BSF    03.6
0DE7:  INCF   1F,F
0DE8:  INCF   1E,F
0DE9:  GOTO   5D8
0DEA:  BCF    03.6
....................       ITOA(TT_THIETBI_TEMP[ST],10,TEMP_CHAR); 
0DEB:  BSF    03.6
0DEC:  MOVF   1D,W
0DED:  MOVWF  21
0DEE:  CLRF   23
0DEF:  MOVLW  53
0DF0:  MOVWF  22
0DF1:  BCF    0A.3
0DF2:  BCF    03.6
0DF3:  CALL   7D4
0DF4:  BSF    0A.3
0DF5:  MOVLW  00
0DF6:  BTFSC  78.0
0DF7:  MOVLW  01
0DF8:  BSF    03.6
0DF9:  MOVWF  1E
0DFA:  CLRF   47
0DFB:  CLRF   46
0DFC:  CLRF   45
0DFD:  MOVF   1E,W
0DFE:  MOVWF  44
0DFF:  MOVLW  0A
0E00:  MOVWF  48
0E01:  CLRF   4A
0E02:  MOVLW  7B
0E03:  MOVWF  49
0E04:  BCF    0A.3
0E05:  BCF    03.6
0E06:  CALL   399
0E07:  BSF    0A.3
....................       PRINTF (LCD_PUTC, TEMP_CHAR); 
0E08:  MOVLW  7B
0E09:  MOVWF  04
0E0A:  BCF    03.7
0E0B:  BCF    0A.3
0E0C:  CALL   711
0E0D:  BSF    0A.3
0E0E:  BSF    03.6
0E0F:  INCF   1D,F
0E10:  GOTO   5D2
....................    }    
0E11:  BCF    03.6
0E12:  RETURN
....................     
....................  } 
....................  VOID DIEUKHIENTHIETBI () 
*
1220:  BSF    03.6
1221:  CLRF   1B
....................  { 
....................     INT MA_DEC = 0; 
....................     MA_DEC = ATOI (KYTUCHAR2); 
1222:  CLRF   1E
1223:  MOVLW  D2
1224:  MOVWF  1D
1225:  BCF    0A.4
1226:  BSF    0A.3
1227:  BCF    03.6
1228:  CALL   356
1229:  BSF    0A.4
122A:  BCF    0A.3
122B:  MOVF   78,W
122C:  BSF    03.6
122D:  MOVWF  1B
....................  
....................    UNSIGNED INT8   SB;    
....................    #BIT BSERI  = MA_DEC.0 
....................     
....................    FOR (SB=0;SB<8;SB++) 
122E:  CLRF   1C
122F:  MOVF   1C,W
1230:  SUBLW  07
1231:  BTFSS  03.0
1232:  GOTO   247
....................       {                                                     
....................          TT_THIETBI_TEMP[SB] = BSERI; 
1233:  MOVLW  00
1234:  BTFSC  1B.0
1235:  MOVLW  01
1236:  MOVWF  1D
1237:  MOVF   1C,W
1238:  MOVWF  1E
1239:  MOVF   1D,W
123A:  MOVWF  1F
123B:  CLRF   21
123C:  MOVLW  53
123D:  MOVWF  20
123E:  BCF    0A.4
123F:  BCF    03.6
1240:  CALL   7B2
1241:  BSF    0A.4
....................          MA_DEC=MA_DEC>>1;  
1242:  BCF    03.0
1243:  BSF    03.6
1244:  RRF    1B,F
1245:  INCF   1C,F
1246:  GOTO   22F
....................      }     
....................     XUAT_DIEU_KHIEN(); 
1247:  BCF    0A.4
1248:  BSF    0A.3
1249:  BCF    03.6
124A:  CALL   48B
124B:  BSF    0A.4
124C:  BCF    0A.3
....................  } 
....................  
....................  
.................... #INCLUDE <analog.C> 
....................  
....................   INT ADC_READ (INT KENH) 
....................  { 
....................     UNSIGNED INT8 ANALOG_PORT[] = {1,2,4,8,16,32,64};  
*
1273:  MOVLW  01
1274:  MOVWF  1A
1275:  MOVLW  02
1276:  MOVWF  1B
1277:  MOVLW  04
1278:  MOVWF  1C
1279:  MOVLW  08
127A:  MOVWF  1D
127B:  MOVLW  10
127C:  MOVWF  1E
127D:  MOVLW  20
127E:  MOVWF  1F
127F:  MOVLW  40
1280:  MOVWF  20
....................     SETUP_ADC_PORTS (ANALOG_PORT[KENH]); 
1281:  MOVLW  1A
1282:  ADDWF  19,W
1283:  MOVWF  04
1284:  BSF    03.7
1285:  MOVF   00,W
1286:  MOVWF  22
1287:  MOVWF  23
1288:  CLRF   24
1289:  CLRF   25
128A:  CLRF   26
128B:  MOVLW  89
128C:  MOVWF  04
128D:  BSF    03.7
128E:  MOVLW  C0
128F:  ANDWF  00,F
1290:  MOVF   25,W
1291:  IORWF  00,F
1292:  MOVLW  9F
1293:  MOVWF  04
1294:  BCF    03.7
1295:  MOVLW  CF
1296:  ANDWF  00,F
1297:  MOVF   24,W
1298:  IORWF  00,F
1299:  MOVLW  88
129A:  MOVWF  04
129B:  BSF    03.7
129C:  MOVF   23,W
129D:  MOVWF  00
....................     DELAY_MS(3); 
129E:  MOVLW  03
129F:  MOVWF  46
12A0:  BCF    0A.4
12A1:  BCF    03.6
12A2:  CALL   16C
12A3:  BSF    0A.4
....................     SET_ADC_CHANNEL (KENH); 
12A4:  BSF    03.6
12A5:  RLF    19,W
12A6:  MOVWF  77
12A7:  RLF    77,F
12A8:  MOVLW  FC
12A9:  ANDWF  77,F
12AA:  BCF    03.6
12AB:  MOVF   1F,W
12AC:  ANDLW  C3
12AD:  IORWF  77,W
12AE:  MOVWF  1F
....................     DELAY_MS(3); 
12AF:  MOVLW  03
12B0:  BSF    03.6
12B1:  MOVWF  46
12B2:  BCF    0A.4
12B3:  BCF    03.6
12B4:  CALL   16C
12B5:  BSF    0A.4
....................     KQADC = 0; 
12B6:  CLRF   33
12B7:  CLRF   32
....................     FOR (INT I = 0; I < 100; I++) 
12B8:  BSF    03.6
12B9:  CLRF   21
12BA:  MOVF   21,W
12BB:  SUBLW  63
12BC:  BTFSS  03.0
12BD:  GOTO   2D4
....................     { 
....................        KQADC = KQADC + READ_ADC () ; 
12BE:  BCF    03.6
12BF:  BSF    1F.1
12C0:  BTFSC  1F.1
12C1:  GOTO   2C0
12C2:  BSF    03.5
12C3:  MOVF   1E,W
12C4:  BCF    03.5
12C5:  ADDWF  32,F
12C6:  MOVF   1E,W
12C7:  BTFSC  03.0
12C8:  INCFSZ 1E,W
12C9:  ADDWF  33,F
....................        DELAY_MS (1); 
12CA:  MOVLW  01
12CB:  BSF    03.6
12CC:  MOVWF  46
12CD:  BCF    0A.4
12CE:  BCF    03.6
12CF:  CALL   16C
12D0:  BSF    0A.4
12D1:  BSF    03.6
12D2:  INCF   21,F
12D3:  GOTO   2BA
....................     } 
....................  
....................     KQADC = KQADC / (100 * 2.046); 
12D4:  BCF    03.6
12D5:  MOVF   33,W
12D6:  BSF    03.6
12D7:  MOVWF  23
12D8:  BCF    03.6
12D9:  MOVF   32,W
12DA:  BSF    03.6
12DB:  MOVWF  22
*
12F8:  MOVF   7A,W
12F9:  MOVWF  25
12FA:  MOVF   79,W
12FB:  MOVWF  24
12FC:  MOVF   78,W
12FD:  MOVWF  23
12FE:  MOVF   77,W
12FF:  MOVWF  22
1300:  MOVLW  9A
1301:  MOVWF  29
1302:  MOVLW  99
1303:  MOVWF  28
1304:  MOVLW  4C
1305:  MOVWF  27
1306:  MOVLW  86
1307:  MOVWF  26
*
13D1:  MOVF   7A,W
13D2:  MOVWF  25
13D3:  MOVF   79,W
13D4:  MOVWF  24
13D5:  MOVF   78,W
13D6:  MOVWF  23
13D7:  MOVF   77,W
13D8:  MOVWF  22
*
13F7:  MOVF   79,W
13F8:  BCF    03.6
13F9:  MOVWF  33
13FA:  MOVF   78,W
13FB:  MOVWF  32
....................     RETURN KQADC; 
13FC:  MOVF   32,W
13FD:  MOVWF  78
....................  } 
....................  
....................  
....................  VOID READ_ANALOG ( ) 
*
1262:  BSF    03.6
1263:  CLRF   15
....................  { 
....................    SIGNED INT8 CHENH_LECH = 0; 
....................    FOR(INT K = 0; K<SOLUONGCAMBIEN_CONFIG; K++){ 
1264:  CLRF   16
1265:  BCF    03.6
1266:  MOVF   50,W
1267:  BSF    03.6
1268:  SUBWF  16,W
1269:  BTFSC  03.0
126A:  GOTO   4A2
....................       KET_QUA_ANALOG[K] = ADC_READ (K);   
126B:  MOVLW  34
126C:  ADDWF  16,W
126D:  MOVWF  17
126E:  CLRF   18
126F:  BTFSC  03.0
1270:  INCF   18,F
1271:  MOVF   16,W
1272:  MOVWF  19
*
13FE:  BSF    03.6
13FF:  MOVF   17,W
1400:  MOVWF  04
1401:  BCF    03.7
1402:  BTFSC  18.0
1403:  BSF    03.7
1404:  MOVF   78,W
1405:  MOVWF  00
....................       CHENH_LECH = ABS( KET_QUA_ANALOG[K] -KET_QUA_ANALOG_TEMP[K] ); 
1406:  MOVLW  34
1407:  ADDWF  16,W
1408:  MOVWF  04
1409:  BCF    03.7
140A:  MOVF   00,W
140B:  MOVWF  17
140C:  MOVLW  39
140D:  ADDWF  16,W
140E:  MOVWF  04
140F:  BCF    03.7
1410:  MOVF   00,W
1411:  SUBWF  17,F
1412:  MOVF   17,W
1413:  MOVWF  15
....................       IF (CHENH_LECH>0.5){ 
1414:  CLRF   18
1415:  MOVF   15,W
1416:  MOVWF  17
1417:  BTFSC  17.7
1418:  DECF   18,F
*
143D:  CLRF   1A
143E:  CLRF   19
143F:  CLRF   18
1440:  MOVLW  7E
1441:  MOVWF  17
1442:  MOVF   7A,W
1443:  MOVWF  1E
1444:  MOVF   79,W
1445:  MOVWF  1D
1446:  MOVF   78,W
1447:  MOVWF  1C
1448:  MOVF   77,W
1449:  MOVWF  1B
*
1488:  BTFSS  03.0
1489:  GOTO   48D
....................       TT_SEND_ANALOG = 1; 
148A:  BCF    03.6
148B:  BSF    55.0
148C:  BSF    03.6
....................       } 
....................       KET_QUA_ANALOG_TEMP[K] = KET_QUA_ANALOG[K]; 
148D:  MOVLW  39
148E:  ADDWF  16,W
148F:  MOVWF  17
1490:  CLRF   18
1491:  BTFSC  03.0
1492:  INCF   18,F
1493:  MOVLW  34
1494:  ADDWF  16,W
1495:  MOVWF  04
1496:  BCF    03.7
1497:  MOVF   00,W
1498:  MOVWF  19
1499:  MOVF   17,W
149A:  MOVWF  04
149B:  BCF    03.7
149C:  BTFSC  18.0
149D:  BSF    03.7
149E:  MOVF   19,W
149F:  MOVWF  00
14A0:  INCF   16,F
14A1:  GOTO   265
....................    } 
14A2:  BCF    03.6
14A3:  BCF    0A.3
14A4:  BSF    0A.4
14A5:  GOTO   5B8 (RETURN)
....................  } 
.................... /* 
....................  VOID SEND_ANALOG_UART() 
....................  { 
....................    OUTPUT_TOGGLE(PIN_C4); 
....................    //CHAR *PACKAGE_SS[]={"*", "26","SS", "IDGW12" ,"NODE","ZZ","AA","VV","CC","SS"}; 
....................    CHAR *PACKAGE_SS[]={"ZZ","AA","VV","CC","SS"};    
....................    PACKAGE_SS[0] = ID_GATEWAY_CHAR; 
....................    PACKAGE_SS[1] = ID_NODE_CHAR; 
....................    UNSIGNED INT8 DO_DAI =20; 
....................     
....................    FOR(INT I = 0; I<SOLUONGCAMBIEN_CONFIG; I++) 
....................    { 
....................       ITOA(KET_QUA_ANALOG[I],10,PACKAGE_SS[I]); 
....................       DO_DAI = DO_DAI + 3; 
....................    }       
....................    ITOA(DO_DAI,10,TEMP_CHAR2); 
....................    PRINTF ("*@");    
....................    PRINTF (TEMP_CHAR2); 
....................    PRINTF ("@SS@");    
....................    PRINTF (ID_GATEWAY_CHAR); 
....................    PRINTF ("@"); 
....................    PRINTF (ID_NODE_CHAR); 
....................    PRINTF ("@");    
....................    FOR ( I = 0; I < SOLUONGCAMBIEN_CONFIG; I++) 
....................    { 
....................       PRINTF (PACKAGE_SS[I]); 
....................       PRINTF ("@"); 
....................    } 
....................    PRINTF ("#"); 
....................    OUTPUT_TOGGLE(PIN_C4); 
....................     
....................  } 
....................   
....................   
....................  */ 
....................   
....................  /* 
....................  INT ADC_READ (INT KENH) 
....................  { 
....................     UNSIGNED INT8 ANALOG_PORT[] = {1, 2, 4, 8, 16, 32, 64}; 
....................     SETUP_ADC_PORTS (ANALOG_PORT[KENH]); 
....................     DELAY_MS (3) ; 
....................     SET_ADC_CHANNEL (KENH); 
....................     DELAY_MS (3) ; 
....................     KQADC = 0; 
....................     FOR (INT I = 0; I < 100; I++) 
....................     { 
....................        KQADC = KQADC + READ_ADC () ; 
....................        DELAY_MS (1); 
....................     } 
....................  
....................     KQADC = KQADC / (100 * 2.046); 
....................     RETURN KQADC; 
....................  } 
....................  
....................  VOID READ_ANALOG () 
....................  { 
....................     FOR (INT K = 0; K < SOLUONGCAMBIEN_CONFIG; K++) 
....................     { 
....................        KET_QUA_ANALOG[K] = ADC_READ (K); 
....................     } 
....................  } 
.................... */ 
....................  VOID SEND_ANALOG_UART () 
....................  { 
....................     OUTPUT_TOGGLE (PIN_C4) ; 
*
0E64:  BCF    31.4
0E65:  MOVF   31,W
0E66:  BSF    03.5
0E67:  MOVWF  07
0E68:  MOVLW  10
0E69:  BCF    03.5
0E6A:  XORWF  07,F
....................     //CHAR * PACKAGE_SS[] ={" * ", "26", "SS", "IDGW12", "NODE", "ZZ", "AA", "VV", "CC", "SS"}; 
....................     CHAR * PACKAGE_SS[] ={"IDGW12", "NODE", "ZZ", "AA", "VV", "CC", "SS"}; 
0E6B:  MOVLW  49
0E6C:  BSF    03.6
0E6D:  MOVWF  23
0E6E:  MOVLW  44
0E6F:  MOVWF  24
0E70:  MOVLW  47
0E71:  MOVWF  25
0E72:  MOVLW  57
0E73:  MOVWF  26
0E74:  MOVLW  31
0E75:  MOVWF  27
0E76:  MOVLW  32
0E77:  MOVWF  28
0E78:  CLRF   29
0E79:  MOVLW  4E
0E7A:  MOVWF  2A
0E7B:  MOVLW  4F
0E7C:  MOVWF  2B
0E7D:  MOVLW  44
0E7E:  MOVWF  2C
0E7F:  MOVLW  45
0E80:  MOVWF  2D
0E81:  CLRF   2E
0E82:  MOVLW  5A
0E83:  MOVWF  2F
0E84:  MOVWF  30
0E85:  CLRF   31
0E86:  MOVLW  41
0E87:  MOVWF  32
0E88:  MOVWF  33
0E89:  CLRF   34
0E8A:  MOVLW  56
0E8B:  MOVWF  35
0E8C:  MOVWF  36
0E8D:  CLRF   37
0E8E:  MOVLW  43
0E8F:  MOVWF  38
0E90:  MOVWF  39
0E91:  CLRF   3A
0E92:  MOVLW  53
0E93:  MOVWF  3B
0E94:  MOVWF  3C
0E95:  CLRF   3D
0E96:  MOVLW  01
0E97:  MOVWF  16
0E98:  MOVLW  23
0E99:  MOVWF  15
0E9A:  MOVLW  01
0E9B:  MOVWF  18
0E9C:  MOVLW  2A
0E9D:  MOVWF  17
0E9E:  MOVLW  01
0E9F:  MOVWF  1A
0EA0:  MOVLW  2F
0EA1:  MOVWF  19
0EA2:  MOVLW  01
0EA3:  MOVWF  1C
0EA4:  MOVLW  32
0EA5:  MOVWF  1B
0EA6:  MOVLW  01
0EA7:  MOVWF  1E
0EA8:  MOVLW  35
0EA9:  MOVWF  1D
0EAA:  MOVLW  01
0EAB:  MOVWF  20
0EAC:  MOVLW  38
0EAD:  MOVWF  1F
0EAE:  MOVLW  01
0EAF:  MOVWF  22
0EB0:  MOVLW  3B
0EB1:  MOVWF  21
....................     PACKAGE_SS[0] = ID_GATEWAY_CHAR; 
0EB2:  CLRF   16
0EB3:  MOVLW  5D
0EB4:  MOVWF  15
....................     PACKAGE_SS[1] = ID_NODE_CHAR; 
0EB5:  CLRF   18
0EB6:  MOVLW  56
0EB7:  MOVWF  17
....................     UNSIGNED INT8 DO_DAI = 20; 
0EB8:  MOVLW  14
0EB9:  MOVWF  3E
....................      
....................     FOR (INT I = 0; I < SOLUONGCAMBIEN_CONFIG; I++) 
0EBA:  CLRF   3F
0EBB:  BCF    03.6
0EBC:  MOVF   50,W
0EBD:  BSF    03.6
0EBE:  SUBWF  3F,W
0EBF:  BTFSC  03.0
0EC0:  GOTO   6EA
....................     { 
....................        ITOA (KET_QUA_ANALOG[I], 10, PACKAGE_SS[2 + I]) ; 
0EC1:  MOVLW  34
0EC2:  ADDWF  3F,W
0EC3:  MOVWF  04
0EC4:  BCF    03.7
0EC5:  MOVF   00,W
0EC6:  MOVWF  40
0EC7:  MOVLW  02
0EC8:  ADDWF  3F,W
0EC9:  MOVWF  77
0ECA:  BCF    03.0
0ECB:  RLF    77,F
0ECC:  MOVF   77,W
0ECD:  ADDLW  15
0ECE:  MOVWF  04
0ECF:  BSF    03.7
0ED0:  INCF   04,F
0ED1:  MOVF   00,W
0ED2:  MOVWF  42
0ED3:  DECF   04,F
0ED4:  MOVF   00,W
0ED5:  MOVWF  41
0ED6:  CLRF   47
0ED7:  CLRF   46
0ED8:  CLRF   45
0ED9:  MOVF   40,W
0EDA:  MOVWF  44
0EDB:  MOVLW  0A
0EDC:  MOVWF  48
0EDD:  MOVF   42,W
0EDE:  MOVWF  4A
0EDF:  MOVF   41,W
0EE0:  MOVWF  49
0EE1:  BCF    0A.3
0EE2:  BCF    03.6
0EE3:  CALL   399
0EE4:  BSF    0A.3
....................        DO_DAI = DO_DAI + 3; 
0EE5:  MOVLW  03
0EE6:  BSF    03.6
0EE7:  ADDWF  3E,F
0EE8:  INCF   3F,F
0EE9:  GOTO   6BB
....................     } 
....................  
....................     ITOA (DO_DAI, 10, TEMP_CHAR2) ; 
0EEA:  CLRF   47
0EEB:  CLRF   46
0EEC:  CLRF   45
0EED:  MOVF   3E,W
0EEE:  MOVWF  44
0EEF:  MOVLW  0A
0EF0:  MOVWF  48
0EF1:  CLRF   4A
0EF2:  MOVLW  7D
0EF3:  MOVWF  49
0EF4:  BCF    0A.3
0EF5:  BCF    03.6
0EF6:  CALL   399
0EF7:  BSF    0A.3
....................     PRINTF ("*@"); 
0EF8:  MOVLW  2A
0EF9:  BTFSS  0C.4
0EFA:  GOTO   6F9
0EFB:  MOVWF  19
0EFC:  MOVLW  40
0EFD:  BTFSS  0C.4
0EFE:  GOTO   6FD
0EFF:  MOVWF  19
....................     PRINTF (TEMP_CHAR2); 
0F00:  MOVLW  7D
0F01:  MOVWF  04
0F02:  BCF    03.7
0F03:  BCF    0A.3
0F04:  CALL   4F7
0F05:  BSF    0A.3
....................     PRINTF ("@SS@"); 
0F06:  MOVLW  06
0F07:  BSF    03.6
0F08:  MOVWF  0D
0F09:  MOVLW  01
0F0A:  MOVWF  0F
0F0B:  BCF    03.6
0F0C:  CALL   439
....................     FOR (I = 0; I < 2 + SOLUONGCAMBIEN_CONFIG; I++) 
0F0D:  BSF    03.6
0F0E:  CLRF   3F
0F0F:  MOVLW  02
0F10:  BCF    03.6
0F11:  ADDWF  50,W
0F12:  BSF    03.6
0F13:  SUBWF  3F,W
0F14:  BTFSC  03.0
0F15:  GOTO   730
....................     { 
....................        PRINTF (PACKAGE_SS[I]); 
0F16:  BCF    03.0
0F17:  RLF    3F,W
0F18:  ADDLW  15
0F19:  MOVWF  04
0F1A:  BSF    03.7
0F1B:  INCF   04,F
0F1C:  MOVF   00,W
0F1D:  MOVWF  41
0F1E:  DECF   04,F
0F1F:  MOVF   00,W
0F20:  MOVWF  40
0F21:  MOVWF  04
0F22:  BCF    03.7
0F23:  BTFSC  41.0
0F24:  BSF    03.7
0F25:  BCF    0A.3
0F26:  BCF    03.6
0F27:  CALL   4F7
0F28:  BSF    0A.3
....................        PRINTF ("@"); 
0F29:  MOVLW  40
0F2A:  BTFSS  0C.4
0F2B:  GOTO   72A
0F2C:  MOVWF  19
0F2D:  BSF    03.6
0F2E:  INCF   3F,F
0F2F:  GOTO   70F
....................     } 
....................  
....................     PRINTF ("#"); 
0F30:  MOVLW  23
0F31:  BCF    03.6
0F32:  BTFSS  0C.4
0F33:  GOTO   732
0F34:  MOVWF  19
....................     OUTPUT_TOGGLE (PIN_C4) ; 
0F35:  BCF    31.4
0F36:  MOVF   31,W
0F37:  BSF    03.5
0F38:  MOVWF  07
0F39:  MOVLW  10
0F3A:  BCF    03.5
0F3B:  XORWF  07,F
0F3C:  BCF    0A.3
0F3D:  BSF    0A.4
0F3E:  GOTO   5BE (RETURN)
....................  } 
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
.................... VOID QUET_PHIM() 
*
0109:  BSF    03.6
010A:  CLRF   69
.................... { 
....................    INT BDT = 0; 
....................    WHILE (!INPUT (BT1_PIN)) //NEU NUT BAM DUOC BAM 
010B:  BSF    03.5
010C:  BCF    03.6
010D:  BSF    06.1
010E:  BCF    03.5
010F:  BTFSC  06.1
0110:  GOTO   126
....................    { 
....................       IF (TMR1IF) 
0111:  BTFSS  0C.0
0112:  GOTO   123
....................       { 
....................          OUTPUT_TOGGLE (PIN_C4); 
0113:  BCF    31.4
0114:  MOVF   31,W
0115:  BSF    03.5
0116:  MOVWF  07
0117:  MOVLW  10
0118:  BCF    03.5
0119:  XORWF  07,F
....................          TMR1IF = 0; SET_TIMER1 (3036); BDT++; 
011A:  BCF    0C.0
011B:  CLRF   0E
011C:  MOVLW  0B
011D:  MOVWF  0F
011E:  MOVLW  DC
011F:  MOVWF  0E
0120:  BSF    03.6
0121:  INCF   69,F
0122:  BCF    03.6
....................       } 
0123:  BSF    03.6
0124:  GOTO   10B
0125:  BCF    03.6
....................    } 
....................  
....................    IF (BDT > 20) 
0126:  BSF    03.6
0127:  MOVF   69,W
0128:  SUBLW  14
0129:  BTFSC  03.0
012A:  GOTO   134
....................    { 
....................       //CONFIG NODE 
....................       TT_CONFIG = ~TT_CONFIG; // VAO TRANG THAI CONFIG 
012B:  MOVLW  02
012C:  BCF    03.6
012D:  XORWF  54,F
....................       TT_CONTROL = ~TT_CONTROL; 
012E:  MOVLW  04
012F:  XORWF  54,F
....................       //CONFIG_DONE (); 
....................       TT_CONFIG_DONE = 1; 
0130:  BSF    54.3
....................       TT_FUN = 0; 
0131:  BCF    54.4
....................    } 
0132:  GOTO   14B
0133:  BSF    03.6
....................  
....................    ELSE IF (BDT > 1&&BDT < 20) 
0134:  MOVF   69,W
0135:  SUBLW  01
0136:  BTFSC  03.0
0137:  GOTO   142
0138:  MOVF   69,W
0139:  SUBLW  13
013A:  BTFSS  03.0
013B:  GOTO   142
....................    { 
....................       BUTT_OKE (); //OKE 
....................    } 
*
0140:  GOTO   14B
0141:  BSF    03.6
....................  
....................    ELSE 
....................    {             
....................       //TMR1IF = 0; SET_TIMER1 (0);       
....................       TT_SW = 1; 
0142:  BCF    03.6
0143:  BSF    54.7
....................       OUTPUT_TOGGLE (PIN_C4); 
0144:  BCF    31.4
0145:  MOVF   31,W
0146:  BSF    03.5
0147:  MOVWF  07
0148:  MOVLW  10
0149:  BCF    03.5
014A:  XORWF  07,F
....................       //READ_BTN_STATE () ;       
....................    } 
.................... } 
....................  
.................... #INT_EXT 
....................  
....................  VOID NGAT_NGOAI  () 
....................  { 
....................     QUET_PHIM (); 
....................  } 
....................  
014B:  BCF    0B.1
014C:  BCF    0A.3
014D:  BCF    0A.4
014E:  GOTO   031
....................  #INT_RDA 
....................  VOID NGAT  () 
....................  { 
....................     KYTUCHAR[VT] = GETCH (); 
014F:  MOVLW  A0
0150:  ADDWF  3F,W
0151:  MOVWF  04
0152:  BCF    03.7
0153:  BTFSS  0C.5
0154:  GOTO   153
0155:  MOVF   1A,W
0156:  MOVWF  00
....................  
....................     IF (KYTUCHAR[VT] == '.') 
0157:  MOVLW  A0
0158:  ADDWF  3F,W
0159:  MOVWF  04
015A:  BCF    03.7
015B:  MOVF   00,W
015C:  SUBLW  2E
015D:  BTFSS  03.2
015E:  GOTO   167
....................     { 
....................        KYTUCHAR[VT] = '\0'; 
015F:  MOVLW  A0
0160:  ADDWF  3F,W
0161:  MOVWF  04
0162:  BCF    03.7
0163:  CLRF   00
....................        VT = 0; 
0164:  CLRF   3F
....................        TTNHAN = 1; 
0165:  BSF    54.0
....................     } 
0166:  GOTO   168
....................  
....................     ELSE 
....................     VT++; 
0167:  INCF   3F,F
0168:  BCF    0C.5
0169:  BCF    0A.3
016A:  BCF    0A.4
016B:  GOTO   031
....................  } 
....................  
....................  VOID XU_LY_UART () 
*
1000:  MOVLW  2A
1001:  BSF    03.6
1002:  MOVWF  15
....................  { 
....................     //ID_NODE_NHAN = KYTU[1] - 48; 
....................     //ID_DEVICE_NHAN = KYTU[2] - 48 + 64; 
....................     //TT_DEVICE_NHAN = KYTU[3] - 48; // - 48 ASCII -- > S?. + 64 -- > PORT_D (D0 = 64) 
....................     /* TINH DO DAI*/ 
....................     CHAR CH = '*'; 
....................     CHAR * RET; 
....................     * ID_NODE_NHAN = '\0'; 
1003:  CLRF   7A
1004:  MOVLW  66
1005:  MOVWF  04
1006:  BCF    03.7
1007:  BTFSC  7A.0
1008:  BSF    03.7
1009:  CLRF   00
....................     * ID_GW_NHAN = '\0'; 
100A:  CLRF   7A
100B:  MOVLW  6D
100C:  MOVWF  04
100D:  BCF    03.7
100E:  BTFSC  7A.0
100F:  BSF    03.7
1010:  CLRF   00
....................     KYTUCHAR2 = ""; 
1011:  CLRF   1B
1012:  CLRF   1C
1013:  MOVLW  D2
1014:  MOVWF  04
1015:  BCF    03.7
1016:  MOVF   1B,W
1017:  ADDWF  04,F
1018:  MOVF   1C,W
1019:  BCF    0A.4
101A:  BCF    03.6
101B:  CALL   07F
101C:  BSF    0A.4
101D:  MOVWF  00
101E:  IORLW  00
101F:  BTFSC  03.2
1020:  GOTO   026
1021:  BSF    03.6
1022:  INCF   1C,F
1023:  INCF   1B,F
1024:  GOTO   013
1025:  BCF    03.6
....................     UNSIGNED INT8 LEN_RET; 
....................     RET = STRCHR (KYTUCHAR, CH); 
1026:  BSF    03.6
1027:  CLRF   1C
1028:  MOVLW  A0
1029:  MOVWF  1B
102A:  MOVF   15,W
102B:  MOVWF  1D
*
104D:  MOVF   79,W
104E:  MOVWF  17
104F:  MOVF   78,W
1050:  MOVWF  16
....................     LEN_RET = STRLEN (RET); 
1051:  MOVF   17,W
1052:  MOVWF  1C
1053:  MOVF   16,W
1054:  MOVWF  1B
*
1072:  MOVF   78,W
1073:  MOVWF  18
....................  
....................     /* LAY TOKEN DAU TIEN */ 
....................     KYTU = 0; 
1074:  BCF    03.6
1075:  CLRF   40
....................     TEMP_CHAR = "#"; 
1076:  BSF    03.6
1077:  CLRF   1B
1078:  CLRF   1C
1079:  MOVLW  7B
107A:  MOVWF  04
107B:  BCF    03.7
107C:  MOVF   1B,W
107D:  ADDWF  04,F
107E:  MOVF   1C,W
107F:  BCF    0A.4
1080:  BCF    03.6
1081:  CALL   079
1082:  BSF    0A.4
1083:  MOVWF  00
1084:  IORLW  00
1085:  BTFSC  03.2
1086:  GOTO   08C
1087:  BSF    03.6
1088:  INCF   1C,F
1089:  INCF   1B,F
108A:  GOTO   079
108B:  BCF    03.6
....................     CHAR * TOKEN; 
....................     TOKEN = STRTOK (KYTUCHAR, TEMP_CHAR); 
108C:  BSF    03.6
108D:  CLRF   1E
108E:  MOVLW  A0
108F:  MOVWF  1D
1090:  CLRF   20
1091:  MOVLW  7B
1092:  MOVWF  1F
1093:  BCF    0A.4
1094:  BSF    0A.3
1095:  BCF    03.6
1096:  CALL   265
1097:  BSF    0A.4
1098:  BCF    0A.3
1099:  MOVF   79,W
109A:  BSF    03.6
109B:  MOVWF  1A
109C:  MOVF   78,W
109D:  MOVWF  19
....................  
....................     /* DUYET QUA CAC TOKEN CON LAI */ 
....................     WHILE (TOKEN != NULL) 
109E:  MOVF   19,F
109F:  BTFSS  03.2
10A0:  GOTO   0A4
10A1:  MOVF   1A,F
10A2:  BTFSC  03.2
10A3:  GOTO   103
....................     { 
....................        SWITCH (KYTU) 
10A4:  BCF    03.6
10A5:  MOVF   40,W
10A6:  ADDLW  FA
10A7:  BTFSC  03.0
10A8:  GOTO   0EE
10A9:  ADDLW  06
10AA:  GOTO   258
....................        { 
....................           CASE 0: 
....................           BREAK; 
10AB:  GOTO   0EE
....................  
....................           CASE 1: 
....................           STRCAT (ID_GW_NHAN, TOKEN); 
10AC:  BSF    03.6
10AD:  CLRF   44
10AE:  MOVLW  6D
10AF:  MOVWF  43
10B0:  MOVF   1A,W
10B1:  MOVWF  46
10B2:  MOVF   19,W
10B3:  MOVWF  45
10B4:  BCF    0A.4
10B5:  BCF    03.6
10B6:  CALL   4B9
10B7:  BSF    0A.4
....................           BREAK; 
10B8:  GOTO   0EE
....................  
....................           CASE 2: 
....................           STRCAT (ID_NODE_NHAN, TOKEN); 
10B9:  BSF    03.6
10BA:  CLRF   44
10BB:  MOVLW  66
10BC:  MOVWF  43
10BD:  MOVF   1A,W
10BE:  MOVWF  46
10BF:  MOVF   19,W
10C0:  MOVWF  45
10C1:  BCF    0A.4
10C2:  BCF    03.6
10C3:  CALL   4B9
10C4:  BSF    0A.4
....................           BREAK; 
10C5:  GOTO   0EE
....................  
....................           CASE 3: 
....................           LENHDIEUKHIEN = ATOI (TOKEN); 
10C6:  BSF    03.6
10C7:  MOVF   1A,W
10C8:  MOVWF  1E
10C9:  MOVF   19,W
10CA:  MOVWF  1D
10CB:  BCF    0A.4
10CC:  BSF    0A.3
10CD:  BCF    03.6
10CE:  CALL   356
10CF:  BSF    0A.4
10D0:  BCF    0A.3
10D1:  MOVF   78,W
10D2:  MOVWF  4D
....................           BREAK; 
10D3:  GOTO   0EE
....................  
....................           CASE 4: 
....................           DODAI_DATA_NHAN = ATOI (TOKEN); 
10D4:  BSF    03.6
10D5:  MOVF   1A,W
10D6:  MOVWF  1E
10D7:  MOVF   19,W
10D8:  MOVWF  1D
10D9:  BCF    0A.4
10DA:  BSF    0A.3
10DB:  BCF    03.6
10DC:  CALL   356
10DD:  BSF    0A.4
10DE:  BCF    0A.3
10DF:  MOVF   78,W
10E0:  MOVWF  4E
....................           BREAK; 
10E1:  GOTO   0EE
....................  
....................           CASE 5: 
....................           STRCAT (KYTUCHAR2, TOKEN); 
10E2:  BSF    03.6
10E3:  CLRF   44
10E4:  MOVLW  D2
10E5:  MOVWF  43
10E6:  MOVF   1A,W
10E7:  MOVWF  46
10E8:  MOVF   19,W
10E9:  MOVWF  45
10EA:  BCF    0A.4
10EB:  BCF    03.6
10EC:  CALL   4B9
10ED:  BSF    0A.4
....................           BREAK; 
....................        } 
....................  
....................        TOKEN = STRTOK (NULL, TEMP_CHAR); 
10EE:  BSF    03.6
10EF:  CLRF   1E
10F0:  CLRF   1D
10F1:  CLRF   20
10F2:  MOVLW  7B
10F3:  MOVWF  1F
10F4:  BCF    0A.4
10F5:  BSF    0A.3
10F6:  BCF    03.6
10F7:  CALL   265
10F8:  BSF    0A.4
10F9:  BCF    0A.3
10FA:  MOVF   79,W
10FB:  BSF    03.6
10FC:  MOVWF  1A
10FD:  MOVF   78,W
10FE:  MOVWF  19
....................        KYTU++; 
10FF:  BCF    03.6
1100:  INCF   40,F
1101:  BSF    03.6
1102:  GOTO   09E
....................     } 
....................  
....................     /* SO SANH ID returns - 1 IF s1 < s2, 0 if s1 = s2, 1 if s1 > s2 */ 
....................     SOSANH_IDGW = STRCMP (ID_GW_NHAN, ID_GATEWAY_CHAR); 
1103:  CLRF   1C
1104:  MOVLW  6D
1105:  MOVWF  1B
1106:  CLRF   1E
1107:  MOVLW  5D
1108:  MOVWF  1D
1109:  BCF    0A.4
110A:  BCF    03.6
110B:  CALL   76C
110C:  BSF    0A.4
110D:  MOVF   78,W
110E:  MOVWF  52
....................     SOSANH_IDNODE = STRCMP (ID_NODE_NHAN, ID_NODE_CHAR); 
110F:  BSF    03.6
1110:  CLRF   1C
1111:  MOVLW  66
1112:  MOVWF  1B
1113:  CLRF   1E
1114:  MOVLW  56
1115:  MOVWF  1D
1116:  BCF    0A.4
1117:  BCF    03.6
1118:  CALL   76C
1119:  BSF    0A.4
111A:  MOVF   78,W
111B:  MOVWF  51
....................      
....................     IF (SOSANH_IDGW == 0&&SOSANH_IDNODE == 0&&LEN_RET == DODAI_DATA_NHAN) 
111C:  MOVF   52,F
111D:  BTFSS  03.2
111E:  GOTO   24E
111F:  MOVF   51,F
1120:  BTFSS  03.2
1121:  GOTO   24E
1122:  MOVF   4E,W
1123:  BSF    03.6
1124:  SUBWF  18,W
1125:  BTFSC  03.2
1126:  GOTO   129
1127:  BCF    03.6
1128:  GOTO   24E
....................     { 
....................        SWITCH (LENHDIEUKHIEN) 
1129:  BCF    03.6
112A:  MOVF   4D,W
112B:  BTFSC  03.2
112C:  GOTO   134
112D:  XORLW  01
112E:  BTFSC  03.2
112F:  GOTO   135
1130:  XORLW  03
1131:  BTFSC  03.2
1132:  GOTO   220
1133:  GOTO   24D
....................        { 
....................           CASE 0: 
....................           BREAK; 
1134:  GOTO   24D
....................  
....................           CASE 1: 
....................           XACNHANCONFIG () ; 
....................           BREAK; 
*
121F:  GOTO   24D
....................  
....................           CASE 2: 
....................           DIEUKHIENTHIETBI () ; 
....................           BREAK; 
....................        } 
....................     } 
*
124D:  GOTO   255
....................  
....................     ELSE 
....................     { 
....................        DELAY_MS (10); 
124E:  MOVLW  0A
124F:  BSF    03.6
1250:  MOVWF  46
1251:  BCF    0A.4
1252:  BCF    03.6
1253:  CALL   16C
1254:  BSF    0A.4
....................  
....................        /* DATA RCV SAI ID NODE, ID GW HOAC LA SAI DO DAI*/ 
....................     } 
1255:  BCF    0A.3
1256:  BSF    0A.4
1257:  GOTO   5A1 (RETURN)
....................  
....................  } 
....................  
....................  VOID MAIN () 
*
14A6:  MOVF   03,W
14A7:  ANDLW  1F
14A8:  MOVWF  03
14A9:  BSF    03.5
14AA:  BSF    03.6
14AB:  BSF    07.3
14AC:  MOVLW  08
14AD:  BCF    03.6
14AE:  MOVWF  19
14AF:  MOVLW  02
14B0:  MOVWF  1A
14B1:  MOVLW  A6
14B2:  MOVWF  18
14B3:  MOVLW  90
14B4:  BCF    03.5
14B5:  MOVWF  18
14B6:  MOVLW  FF
14B7:  MOVWF  31
14B8:  CLRF   3E
14B9:  CLRF   3F
14BA:  CLRF   40
14BB:  CLRF   41
14BC:  CLRF   4C
14BD:  CLRF   4D
14BE:  CLRF   4E
14BF:  CLRF   4F
14C0:  MOVLW  03
14C1:  MOVWF  50
14C2:  CLRF   51
14C3:  CLRF   52
14C4:  BCF    54.0
14C5:  BCF    54.1
14C6:  BCF    54.2
14C7:  BCF    54.3
14C8:  BCF    54.4
14C9:  BCF    54.5
14CA:  BCF    54.6
14CB:  BCF    54.7
14CC:  BCF    55.0
14CD:  BSF    03.5
14CE:  BSF    03.6
14CF:  MOVF   09,W
14D0:  ANDLW  C0
14D1:  MOVWF  09
14D2:  BCF    03.6
14D3:  BCF    1F.4
14D4:  BCF    1F.5
14D5:  MOVLW  00
14D6:  BSF    03.6
14D7:  MOVWF  08
14D8:  BCF    03.5
14D9:  CLRF   07
14DA:  CLRF   08
14DB:  CLRF   09
14DC:  BCF    03.7
....................  { 
....................     SET_TRIS_D (0XF0); 
*
1557:  MOVLW  F0
1558:  BSF    03.5
1559:  BCF    03.6
155A:  MOVWF  08
....................     SET_TRIS_B (0XFF); 
155B:  MOVLW  FF
155C:  MOVWF  06
....................     SET_TRIS_E (0); 
155D:  BCF    09.0
155E:  BCF    09.1
155F:  BCF    09.2
1560:  BCF    09.3
....................     SET_TRIS_C (0X80); 
1561:  MOVLW  80
1562:  MOVWF  07
1563:  BCF    03.5
1564:  MOVWF  31
....................     SETUP_ADC (ADC_CLOCK_DIV_8); 
1565:  BSF    1F.6
1566:  BCF    1F.7
1567:  BSF    03.5
1568:  BSF    1F.7
1569:  BCF    03.5
156A:  BSF    1F.0
....................     ENABLE_INTERRUPTS (INT_TIMER0); 
156B:  BSF    0B.5
....................     ENABLE_INTERRUPTS (INT_EXT); //CHO PHEP NGAT NGOAI 
156C:  BSF    0B.4
....................     ENABLE_INTERRUPTS (INT_EXT_H2L); //NGAT XAY RA KHI CO XUNG TU CAO XUONG THAP 
156D:  BSF    0B.4
156E:  BSF    03.5
156F:  BCF    01.6
....................     ENABLE_INTERRUPTS (INT_RDA); 
1570:  BSF    0C.5
....................     ENABLE_INTERRUPTS (GLOBAL); 
1571:  MOVLW  C0
1572:  BCF    03.5
1573:  IORWF  0B,F
....................      
....................     SETUP_TIMER_1 (T1_INTERNAL|T1_DIV_BY_8); 
1574:  MOVLW  35
1575:  MOVWF  10
....................     //SET_TIMER1 (0); 
....................     SET_TIMER1 (3036); 
1576:  CLRF   0E
1577:  MOVLW  0B
1578:  MOVWF  0F
1579:  MOVLW  DC
157A:  MOVWF  0E
....................     TMR1IF = 0; 
157B:  BCF    0C.0
....................     LCD_INIT (); // KHOI TAO LCD 
157C:  BCF    0A.4
157D:  GOTO   286
157E:  BSF    0A.4
....................     TT_CONFIG = 0; 
157F:  BCF    54.1
....................     TT_CONFIG_DONE = 0; 
1580:  BCF    54.3
....................     TT_CONTROL = 1; 
1581:  BSF    54.2
....................     OUTPUT_HIGH (PIN_D3) ; 
1582:  BSF    03.5
1583:  BCF    08.3
1584:  BCF    03.5
1585:  BSF    08.3
....................     TTNHAN = 0; 
1586:  BCF    54.0
....................  
....................     READ_EEPROMP_DATA_NODE(); 
1587:  BCF    0A.4
1588:  GOTO   2EC
1589:  BSF    0A.4
....................     CONFIG_DONE(); 
158A:  BCF    0A.4
158B:  CALL   5B3
158C:  BSF    0A.4
....................  
....................      
....................     WHILE (TRUE) 
....................     { 
....................        IF (TT_CONFIG)   {BUTT_FUN (); } // GOI HAM CHON LENH (SWITCH CASE) 
158D:  BTFSS  54.1
158E:  GOTO   595
158F:  BCF    0A.4
1590:  BSF    0A.3
1591:  GOTO   000
1592:  BSF    0A.4
1593:  BCF    0A.3
1594:  GOTO   5C8
....................        ELSE IF (TT_CONFIG_DONE) { CONFIG_DONE (); } 
1595:  BTFSS  54.3
1596:  GOTO   59B
1597:  BCF    0A.4
1598:  CALL   5B3
1599:  BSF    0A.4
159A:  GOTO   5C8
....................        ELSE 
....................        { 
....................           WHILE (!TT_CONFIG) 
159B:  BTFSC  54.1
159C:  GOTO   5C8
....................           { 
....................              IF (TTNHAN == 1) 
159D:  BTFSS  54.0
159E:  GOTO   5A1
....................              { 
....................                 TTNHAN = 0; 
159F:  BCF    54.0
....................                 XU_LY_UART () ; 
15A0:  GOTO   000
....................              } 
....................              IF (TT_CONFIG_OKE_UART == 1) 
15A1:  BTFSS  54.6
15A2:  GOTO   5C7
....................              { 
....................                  
....................                IF (TT_SW) 
15A3:  BTFSS  54.7
15A4:  GOTO   5B0
....................                { 
....................                   READ_BTN_STATE(); 
15A5:  BCF    0A.4
15A6:  BSF    0A.3
15A7:  GOTO   613
15A8:  BSF    0A.4
15A9:  BCF    0A.3
....................                   TT_SW = 0;              
15AA:  BCF    54.7
....................                   XUAT_DIEU_KHIEN();               
15AB:  BCF    0A.4
15AC:  BSF    0A.3
15AD:  CALL   48B
15AE:  BSF    0A.4
15AF:  BCF    0A.3
....................                }                 
....................                 DELAY_MS (100) ; 
15B0:  MOVLW  64
15B1:  BSF    03.6
15B2:  MOVWF  46
15B3:  BCF    0A.4
15B4:  BCF    03.6
15B5:  CALL   16C
15B6:  BSF    0A.4
....................                 READ_ANALOG () ; 
15B7:  GOTO   262
....................  
....................                 IF (TT_SEND_ANALOG) 
15B8:  BTFSS  55.0
15B9:  GOTO   5C7
....................                 { 
....................                   TT_SEND_ANALOG = 0; 
15BA:  BCF    55.0
....................                    SEND_ANALOG_UART () ; 
15BB:  BCF    0A.4
15BC:  BSF    0A.3
15BD:  GOTO   664
15BE:  BSF    0A.4
15BF:  BCF    0A.3
....................                    DELAY_MS (200) ; 
15C0:  MOVLW  C8
15C1:  BSF    03.6
15C2:  MOVWF  46
15C3:  BCF    0A.4
15C4:  BCF    03.6
15C5:  CALL   16C
15C6:  BSF    0A.4
....................                 } 
....................              } 
15C7:  GOTO   59B
....................           } 
....................        } 
15C8:  GOTO   58D
....................     } 
....................  } 
....................  
15C9:  SLEEP

Configuration Fuses:
   Word  1: 2FE2   HS NOWDT PUT MCLR NOPROTECT NOCPD BROWNOUT IESO FCMEN NOLVP NODEBUG
   Word  2: 3FFF   BORV40 NOWRT
