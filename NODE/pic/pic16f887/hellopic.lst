CCS PCM C Compiler, Version 5.015, 5967               30-Nov-21 00:45

               Filename:   E:\DATN_V2\NODE\pic\pic16f887\hellopic.lst

               ROM used:   7083 words (86%)
                           Largest free fragment is 921
               RAM used:   209 (57%) at main() level
                           300 (82%) worst case
               Stack used: 8 locations (7 in main + 1 for interrupts)
               Stack size: 8

*
0000:  MOVLW  1A
0001:  MOVWF  0A
0002:  GOTO   2DD
0003:  NOP
0004:  MOVWF  7F
0005:  SWAPF  03,W
0006:  CLRF   03
0007:  MOVWF  21
0008:  MOVF   0A,W
0009:  MOVWF  20
000A:  CLRF   0A
000B:  MOVF   04,W
000C:  MOVWF  22
000D:  MOVF   77,W
000E:  MOVWF  23
000F:  MOVF   78,W
0010:  MOVWF  24
0011:  MOVF   79,W
0012:  MOVWF  25
0013:  MOVF   7A,W
0014:  MOVWF  26
0015:  BSF    03.6
0016:  MOVF   0D,W
0017:  BCF    03.6
0018:  MOVWF  27
0019:  BSF    03.6
001A:  MOVF   0F,W
001B:  BCF    03.6
001C:  MOVWF  28
001D:  BSF    03.6
001E:  MOVF   0C,W
001F:  BCF    03.6
0020:  MOVWF  29
0021:  BSF    03.6
0022:  MOVF   0E,W
0023:  BCF    03.6
0024:  MOVWF  2A
0025:  BCF    03.7
0026:  BCF    03.5
0027:  BTFSS  0B.4
0028:  GOTO   02B
0029:  BTFSC  0B.1
002A:  GOTO   052
002B:  MOVLW  8C
002C:  MOVWF  04
002D:  BTFSS  00.5
002E:  GOTO   031
002F:  BTFSC  0C.5
0030:  GOTO   055
0031:  MOVF   22,W
0032:  MOVWF  04
0033:  MOVF   23,W
0034:  MOVWF  77
0035:  MOVF   24,W
0036:  MOVWF  78
0037:  MOVF   25,W
0038:  MOVWF  79
0039:  MOVF   26,W
003A:  MOVWF  7A
003B:  MOVF   27,W
003C:  BSF    03.6
003D:  MOVWF  0D
003E:  BCF    03.6
003F:  MOVF   28,W
0040:  BSF    03.6
0041:  MOVWF  0F
0042:  BCF    03.6
0043:  MOVF   29,W
0044:  BSF    03.6
0045:  MOVWF  0C
0046:  BCF    03.6
0047:  MOVF   2A,W
0048:  BSF    03.6
0049:  MOVWF  0E
004A:  BCF    03.6
004B:  MOVF   20,W
004C:  MOVWF  0A
004D:  SWAPF  21,W
004E:  MOVWF  03
004F:  SWAPF  7F,F
0050:  SWAPF  7F,W
0051:  RETFIE
0052:  BCF    0A.3
0053:  BCF    0A.4
0054:  GOTO   103
0055:  BCF    0A.3
0056:  BCF    0A.4
0057:  GOTO   153
....................  
.................... #INCLUDE <thuvien.c> 
.................... #INCLUDE <16F887.H> 
.................... //////////// Standard Header file for the PIC16F887 device //////////////// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2013 Custom Computer Services          //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... #device PIC16F887 
0058:  BCF    0A.0
0059:  BCF    0A.1
005A:  BCF    0A.2
005B:  ADDWF  02,F
005C:  RETLW  30
005D:  RETLW  00
005E:  BCF    0A.0
005F:  BCF    0A.1
0060:  BCF    0A.2
0061:  ADDWF  02,F
0062:  RETLW  5F
0063:  RETLW  00
0064:  BCF    0A.0
0065:  BCF    0A.1
0066:  BCF    0A.2
0067:  ADDWF  02,F
0068:  RETLW  32
0069:  RETLW  32
006A:  RETLW  00
006B:  BCF    0A.0
006C:  BCF    0A.1
006D:  BCF    0A.2
006E:  ADDWF  02,F
006F:  RETLW  32
0070:  RETLW  33
0071:  RETLW  00
0072:  BCF    0A.0
0073:  BCF    0A.1
0074:  BCF    0A.2
0075:  ADDWF  02,F
0076:  RETLW  32
0077:  RETLW  34
0078:  RETLW  00
0079:  BCF    0A.0
007A:  BCF    0A.1
007B:  BCF    0A.2
007C:  ADDWF  02,F
007D:  RETLW  00
007E:  DATA CE,27
007F:  DATA C4,22
0080:  DATA 3A,10
0081:  DATA 00,00
0082:  DATA 20,10
0083:  DATA 20,10
0084:  DATA 20,10
0085:  DATA 20,10
0086:  DATA 20,10
0087:  DATA 00,01
0088:  DATA 20,10
0089:  DATA 20,10
008A:  DATA 20,10
008B:  DATA 5F,10
008C:  DATA 20,10
008D:  DATA 20,10
008E:  DATA 20,10
008F:  DATA 20,10
0090:  DATA 20,10
0091:  DATA 20,10
0092:  DATA 20,00
0093:  DATA 20,10
0094:  DATA 20,10
0095:  DATA 5F,10
0096:  DATA 20,10
0097:  DATA 20,00
0098:  DATA 49,22
0099:  DATA DF,23
009A:  DATA 57,1D
009B:  DATA 00,01
009C:  DATA 20,10
009D:  DATA 20,10
009E:  DATA 20,10
009F:  DATA 20,10
00A0:  DATA 20,10
00A1:  DATA 00,01
00A2:  DATA 20,10
00A3:  DATA 20,10
00A4:  DATA 20,10
00A5:  DATA 5F,10
00A6:  DATA 20,10
00A7:  DATA 20,10
00A8:  DATA 20,10
00A9:  DATA 20,10
00AA:  DATA 20,10
00AB:  DATA 20,10
00AC:  DATA 20,10
00AD:  DATA 20,00
00AE:  DATA 20,10
00AF:  DATA 20,10
00B0:  DATA 5F,10
00B1:  DATA 20,10
00B2:  DATA 20,10
00B3:  DATA 20,10
00B4:  DATA 20,00
00B5:  DATA C3,27
00B6:  DATA 4E,23
00B7:  DATA C9,23
00B8:  DATA 3A,10
00B9:  DATA 20,10
00BA:  DATA 20,10
00BB:  DATA 20,10
00BC:  DATA 20,00
00BD:  DATA C3,20
00BE:  DATA D3,22
00BF:  DATA 3A,10
00C0:  DATA 20,10
00C1:  DATA 20,10
00C2:  DATA 20,10
00C3:  DATA 20,10
00C4:  DATA 20,00
00C5:  DATA A0,16
00C6:  DATA A0,24
00C7:  DATA C4,16
00C8:  DATA CE,27
00C9:  DATA C4,22
00CA:  DATA 20,10
00CB:  DATA 20,10
00CC:  DATA 20,10
00CD:  DATA 00,01
00CE:  DATA A0,16
00CF:  DATA A0,24
00D0:  DATA C4,16
00D1:  DATA C7,2B
00D2:  DATA 20,10
00D3:  DATA 20,10
00D4:  DATA 20,10
00D5:  DATA 20,00
00D6:  DATA D7,20
00D7:  DATA 49,2A
00D8:  DATA 49,27
00D9:  DATA 47,10
00DA:  DATA 2E,17
00DB:  DATA 2E,17
00DC:  DATA 20,10
00DD:  DATA 20,10
00DE:  DATA 20,10
00DF:  DATA 20,10
00E0:  DATA 00,01
00E1:  DATA D7,20
00E2:  DATA 49,2A
00E3:  DATA 49,27
00E4:  DATA 47,10
00E5:  DATA 2E,17
00E6:  DATA 2E,17
00E7:  DATA 20,10
00E8:  DATA 20,10
00E9:  DATA 20,10
00EA:  DATA 20,10
00EB:  DATA 00,00
00EC:  DATA 20,10
00ED:  DATA 20,10
00EE:  DATA 20,10
00EF:  DATA 20,10
00F0:  DATA 20,10
00F1:  DATA 20,10
00F2:  DATA 00,01
00F3:  DATA 54,21
00F4:  DATA 3A,10
00F5:  DATA 00,01
00F6:  DATA 20,10
00F7:  DATA 20,10
00F8:  DATA 43,21
00F9:  DATA 3A,00
00FA:  DATA 40,22
00FB:  DATA 4B,20
00FC:  DATA 00,00
00FD:  DATA D3,2B
00FE:  DATA 3A,10
00FF:  DATA 00,01
0100:  DATA C0,29
0101:  DATA 53,20
0102:  DATA 00,01
*
0170:  DATA E8,34
0171:  DATA E8,34
0172:  DATA E8,37
0173:  DATA 61,37
0174:  DATA 67,00
0175:  DATA 43,24
0176:  DATA C1,27
0177:  DATA C8,27
0178:  DATA 41,27
0179:  DATA 47,00
*
0348:  MOVF   0B,W
0349:  BSF    03.6
034A:  MOVWF  5E
034B:  BCF    03.6
034C:  BCF    0B.7
034D:  BSF    03.5
034E:  BSF    03.6
034F:  BSF    0C.7
0350:  BSF    0C.0
0351:  NOP
0352:  NOP
0353:  BCF    03.5
0354:  BTFSS  5E.7
0355:  GOTO   359
0356:  BCF    03.6
0357:  BSF    0B.7
0358:  BSF    03.6
0359:  MOVF   0C,W
035A:  ANDLW  7F
035B:  BTFSC  03.2
035C:  GOTO   396
035D:  MOVWF  5E
035E:  MOVF   0D,W
035F:  MOVWF  5F
0360:  MOVF   0F,W
0361:  MOVWF  60
0362:  MOVF   5E,W
0363:  MOVWF  61
0364:  BCF    03.6
0365:  CALL   30E
0366:  BSF    03.6
0367:  MOVF   5F,W
0368:  MOVWF  0D
0369:  MOVF   60,W
036A:  MOVWF  0F
036B:  BCF    03.6
036C:  MOVF   0B,W
036D:  BSF    03.6
036E:  MOVWF  61
036F:  BCF    03.6
0370:  BCF    0B.7
0371:  BSF    03.5
0372:  BSF    03.6
0373:  BSF    0C.7
0374:  BSF    0C.0
0375:  NOP
0376:  NOP
0377:  BCF    03.5
0378:  BTFSS  61.7
0379:  GOTO   37D
037A:  BCF    03.6
037B:  BSF    0B.7
037C:  BSF    03.6
037D:  RLF    0C,W
037E:  RLF    0E,W
037F:  ANDLW  7F
0380:  BTFSC  03.2
0381:  GOTO   396
0382:  MOVWF  5E
0383:  MOVF   0D,W
0384:  MOVWF  5F
0385:  MOVF   0F,W
0386:  MOVWF  60
0387:  MOVF   5E,W
0388:  MOVWF  61
0389:  BCF    03.6
038A:  CALL   30E
038B:  BSF    03.6
038C:  MOVF   5F,W
038D:  MOVWF  0D
038E:  MOVF   60,W
038F:  MOVWF  0F
0390:  INCF   0D,F
0391:  BTFSC  03.2
0392:  INCF   0F,F
0393:  BCF    03.6
0394:  GOTO   348
0395:  BSF    03.6
0396:  BCF    03.6
0397:  RETURN
*
03C9:  BTFSC  03.1
03CA:  GOTO   3CE
03CB:  MOVLW  A3
03CC:  MOVWF  04
03CD:  BSF    03.7
03CE:  BSF    03.5
03CF:  BSF    03.6
03D0:  MOVF   1E,W
03D1:  XORWF  22,W
03D2:  ANDLW  80
03D3:  MOVWF  28
03D4:  BTFSS  1E.7
03D5:  GOTO   3E1
03D6:  COMF   1B,F
03D7:  COMF   1C,F
03D8:  COMF   1D,F
03D9:  COMF   1E,F
03DA:  INCF   1B,F
03DB:  BTFSC  03.2
03DC:  INCF   1C,F
03DD:  BTFSC  03.2
03DE:  INCF   1D,F
03DF:  BTFSC  03.2
03E0:  INCF   1E,F
03E1:  BTFSS  22.7
03E2:  GOTO   3EE
03E3:  COMF   1F,F
03E4:  COMF   20,F
03E5:  COMF   21,F
03E6:  COMF   22,F
03E7:  INCF   1F,F
03E8:  BTFSC  03.2
03E9:  INCF   20,F
03EA:  BTFSC  03.2
03EB:  INCF   21,F
03EC:  BTFSC  03.2
03ED:  INCF   22,F
03EE:  CLRF   77
03EF:  CLRF   78
03F0:  CLRF   79
03F1:  CLRF   7A
03F2:  CLRF   23
03F3:  CLRF   24
03F4:  CLRF   25
03F5:  CLRF   26
03F6:  MOVF   22,W
03F7:  IORWF  21,W
03F8:  IORWF  20,W
03F9:  IORWF  1F,W
03FA:  BTFSC  03.2
03FB:  GOTO   42C
03FC:  MOVLW  20
03FD:  MOVWF  27
03FE:  BCF    03.0
03FF:  RLF    1B,F
0400:  RLF    1C,F
0401:  RLF    1D,F
0402:  RLF    1E,F
0403:  RLF    23,F
0404:  RLF    24,F
0405:  RLF    25,F
0406:  RLF    26,F
0407:  MOVF   22,W
0408:  SUBWF  26,W
0409:  BTFSS  03.2
040A:  GOTO   415
040B:  MOVF   21,W
040C:  SUBWF  25,W
040D:  BTFSS  03.2
040E:  GOTO   415
040F:  MOVF   20,W
0410:  SUBWF  24,W
0411:  BTFSS  03.2
0412:  GOTO   415
0413:  MOVF   1F,W
0414:  SUBWF  23,W
0415:  BTFSS  03.0
0416:  GOTO   426
0417:  MOVF   1F,W
0418:  SUBWF  23,F
0419:  MOVF   20,W
041A:  BTFSS  03.0
041B:  INCFSZ 20,W
041C:  SUBWF  24,F
041D:  MOVF   21,W
041E:  BTFSS  03.0
041F:  INCFSZ 21,W
0420:  SUBWF  25,F
0421:  MOVF   22,W
0422:  BTFSS  03.0
0423:  INCFSZ 22,W
0424:  SUBWF  26,F
0425:  BSF    03.0
0426:  RLF    77,F
0427:  RLF    78,F
0428:  RLF    79,F
0429:  RLF    7A,F
042A:  DECFSZ 27,F
042B:  GOTO   3FE
042C:  BTFSS  28.7
042D:  GOTO   439
042E:  COMF   77,F
042F:  COMF   78,F
0430:  COMF   79,F
0431:  COMF   7A,F
0432:  INCF   77,F
0433:  BTFSC  03.2
0434:  INCF   78,F
0435:  BTFSC  03.2
0436:  INCF   79,F
0437:  BTFSC  03.2
0438:  INCF   7A,F
0439:  MOVF   23,W
043A:  MOVWF  00
043B:  INCF   04,F
043C:  MOVF   24,W
043D:  MOVWF  00
043E:  INCF   04,F
043F:  MOVF   25,W
0440:  MOVWF  00
0441:  INCF   04,F
0442:  MOVF   26,W
0443:  MOVWF  00
0444:  BCF    03.5
0445:  BCF    03.6
0446:  RETURN
*
046B:  MOVLW  20
046C:  MOVWF  1F
046D:  CLRF   1B
046E:  CLRF   1C
046F:  CLRF   1D
0470:  CLRF   1E
0471:  MOVF   16,W
0472:  MOVWF  7A
0473:  MOVF   15,W
0474:  MOVWF  79
0475:  MOVF   14,W
0476:  MOVWF  78
0477:  MOVF   13,W
0478:  MOVWF  77
0479:  BCF    03.0
047A:  BTFSS  77.0
047B:  GOTO   48A
047C:  MOVF   17,W
047D:  ADDWF  1B,F
047E:  MOVF   18,W
047F:  BTFSC  03.0
0480:  INCFSZ 18,W
0481:  ADDWF  1C,F
0482:  MOVF   19,W
0483:  BTFSC  03.0
0484:  INCFSZ 19,W
0485:  ADDWF  1D,F
0486:  MOVF   1A,W
0487:  BTFSC  03.0
0488:  INCFSZ 1A,W
0489:  ADDWF  1E,F
048A:  RRF    1E,F
048B:  RRF    1D,F
048C:  RRF    1C,F
048D:  RRF    1B,F
048E:  RRF    7A,F
048F:  RRF    79,F
0490:  RRF    78,F
0491:  RRF    77,F
0492:  DECFSZ 1F,F
0493:  GOTO   479
*
05E3:  MOVF   00,F
05E4:  BTFSC  03.2
05E5:  GOTO   600
05E6:  BSF    03.6
05E7:  CLRF   67
05E8:  MOVF   04,W
05E9:  MOVWF  66
05EA:  BCF    67.0
05EB:  BTFSC  03.7
05EC:  BSF    67.0
05ED:  MOVF   00,W
05EE:  BCF    03.6
05EF:  BTFSS  0C.4
05F0:  GOTO   5EF
05F1:  MOVWF  19
05F2:  BSF    03.6
05F3:  MOVF   66,W
05F4:  MOVWF  04
05F5:  BCF    03.7
05F6:  BTFSC  67.0
05F7:  BSF    03.7
05F8:  INCF   04,F
05F9:  BTFSS  03.2
05FA:  GOTO   5FE
05FB:  BCF    03.6
05FC:  INCF   05,F
05FD:  BSF    03.6
05FE:  BCF    03.6
05FF:  GOTO   5E3
0600:  RETURN
*
075F:  MOVF   00,F
0760:  BTFSC  03.2
0761:  GOTO   77B
0762:  BSF    03.6
0763:  CLRF   3F
0764:  MOVF   04,W
0765:  MOVWF  3E
0766:  BCF    3F.0
0767:  BTFSC  03.7
0768:  BSF    3F.0
0769:  MOVF   00,W
076A:  MOVWF  61
076B:  BCF    03.6
076C:  CALL   30E
076D:  BSF    03.6
076E:  MOVF   3E,W
076F:  MOVWF  04
0770:  BCF    03.7
0771:  BTFSC  3F.0
0772:  BSF    03.7
0773:  INCF   04,F
0774:  BTFSS  03.2
0775:  GOTO   779
0776:  BCF    03.6
0777:  INCF   05,F
0778:  BSF    03.6
0779:  BCF    03.6
077A:  GOTO   75F
077B:  RETURN
077C:  BSF    03.6
077D:  MOVF   36,W
077E:  CLRF   78
077F:  SUBWF  35,W
0780:  BTFSC  03.0
0781:  GOTO   785
0782:  MOVF   35,W
0783:  MOVWF  77
0784:  GOTO   791
0785:  CLRF   77
0786:  MOVLW  08
0787:  MOVWF  37
0788:  RLF    35,F
0789:  RLF    77,F
078A:  MOVF   36,W
078B:  SUBWF  77,W
078C:  BTFSC  03.0
078D:  MOVWF  77
078E:  RLF    78,F
078F:  DECFSZ 37,F
0790:  GOTO   788
0791:  BCF    03.6
0792:  RETURN
0793:  CLRF   77
0794:  CLRF   78
0795:  BSF    03.6
0796:  MOVF   44,W
0797:  BCF    03.0
0798:  BTFSC  45.0
0799:  ADDWF  77,F
079A:  RRF    77,F
079B:  RRF    78,F
079C:  BTFSC  45.1
079D:  ADDWF  77,F
079E:  RRF    77,F
079F:  RRF    78,F
07A0:  BTFSC  45.2
07A1:  ADDWF  77,F
07A2:  RRF    77,F
07A3:  RRF    78,F
07A4:  BTFSC  45.3
07A5:  ADDWF  77,F
07A6:  RRF    77,F
07A7:  RRF    78,F
07A8:  BTFSC  45.4
07A9:  ADDWF  77,F
07AA:  RRF    77,F
07AB:  RRF    78,F
07AC:  BTFSC  45.5
07AD:  ADDWF  77,F
07AE:  RRF    77,F
07AF:  RRF    78,F
07B0:  BTFSC  45.6
07B1:  ADDWF  77,F
07B2:  RRF    77,F
07B3:  RRF    78,F
07B4:  BTFSC  45.7
07B5:  ADDWF  77,F
07B6:  RRF    77,F
07B7:  RRF    78,F
07B8:  BCF    03.6
07B9:  RETURN
*
0C39:  BSF    03.6
0C3A:  MOVF   3E,W
0C3B:  ANDLW  07
0C3C:  MOVWF  77
0C3D:  RRF    3E,W
0C3E:  MOVWF  78
0C3F:  RRF    78,F
0C40:  RRF    78,F
0C41:  MOVLW  1F
0C42:  ANDWF  78,F
0C43:  MOVF   78,W
0C44:  ADDWF  40,W
0C45:  MOVWF  04
0C46:  BCF    03.7
0C47:  BTFSC  41.0
0C48:  BSF    03.7
0C49:  CLRF   78
0C4A:  INCF   78,F
0C4B:  INCF   77,F
0C4C:  GOTO   44E
0C4D:  RLF    78,F
0C4E:  DECFSZ 77,F
0C4F:  GOTO   44D
0C50:  MOVF   3F,F
0C51:  BTFSC  03.2
0C52:  GOTO   456
0C53:  MOVF   78,W
0C54:  IORWF  00,F
0C55:  GOTO   459
0C56:  COMF   78,F
0C57:  MOVF   78,W
0C58:  ANDWF  00,F
0C59:  BCF    03.6
0C5A:  RETURN
0C5B:  BSF    03.6
0C5C:  MOVF   41,W
0C5D:  ANDLW  07
0C5E:  MOVWF  77
0C5F:  RRF    41,W
0C60:  MOVWF  78
0C61:  RRF    78,F
0C62:  RRF    78,F
0C63:  MOVLW  1F
0C64:  ANDWF  78,F
0C65:  MOVF   78,W
0C66:  ADDWF  42,W
0C67:  MOVWF  04
0C68:  BCF    03.7
0C69:  BTFSC  43.0
0C6A:  BSF    03.7
0C6B:  MOVF   00,W
0C6C:  MOVWF  78
0C6D:  INCF   77,F
0C6E:  GOTO   470
0C6F:  RRF    78,F
0C70:  DECFSZ 77,F
0C71:  GOTO   46F
0C72:  BCF    03.6
0C73:  RETURN
0C74:  MOVF   0B,W
0C75:  BSF    03.6
0C76:  MOVWF  64
0C77:  BCF    03.6
0C78:  BCF    0B.7
0C79:  BSF    03.5
0C7A:  BSF    03.6
0C7B:  BSF    0C.7
0C7C:  BSF    0C.0
0C7D:  NOP
0C7E:  NOP
0C7F:  BCF    03.5
0C80:  BTFSS  64.7
0C81:  GOTO   485
0C82:  BCF    03.6
0C83:  BSF    0B.7
0C84:  BSF    03.6
0C85:  MOVF   0C,W
0C86:  ANDLW  7F
0C87:  BTFSC  03.2
0C88:  GOTO   4C4
0C89:  MOVWF  64
0C8A:  MOVF   0D,W
0C8B:  MOVWF  65
0C8C:  MOVF   0F,W
0C8D:  MOVWF  66
0C8E:  MOVF   64,W
0C8F:  BCF    03.6
0C90:  BTFSS  0C.4
0C91:  GOTO   490
0C92:  MOVWF  19
0C93:  BSF    03.6
0C94:  MOVF   65,W
0C95:  MOVWF  0D
0C96:  MOVF   66,W
0C97:  MOVWF  0F
0C98:  BCF    03.6
0C99:  MOVF   0B,W
0C9A:  BSF    03.6
0C9B:  MOVWF  67
0C9C:  BCF    03.6
0C9D:  BCF    0B.7
0C9E:  BSF    03.5
0C9F:  BSF    03.6
0CA0:  BSF    0C.7
0CA1:  BSF    0C.0
0CA2:  NOP
0CA3:  NOP
0CA4:  BCF    03.5
0CA5:  BTFSS  67.7
0CA6:  GOTO   4AA
0CA7:  BCF    03.6
0CA8:  BSF    0B.7
0CA9:  BSF    03.6
0CAA:  RLF    0C,W
0CAB:  RLF    0E,W
0CAC:  ANDLW  7F
0CAD:  BTFSC  03.2
0CAE:  GOTO   4C4
0CAF:  MOVWF  64
0CB0:  MOVF   0D,W
0CB1:  MOVWF  65
0CB2:  MOVF   0F,W
0CB3:  MOVWF  66
0CB4:  MOVF   64,W
0CB5:  BCF    03.6
0CB6:  BTFSS  0C.4
0CB7:  GOTO   4B6
0CB8:  MOVWF  19
0CB9:  BSF    03.6
0CBA:  MOVF   65,W
0CBB:  MOVWF  0D
0CBC:  MOVF   66,W
0CBD:  MOVWF  0F
0CBE:  INCF   0D,F
0CBF:  BTFSC  03.2
0CC0:  INCF   0F,F
0CC1:  BCF    03.6
0CC2:  GOTO   474
0CC3:  BSF    03.6
0CC4:  BCF    03.6
0CC5:  RETURN
*
1298:  BCF    0A.0
1299:  BSF    0A.1
129A:  BCF    0A.2
129B:  ADDWF  02,F
129C:  GOTO   09E
129D:  GOTO   0AB
129E:  GOTO   0B8
129F:  GOTO   0C6
12A0:  GOTO   0D4
12A1:  MOVLW  80
12A2:  BTFSS  03.1
12A3:  GOTO   2A9
12A4:  BSF    03.5
12A5:  BSF    03.6
12A6:  XORWF  1D,F
12A7:  BCF    03.5
12A8:  BCF    03.6
12A9:  BSF    03.5
12AA:  BSF    03.6
12AB:  CLRF   22
12AC:  CLRF   23
12AD:  MOVF   19,W
12AE:  MOVWF  21
12AF:  MOVF   1D,W
12B0:  XORWF  21,F
12B1:  MOVF   18,W
12B2:  BTFSC  03.2
12B3:  GOTO   398
12B4:  MOVWF  20
12B5:  MOVWF  77
12B6:  MOVF   1C,W
12B7:  BTFSC  03.2
12B8:  GOTO   3A1
12B9:  SUBWF  20,F
12BA:  BTFSC  03.2
12BB:  GOTO   33D
12BC:  BTFSS  03.0
12BD:  GOTO   2FB
12BE:  MOVF   1D,W
12BF:  MOVWF  26
12C0:  BSF    26.7
12C1:  MOVF   1E,W
12C2:  MOVWF  25
12C3:  MOVF   1F,W
12C4:  MOVWF  24
12C5:  CLRF   23
12C6:  BCF    03.0
12C7:  RRF    26,F
12C8:  RRF    25,F
12C9:  RRF    24,F
12CA:  RRF    23,F
12CB:  DECFSZ 20,F
12CC:  GOTO   2C5
12CD:  BTFSS  21.7
12CE:  GOTO   2D2
12CF:  BSF    22.0
12D0:  GOTO   3B5
12D1:  BCF    22.0
12D2:  BCF    20.0
12D3:  BSF    22.4
12D4:  MOVLW  9B
12D5:  MOVWF  04
12D6:  BSF    03.7
12D7:  GOTO   3CA
12D8:  BCF    22.4
12D9:  BTFSC  21.7
12DA:  GOTO   2E5
12DB:  BTFSS  20.0
12DC:  GOTO   2F0
12DD:  RRF    26,F
12DE:  RRF    25,F
12DF:  RRF    24,F
12E0:  RRF    23,F
12E1:  INCF   77,F
12E2:  BTFSC  03.2
12E3:  GOTO   3B0
12E4:  GOTO   2F0
12E5:  BTFSC  26.7
12E6:  GOTO   2F3
12E7:  BCF    03.0
12E8:  RLF    23,F
12E9:  RLF    24,F
12EA:  RLF    25,F
12EB:  RLF    26,F
12EC:  DECF   77,F
12ED:  BTFSC  03.2
12EE:  GOTO   3B0
12EF:  GOTO   2E5
12F0:  BSF    22.6
12F1:  GOTO   35D
12F2:  BCF    22.6
12F3:  MOVF   19,W
12F4:  MOVWF  21
12F5:  BTFSS  21.7
12F6:  GOTO   2F9
12F7:  BSF    26.7
12F8:  GOTO   3A9
12F9:  BCF    26.7
12FA:  GOTO   3A9
12FB:  MOVF   1C,W
12FC:  MOVWF  20
12FD:  MOVWF  77
12FE:  MOVF   18,W
12FF:  SUBWF  20,F
1300:  MOVF   19,W
1301:  MOVWF  26
1302:  BSF    26.7
1303:  MOVF   1A,W
1304:  MOVWF  25
1305:  MOVF   1B,W
1306:  MOVWF  24
1307:  CLRF   23
1308:  BCF    03.0
1309:  RRF    26,F
130A:  RRF    25,F
130B:  RRF    24,F
130C:  RRF    23,F
130D:  DECFSZ 20,F
130E:  GOTO   307
130F:  BTFSS  21.7
1310:  GOTO   314
1311:  BSF    22.1
1312:  GOTO   3B5
1313:  BCF    22.1
1314:  BCF    20.0
1315:  BSF    22.5
1316:  MOVLW  9F
1317:  MOVWF  04
1318:  BSF    03.7
1319:  GOTO   3CA
131A:  BCF    22.5
131B:  BTFSC  21.7
131C:  GOTO   327
131D:  BTFSS  20.0
131E:  GOTO   332
131F:  RRF    26,F
1320:  RRF    25,F
1321:  RRF    24,F
1322:  RRF    23,F
1323:  INCF   77,F
1324:  BTFSC  03.2
1325:  GOTO   3B0
1326:  GOTO   332
1327:  BTFSC  26.7
1328:  GOTO   335
1329:  BCF    03.0
132A:  RLF    23,F
132B:  RLF    24,F
132C:  RLF    25,F
132D:  RLF    26,F
132E:  DECF   77,F
132F:  BTFSC  03.2
1330:  GOTO   3B0
1331:  GOTO   327
1332:  BSF    22.7
1333:  GOTO   35D
1334:  BCF    22.7
1335:  MOVF   1D,W
1336:  MOVWF  21
1337:  BTFSS  21.7
1338:  GOTO   33B
1339:  BSF    26.7
133A:  GOTO   3A9
133B:  BCF    26.7
133C:  GOTO   3A9
133D:  MOVF   1D,W
133E:  MOVWF  26
133F:  BSF    26.7
1340:  MOVF   1E,W
1341:  MOVWF  25
1342:  MOVF   1F,W
1343:  MOVWF  24
1344:  BTFSS  21.7
1345:  GOTO   34A
1346:  BCF    26.7
1347:  BSF    22.2
1348:  GOTO   3B5
1349:  BCF    22.2
134A:  CLRF   23
134B:  BCF    20.0
134C:  MOVLW  9B
134D:  MOVWF  04
134E:  BSF    03.7
134F:  GOTO   3CA
1350:  BTFSC  21.7
1351:  GOTO   373
1352:  MOVF   19,W
1353:  MOVWF  21
1354:  BTFSS  20.0
1355:  GOTO   35D
1356:  RRF    26,F
1357:  RRF    25,F
1358:  RRF    24,F
1359:  RRF    23,F
135A:  INCF   77,F
135B:  BTFSC  03.2
135C:  GOTO   3B0
135D:  BTFSS  23.7
135E:  GOTO   36E
135F:  INCF   24,F
1360:  BTFSS  03.2
1361:  GOTO   36E
1362:  INCF   25,F
1363:  BTFSS  03.2
1364:  GOTO   36E
1365:  INCF   26,F
1366:  BTFSS  03.2
1367:  GOTO   36E
1368:  RRF    26,F
1369:  RRF    25,F
136A:  RRF    24,F
136B:  INCF   77,F
136C:  BTFSC  03.2
136D:  GOTO   3B0
136E:  BTFSC  22.6
136F:  GOTO   2F2
1370:  BTFSC  22.7
1371:  GOTO   334
1372:  GOTO   392
1373:  MOVLW  80
1374:  XORWF  26,F
1375:  BTFSS  26.7
1376:  GOTO   37B
1377:  GOTO   3B5
1378:  MOVF   1D,W
1379:  MOVWF  21
137A:  GOTO   388
137B:  MOVF   19,W
137C:  MOVWF  21
137D:  MOVF   26,F
137E:  BTFSS  03.2
137F:  GOTO   388
1380:  MOVF   25,F
1381:  BTFSS  03.2
1382:  GOTO   388
1383:  MOVF   24,F
1384:  BTFSS  03.2
1385:  GOTO   388
1386:  CLRF   77
1387:  GOTO   3A9
1388:  BTFSC  26.7
1389:  GOTO   392
138A:  BCF    03.0
138B:  RLF    23,F
138C:  RLF    24,F
138D:  RLF    25,F
138E:  RLF    26,F
138F:  DECFSZ 77,F
1390:  GOTO   388
1391:  GOTO   3B0
1392:  BTFSS  21.7
1393:  GOTO   396
1394:  BSF    26.7
1395:  GOTO   3A9
1396:  BCF    26.7
1397:  GOTO   3A9
1398:  MOVF   1C,W
1399:  MOVWF  77
139A:  MOVF   1D,W
139B:  MOVWF  26
139C:  MOVF   1E,W
139D:  MOVWF  25
139E:  MOVF   1F,W
139F:  MOVWF  24
13A0:  GOTO   3A9
13A1:  MOVF   18,W
13A2:  MOVWF  77
13A3:  MOVF   19,W
13A4:  MOVWF  26
13A5:  MOVF   1A,W
13A6:  MOVWF  25
13A7:  MOVF   1B,W
13A8:  MOVWF  24
13A9:  MOVF   26,W
13AA:  MOVWF  78
13AB:  MOVF   25,W
13AC:  MOVWF  79
13AD:  MOVF   24,W
13AE:  MOVWF  7A
13AF:  GOTO   3E8
13B0:  CLRF   77
13B1:  CLRF   78
13B2:  CLRF   79
13B3:  CLRF   7A
13B4:  GOTO   3E8
13B5:  CLRF   23
13B6:  COMF   24,F
13B7:  COMF   25,F
13B8:  COMF   26,F
13B9:  COMF   23,F
13BA:  INCF   23,F
13BB:  BTFSS  03.2
13BC:  GOTO   3C3
13BD:  INCF   24,F
13BE:  BTFSS  03.2
13BF:  GOTO   3C3
13C0:  INCF   25,F
13C1:  BTFSC  03.2
13C2:  INCF   26,F
13C3:  BTFSC  22.0
13C4:  GOTO   2D1
13C5:  BTFSC  22.1
13C6:  GOTO   313
13C7:  BTFSC  22.2
13C8:  GOTO   349
13C9:  GOTO   378
13CA:  MOVF   00,W
13CB:  ADDWF  24,F
13CC:  BTFSS  03.0
13CD:  GOTO   3D4
13CE:  INCF   25,F
13CF:  BTFSS  03.2
13D0:  GOTO   3D4
13D1:  INCF   26,F
13D2:  BTFSC  03.2
13D3:  BSF    20.0
13D4:  DECF   04,F
13D5:  MOVF   00,W
13D6:  ADDWF  25,F
13D7:  BTFSS  03.0
13D8:  GOTO   3DC
13D9:  INCF   26,F
13DA:  BTFSC  03.2
13DB:  BSF    20.0
13DC:  DECF   04,F
13DD:  MOVF   00,W
13DE:  BTFSS  00.7
13DF:  XORLW  80
13E0:  ADDWF  26,F
13E1:  BTFSC  03.0
13E2:  BSF    20.0
13E3:  BTFSC  22.4
13E4:  GOTO   2D8
13E5:  BTFSC  22.5
13E6:  GOTO   31A
13E7:  GOTO   350
13E8:  BCF    03.5
13E9:  BCF    03.6
13EA:  RETURN
*
14C4:  CLRF   78
14C5:  CLRF   79
14C6:  CLRF   77
14C7:  CLRF   7A
14C8:  MOVF   48,W
14C9:  BTFSS  03.2
14CA:  GOTO   4CE
14CB:  MOVF   47,W
14CC:  BTFSC  03.2
14CD:  GOTO   4E8
14CE:  MOVLW  10
14CF:  MOVWF  49
14D0:  BCF    03.0
14D1:  RLF    45,F
14D2:  RLF    46,F
14D3:  RLF    77,F
14D4:  RLF    7A,F
14D5:  MOVF   48,W
14D6:  SUBWF  7A,W
14D7:  BTFSS  03.2
14D8:  GOTO   4DB
14D9:  MOVF   47,W
14DA:  SUBWF  77,W
14DB:  BTFSS  03.0
14DC:  GOTO   4E4
14DD:  MOVF   47,W
14DE:  SUBWF  77,F
14DF:  BTFSS  03.0
14E0:  DECF   7A,F
14E1:  MOVF   48,W
14E2:  SUBWF  7A,F
14E3:  BSF    03.0
14E4:  RLF    78,F
14E5:  RLF    79,F
14E6:  DECFSZ 49,F
14E7:  GOTO   4D0
*
1509:  MOVLW  8E
150A:  MOVWF  77
150B:  MOVF   36,W
150C:  MOVWF  78
150D:  MOVF   35,W
150E:  MOVWF  79
150F:  CLRF   7A
1510:  BTFSS  36.7
1511:  GOTO   517
1512:  COMF   78,F
1513:  COMF   79,F
1514:  INCF   79,F
1515:  BTFSC  03.2
1516:  INCF   78,F
1517:  MOVF   78,F
1518:  BTFSS  03.2
1519:  GOTO   524
151A:  MOVF   79,W
151B:  MOVWF  78
151C:  CLRF   79
151D:  MOVLW  08
151E:  SUBWF  77,F
151F:  MOVF   78,F
1520:  BTFSS  03.2
1521:  GOTO   524
1522:  CLRF   77
1523:  GOTO   52D
1524:  BCF    03.0
1525:  BTFSC  78.7
1526:  GOTO   52B
1527:  RLF    79,F
1528:  RLF    78,F
1529:  DECF   77,F
152A:  GOTO   524
152B:  BTFSS  36.7
152C:  BCF    78.7
*
1542:  MOVF   39,W
1543:  BTFSC  03.2
1544:  GOTO   607
1545:  MOVWF  45
1546:  MOVF   3D,W
1547:  BTFSC  03.2
1548:  GOTO   607
1549:  SUBWF  45,F
154A:  BTFSS  03.0
154B:  GOTO   551
154C:  MOVLW  7F
154D:  ADDWF  45,F
154E:  BTFSC  03.0
154F:  GOTO   607
1550:  GOTO   557
1551:  MOVLW  81
1552:  SUBWF  45,F
1553:  BTFSS  03.0
1554:  GOTO   607
1555:  BTFSC  03.2
1556:  GOTO   607
1557:  MOVF   45,W
1558:  MOVWF  77
1559:  CLRF   78
155A:  CLRF   79
155B:  CLRF   7A
155C:  CLRF   44
155D:  MOVF   3A,W
155E:  MOVWF  43
155F:  BSF    43.7
1560:  MOVF   3B,W
1561:  MOVWF  42
1562:  MOVF   3C,W
1563:  MOVWF  41
1564:  MOVLW  19
1565:  MOVWF  45
1566:  MOVF   40,W
1567:  SUBWF  41,F
1568:  BTFSC  03.0
1569:  GOTO   57A
156A:  MOVLW  01
156B:  SUBWF  42,F
156C:  BTFSC  03.0
156D:  GOTO   57A
156E:  SUBWF  43,F
156F:  BTFSC  03.0
1570:  GOTO   57A
1571:  SUBWF  44,F
1572:  BTFSC  03.0
1573:  GOTO   57A
1574:  INCF   44,F
1575:  INCF   43,F
1576:  INCF   42,F
1577:  MOVF   40,W
1578:  ADDWF  41,F
1579:  GOTO   5AC
157A:  MOVF   3F,W
157B:  SUBWF  42,F
157C:  BTFSC  03.0
157D:  GOTO   595
157E:  MOVLW  01
157F:  SUBWF  43,F
1580:  BTFSC  03.0
1581:  GOTO   595
1582:  SUBWF  44,F
1583:  BTFSC  03.0
1584:  GOTO   595
1585:  INCF   44,F
1586:  INCF   43,F
1587:  MOVF   3F,W
1588:  ADDWF  42,F
1589:  MOVF   40,W
158A:  ADDWF  41,F
158B:  BTFSS  03.0
158C:  GOTO   5AC
158D:  INCF   42,F
158E:  BTFSS  03.2
158F:  GOTO   5AC
1590:  INCF   43,F
1591:  BTFSS  03.2
1592:  GOTO   5AC
1593:  INCF   44,F
1594:  GOTO   5AC
1595:  MOVF   3E,W
1596:  IORLW  80
1597:  SUBWF  43,F
1598:  BTFSC  03.0
1599:  GOTO   5AB
159A:  MOVLW  01
159B:  SUBWF  44,F
159C:  BTFSC  03.0
159D:  GOTO   5AB
159E:  INCF   44,F
159F:  MOVF   3E,W
15A0:  IORLW  80
15A1:  ADDWF  43,F
15A2:  MOVF   3F,W
15A3:  ADDWF  42,F
15A4:  BTFSS  03.0
15A5:  GOTO   589
15A6:  INCF   43,F
15A7:  BTFSS  03.2
15A8:  GOTO   589
15A9:  INCF   44,F
15AA:  GOTO   589
15AB:  BSF    7A.0
15AC:  DECFSZ 45,F
15AD:  GOTO   5AF
15AE:  GOTO   5BA
15AF:  BCF    03.0
15B0:  RLF    41,F
15B1:  RLF    42,F
15B2:  RLF    43,F
15B3:  RLF    44,F
15B4:  BCF    03.0
15B5:  RLF    7A,F
15B6:  RLF    79,F
15B7:  RLF    78,F
15B8:  RLF    46,F
15B9:  GOTO   566
15BA:  BTFSS  46.0
15BB:  GOTO   5C2
15BC:  BCF    03.0
15BD:  RRF    78,F
15BE:  RRF    79,F
15BF:  RRF    7A,F
15C0:  RRF    46,F
15C1:  GOTO   5C5
15C2:  DECF   77,F
15C3:  BTFSC  03.2
15C4:  GOTO   607
15C5:  BTFSC  46.7
15C6:  GOTO   5EE
15C7:  BCF    03.0
15C8:  RLF    41,F
15C9:  RLF    42,F
15CA:  RLF    43,F
15CB:  RLF    44,F
15CC:  MOVF   40,W
15CD:  SUBWF  41,F
15CE:  BTFSC  03.0
15CF:  GOTO   5DA
15D0:  MOVLW  01
15D1:  SUBWF  42,F
15D2:  BTFSC  03.0
15D3:  GOTO   5DA
15D4:  SUBWF  43,F
15D5:  BTFSC  03.0
15D6:  GOTO   5DA
15D7:  SUBWF  44,F
15D8:  BTFSS  03.0
15D9:  GOTO   5FD
15DA:  MOVF   3F,W
15DB:  SUBWF  42,F
15DC:  BTFSC  03.0
15DD:  GOTO   5E5
15DE:  MOVLW  01
15DF:  SUBWF  43,F
15E0:  BTFSC  03.0
15E1:  GOTO   5E5
15E2:  SUBWF  44,F
15E3:  BTFSS  03.0
15E4:  GOTO   5FD
15E5:  MOVF   3E,W
15E6:  IORLW  80
15E7:  SUBWF  43,F
15E8:  BTFSC  03.0
15E9:  GOTO   5EE
15EA:  MOVLW  01
15EB:  SUBWF  44,F
15EC:  BTFSS  03.0
15ED:  GOTO   5FD
15EE:  INCF   7A,F
15EF:  BTFSS  03.2
15F0:  GOTO   5FD
15F1:  INCF   79,F
15F2:  BTFSS  03.2
15F3:  GOTO   5FD
15F4:  INCF   78,F
15F5:  BTFSS  03.2
15F6:  GOTO   5FD
15F7:  INCF   77,F
15F8:  BTFSC  03.2
15F9:  GOTO   607
15FA:  RRF    78,F
15FB:  RRF    79,F
15FC:  RRF    7A,F
15FD:  MOVF   3A,W
15FE:  MOVWF  45
15FF:  MOVF   3E,W
1600:  XORWF  45,F
1601:  BTFSS  45.7
1602:  GOTO   605
1603:  BSF    78.7
1604:  GOTO   60B
1605:  BCF    78.7
1606:  GOTO   60B
1607:  CLRF   77
1608:  CLRF   78
1609:  CLRF   79
160A:  CLRF   7A
*
168E:  MOVF   36,W
168F:  MOVWF  3D
1690:  MOVF   3A,W
1691:  XORWF  3D,F
1692:  BTFSS  3D.7
1693:  GOTO   699
1694:  BCF    03.2
1695:  BCF    03.0
1696:  BTFSC  36.7
1697:  BSF    03.0
1698:  GOTO   6CC
1699:  MOVF   36,W
169A:  MOVWF  3D
169B:  MOVF   39,W
169C:  MOVWF  3E
169D:  MOVF   35,W
169E:  SUBWF  3E,F
169F:  BTFSC  03.2
16A0:  GOTO   6A7
16A1:  BTFSS  3D.7
16A2:  GOTO   6CC
16A3:  MOVF   03,W
16A4:  XORLW  01
16A5:  MOVWF  03
16A6:  GOTO   6CC
16A7:  MOVF   3A,W
16A8:  MOVWF  3E
16A9:  MOVF   36,W
16AA:  SUBWF  3E,F
16AB:  BTFSC  03.2
16AC:  GOTO   6B3
16AD:  BTFSS  3D.7
16AE:  GOTO   6CC
16AF:  MOVF   03,W
16B0:  XORLW  01
16B1:  MOVWF  03
16B2:  GOTO   6CC
16B3:  MOVF   3B,W
16B4:  MOVWF  3E
16B5:  MOVF   37,W
16B6:  SUBWF  3E,F
16B7:  BTFSC  03.2
16B8:  GOTO   6BF
16B9:  BTFSS  3D.7
16BA:  GOTO   6CC
16BB:  MOVF   03,W
16BC:  XORLW  01
16BD:  MOVWF  03
16BE:  GOTO   6CC
16BF:  MOVF   3C,W
16C0:  MOVWF  3E
16C1:  MOVF   38,W
16C2:  SUBWF  3E,F
16C3:  BTFSC  03.2
16C4:  GOTO   6CB
16C5:  BTFSS  3D.7
16C6:  GOTO   6CC
16C7:  MOVF   03,W
16C8:  XORLW  01
16C9:  MOVWF  03
16CA:  GOTO   6CC
16CB:  BCF    03.0
*
16E3:  BTFSC  03.1
16E4:  GOTO   6E8
16E5:  MOVLW  A0
16E6:  MOVWF  04
16E7:  BSF    03.7
16E8:  CLRF   77
16E9:  CLRF   78
16EA:  CLRF   79
16EB:  CLRF   7A
16EC:  BSF    03.5
16ED:  BSF    03.6
16EE:  CLRF   20
16EF:  CLRF   21
16F0:  CLRF   22
16F1:  CLRF   23
16F2:  MOVF   1F,W
16F3:  IORWF  1E,W
16F4:  IORWF  1D,W
16F5:  IORWF  1C,W
16F6:  BTFSC  03.2
16F7:  GOTO   728
16F8:  MOVLW  20
16F9:  MOVWF  24
16FA:  BCF    03.0
16FB:  RLF    18,F
16FC:  RLF    19,F
16FD:  RLF    1A,F
16FE:  RLF    1B,F
16FF:  RLF    20,F
1700:  RLF    21,F
1701:  RLF    22,F
1702:  RLF    23,F
1703:  MOVF   1F,W
1704:  SUBWF  23,W
1705:  BTFSS  03.2
1706:  GOTO   711
1707:  MOVF   1E,W
1708:  SUBWF  22,W
1709:  BTFSS  03.2
170A:  GOTO   711
170B:  MOVF   1D,W
170C:  SUBWF  21,W
170D:  BTFSS  03.2
170E:  GOTO   711
170F:  MOVF   1C,W
1710:  SUBWF  20,W
1711:  BTFSS  03.0
1712:  GOTO   722
1713:  MOVF   1C,W
1714:  SUBWF  20,F
1715:  MOVF   1D,W
1716:  BTFSS  03.0
1717:  INCFSZ 1D,W
1718:  SUBWF  21,F
1719:  MOVF   1E,W
171A:  BTFSS  03.0
171B:  INCFSZ 1E,W
171C:  SUBWF  22,F
171D:  MOVF   1F,W
171E:  BTFSS  03.0
171F:  INCFSZ 1F,W
1720:  SUBWF  23,F
1721:  BSF    03.0
1722:  RLF    77,F
1723:  RLF    78,F
1724:  RLF    79,F
1725:  RLF    7A,F
1726:  DECFSZ 24,F
1727:  GOTO   6FA
1728:  MOVF   20,W
1729:  MOVWF  00
172A:  INCF   04,F
172B:  MOVF   21,W
172C:  MOVWF  00
172D:  INCF   04,F
172E:  MOVF   22,W
172F:  MOVWF  00
1730:  INCF   04,F
1731:  MOVF   23,W
1732:  MOVWF  00
1733:  BCF    03.5
1734:  BCF    03.6
1735:  RETURN
1736:  MOVF   75,W
1737:  MOVWF  04
1738:  BCF    03.7
1739:  BTFSC  76.0
173A:  BSF    03.7
173B:  BSF    03.5
173C:  BSF    03.6
173D:  MOVF   18,W
173E:  MOVWF  00
173F:  INCF   04,F
1740:  CLRF   00
1741:  INCF   75,F
1742:  BTFSC  03.2
1743:  INCF   76,F
1744:  BCF    03.5
1745:  BCF    03.6
1746:  RETURN
*
1800:  MOVF   04,W
1801:  BSF    03.5
1802:  BSF    03.6
1803:  MOVWF  10
1804:  BCF    03.5
1805:  MOVF   6E,W
1806:  BSF    03.5
1807:  MOVWF  12
1808:  BTFSC  03.2
1809:  GOTO   0A0
180A:  BCF    03.5
180B:  MOVF   6D,W
180C:  BSF    03.5
180D:  MOVWF  1B
180E:  BCF    03.5
180F:  MOVF   6C,W
1810:  BSF    03.5
1811:  MOVWF  1A
1812:  BCF    03.5
1813:  MOVF   6B,W
1814:  BSF    03.5
1815:  MOVWF  19
1816:  BCF    03.5
1817:  MOVF   6A,W
1818:  BSF    03.5
1819:  MOVWF  18
181A:  CLRF   1F
181B:  CLRF   1E
181C:  MOVLW  20
181D:  MOVWF  1D
181E:  MOVLW  82
181F:  MOVWF  1C
1820:  MOVF   18,W
1821:  BTFSC  03.2
1822:  GOTO   090
1823:  MOVWF  20
1824:  MOVF   1C,W
1825:  BTFSC  03.2
1826:  GOTO   090
1827:  ADDWF  20,F
1828:  BTFSC  03.0
1829:  GOTO   031
182A:  MOVLW  7F
182B:  SUBWF  20,F
182C:  BTFSS  03.0
182D:  GOTO   090
182E:  BTFSC  03.2
182F:  GOTO   090
1830:  GOTO   035
1831:  MOVLW  81
1832:  ADDWF  20,F
1833:  BTFSC  03.0
1834:  GOTO   090
1835:  MOVF   20,W
1836:  MOVWF  77
1837:  CLRF   78
1838:  CLRF   79
1839:  CLRF   7A
183A:  MOVF   19,W
183B:  MOVWF  24
183C:  BSF    24.7
183D:  MOVF   1A,W
183E:  MOVWF  23
183F:  MOVF   1B,W
1840:  MOVWF  22
1841:  MOVLW  18
1842:  MOVWF  20
1843:  CLRF   21
1844:  BTFSS  22.0
1845:  GOTO   05E
1846:  MOVF   1F,W
1847:  ADDWF  7A,F
1848:  BTFSS  03.0
1849:  GOTO   050
184A:  INCF   79,F
184B:  BTFSS  03.2
184C:  GOTO   050
184D:  INCF   78,F
184E:  BTFSC  03.2
184F:  BSF    21.7
1850:  MOVF   1E,W
1851:  ADDWF  79,F
1852:  BTFSS  03.0
1853:  GOTO   057
1854:  INCF   78,F
1855:  BTFSC  03.2
1856:  BSF    21.7
1857:  MOVF   1D,W
1858:  MOVWF  1A
1859:  BSF    1A.7
185A:  MOVF   1A,W
185B:  ADDWF  78,F
185C:  BTFSC  03.0
185D:  BSF    21.7
185E:  RLF    21,F
185F:  RRF    78,F
1860:  RRF    79,F
1861:  RRF    7A,F
1862:  RRF    24,F
1863:  RRF    23,F
1864:  RRF    22,F
1865:  BCF    03.0
1866:  DECFSZ 20,F
1867:  GOTO   043
1868:  MOVLW  01
1869:  ADDWF  77,F
186A:  BTFSC  03.0
186B:  GOTO   090
186C:  BTFSC  78.7
186D:  GOTO   075
186E:  RLF    24,F
186F:  RLF    7A,F
1870:  RLF    79,F
1871:  RLF    78,F
1872:  DECF   77,F
1873:  BTFSC  03.2
1874:  GOTO   090
1875:  BTFSS  24.7
1876:  GOTO   086
1877:  INCF   7A,F
1878:  BTFSS  03.2
1879:  GOTO   086
187A:  INCF   79,F
187B:  BTFSS  03.2
187C:  GOTO   086
187D:  INCF   78,F
187E:  BTFSS  03.2
187F:  GOTO   086
1880:  RRF    78,F
1881:  RRF    79,F
1882:  RRF    7A,F
1883:  INCF   77,F
1884:  BTFSC  03.2
1885:  GOTO   090
1886:  MOVF   19,W
1887:  MOVWF  21
1888:  MOVF   1D,W
1889:  XORWF  21,F
188A:  BTFSS  21.7
188B:  GOTO   08E
188C:  BSF    78.7
188D:  GOTO   094
188E:  BCF    78.7
188F:  GOTO   094
1890:  CLRF   77
1891:  CLRF   78
1892:  CLRF   79
1893:  CLRF   7A
1894:  MOVF   7A,W
1895:  BCF    03.5
1896:  MOVWF  6D
1897:  MOVF   79,W
1898:  MOVWF  6C
1899:  MOVF   78,W
189A:  MOVWF  6B
189B:  MOVF   77,W
189C:  MOVWF  6A
189D:  BSF    03.5
189E:  DECFSZ 12,F
189F:  GOTO   00A
18A0:  MOVLW  7E
18A1:  MOVWF  77
18A2:  CLRF   78
18A3:  BCF    03.5
18A4:  BTFSC  6B.7
18A5:  BSF    78.7
18A6:  CLRF   79
18A7:  CLRF   7A
18A8:  BCF    03.1
18A9:  MOVF   6D,W
18AA:  BSF    03.5
18AB:  MOVWF  1B
18AC:  BCF    03.5
18AD:  MOVF   6C,W
18AE:  BSF    03.5
18AF:  MOVWF  1A
18B0:  BCF    03.5
18B1:  MOVF   6B,W
18B2:  BSF    03.5
18B3:  MOVWF  19
18B4:  BCF    03.5
18B5:  MOVF   6A,W
18B6:  BSF    03.5
18B7:  MOVWF  18
18B8:  MOVF   7A,W
18B9:  MOVWF  1F
18BA:  MOVF   79,W
18BB:  MOVWF  1E
18BC:  MOVF   78,W
18BD:  MOVWF  1D
18BE:  MOVF   77,W
18BF:  MOVWF  1C
18C0:  BCF    0A.3
18C1:  BCF    03.5
18C2:  BCF    03.6
18C3:  CALL   2A1
18C4:  BSF    0A.3
18C5:  MOVF   7A,W
18C6:  BSF    03.6
18C7:  MOVWF  6D
18C8:  MOVF   79,W
18C9:  MOVWF  6C
18CA:  MOVF   78,W
18CB:  MOVWF  6B
18CC:  MOVF   77,W
18CD:  MOVWF  6A
18CE:  MOVF   6D,W
18CF:  BSF    03.5
18D0:  MOVWF  1B
18D1:  BCF    03.5
18D2:  MOVF   6C,W
18D3:  BSF    03.5
18D4:  MOVWF  1A
18D5:  BCF    03.5
18D6:  MOVF   6B,W
18D7:  BSF    03.5
18D8:  MOVWF  19
18D9:  BCF    03.5
18DA:  MOVF   6A,W
18DB:  BSF    03.5
18DC:  MOVWF  18
18DD:  MOVF   18,W
18DE:  SUBLW  B6
18DF:  MOVWF  18
18E0:  CLRF   7A
18E1:  MOVF   19,W
18E2:  MOVWF  1C
18E3:  BSF    19.7
18E4:  BCF    03.0
18E5:  RRF    19,F
18E6:  RRF    1A,F
18E7:  RRF    1B,F
18E8:  RRF    7A,F
18E9:  RRF    79,F
18EA:  RRF    78,F
18EB:  RRF    77,F
18EC:  DECFSZ 18,F
18ED:  GOTO   0E4
18EE:  BTFSS  1C.7
18EF:  GOTO   0FB
18F0:  COMF   77,F
18F1:  COMF   78,F
18F2:  COMF   79,F
18F3:  COMF   7A,F
18F4:  INCF   77,F
18F5:  BTFSC  03.2
18F6:  INCF   78,F
18F7:  BTFSC  03.2
18F8:  INCF   79,F
18F9:  BTFSC  03.2
18FA:  INCF   7A,F
18FB:  MOVF   7A,W
18FC:  BCF    03.5
18FD:  MOVWF  6D
18FE:  MOVF   79,W
18FF:  MOVWF  6C
1900:  MOVF   78,W
1901:  MOVWF  6B
1902:  MOVF   77,W
1903:  MOVWF  6A
1904:  BTFSS  6D.7
1905:  GOTO   115
1906:  BSF    03.5
1907:  DECF   10,F
1908:  BSF    10.5
1909:  BCF    03.5
190A:  COMF   6A,F
190B:  COMF   6B,F
190C:  COMF   6C,F
190D:  COMF   6D,F
190E:  INCF   6A,F
190F:  BTFSC  03.2
1910:  INCF   6B,F
1911:  BTFSC  03.2
1912:  INCF   6C,F
1913:  BTFSC  03.2
1914:  INCF   6D,F
1915:  MOVLW  3B
1916:  BSF    03.5
1917:  MOVWF  17
1918:  MOVLW  9A
1919:  MOVWF  16
191A:  MOVLW  CA
191B:  MOVWF  15
191C:  CLRF   14
191D:  MOVLW  0A
191E:  MOVWF  12
191F:  BCF    03.5
1920:  MOVF   6E,W
1921:  BTFSS  03.2
1922:  GOTO   126
1923:  BSF    03.5
1924:  INCF   10,F
1925:  BCF    03.5
1926:  BSF    03.1
1927:  MOVLW  6A
1928:  MOVWF  04
1929:  BSF    03.7
192A:  MOVF   6D,W
192B:  BSF    03.5
192C:  MOVWF  1B
192D:  BCF    03.5
192E:  MOVF   6C,W
192F:  BSF    03.5
1930:  MOVWF  1A
1931:  BCF    03.5
1932:  MOVF   6B,W
1933:  BSF    03.5
1934:  MOVWF  19
1935:  BCF    03.5
1936:  MOVF   6A,W
1937:  BSF    03.5
1938:  MOVWF  18
1939:  MOVF   17,W
193A:  MOVWF  1F
193B:  MOVF   16,W
193C:  MOVWF  1E
193D:  MOVF   15,W
193E:  MOVWF  1D
193F:  MOVF   14,W
1940:  MOVWF  1C
1941:  BCF    0A.3
1942:  BCF    03.5
1943:  BCF    03.6
1944:  CALL   6E3
1945:  BSF    0A.3
1946:  MOVF   78,W
1947:  MOVF   77,F
1948:  BTFSS  03.2
1949:  GOTO   164
194A:  BSF    03.6
194B:  INCF   6E,W
194C:  BSF    03.5
194D:  SUBWF  12,W
194E:  BTFSS  03.2
194F:  GOTO   153
1950:  BCF    03.5
1951:  BCF    03.6
1952:  GOTO   164
1953:  MOVF   10,W
1954:  BTFSC  03.2
1955:  GOTO   168
1956:  ANDLW  0F
1957:  SUBWF  12,W
1958:  BTFSC  03.2
1959:  GOTO   15C
195A:  BTFSC  03.0
195B:  GOTO   1BC
195C:  BTFSC  10.7
195D:  GOTO   1BC
195E:  BTFSC  10.6
195F:  GOTO   168
1960:  MOVLW  20
1961:  GOTO   1B2
1962:  BCF    03.5
1963:  BCF    03.6
1964:  MOVLW  20
1965:  BSF    03.5
1966:  BSF    03.6
1967:  ANDWF  10,F
1968:  BTFSS  10.5
1969:  GOTO   181
196A:  BCF    10.5
196B:  BCF    03.5
196C:  MOVF   6E,W
196D:  BTFSC  03.2
196E:  GOTO   172
196F:  BSF    03.5
1970:  DECF   10,F
1971:  BCF    03.5
1972:  MOVF   77,W
1973:  BSF    03.5
1974:  MOVWF  10
1975:  MOVLW  2D
1976:  MOVWF  18
1977:  BCF    0A.3
1978:  BCF    03.5
1979:  BCF    03.6
197A:  CALL   736
197B:  BSF    0A.3
197C:  BSF    03.5
197D:  BSF    03.6
197E:  MOVF   10,W
197F:  MOVWF  77
1980:  CLRF   10
1981:  BCF    03.5
1982:  MOVF   6E,W
1983:  BSF    03.5
1984:  SUBWF  12,W
1985:  BTFSS  03.2
1986:  GOTO   197
1987:  MOVF   77,W
1988:  MOVWF  10
1989:  MOVLW  2E
198A:  MOVWF  18
198B:  BCF    0A.3
198C:  BCF    03.5
198D:  BCF    03.6
198E:  CALL   736
198F:  BSF    0A.3
1990:  BSF    03.5
1991:  BSF    03.6
1992:  MOVF   10,W
1993:  MOVWF  77
1994:  MOVLW  20
1995:  ANDWF  10,F
1996:  MOVLW  00
1997:  MOVLW  30
1998:  BTFSS  10.5
1999:  GOTO   1B2
199A:  BCF    10.5
199B:  BCF    03.5
199C:  MOVF   6E,W
199D:  BTFSC  03.2
199E:  GOTO   1A2
199F:  BSF    03.5
19A0:  DECF   10,F
19A1:  BCF    03.5
19A2:  MOVF   77,W
19A3:  BSF    03.5
19A4:  MOVWF  10
19A5:  MOVLW  2D
19A6:  MOVWF  18
19A7:  BCF    0A.3
19A8:  BCF    03.5
19A9:  BCF    03.6
19AA:  CALL   736
19AB:  BSF    0A.3
19AC:  BSF    03.5
19AD:  BSF    03.6
19AE:  MOVF   10,W
19AF:  MOVWF  77
19B0:  CLRF   10
19B1:  MOVLW  30
19B2:  ADDWF  77,F
19B3:  MOVF   77,W
19B4:  MOVWF  18
19B5:  BCF    0A.3
19B6:  BCF    03.5
19B7:  BCF    03.6
19B8:  CALL   736
19B9:  BSF    0A.3
19BA:  BSF    03.5
19BB:  BSF    03.6
19BC:  BCF    03.1
19BD:  MOVF   17,W
19BE:  MOVWF  1B
19BF:  MOVF   16,W
19C0:  MOVWF  1A
19C1:  MOVF   15,W
19C2:  MOVWF  19
19C3:  MOVF   14,W
19C4:  MOVWF  18
19C5:  CLRF   1F
19C6:  CLRF   1E
19C7:  CLRF   1D
19C8:  MOVLW  0A
19C9:  MOVWF  1C
19CA:  BCF    0A.3
19CB:  BCF    03.5
19CC:  BCF    03.6
19CD:  CALL   6E3
19CE:  BSF    0A.3
19CF:  MOVF   7A,W
19D0:  BSF    03.5
19D1:  BSF    03.6
19D2:  MOVWF  17
19D3:  MOVF   79,W
19D4:  MOVWF  16
19D5:  MOVF   78,W
19D6:  MOVWF  15
19D7:  MOVF   77,W
19D8:  MOVWF  14
19D9:  DECFSZ 12,F
19DA:  GOTO   1DC
19DB:  GOTO   1DE
19DC:  BCF    03.5
19DD:  GOTO   126
19DE:  BCF    03.6
19DF:  BCF    03.5
19E0:  BSF    0A.3
19E1:  BSF    0A.4
19E2:  GOTO   278 (RETURN)
....................  
.................... #list 
....................  
.................... #DEVICE ADC=10 
.................... #INCLUDE <STRING.H> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
*
05A5:  BSF    03.6
05A6:  MOVF   60,W
05A7:  MOVWF  64
05A8:  MOVF   5F,W
05A9:  MOVWF  63
05AA:  MOVF   64,W
05AB:  MOVWF  7A
05AC:  MOVF   63,W
05AD:  MOVWF  04
05AE:  BCF    03.7
05AF:  BTFSC  7A.0
05B0:  BSF    03.7
05B1:  MOVF   00,F
05B2:  BTFSC  03.2
05B3:  GOTO   5B8
05B4:  INCF   63,F
05B5:  BTFSC  03.2
05B6:  INCF   64,F
05B7:  GOTO   5AA
....................    while(*s2 != '\0') 
05B8:  MOVF   62,W
05B9:  MOVWF  7A
05BA:  MOVF   61,W
05BB:  MOVWF  04
05BC:  BCF    03.7
05BD:  BTFSC  7A.0
05BE:  BSF    03.7
05BF:  MOVF   00,F
05C0:  BTFSC  03.2
05C1:  GOTO   5D7
....................    { 
....................       *s = *s2; 
05C2:  MOVF   61,W
05C3:  MOVWF  04
05C4:  BCF    03.7
05C5:  BTFSC  62.0
05C6:  BSF    03.7
05C7:  MOVF   00,W
05C8:  MOVWF  67
05C9:  MOVF   63,W
05CA:  MOVWF  04
05CB:  BCF    03.7
05CC:  BTFSC  64.0
05CD:  BSF    03.7
05CE:  MOVF   67,W
05CF:  MOVWF  00
....................       ++s; 
05D0:  INCF   63,F
05D1:  BTFSC  03.2
05D2:  INCF   64,F
....................       ++s2; 
05D3:  INCF   61,F
05D4:  BTFSC  03.2
05D5:  INCF   62,F
05D6:  GOTO   5B8
....................    } 
....................  
....................    *s = '\0'; 
05D7:  MOVF   63,W
05D8:  MOVWF  04
05D9:  BCF    03.7
05DA:  BTFSC  64.0
05DB:  BSF    03.7
05DC:  CLRF   00
....................    return(s1); 
05DD:  MOVF   5F,W
05DE:  MOVWF  78
05DF:  MOVF   60,W
05E0:  MOVWF  79
05E1:  BCF    03.6
05E2:  RETURN
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
*
07BA:  BSF    03.6
07BB:  MOVF   3C,W
07BC:  MOVWF  7A
07BD:  MOVF   3B,W
07BE:  MOVWF  04
07BF:  BCF    03.7
07C0:  BTFSC  7A.0
07C1:  BSF    03.7
07C2:  MOVF   00,W
07C3:  MOVWF  3F
07C4:  MOVF   3E,W
07C5:  MOVWF  7A
07C6:  MOVF   3D,W
07C7:  MOVWF  04
07C8:  BCF    03.7
07C9:  BTFSC  7A.0
07CA:  BSF    03.7
07CB:  MOVF   00,W
07CC:  SUBWF  3F,W
07CD:  BTFSS  03.2
07CE:  GOTO   7E6
....................       if (*s1 == '\0') 
07CF:  MOVF   3C,W
07D0:  MOVWF  7A
07D1:  MOVF   3B,W
07D2:  MOVWF  04
07D3:  BCF    03.7
07D4:  BTFSC  7A.0
07D5:  BSF    03.7
07D6:  MOVF   00,F
07D7:  BTFSS  03.2
07D8:  GOTO   7DC
....................          return(0); 
07D9:  MOVLW  00
07DA:  MOVWF  78
07DB:  GOTO   7FE
07DC:  MOVF   3C,W
07DD:  MOVWF  7A
07DE:  MOVF   3B,W
07DF:  INCF   3B,F
07E0:  BTFSC  03.2
07E1:  INCF   3C,F
07E2:  INCF   3D,F
07E3:  BTFSC  03.2
07E4:  INCF   3E,F
07E5:  GOTO   7BB
....................    return((*s1 < *s2) ? -1: 1); 
07E6:  MOVF   3C,W
07E7:  MOVWF  7A
07E8:  MOVF   3B,W
07E9:  MOVWF  04
07EA:  BCF    03.7
07EB:  BTFSC  3C.0
07EC:  BSF    03.7
07ED:  MOVF   00,W
07EE:  MOVWF  3F
07EF:  MOVF   3E,W
07F0:  MOVWF  7A
07F1:  MOVF   3D,W
07F2:  MOVWF  04
07F3:  BCF    03.7
07F4:  BTFSC  3E.0
07F5:  BSF    03.7
07F6:  MOVF   00,W
07F7:  SUBWF  3F,W
07F8:  BTFSC  03.0
07F9:  GOTO   7FC
07FA:  MOVLW  FF
07FB:  GOTO   7FD
07FC:  MOVLW  01
07FD:  MOVWF  78
07FE:  BCF    03.6
07FF:  RETURN
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
*
102C:  MOVF   3C,W
102D:  MOVWF  7A
102E:  MOVF   3B,W
102F:  MOVWF  04
1030:  BCF    03.7
1031:  BTFSC  7A.0
1032:  BSF    03.7
1033:  MOVF   3D,W
1034:  SUBWF  00,W
1035:  BTFSC  03.2
1036:  GOTO   049
....................       if (*s == '\0') 
1037:  MOVF   3C,W
1038:  MOVWF  7A
1039:  MOVF   3B,W
103A:  MOVWF  04
103B:  BCF    03.7
103C:  BTFSC  7A.0
103D:  BSF    03.7
103E:  MOVF   00,F
103F:  BTFSS  03.2
1040:  GOTO   045
....................          return(0); 
1041:  MOVLW  00
1042:  MOVWF  78
1043:  MOVWF  79
1044:  GOTO   04D
1045:  INCF   3B,F
1046:  BTFSC  03.2
1047:  INCF   3C,F
1048:  GOTO   02C
....................    return(s); 
1049:  MOVF   3B,W
104A:  MOVWF  78
104B:  MOVF   3C,W
104C:  MOVWF  79
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
*
0AF1:  MOVF   46,W
0AF2:  MOVWF  4A
0AF3:  MOVF   45,W
0AF4:  MOVWF  49
0AF5:  MOVF   4A,W
0AF6:  MOVWF  7A
0AF7:  MOVF   49,W
0AF8:  MOVWF  04
0AF9:  BCF    03.7
0AFA:  BTFSC  7A.0
0AFB:  BSF    03.7
0AFC:  MOVF   00,F
0AFD:  BTFSC  03.2
0AFE:  GOTO   32E
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
0AFF:  MOVF   48,W
0B00:  MOVWF  4C
0B01:  MOVF   47,W
0B02:  MOVWF  4B
0B03:  MOVF   4C,W
0B04:  MOVWF  7A
0B05:  MOVF   4B,W
0B06:  MOVWF  04
0B07:  BCF    03.7
0B08:  BTFSC  7A.0
0B09:  BSF    03.7
0B0A:  MOVF   00,F
0B0B:  BTFSC  03.2
0B0C:  GOTO   32A
....................          if (*sc1 == *sc2) 
0B0D:  MOVF   4A,W
0B0E:  MOVWF  7A
0B0F:  MOVF   49,W
0B10:  MOVWF  04
0B11:  BCF    03.7
0B12:  BTFSC  7A.0
0B13:  BSF    03.7
0B14:  MOVF   00,W
0B15:  MOVWF  4D
0B16:  MOVF   4C,W
0B17:  MOVWF  7A
0B18:  MOVF   4B,W
0B19:  MOVWF  04
0B1A:  BCF    03.7
0B1B:  BTFSC  7A.0
0B1C:  BSF    03.7
0B1D:  MOVF   00,W
0B1E:  SUBWF  4D,W
0B1F:  BTFSS  03.2
0B20:  GOTO   326
....................             return(sc1); 
0B21:  MOVF   49,W
0B22:  MOVWF  78
0B23:  MOVF   4A,W
0B24:  MOVWF  79
0B25:  GOTO   331
0B26:  INCF   4B,F
0B27:  BTFSC  03.2
0B28:  INCF   4C,F
0B29:  GOTO   303
0B2A:  INCF   49,F
0B2B:  BTFSC  03.2
0B2C:  INCF   4A,F
0B2D:  GOTO   2F5
....................    return(0); 
0B2E:  MOVLW  00
0B2F:  MOVWF  78
0B30:  MOVWF  79
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
*
0A7E:  MOVF   46,W
0A7F:  MOVWF  4A
0A80:  MOVF   45,W
0A81:  MOVWF  49
0A82:  MOVF   4A,W
0A83:  MOVWF  7A
0A84:  MOVF   49,W
0A85:  MOVWF  04
0A86:  BCF    03.7
0A87:  BTFSC  7A.0
0A88:  BSF    03.7
0A89:  MOVF   00,F
0A8A:  BTFSC  03.2
0A8B:  GOTO   2C3
....................       for (sc2 = s2; ; sc2++) 
0A8C:  MOVF   48,W
0A8D:  MOVWF  4C
0A8E:  MOVF   47,W
0A8F:  MOVWF  4B
....................     if (*sc2 == '\0') 
0A90:  MOVF   4C,W
0A91:  MOVWF  7A
0A92:  MOVF   4B,W
0A93:  MOVWF  04
0A94:  BCF    03.7
0A95:  BTFSC  7A.0
0A96:  BSF    03.7
0A97:  MOVF   00,F
0A98:  BTFSS  03.2
0A99:  GOTO   2A7
....................        return(sc1 - s1); 
0A9A:  MOVF   45,W
0A9B:  SUBWF  49,W
0A9C:  MOVWF  77
0A9D:  MOVF   4A,W
0A9E:  MOVWF  7A
0A9F:  MOVF   46,W
0AA0:  BTFSS  03.0
0AA1:  INCFSZ 46,W
0AA2:  SUBWF  7A,F
0AA3:  MOVF   77,W
0AA4:  MOVWF  78
0AA5:  GOTO   2CE
0AA6:  GOTO   2BB
....................          else if (*sc1 == *sc2) 
0AA7:  MOVF   4A,W
0AA8:  MOVWF  7A
0AA9:  MOVF   49,W
0AAA:  MOVWF  04
0AAB:  BCF    03.7
0AAC:  BTFSC  7A.0
0AAD:  BSF    03.7
0AAE:  MOVF   00,W
0AAF:  MOVWF  4D
0AB0:  MOVF   4C,W
0AB1:  MOVWF  7A
0AB2:  MOVF   4B,W
0AB3:  MOVWF  04
0AB4:  BCF    03.7
0AB5:  BTFSC  7A.0
0AB6:  BSF    03.7
0AB7:  MOVF   00,W
0AB8:  SUBWF  4D,W
0AB9:  BTFSC  03.2
....................             break; 
0ABA:  GOTO   2BF
0ABB:  INCF   4B,F
0ABC:  BTFSC  03.2
0ABD:  INCF   4C,F
0ABE:  GOTO   290
0ABF:  INCF   49,F
0AC0:  BTFSC  03.2
0AC1:  INCF   4A,F
0AC2:  GOTO   282
....................    return(sc1 - s1); 
0AC3:  MOVF   45,W
0AC4:  SUBWF  49,W
0AC5:  MOVWF  77
0AC6:  MOVF   4A,W
0AC7:  MOVWF  7A
0AC8:  MOVF   46,W
0AC9:  BTFSS  03.0
0ACA:  INCFSZ 46,W
0ACB:  SUBWF  7A,F
0ACC:  MOVF   77,W
0ACD:  MOVWF  78
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
*
1B1B:  BCF    03.6
1B1C:  CLRF   2B
1B1D:  CLRF   2C
....................  
....................    beg = (s1)? s1: save; 
*
0A65:  BSF    03.6
0A66:  MOVF   3D,W
0A67:  IORWF  3E,W
0A68:  BTFSC  03.2
0A69:  GOTO   26E
0A6A:  MOVF   3E,W
0A6B:  MOVWF  7A
0A6C:  MOVF   3D,W
0A6D:  GOTO   273
0A6E:  BCF    03.6
0A6F:  MOVF   2C,W
0A70:  MOVWF  7A
0A71:  MOVF   2B,W
0A72:  BSF    03.6
0A73:  MOVWF  41
0A74:  MOVF   7A,W
0A75:  MOVWF  42
....................    beg += strspn(beg, s2); 
0A76:  MOVF   42,W
0A77:  MOVWF  46
0A78:  MOVF   41,W
0A79:  MOVWF  45
0A7A:  MOVF   40,W
0A7B:  MOVWF  48
0A7C:  MOVF   3F,W
0A7D:  MOVWF  47
*
0ACE:  MOVF   78,W
0ACF:  ADDWF  41,F
0AD0:  BTFSC  03.0
0AD1:  INCF   42,F
....................    if (*beg == '\0') 
0AD2:  MOVF   42,W
0AD3:  MOVWF  7A
0AD4:  MOVF   41,W
0AD5:  MOVWF  04
0AD6:  BCF    03.7
0AD7:  BTFSC  7A.0
0AD8:  BSF    03.7
0AD9:  MOVF   00,F
0ADA:  BTFSS  03.2
0ADB:  GOTO   2E9
....................    { 
....................       *save = ' '; 
0ADC:  BCF    03.6
0ADD:  MOVF   2B,W
0ADE:  MOVWF  04
0ADF:  BCF    03.7
0AE0:  BTFSC  2C.0
0AE1:  BSF    03.7
0AE2:  MOVLW  20
0AE3:  MOVWF  00
....................       return(0); 
0AE4:  MOVLW  00
0AE5:  MOVWF  78
0AE6:  MOVWF  79
0AE7:  GOTO   355
0AE8:  BSF    03.6
....................    } 
....................    end = strpbrk(beg, s2); 
0AE9:  MOVF   42,W
0AEA:  MOVWF  46
0AEB:  MOVF   41,W
0AEC:  MOVWF  45
0AED:  MOVF   40,W
0AEE:  MOVWF  48
0AEF:  MOVF   3F,W
0AF0:  MOVWF  47
*
0B31:  MOVF   79,W
0B32:  MOVWF  44
0B33:  MOVF   78,W
0B34:  MOVWF  43
....................    if (*end != '\0') 
0B35:  MOVF   44,W
0B36:  MOVWF  7A
0B37:  MOVF   43,W
0B38:  MOVWF  04
0B39:  BCF    03.7
0B3A:  BTFSC  7A.0
0B3B:  BSF    03.7
0B3C:  MOVF   00,F
0B3D:  BTFSC  03.2
0B3E:  GOTO   348
....................    { 
....................       *end = '\0'; 
0B3F:  MOVF   43,W
0B40:  MOVWF  04
0B41:  BCF    03.7
0B42:  BTFSC  44.0
0B43:  BSF    03.7
0B44:  CLRF   00
....................       end++; 
0B45:  INCF   43,F
0B46:  BTFSC  03.2
0B47:  INCF   44,F
....................    } 
....................    save = end; 
0B48:  MOVF   44,W
0B49:  BCF    03.6
0B4A:  MOVWF  2C
0B4B:  BSF    03.6
0B4C:  MOVF   43,W
0B4D:  BCF    03.6
0B4E:  MOVWF  2B
....................    return(beg); 
0B4F:  BSF    03.6
0B50:  MOVF   41,W
0B51:  MOVWF  78
0B52:  MOVF   42,W
0B53:  MOVWF  79
0B54:  BCF    03.6
0B55:  RETURN
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
*
1055:  MOVF   3C,W
1056:  MOVWF  3E
1057:  MOVF   3B,W
1058:  MOVWF  3D
1059:  MOVF   3E,W
105A:  MOVWF  7A
105B:  MOVF   3D,W
105C:  MOVWF  04
105D:  BCF    03.7
105E:  BTFSC  7A.0
105F:  BSF    03.7
1060:  MOVF   00,F
1061:  BTFSC  03.2
1062:  GOTO   067
1063:  INCF   3D,F
1064:  BTFSC  03.2
1065:  INCF   3E,F
1066:  GOTO   059
....................    return(sc - s); 
1067:  MOVF   3B,W
1068:  SUBWF  3D,W
1069:  MOVWF  77
106A:  MOVF   3E,W
106B:  MOVWF  7A
106C:  MOVF   3C,W
106D:  BTFSS  03.0
106E:  INCFSZ 3C,W
106F:  SUBWF  7A,F
1070:  MOVF   77,W
1071:  MOVWF  78
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #INCLUDE <STDLIB.H> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... /* Standart template: float strtof(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... float strtof(char *s,char *endptr); 
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s,char *endptr); 
.................... float64 strtod(char *s,char *endptr); 
.................... #else 
.................... //provided for compatibility 
.................... #define strtof48(s, e) strtof(s, e) 
.................... #define strtod(s, e) strtof(s, e) 
.................... #endif 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof(s)   strtof(s, 0) 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof48(s) strtof48(s, 0) 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof64(s) strtod(s, 0) 
.................... #endif 
....................  
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float atoe(char * s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s); 
.................... #endif 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... unsigned int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................  
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
*
0B56:  BSF    03.6
0B57:  CLRF   42
....................    sign = 0; 
0B58:  CLRF   40
....................    base = 10; 
0B59:  MOVLW  0A
0B5A:  MOVWF  41
....................    result = 0; 
0B5B:  CLRF   3F
....................  
....................    if (!s) 
0B5C:  MOVF   3D,W
0B5D:  IORWF  3E,W
0B5E:  BTFSS  03.2
0B5F:  GOTO   363
....................       return 0; 
0B60:  MOVLW  00
0B61:  MOVWF  78
0B62:  GOTO   437
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
0B63:  MOVF   42,W
0B64:  INCF   42,F
0B65:  ADDWF  3D,W
0B66:  MOVWF  04
0B67:  BCF    03.7
0B68:  BTFSC  3E.0
0B69:  BSF    03.7
0B6A:  MOVF   00,W
0B6B:  MOVWF  43
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
0B6C:  MOVF   43,W
0B6D:  SUBLW  2D
0B6E:  BTFSS  03.2
0B6F:  GOTO   37C
....................    { 
....................       sign = 1;         // Set the sign to negative 
0B70:  MOVLW  01
0B71:  MOVWF  40
....................       c = s[index++]; 
0B72:  MOVF   42,W
0B73:  INCF   42,F
0B74:  ADDWF  3D,W
0B75:  MOVWF  04
0B76:  BCF    03.7
0B77:  BTFSC  3E.0
0B78:  BSF    03.7
0B79:  MOVF   00,W
0B7A:  MOVWF  43
....................    } 
0B7B:  GOTO   389
....................    else if (c == '+') 
0B7C:  MOVF   43,W
0B7D:  SUBLW  2B
0B7E:  BTFSS  03.2
0B7F:  GOTO   389
....................    { 
....................       c = s[index++]; 
0B80:  MOVF   42,W
0B81:  INCF   42,F
0B82:  ADDWF  3D,W
0B83:  MOVWF  04
0B84:  BCF    03.7
0B85:  BTFSC  3E.0
0B86:  BSF    03.7
0B87:  MOVF   00,W
0B88:  MOVWF  43
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
0B89:  MOVF   43,W
0B8A:  SUBLW  2F
0B8B:  BTFSC  03.0
0B8C:  GOTO   42D
0B8D:  MOVF   43,W
0B8E:  SUBLW  39
0B8F:  BTFSS  03.0
0B90:  GOTO   42D
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
0B91:  MOVF   43,W
0B92:  SUBLW  30
0B93:  BTFSS  03.2
0B94:  GOTO   3B5
0B95:  MOVF   42,W
0B96:  ADDWF  3D,W
0B97:  MOVWF  04
0B98:  BCF    03.7
0B99:  BTFSC  3E.0
0B9A:  BSF    03.7
0B9B:  MOVF   00,W
0B9C:  SUBLW  78
0B9D:  BTFSC  03.2
0B9E:  GOTO   3A9
0B9F:  MOVF   42,W
0BA0:  ADDWF  3D,W
0BA1:  MOVWF  04
0BA2:  BCF    03.7
0BA3:  BTFSC  3E.0
0BA4:  BSF    03.7
0BA5:  MOVF   00,W
0BA6:  SUBLW  58
0BA7:  BTFSS  03.2
0BA8:  GOTO   3B5
....................       { 
....................          base = 16; 
0BA9:  MOVLW  10
0BAA:  MOVWF  41
....................          index++; 
0BAB:  INCF   42,F
....................          c = s[index++]; 
0BAC:  MOVF   42,W
0BAD:  INCF   42,F
0BAE:  ADDWF  3D,W
0BAF:  MOVWF  04
0BB0:  BCF    03.7
0BB1:  BTFSC  3E.0
0BB2:  BSF    03.7
0BB3:  MOVF   00,W
0BB4:  MOVWF  43
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
0BB5:  MOVF   41,W
0BB6:  SUBLW  0A
0BB7:  BTFSS  03.2
0BB8:  GOTO   3DB
....................       { 
....................          while (c >= '0' && c <= '9') 
0BB9:  MOVF   43,W
0BBA:  SUBLW  2F
0BBB:  BTFSC  03.0
0BBC:  GOTO   3DA
0BBD:  MOVF   43,W
0BBE:  SUBLW  39
0BBF:  BTFSS  03.0
0BC0:  GOTO   3DA
....................          { 
....................             result = 10*result + (c - '0'); 
0BC1:  MOVLW  0A
0BC2:  MOVWF  44
0BC3:  MOVF   3F,W
0BC4:  MOVWF  45
0BC5:  BCF    0A.3
0BC6:  BCF    03.6
0BC7:  CALL   793
0BC8:  BSF    0A.3
0BC9:  MOVF   78,W
0BCA:  BSF    03.6
0BCB:  MOVWF  44
0BCC:  MOVLW  30
0BCD:  SUBWF  43,W
0BCE:  ADDWF  44,W
0BCF:  MOVWF  3F
....................             c = s[index++]; 
0BD0:  MOVF   42,W
0BD1:  INCF   42,F
0BD2:  ADDWF  3D,W
0BD3:  MOVWF  04
0BD4:  BCF    03.7
0BD5:  BTFSC  3E.0
0BD6:  BSF    03.7
0BD7:  MOVF   00,W
0BD8:  MOVWF  43
0BD9:  GOTO   3B9
....................          } 
....................       } 
0BDA:  GOTO   42D
....................       else if (base == 16)    // The number is a hexa number 
0BDB:  MOVF   41,W
0BDC:  SUBLW  10
0BDD:  BTFSS  03.2
0BDE:  GOTO   42D
....................       { 
....................          c = toupper(c); 
0BDF:  MOVF   43,W
0BE0:  SUBLW  60
0BE1:  BTFSC  03.0
0BE2:  GOTO   3EA
0BE3:  MOVF   43,W
0BE4:  SUBLW  7A
0BE5:  BTFSS  03.0
0BE6:  GOTO   3EA
0BE7:  MOVF   43,W
0BE8:  ANDLW  DF
0BE9:  GOTO   3EB
0BEA:  MOVF   43,W
0BEB:  MOVWF  43
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
0BEC:  MOVF   43,W
0BED:  SUBLW  2F
0BEE:  BTFSC  03.0
0BEF:  GOTO   3F4
0BF0:  MOVF   43,W
0BF1:  SUBLW  39
0BF2:  BTFSC  03.0
0BF3:  GOTO   3FC
0BF4:  MOVF   43,W
0BF5:  SUBLW  40
0BF6:  BTFSC  03.0
0BF7:  GOTO   42D
0BF8:  MOVF   43,W
0BF9:  SUBLW  46
0BFA:  BTFSS  03.0
0BFB:  GOTO   42D
....................          { 
....................             if (c >= '0' && c <= '9') 
0BFC:  MOVF   43,W
0BFD:  SUBLW  2F
0BFE:  BTFSC  03.0
0BFF:  GOTO   40D
0C00:  MOVF   43,W
0C01:  SUBLW  39
0C02:  BTFSS  03.0
0C03:  GOTO   40D
....................                result = (result << 4) + (c - '0'); 
0C04:  SWAPF  3F,W
0C05:  MOVWF  44
0C06:  MOVLW  F0
0C07:  ANDWF  44,F
0C08:  MOVLW  30
0C09:  SUBWF  43,W
0C0A:  ADDWF  44,W
0C0B:  MOVWF  3F
0C0C:  GOTO   416
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
0C0D:  SWAPF  3F,W
0C0E:  MOVWF  44
0C0F:  MOVLW  F0
0C10:  ANDWF  44,F
0C11:  MOVLW  41
0C12:  SUBWF  43,W
0C13:  ADDLW  0A
0C14:  ADDWF  44,W
0C15:  MOVWF  3F
....................  
....................             c = s[index++]; 
0C16:  MOVF   42,W
0C17:  INCF   42,F
0C18:  ADDWF  3D,W
0C19:  MOVWF  04
0C1A:  BCF    03.7
0C1B:  BTFSC  3E.0
0C1C:  BSF    03.7
0C1D:  MOVF   00,W
0C1E:  MOVWF  43
....................             c = toupper(c); 
0C1F:  MOVF   43,W
0C20:  SUBLW  60
0C21:  BTFSC  03.0
0C22:  GOTO   42A
0C23:  MOVF   43,W
0C24:  SUBLW  7A
0C25:  BTFSS  03.0
0C26:  GOTO   42A
0C27:  MOVF   43,W
0C28:  ANDLW  DF
0C29:  GOTO   42B
0C2A:  MOVF   43,W
0C2B:  MOVWF  43
0C2C:  GOTO   3EC
....................          } 
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
0C2D:  DECFSZ 40,W
0C2E:  GOTO   435
0C2F:  MOVF   41,W
0C30:  SUBLW  0A
0C31:  BTFSS  03.2
0C32:  GOTO   435
....................        result = -result; 
0C33:  COMF   3F,F
0C34:  INCF   3F,F
....................  
....................    return(result); 
0C35:  MOVF   3F,W
0C36:  MOVWF  78
0C37:  BCF    03.6
0C38:  RETURN
.................... } 
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
*
0447:  BSF    03.6
0448:  CLRF   6E
0449:  CLRF   6D
044A:  CLRF   6C
044B:  MOVLW  01
044C:  MOVWF  6B
044D:  BSF    03.5
044E:  CLRF   10
044F:  CLRF   11
.................... { 
....................      unsigned int32 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
0450:  BCF    03.5
0451:  BTFSS  67.7
0452:  GOTO   49D
....................          sign=1;        // Check for negative number 
0453:  MOVLW  01
0454:  BSF    03.5
0455:  MOVWF  10
....................          num*=-1; 
0456:  BCF    03.5
0457:  MOVF   67,W
0458:  BSF    03.5
0459:  MOVWF  16
045A:  BCF    03.5
045B:  MOVF   66,W
045C:  BSF    03.5
045D:  MOVWF  15
045E:  BCF    03.5
045F:  MOVF   65,W
0460:  BSF    03.5
0461:  MOVWF  14
0462:  BCF    03.5
0463:  MOVF   64,W
0464:  BSF    03.5
0465:  MOVWF  13
0466:  MOVLW  FF
0467:  MOVWF  1A
0468:  MOVWF  19
0469:  MOVWF  18
046A:  MOVWF  17
*
0494:  MOVF   7A,W
0495:  BCF    03.5
0496:  MOVWF  67
0497:  MOVF   79,W
0498:  MOVWF  66
0499:  MOVF   78,W
049A:  MOVWF  65
049B:  MOVF   77,W
049C:  MOVWF  64
....................      } 
....................  
....................      while(temp>0) { 
049D:  MOVF   6B,F
049E:  BTFSS  03.2
049F:  GOTO   4A9
04A0:  MOVF   6C,F
04A1:  BTFSS  03.2
04A2:  GOTO   4A9
04A3:  MOVF   6D,F
04A4:  BTFSS  03.2
04A5:  GOTO   4A9
04A6:  MOVF   6E,F
04A7:  BTFSC  03.2
04A8:  GOTO   543
....................          temp=(num/base); 
04A9:  BCF    03.1
04AA:  MOVF   67,W
04AB:  BSF    03.5
04AC:  MOVWF  1E
04AD:  BCF    03.5
04AE:  MOVF   66,W
04AF:  BSF    03.5
04B0:  MOVWF  1D
04B1:  BCF    03.5
04B2:  MOVF   65,W
04B3:  BSF    03.5
04B4:  MOVWF  1C
04B5:  BCF    03.5
04B6:  MOVF   64,W
04B7:  BSF    03.5
04B8:  MOVWF  1B
04B9:  CLRF   22
04BA:  CLRF   21
04BB:  CLRF   20
04BC:  BCF    03.5
04BD:  MOVF   68,W
04BE:  BSF    03.5
04BF:  MOVWF  1F
04C0:  BCF    03.5
04C1:  BCF    03.6
04C2:  CALL   3C9
04C3:  MOVF   7A,W
04C4:  BSF    03.6
04C5:  MOVWF  6E
04C6:  MOVF   79,W
04C7:  MOVWF  6D
04C8:  MOVF   78,W
04C9:  MOVWF  6C
04CA:  MOVF   77,W
04CB:  MOVWF  6B
....................          s[cnt]=(num%base)+'0';    // Conversion 
04CC:  BSF    03.5
04CD:  MOVF   11,W
04CE:  BCF    03.5
04CF:  ADDWF  69,W
04D0:  MOVWF  78
04D1:  MOVF   6A,W
04D2:  MOVWF  7A
04D3:  BTFSC  03.0
04D4:  INCF   7A,F
04D5:  MOVF   78,W
04D6:  BSF    03.5
04D7:  MOVWF  13
04D8:  MOVF   7A,W
04D9:  MOVWF  14
04DA:  CLRF   16
04DB:  MOVF   04,W
04DC:  MOVWF  15
04DD:  BCF    16.0
04DE:  BTFSC  03.7
04DF:  BSF    16.0
04E0:  BSF    03.1
04E1:  MOVLW  97
04E2:  MOVWF  04
04E3:  BSF    03.7
04E4:  BCF    03.5
04E5:  MOVF   67,W
04E6:  BSF    03.5
04E7:  MOVWF  1E
04E8:  BCF    03.5
04E9:  MOVF   66,W
04EA:  BSF    03.5
04EB:  MOVWF  1D
04EC:  BCF    03.5
04ED:  MOVF   65,W
04EE:  BSF    03.5
04EF:  MOVWF  1C
04F0:  BCF    03.5
04F1:  MOVF   64,W
04F2:  BSF    03.5
04F3:  MOVWF  1B
04F4:  CLRF   22
04F5:  CLRF   21
04F6:  CLRF   20
04F7:  BCF    03.5
04F8:  MOVF   68,W
04F9:  BSF    03.5
04FA:  MOVWF  1F
04FB:  BCF    03.5
04FC:  BCF    03.6
04FD:  CALL   3C9
04FE:  BSF    03.5
04FF:  BSF    03.6
0500:  MOVF   15,W
0501:  MOVWF  04
0502:  BCF    03.7
0503:  BTFSC  16.0
0504:  BSF    03.7
0505:  MOVLW  30
0506:  ADDWF  17,W
0507:  MOVWF  77
0508:  MOVF   18,W
0509:  MOVWF  78
050A:  MOVLW  00
050B:  BTFSC  03.0
050C:  MOVLW  01
050D:  ADDWF  78,F
050E:  MOVF   19,W
050F:  MOVWF  79
0510:  MOVLW  00
0511:  BTFSC  03.0
0512:  MOVLW  01
0513:  ADDWF  79,F
0514:  MOVF   1A,W
0515:  MOVWF  7A
0516:  MOVLW  00
0517:  BTFSC  03.0
0518:  MOVLW  01
0519:  ADDWF  7A,F
051A:  MOVF   13,W
051B:  MOVWF  04
051C:  BCF    03.7
051D:  BTFSC  14.0
051E:  BSF    03.7
051F:  MOVF   77,W
0520:  MOVWF  00
....................  
....................          if(s[cnt]>0x39) 
0521:  MOVF   11,W
0522:  BCF    03.5
0523:  ADDWF  69,W
0524:  MOVWF  04
0525:  BCF    03.7
0526:  BTFSC  6A.0
0527:  BSF    03.7
0528:  MOVF   00,W
0529:  SUBLW  39
052A:  BTFSC  03.0
052B:  GOTO   537
....................             s[cnt]+=0x7; 
052C:  BSF    03.5
052D:  MOVF   11,W
052E:  BCF    03.5
052F:  ADDWF  69,W
0530:  MOVWF  04
0531:  BCF    03.7
0532:  BTFSC  6A.0
0533:  BSF    03.7
0534:  MOVLW  07
0535:  ADDWF  00,W
0536:  MOVWF  00
....................  
....................          cnt++; 
0537:  BSF    03.5
0538:  INCF   11,F
....................          num=temp; 
0539:  BCF    03.5
053A:  MOVF   6E,W
053B:  MOVWF  67
053C:  MOVF   6D,W
053D:  MOVWF  66
053E:  MOVF   6C,W
053F:  MOVWF  65
0540:  MOVF   6B,W
0541:  MOVWF  64
0542:  GOTO   49D
....................      } 
....................  
....................      if(sign==1) { 
0543:  BSF    03.5
0544:  DECFSZ 10,W
0545:  GOTO   551
....................          s[cnt]=0x2D;      // Negative sign 
0546:  MOVF   11,W
0547:  BCF    03.5
0548:  ADDWF  69,W
0549:  MOVWF  04
054A:  BCF    03.7
054B:  BTFSC  6A.0
054C:  BSF    03.7
054D:  MOVLW  2D
054E:  MOVWF  00
....................          cnt++; 
054F:  BSF    03.5
0550:  INCF   11,F
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
0551:  BCF    03.5
0552:  CLRF   6F
0553:  BCF    03.0
0554:  BSF    03.5
0555:  RRF    11,W
0556:  BCF    03.5
0557:  SUBWF  6F,W
0558:  BTFSC  03.0
0559:  GOTO   596
....................  
....................          c=s[i]; 
055A:  MOVF   6F,W
055B:  ADDWF  69,W
055C:  MOVWF  04
055D:  BCF    03.7
055E:  BTFSC  6A.0
055F:  BSF    03.7
0560:  MOVF   00,W
0561:  BSF    03.5
0562:  MOVWF  12
....................          s[i]=s[cnt-i-1];        // Reverse the number 
0563:  BCF    03.5
0564:  MOVF   6F,W
0565:  ADDWF  69,W
0566:  MOVWF  78
0567:  MOVF   6A,W
0568:  MOVWF  7A
0569:  BTFSC  03.0
056A:  INCF   7A,F
056B:  MOVF   78,W
056C:  BSF    03.5
056D:  MOVWF  13
056E:  MOVF   7A,W
056F:  MOVWF  14
0570:  BCF    03.5
0571:  MOVF   6F,W
0572:  BSF    03.5
0573:  SUBWF  11,W
0574:  ADDLW  FF
0575:  BCF    03.5
0576:  ADDWF  69,W
0577:  MOVWF  04
0578:  BCF    03.7
0579:  BTFSC  6A.0
057A:  BSF    03.7
057B:  MOVF   00,W
057C:  BSF    03.5
057D:  MOVWF  15
057E:  MOVF   13,W
057F:  MOVWF  04
0580:  BCF    03.7
0581:  BTFSC  14.0
0582:  BSF    03.7
0583:  MOVF   15,W
0584:  MOVWF  00
....................          s[cnt-i-1]=c; 
0585:  BCF    03.5
0586:  MOVF   6F,W
0587:  BSF    03.5
0588:  SUBWF  11,W
0589:  ADDLW  FF
058A:  BCF    03.5
058B:  ADDWF  69,W
058C:  MOVWF  04
058D:  BCF    03.7
058E:  BTFSC  6A.0
058F:  BSF    03.7
0590:  BSF    03.5
0591:  MOVF   12,W
0592:  MOVWF  00
0593:  BCF    03.5
0594:  INCF   6F,F
0595:  GOTO   553
....................      } 
....................      s[cnt]='\0';     // End the string 
0596:  BSF    03.5
0597:  MOVF   11,W
0598:  BCF    03.5
0599:  ADDWF  69,W
059A:  MOVWF  04
059B:  BCF    03.7
059C:  BTFSC  6A.0
059D:  BSF    03.7
059E:  CLRF   00
....................      return s; 
059F:  MOVF   69,W
05A0:  MOVWF  78
05A1:  MOVF   6A,W
05A2:  MOVWF  79
05A3:  BCF    03.6
05A4:  RETURN
.................... } 
....................  
.................... #if defined(__PCD__) 
....................  
.................... char * itoa(signed int48 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int48 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... char * itoa(signed int64 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int64 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................       
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1;         
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................              
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #endif 
....................  
.................... float strtof(char *s, char *endptr) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s, char *endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float48)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float48)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s, char *endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float64)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float64)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtoulGO; 
....................  
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................    { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... int8 mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #if !defined(__PCD__) 
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2);  
.................... #else  
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2);  
.................... #endif 
....................  
....................  
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    unsigned int8 t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=1; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = 0; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
.................... #INCLUDE <STDIO.H> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDIO 
.................... #define _STDIO 
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #ifndef getc 
.................... #define getc getch 
.................... #define getchar getch 
.................... #define puts(s) {printf(s); putchar(13); putchar(10);} 
.................... #define putc putchar 
.................... #endif 
.................... /* maps error number to an error message. Writes a sequence of characters to 
.................... stderr stream thus: if s is not null then string pointed to by s follwed by 
.................... a colon (:) and a space and the appropriate error message returned by strerror 
.................... function with argument errno 
....................  
.................... Returns: no value 
.................... */ 
....................  
.................... #ifdef _ERRNO 
.................... void perror(char *s) 
.................... { 
....................   if(s) 
....................   fprintf(STDERR,"%s: ",s); 
....................   fprintf(STDERR,"%s\r\n",strerror(errno)); 
.................... } 
.................... #endif 
.................... #endif 
....................  
.................... #INCLUDE <MATH.H> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2011 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                    //// 
.................... //// History:                                                           //// 
.................... ////  * 9/20/2001 :  Improvments are made to sin/cos code.              //// 
.................... ////                 The code now is small, much faster,                //// 
.................... ////                 and more accurate.                                 //// 
.................... ////  * 2/21/2007 :  Compiler handles & operator differently and does   //// 
.................... ////                 not return generic (int8 *) so type cast is done   //// 
.................... ////  * 6/19/2010 :  Divisions by constants converted to multiplication //// 
.................... ////                 by its inverse to improve computation speed        //// 
.................... ////  * 1/21/2011 :  Constants used for double precision math updated   //// 
.................... ////                 Updated routines include 64 bit versions of cos,   //// 
.................... ////                 asin,atan,exp,log and dependant functions          //// 
.................... ////  * 1/31/2011 :  Optimized current 32-bit float routines for cos    //// 
.................... ////                 and log function                                   //// 
.................... ////  * 6/13/2011 :  Fixed PCD overload CEIL_FLOOR functions for values //// 
.................... ////                 greater then 10000000 and less then -10000000      //// 
.................... ////                                                                    //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef MATH_H 
.................... #define MATH_H 
....................  
.................... #ifdef PI 
.................... #undef  PI 
.................... #endif 
.................... #define PI     3.1415926535897932 
....................  
....................  
.................... #define SQRT2  1.4142135623730950 
....................  
.................... //float const ps[4] = {5.9304945, 21.125224, 8.9403076, 0.29730279}; 
.................... //float const qs[4] = {1.0000000, 15.035723, 17.764134, 2.4934718}; 
....................  
.................... ///////////////////////////// Round Functions ////////////////////////////// 
....................  
.................... float32 CEIL_FLOOR(float32 x, unsigned int8 n) 
.................... { 
....................    float32 y, res; 
....................    unsigned int16 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................       res = (float32)(unsigned int16)y; 
....................  
....................  else if (y < 10000000.0) 
....................    {  
....................       l = (unsigned int16)(y*0.000030517578125); 
....................       y = 32768.0*(y*0.000030517578125 - (float32)l); 
....................       res = 32768.0*(float32)l; 
....................       res += (float32)(unsigned int16)y; 
....................    } 
....................  
....................  else 
....................   res = y; 
....................  
....................  y = y - (float32)(unsigned int16)y; 
....................  
....................  if (s) 
....................   res = -res; 
....................  
....................  if (y != 0) 
....................  { 
....................   if (s == 1 && n == 0) 
....................    res -= 1.0; 
....................  
....................   if (s == 0 && n == 1) 
....................    res += 1.0; 
....................  } 
....................  if (x == 0) 
....................     res = 0; 
....................  
....................  return (res); 
.................... } 
....................  
.................... // Overloaded Functions to take care for new Data types in PCD 
.................... // Overloaded function CEIL_FLOOR() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 CEIL_FLOOR(float48 x, unsigned int8 n) 
.................... { 
....................    float48 y, res; 
....................    unsigned int32 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................       res = (float48)(unsigned int16)y; 
....................  
....................    else if (y < 549755813888.0) 
....................    { 
....................       l = (unsigned int32)(y*0.000030517578125); 
....................       y = 32768.0*(y*0.000030517578125 - (float48)l); 
....................       res = 32768.0*(float48)l; 
....................       res += (float48)(unsigned int16)y; 
....................    } 
....................    else 
....................    {   
....................       res = y; 
....................       y = 0.0; 
....................    } 
....................     
....................    if(y != 0) 
....................       y = y - (float48)(unsigned int16)y; 
....................  
....................    if (s) 
....................       res = -res; 
....................  
....................    if (y != 0) 
....................    { 
....................       if (s == 1 && n == 0) 
....................          res -= 1.0; 
....................  
....................       if (s == 0 && n == 1) 
....................          res += 1.0; 
....................    } 
....................    if (x == 0) 
....................       res = 0; 
....................  
....................    return (res); 
.................... } 
....................  
....................  
.................... // Overloaded function CEIL_FLOOR() for data type - Float64 
.................... float64 CEIL_FLOOR(float64 x, unsigned int8 n) 
.................... { 
....................    float64 y, res; 
....................    int64 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................       res = (float64)(unsigned int16)y; 
....................    else if (y < 4503599627370496.0) 
....................    { 
....................       l = (int64)(y*0.000030517578125); 
....................       y = 32768.0*(y*0.000030517578125 - (float64)l); 
....................       res = 32768.0*(float64)l; 
....................       res += (float64)(unsigned int16)y; 
....................    } 
....................    else 
....................    { 
....................       res = y; 
....................       y = 0.0; 
....................    } 
....................     
....................    if(y != 0) 
....................       y = y - (float64)(unsigned int16)y; 
....................  
....................    if (s) 
....................       res = -res; 
....................  
....................    if (y != 0) 
....................    { 
....................       if (s == 1 && n == 0) 
....................          res -= 1.0; 
....................  
....................       if (s == 0 && n == 1) 
....................          res += 1.0; 
....................    } 
....................     
....................    if (x == 0) 
....................       res = 0; 
....................  
....................    return (res); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float floor(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : rounds down the number x. 
.................... // Date : N/A 
.................... // 
.................... float32 floor(float32 x) 
.................... { 
....................    return CEIL_FLOOR(x,0); 
.................... } 
.................... // Following 2 functions are overloaded functions of floor() for PCD 
.................... // Overloaded function floor() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 floor(float48 x) 
.................... { 
....................    return CEIL_FLOOR(x, 0); 
.................... } 
....................  
.................... // Overloaded function floor() for data type - Float64 
.................... float64 floor(float64 x) 
.................... { 
....................    return CEIL_FLOOR(x, 0); 
.................... } 
.................... #endif 
....................  
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float ceil(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : rounds up the number x. 
.................... // Date : N/A 
.................... // 
.................... float32 ceil(float32 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
.................... // Following 2 functions are overloaded functions of ceil() for PCD 
.................... // Overloaded function ceil() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 ceil(float48 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
....................  
.................... // Overloaded function ceil() for data type - Float64 
.................... float64 ceil(float64 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
.................... #endif 
....................  
....................  //////////////////////////////////////////////////////////////////////////// 
.................... //   float fabs(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the absolute value of floating point number x 
.................... // Returns : returns the absolute value of x 
.................... // Date : N/A 
.................... // 
.................... #define fabs abs 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float fmod(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the floating point remainder of x/y 
.................... // Returns : returns the value of x= i*y, for some integer i such that, if y 
.................... // is non zero, the result has the same isgn of x na dmagnitude less than the 
.................... // magnitude of y. If y is zero then a domain error occurs. 
.................... // Date : N/A 
.................... // 
....................  
.................... float fmod(float32 x,float32 y) 
.................... { 
....................    float32 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... //Overloaded function for fmod() for PCD 
.................... // Overloaded function fmod() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 fmod(float48 x,float48 y) 
.................... { 
....................    float48 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... // Overloaded function fmod() for data type - Float64 
.................... float64 fmod(float64 x,float64 y) 
.................... { 
....................    float64 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... #endif 
.................... //////////////////// Exponential and logarithmic functions //////////////////// 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float exp(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (e^x) 
.................... // Date : N/A 
.................... // 
.................... #define LN2 0.6931471805599453 
.................... #define LN2_INV 1.4426950408889634073 
....................  
.................... float const pe[6] = {0.000207455774, 0.00127100575, 0.00965065093, 
....................                      0.0554965651,  0.240227138,  0.693147172}; 
....................  
....................  
.................... float32 exp(float32 x) 
.................... { 
....................    float32 y, res, r; 
....................    #if defined(__PCD__) 
....................    int8 data1; 
....................    #endif 
....................    signed int8 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 88.722838) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    n = (signed int16)(x*LN2_INV); 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
.................... #if !defined(__PCD__) 
....................    *((unsigned int8 *)(&res)) = n + 0x7F; 
.................... #endif 
....................  
.................... #if defined(__PCD__)  // Takes care of IEEE format for PCD 
....................    data1 = n+0x7F; 
....................    if(bit_test(data1,0)) 
....................    bit_set(*(((unsigned int8 *)(&res)+2)),7); 
....................    rotate_right(&data1,1); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&res)+3)) = data1; 
.................... #endif 
....................  
....................    y = y*LN2_INV - (float32)n; 
....................  
....................    r = pe[0]*y + pe[1]; 
....................    r = r*y + pe[2]; 
....................    r = r*y + pe[3]; 
....................    r = r*y + pe[4]; 
....................    r = r*y + pe[5]; 
....................  
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
....................  
....................  
.................... //Overloaded function for exp() for PCD 
.................... // Overloaded function exp() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 exp(float48 x) 
.................... { 
....................    float48 y, res, r; 
....................    int8 data1; 
....................    signed int8 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 88.722838) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    n = (signed int16)(x*LN2_INV); 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
....................  
....................    data1 = n+0x7F; 
....................    if(bit_test(data1,0)) 
....................    bit_set(*(((unsigned int8 *)(&res)+4)),7); 
....................    rotate_right(&data1,1); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&res)+5)) = data1; 
....................  
....................    y = y*LN2_INV - (float48)n; 
....................  
....................    r = pe[0]*y + pe[1]; 
....................    r = r*y + pe[2]; 
....................    r = r*y + pe[3]; 
....................    r = r*y + pe[4]; 
....................    r = r*y + pe[5]; 
....................  
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function exp() for data type - Float64 
.................... float64 const pe_64[12] ={9.30741400474913e-011,-4.28655416283316e-011, 
....................                           8.71486547014137e-009,9.84458531538385e-008, 
....................                           1.32588296983536e-006,1.52489283823016e-005, 
....................                           0.000154037598423921,0.00133335487036216, 
....................                           0.00961812936407326,0.0555041086222122, 
....................                           0.240226506962827,0.693147180559823}; 
....................  
.................... float64 exp(float64 x) 
.................... { 
....................    float64 y, res, r; 
....................    unsigned int16 data1, data2; 
....................    unsigned int16 *p; 
....................    signed int16 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 709.7827128) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x*LN2_INV; 
....................    n = (signed int16)y; 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
....................  
.................... #if !defined(__PCD__) 
....................    *((unsigned int16 *)(&res)) = n + 0x7F; 
.................... #endif 
....................    p= (((unsigned int16 *)(&res))+3); 
....................    data1 = *p; 
....................    data2 = *p;    
....................    data1 = n + 0x3FF; 
....................    data1 = data1 <<4; 
....................    if(bit_test(data2,15)) 
....................    bit_set(data1,15); 
....................    data2 = data2 & 0x000F; 
....................    data1 ^= data2; 
....................  
....................    *(((unsigned int16 *)(&res)+3)) = data1; 
....................  
....................  
....................    y = y*LN2_INV - (float64)n; 
....................  
....................    r = pe_64[0]*y + pe_64[1]; 
....................    r = r*y + pe_64[2]; 
....................    r = r*y + pe_64[3]; 
....................    r = r*y + pe_64[4]; 
....................    r = r*y + pe_64[5]; 
....................    r = r*y + pe_64[6]; 
....................    r = r*y + pe_64[7]; 
....................    r = r*y + pe_64[8]; 
....................    r = r*y + pe_64[9]; 
....................    r = r*y + pe_64[10]; 
....................    r = r*y + pe_64[11]; 
....................     
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
.................... #ENDIF 
....................  
....................  
.................... /************************************************************/ 
....................  
.................... float32 const pl[4] = {-1.080310025160955, 1.999999947089217}; 
.................... float32 const ql[4] = {0.091284365719509, -0.873491916557671}; 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float log(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the the natural log of x 
.................... // Date : N/A 
.................... // 
.................... float32 log(float32 x) 
.................... { 
....................    float32 y, res, r, y2; 
....................    #if defined(__PCD__) 
....................    unsigned int8  data1,data2; 
....................    #endif 
....................    signed int8 n; 
....................    #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
.................... #if !defined(__PCD__) 
....................     *((unsigned int8 *)(&y)) = 0x7E;  
.................... #endif 
....................  
.................... #if defined(__PCD__) // Takes care of IEEE format 
....................    data2 = *(((unsigned int8 *)(&y))+3); 
....................    *(((unsigned int8 *)(&y))+3) = 0x3F; 
....................    data1 = *(((unsigned int8 *)(&y))+2); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&y))+2) = data1; 
....................    if(bit_test(data2,7)) 
....................      bit_set(*(((unsigned int8 *)(&y))+3),7); 
.................... #endif 
....................  
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl[0]*y2 + pl[1]; 
....................  
....................       r = ql[0]*y2 + ql[1]; 
....................       r = r*y2 + 1.0; 
....................  
....................       res = y*res/r; 
.................... #if !defined(__PCD__) 
....................       n = *((unsigned int8 *)(&x)) - 0x7E; 
.................... #endif 
.................... #if defined(__PCD__)  
....................     data1 = *(((unsigned int8 *)(&x)+3)); 
....................     rotate_left(&data1,1); 
....................     data2 = *(((unsigned int8 *)(&x)+2)); 
....................     if(bit_test (data2,7)) 
....................       bit_set(data1,0); 
....................     n = data1 - 0x7E; 
.................... #endif 
....................  
....................       if (n<0)  
....................          r = -(float32)-n; 
....................       else 
....................          r = (float32)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................       res = 0.0; 
....................  
....................    return(res); 
.................... } 
....................  
.................... //Overloaded function for log() for PCD 
.................... // Overloaded function log() for data type - Float48 
.................... #if defined(__PCD__) 
.................... // Overloaded function log() for data type - float64 
.................... float64 const pl_64[4] = {-0.145694052150681, 1.365485300000370, 
....................                           -3.120535668274329, 2.000000000000000}; 
....................  
.................... float64 const ql_64[4] = {0.006047500465908, -0.208298281937234, 
....................                           1.113943039156721, -1.893601167470470}; 
....................  
.................... float48 log(float48 x) 
.................... { 
....................    float48 y, res, r, y2; 
....................    unsigned int8  data1,data2; 
....................    signed int8 n; 
.................... #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
.................... #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
....................  
.................... #if !defined(__PCD__) 
....................       *((unsigned int8 *)(&y)) = 0x7E;  
.................... #endif 
....................       data2 = *(((unsigned int8 *)(&y))+5); 
....................       *(((unsigned int8 *)(&y))+5) = 0x3F; 
....................       data1 = *(((unsigned int8 *)(&y))+4); 
....................       bit_clear(data1,7); 
....................       *(((unsigned int8 *)(&y))+4) = data1; 
....................  
....................       if(bit_test(data2,7)) 
....................       bit_set(*(((unsigned int8 *)(&y))+4),7); 
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl_64[0]*y2 + pl_64[1]; 
....................       res = res*y2 + pl_64[2]; 
....................       res = res*y2 + pl_64[3]; 
....................  
....................       r = ql_64[0]*y2 + ql_64[1]; 
....................       r = r*y2 + ql_64[2]; 
....................       r = r*y2 + ql_64[3]; 
....................       r = r*y2 + 1.0;  
....................       res = y*res/r; 
....................  
....................       data1 = *(((unsigned int8 *)(&x)+5)); 
....................       rotate_left(&data1,1); 
....................       data2 = *(((unsigned int8 *)(&x)+4)); 
....................       if(bit_test (data2,7)) 
....................       bit_set(data1,0); 
....................        
....................       n = data1 - 0x7E; 
....................  
....................       if (n<0) 
....................       r = -(float48)-n; 
....................       else 
....................       r = (float48)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................    res = 0.0; 
....................  
....................    return(res); 
.................... } 
....................  
.................... float64 log(float64 x) 
.................... { 
....................    float64 y, res, r, y2; 
....................    unsigned int16  data1,data2; 
....................    unsigned int16 *p; 
....................    signed int16 n; 
....................    #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
....................    #if !defined(__PCD__) 
....................        *((unsigned int8 *)(&y)) = 0x7E;  
....................    #endif 
....................       p= (((unsigned int16 *)(&y))+3); 
....................       data1 = *p; 
....................       data2 = *p; 
....................       data1 = 0x3FE; 
....................       data1 = data1 <<4; 
....................       if(bit_test (data2,15)) 
....................          bit_set(data1,15); 
....................       data2 = data2 & 0x000F; 
....................       data1 ^=data2; 
....................  
....................       *p = data1; 
....................  
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl_64[0]*y2 + pl_64[1]; 
....................       res = res*y2 + pl_64[2]; 
....................       res = res*y2 + pl_64[3]; 
....................  
....................       r = ql_64[0]*y2 + ql_64[1]; 
....................       r = r*y2 + ql_64[2]; 
....................       r = r*y2 + ql_64[3]; 
....................       r = r*y2 + 1.0; 
....................  
....................       res = y*res/r; 
....................   
....................       p= (((unsigned int16 *)(&x))+3); 
....................       data1 = *p; 
....................       bit_clear(data1,15); 
....................       data1 = data1 >>4;     
....................       n = data1 - 0x3FE; 
....................  
....................  
....................       if (n<0) 
....................          r = -(float64)-n; 
....................       else 
....................          r = (float64)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................       res = 0.0; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
....................  
.................... #define LN10 2.3025850929940456 
.................... #define LN10_INV 0.4342944819032518276 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float log10(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the the log base 10 of x 
.................... // Date : N/A 
.................... // 
.................... float32 log10(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = log(x); 
....................    r = r*LN10_INV; 
....................    return(r); 
.................... } 
....................  
.................... //Overloaded functions for log10() for PCD 
.................... // Overloaded function log10() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 log10(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = log(x); 
....................    r = r*LN10_INV; 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function log10() for data type - Float64 
.................... float64 log10(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = log(x); 
....................    r = r*LN10_INV; 
....................    return(r); 
.................... } 
.................... #endif 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float modf(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description :breaks the argument value int integral and fractional parts, 
.................... // ach of which have the same sign as the argument.  It stores the integral part 
.................... // as a float in the object pointed to by the iptr 
.................... // Returns : returns the signed fractional part of value. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 modf(float32 value,float32 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... //Overloaded functions for modf() for PCD 
.................... // Overloaded function modf() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 modf(float48 value,float48 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... // Overloaded function modf() for data type - Float64 
.................... float64 modf(float64 value,float64 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float pwr(float x,float y) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (x^y) 
.................... // Date : N/A 
.................... // Note : 0 is returned when the function will generate an imaginary number 
.................... // 
.................... float32 pwr(float32 x,float32 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... //Overloaded functions for pwr() for PCD 
.................... // Overloaded function pwr() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 pwr(float48 x,float48 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... // Overloaded function pwr() for data type - Float64 
.................... float64 pwr(float64 x,float64 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////// Power functions //////////////////// 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float pow(float x,float y) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (x^y) 
.................... // Date : N/A 
.................... // Note : 0 is returned when the function will generate an imaginary number 
.................... // 
.................... float32 pow(float32 x,float32 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... //Overloaded functions for pow() for PCD 
.................... // Overloaded function for pow() data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 pow(float48 x,float48 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
....................  
.................... // Overloaded function pow() for data type - Float64 
.................... float64 pow(float64 x,float64 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sqrt(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the square root of x 
.................... // Date : N/A 
.................... // 
.................... float32 sqrt(float32 x) 
.................... { 
....................    float32 y, res; 
....................    #if defined(__PCD__) 
....................    unsigned int16 data1,data2; 
....................    #endif 
....................    unsigned int8 *p; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................     
....................    #if !defined(__PCD__) 
....................     p=&y; 
....................    (*p)=(unsigned int8)((((unsigned int16)(*p)) + 127) >> 1); 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     p = (((unsigned int8 *)(&y))+3); 
....................     data1 = *(((unsigned int8 *)(&y))+3); 
....................     data2 = *(((unsigned int8 *)(&y))+2); 
....................     rotate_left(&data1,1);     
....................     if(bit_test(data2,7))     
....................        bit_set(data1,0);     
....................     data1 = ((data1+127) >>1); 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+3) = data1; 
....................     *(((unsigned int8 *)(&y))+2) = data2; 
....................      
....................   #endif 
....................  
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................  
....................       #if !defined(__PCD__) 
....................      (*p)--; 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     data1 = *(((unsigned int8 *)(&y))+3); 
....................     data2 = *(((unsigned int8 *)(&y))+2); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................        bit_set(data1,0);     
....................     data1--; 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+3) = data1; 
....................     *(((unsigned int8 *)(&y))+2) = data2; 
....................      
....................   #endif 
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
.................... //Overloaded functions for sqrt() for PCD 
.................... // Overloaded function sqrt() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sqrt(float48 x) 
.................... { 
....................    float48 y, res; 
....................    unsigned int16 data1,data2; 
....................    unsigned int8 *p; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................     
....................    #if !defined(__PCD__) 
....................     p=&y; 
....................    (*p)=(unsigned int8)((((unsigned int16)(*p)) + 127) >> 1); 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     p = (((unsigned int8 *)(&y))+5); 
....................     data1 = *(((unsigned int8 *)(&y))+5); 
....................     data2 = *(((unsigned int8 *)(&y))+4); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................        bit_set(data1,0);     
....................     data1 = ((data1+127) >>1); 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+5) = data1; 
....................     *(((unsigned int8 *)(&y))+4) = data2; 
....................      
....................   #endif 
....................  
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................  
....................       #if !defined(__PCD__) 
....................      (*p)--; 
....................    #endif 
....................     
....................     data1 = *(((unsigned int8 *)(&y))+5); 
....................     data2 = *(((unsigned int8 *)(&y))+4); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................        bit_set(data1,0);     
....................     data1--; 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+5) = data1; 
....................     *(((unsigned int8 *)(&y))+4) = data2; 
....................      
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function sqrt() for data type - Float64 
.................... float64 sqrt(float64 x) 
.................... { 
....................    float64 y, res; 
....................    unsigned int16 *p; 
....................    unsigned int16 temp1,temp2; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................    p= (((unsigned int16 *)(&y))+3); 
....................    temp1 = *p; 
....................    temp2 = *p; 
....................    bit_clear(temp1,15); 
....................    temp1 = (temp1>>4)+1023; 
....................    temp1 = temp1 >> 1; 
....................    temp1 = (temp1<<4) & 0xFFF0; 
....................    if(bit_test(temp2,15)) 
....................       bit_set(temp1,15); 
....................    temp2 = temp2 & 0x000F; 
....................    temp1 ^= temp2; 
....................     
....................    (*p) = temp1; 
....................     
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................      temp1 = *p; 
....................      temp2 = *p; 
....................      bit_clear(temp1,15); 
....................      temp1 = (temp1>>4); 
....................      temp1--; 
....................      temp1 = (temp1<<4) & 0xFFF0; 
....................      if(bit_test(temp2,15)) 
....................         bit_set(temp1,15); 
....................      temp2 = temp2 & 0x000F; 
....................      temp1 ^= temp2; 
....................      (*p) = temp1; 
....................  
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... ////////////////////////////// Trig Functions ////////////////////////////// 
.................... #ifdef PI_DIV_BY_TWO_INV 
.................... #undef PI_DIV_BY_TWO_INV 
.................... #endif 
.................... #define PI_DIV_BY_TWO_INV 0.63661977236758134 
.................... #ifdef PI_DIV_BY_TWO 
.................... #undef PI_DIV_BY_TWO 
.................... #endif 
.................... #define PI_DIV_BY_TWO   1.5707963267948966 
.................... #ifdef TWOBYPI 
.................... #undef TWOBYPI 
.................... #endif 
.................... #define TWOBYPI          0.6366197723675813 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float cos(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the cosine value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 cos(float32 x) 
.................... { 
....................    float32 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float32 frac; 
....................    float32 p[5] = {                    //by the series definition for cosine 
....................       -0.49999999456337096,            // sum ( ( (-1)^n * x^2n )/(2n)! ) 
....................        0.04166663896921267, 
....................       -0.00138883894522527, 
....................        0.00002476138231734, 
....................       -0.00000026070414770 
....................       //-0.00000000001147, 
....................       // 0.00000000000005 
....................    }; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant 
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 1.0; 
....................    t = t * t; 
....................    for (i = 0; i <= 4; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
....................  
.................... //Overloaded functions for cos() for PCD 
.................... // Overloaded function cos() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 cos(float48 x) 
.................... { 
....................    float48 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float48 frac; 
....................    float48 p[6] = {                    //by the series definition for cosine 
....................       -0.5,                            // sum ( ( (-1)^n * x^2n )/(2n)! ) 
....................        0.04166666666667, 
....................       -0.00138888888889, 
....................        0.00002480158730, 
....................       -0.00000027557319, 
....................        0.00000000208767, 
....................       //-0.00000000001147, 
....................       // 0.00000000000005 
....................    }; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant 
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 0.999999999781; 
....................    t = t * t; 
....................    for (i = 0; i <= 5; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
.................... // Overloaded function cos() for data type - Float64 
.................... float64 cos(float64 x) 
.................... { 
....................    float64 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float64 frac; 
....................    float64 p_64[9] = {               //by the series definition for cosine 
....................      -0.49999999999998740,           // sum ( ( (-1)^n * x^2n )/(2n)! )              
....................       0.04166666666656518, 
....................      -0.00138888888851691, 
....................       0.00002480158658490, 
....................      -0.00000027557239796, 
....................       0.00000000208715031, 
....................      -0.00000000001126577, 
....................       0.00000000000000427, 
....................       0.00000000000000372}; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant 
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 1.0; 
....................    t = t * t; 
....................    for (i = 0; i <= 8; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p_64[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sin(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the sine value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 sin(float32 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
....................  
.................... //Overloaded functions for sin() for PCD 
.................... // Overloaded function sin() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sin(float48 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
....................  
.................... // Overloaded function sin() for data type - Float48 
.................... float64 sin(float64 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float tan(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the tangent value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 tan(float32 x) 
.................... { 
....................    float32 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
.................... //Overloaded functions for tan() for PCD 
.................... // Overloaded function tan() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 tan(float48 x) 
.................... { 
....................    float48 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
....................  
.................... // Overloaded function tan() for data type - Float48 
.................... float64 tan(float64 x) 
.................... { 
....................    float64 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
.................... #endif 
....................  
.................... float32 const pas[3] = {0.49559947, -4.6145309, 5.6036290}; 
.................... float32 const qas[3] = {1.0000000,  -5.5484666, 5.6036290}; 
....................  
.................... float32 ASIN_COS(float32 x, unsigned int8 n) 
.................... { 
....................    float32 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)*0.5); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas[0]*y2 + pas[1]; 
....................    res = res*y2 + pas[2]; 
....................  
....................    r = qas[0]*y2 + qas[1]; 
....................    r = r*y2 + qas[2]; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
....................  
....................  
.................... //Overloaded functions for ASIN_COS() for PCD 
.................... // Overloaded function ASIN_COS() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 ASIN_COS(float48 x, unsigned int8 n) 
.................... { 
....................    float48 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)*0.5); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas[0]*y2 + pas[1]; 
....................    res = res*y2 + pas[2]; 
....................  
....................    r = qas[0]*y2 + qas[1]; 
....................    r = r*y2 + qas[2]; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function ASIN_COS() for data type - Float64 
.................... double pas_64[5]={1.000000000000000,-2.069938587724477,1.421444580548907, 
....................                  -0.360690137621842,0.024929451660228}; 
....................  
.................... double qas_64[5]={-2.236605254391134,1.719212122946451,-0.524122954476133, 
....................                    0.052808872045749,-0.000662536036570}; 
....................                     
.................... float64 ASIN_COS(float64 x, unsigned int8 n) 
.................... { 
....................    float64 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)*0.5); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas_64[4]*y2 + pas_64[3]; 
....................    res = res*y2 + pas_64[2]; 
....................    res = res*y2 + pas_64[1]; 
....................    res = res*y2 + pas_64[0]; 
....................  
....................    r = qas_64[4]*y2 + qas_64[3]; 
....................    r = r*y2 + qas_64[2]; 
....................    r = r*y2 + qas_64[1]; 
....................    r = r*y2 + qas_64[0]; 
....................    r = r*y2 + 1.0; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float asin(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arcsine value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 asin(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
.................... //Overloaded functions for asin() for PCD 
.................... // Overloaded function asin() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 asin(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function asin() for data type - Float64 
.................... float64 asin(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float acos(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arccosine value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 acos(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
.................... //Overloaded functions for acos() for PCD 
.................... // Overloaded function acos() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 acos(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function acos() for data type - Float64 
.................... float64 acos(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
.................... #endif 
....................  
.................... float32 const pat[4] = {0.17630401, 5.6710795, 22.376096, 19.818457}; 
.................... float32 const qat[4] = {1.0000000,  11.368190, 28.982246, 19.818457}; 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float atan(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arctangent value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 atan(float32 x) 
.................... { 
....................    float32 y, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................  
....................    res = pat[0]*y*y + pat[1]; 
....................    res = res*y*y + pat[2]; 
....................    res = res*y*y + pat[3]; 
....................  
....................    r = qat[0]*y*y + qat[1]; 
....................    r = r*y*y + qat[2]; 
....................    r = r*y*y + qat[3]; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
.................... //Overloaded functions for atan() for PCD 
.................... // Overloaded function atan() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 atan(float48 x) 
.................... { 
....................    float48 y, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................  
....................    res = pat[0]*y*y + pat[1]; 
....................    res = res*y*y + pat[2]; 
....................    res = res*y*y + pat[3]; 
....................  
....................    r = qat[0]*y*y + qat[1]; 
....................    r = r*y*y + qat[2]; 
....................    r = r*y*y + qat[3]; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
....................  
.................... float64 pat_64[6]={0.999999999999999,2.249923645595566,1.771541617806449, 
....................                    0.579678874003185,0.072162702162882,0.002281100141660}; 
....................  
.................... float64 qat_64[6]={2.583256978928510,2.432627277466967,1.016760379885393, 
....................                    0.182482977188688,0.011155377971690,0.000100013019160}; 
.................... // Overloaded function atan() for data type - Float64 
.................... float64 atan(float64 x) 
.................... { 
....................    float64 y,y2, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................    y2 = y*y; 
....................    res = pat_64[5]*y2 + pat_64[4]; 
....................    res = res*y2 + pat_64[3]; 
....................    res = res*y2 + pat_64[2]; 
....................    res = res*y2 + pat_64[1]; 
....................    res = res*y2 + pat_64[0]; 
....................  
....................    r = qat_64[5]*y2 + qat_64[4]; 
....................    r = r*y2 + qat_64[3]; 
....................    r = r*y2 + qat_64[2]; 
....................    r = r*y2 + qat_64[1]; 
....................    r = r*y2 + qat_64[0]; 
....................    r = r*y2 + 1.0; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... ///////////////////////////////////////////////////////////////////////////// 
.................... //   float atan2(float y, float x) 
.................... ///////////////////////////////////////////////////////////////////////////// 
.................... // Description :computes the principal value of arc tangent of y/x, using the 
.................... // signs of both the arguments to determine the quadrant of the return value 
.................... // Returns : returns the arc tangent of y/x. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 atan2(float32 y,float32 x) 
.................... { 
....................    float32 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
....................  
.................... //Overloaded functions for atan2() for PCD 
.................... // Overloaded function atan2() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 atan2(float48 y,float48 x) 
.................... { 
....................    float48 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
....................  
.................... // Overloaded function atan2() for data type - Float64 
.................... float64 atan2(float64 y,float64 x) 
.................... { 
....................    float64 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////// Hyperbolic functions //////////////////// 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float cosh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic cosine value of x 
.................... // Returns : returns the hyperbolic cosine value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 cosh(float32 x) 
.................... { 
....................    return ((exp(x)+exp(-x))*0.5); 
.................... } 
.................... //Overloaded functions for cosh() for PCD 
.................... // Overloaded function cosh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 cosh(float48 x) 
.................... { 
....................    return ((exp(x)+exp(-x))*0.5); 
.................... } 
....................  
.................... // Overloaded function cosh() for data type - Float64 
.................... float64 cosh(float64 x) 
.................... { 
....................    return ((exp(x)+exp(-x))*0.5); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sinh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic sine value of x 
.................... // Returns : returns the hyperbolic sine value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 sinh(float32 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))*0.5); 
.................... } 
.................... //Overloaded functions for sinh() for PCD 
.................... // Overloaded function sinh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sinh(float48 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))*0.5); 
.................... } 
....................  
.................... // Overloaded function sinh() for data type - Float48 
.................... float64 sinh(float64 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))*0.5); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float tanh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic tangent value of x 
.................... // Returns : returns the hyperbolic tangent value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 tanh(float32 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
.................... //Overloaded functions for tanh() for PCD 
.................... // Overloaded function tanh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 tanh(float48 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
....................  
.................... // Overloaded function tanh() for data type - Float64 
.................... float64 tanh(float64 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float frexp(float x, signed int *exp) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : breaks a floating point number into a normalized fraction and an integral 
.................... // power of 2. It stores the integer in the signed int object pointed to by exp. 
.................... // Returns : returns the value x, such that x is a double with magnitude in the interval 
.................... // [1/2,1) or zero, and value equals x times 2 raised to the power *exp.If value is zero, 
.................... // both parts of the result are zero. 
.................... // Date : N/A 
.................... // 
....................  
.................... #define LOG2 .30102999566398119521 
.................... #define LOG2_INV 3.32192809488736234787 
.................... float32 frexp(float32 x, signed int8 *exp) 
.................... { 
....................    float32 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)*LOG2_INV)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
....................  
.................... //Overloaded functions for frexp() for PCD 
.................... // Overloaded function frexp() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 frexp(float48 x, signed int8 *exp) 
.................... { 
....................    float48 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)*LOG2_INV)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
....................  
.................... // Overloaded function frexp() for data type - Float64 
.................... float64 frexp(float64 x, signed int8 *exp) 
.................... { 
....................    float64 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)*LOG2_INV)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
.................... #endif 
....................  
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... //   float ldexp(float x, signed int *exp) 
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... // Description : multiplies a floating point number by an integral power of 2. 
.................... // Returns : returns the value of x times 2 raised to the power exp. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 ldexp(float32 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... //Overloaded functions for ldexp() for PCD 
.................... // Overloaded function ldexp() for data type - Float48 
....................  
.................... #if defined(__PCD__) 
.................... float48 ldexp(float48 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... // Overloaded function ldexp() for data type - Float64 
.................... float64 ldexp(float64 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... #endif 
....................  
.................... #endif 
....................  
.................... #INCLUDE <xuatbyte74595.c> 
....................  
.................... #DEFINE      DS               PIN_D1 
.................... #DEFINE      SH_CP            PIN_D0   
.................... #DEFINE      STCP             PIN_D2 
.................... VOID XUATTRANGTHAI(UNSIGNED INT8 BYTEXUAT) 
.................... { 
....................    UNSIGNED INT8   SB;    
....................    #BIT BSERI  = BYTEXUAT.7 
....................     
....................    FOR (SB=0;SB<8;SB++) 
*
0CF2:  CLRF   3F
0CF3:  MOVF   3F,W
0CF4:  SUBLW  07
0CF5:  BTFSS  03.0
0CF6:  GOTO   50D
....................       {                                                  
....................          OUTPUT_BIT(DS,BSERI);     
0CF7:  BTFSC  3E.7
0CF8:  GOTO   4FD
0CF9:  BCF    03.6
0CFA:  BCF    08.1
0CFB:  GOTO   4FF
0CFC:  BSF    03.6
0CFD:  BCF    03.6
0CFE:  BSF    08.1
0CFF:  BSF    03.5
0D00:  BCF    08.1
....................          OUTPUT_LOW(SH_CP); OUTPUT_HIGH(SH_CP); 
0D01:  BCF    08.0
0D02:  BCF    03.5
0D03:  BCF    08.0
0D04:  BSF    03.5
0D05:  BCF    08.0
0D06:  BCF    03.5
0D07:  BSF    08.0
....................          BYTEXUAT=BYTEXUAT<<1; //10010010->00100100   
0D08:  BCF    03.0
0D09:  BSF    03.6
0D0A:  RLF    3E,F
0D0B:  INCF   3F,F
0D0C:  GOTO   4F3
....................      } 
....................       OUTPUT_LOW(STCP); OUTPUT_HIGH(STCP); 
0D0D:  BSF    03.5
0D0E:  BCF    03.6
0D0F:  BCF    08.2
0D10:  BCF    03.5
0D11:  BCF    08.2
0D12:  BSF    03.5
0D13:  BCF    08.2
0D14:  BCF    03.5
0D15:  BSF    08.2
.................... } 
....................  
....................  
.................... #FUSES NOWDT, PUT, HS 
.................... #USE DELAY(CLOCK=20M) 
*
017A:  MOVLW  62
017B:  MOVWF  04
017C:  BSF    03.7
017D:  MOVF   00,W
017E:  BTFSC  03.2
017F:  GOTO   18D
0180:  MOVLW  06
0181:  MOVWF  78
0182:  CLRF   77
0183:  DECFSZ 77,F
0184:  GOTO   183
0185:  DECFSZ 78,F
0186:  GOTO   182
0187:  MOVLW  7B
0188:  MOVWF  77
0189:  DECFSZ 77,F
018A:  GOTO   189
018B:  DECFSZ 00,F
018C:  GOTO   180
018D:  RETURN
*
0E8B:  MOVLW  03
0E8C:  BSF    03.6
0E8D:  SUBWF  45,F
0E8E:  BTFSS  03.0
0E8F:  GOTO   69A
0E90:  MOVLW  45
0E91:  MOVWF  04
0E92:  BSF    03.7
0E93:  MOVF   00,W
0E94:  BTFSC  03.2
0E95:  GOTO   69A
0E96:  GOTO   698
0E97:  GOTO   698
0E98:  DECFSZ 00,F
0E99:  GOTO   697
0E9A:  BCF    03.6
0E9B:  RETURN
.................... #USE RS232(BAUD=9600,XMIT=PIN_C6,RCV=PIN_C7) 
.................... #DEFINE BT1_PIN PIN_B1 
.................... #DEFINE BT2_PIN PIN_B2 
.................... #DEFINE BT3_PIN PIN_B3 
.................... #DEFINE LCD_ENABLE_PIN  PIN_E0                                    
.................... #DEFINE LCD_RS_PIN      PIN_E1                                 
.................... #DEFINE LCD_RW_PIN      PIN_E2   
.................... #DEFINE LCD_DATA4       PIN_C0                                
.................... #DEFINE LCD_DATA5       PIN_C1                                  
.................... #DEFINE LCD_DATA6       PIN_C2                                    
.................... #DEFINE LCD_DATA7       PIN_C3   
.................... #INCLUDE <LCD.C> 
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... ////                             LCD.C                                     //// 
.................... ////                 Driver for common LCD modules                         //// 
.................... ////                                                                       //// 
.................... ////  lcd_init()   Must be called before any other function.               //// 
.................... ////                                                                       //// 
.................... ////  lcd_putc(c)  Will display c on the next position of the LCD.         //// 
.................... ////                 \a  Set cursor position to upper left                 //// 
.................... ////                 \f  Clear display, set cursor to upper left           //// 
.................... ////                 \n  Go to start of second line                        //// 
.................... ////                 \b  Move back one position                            //// 
.................... ////              If LCD_EXTENDED_NEWLINE is defined, the \n character     //// 
.................... ////              will erase all remanining characters on the current      //// 
.................... ////              line, and move the cursor to the beginning of the next   //// 
.................... ////              line.                                                    //// 
.................... ////              If LCD_EXTENDED_NEWLINE is defined, the \r character     //// 
.................... ////              will move the cursor to the start of the current         //// 
.................... ////              line.                                                    //// 
.................... ////                                                                       //// 
.................... ////  lcd_gotoxy(x,y) Set write position on LCD (upper left is 1,1)        //// 
.................... ////                                                                       //// 
.................... ////  lcd_getc(x,y)   Returns character at position x,y on LCD             //// 
.................... ////                                                                       //// 
.................... ////  lcd_cursor_on(int1 on)   Turn the cursor on (on=TRUE) or off         //// 
.................... ////              (on=FALSE).                                              //// 
.................... ////                                                                       //// 
.................... ////  lcd_set_cgram_char(w, *p)   Write a custom character to the CGRAM.   //// 
.................... ////                                                                       //// 
.................... ////                                                                       //// 
.................... ////  CONFIGURATION                                                        //// 
.................... ////  The LCD can be configured in one of two ways: a.) port access or     //// 
.................... ////  b.) pin access.  Port access requires the entire 7 bit interface     //// 
.................... ////  connected to one GPIO port, and the data bits (D4:D7 of the LCD)     //// 
.................... ////  connected to sequential pins on the GPIO.  Pin access                //// 
.................... ////  has no requirements, all 7 bits of the control interface can         //// 
.................... ////  can be connected to any GPIO using several ports.                    //// 
.................... ////                                                                       //// 
.................... ////  To use port access, #define LCD_DATA_PORT to the SFR location of     //// 
.................... ////  of the GPIO port that holds the interface, -AND- edit LCD_PIN_MAP    //// 
.................... ////  of this file to configure the pin order.  If you are using a         //// 
.................... ////  baseline PIC (PCB), then LCD_OUTPUT_MAP and LCD_INPUT_MAP also must  //// 
.................... ////  be defined.                                                          //// 
.................... ////                                                                       //// 
.................... ////  Example of port access:                                              //// 
.................... ////     #define LCD_DATA_PORT getenv("SFR:PORTD")                         //// 
.................... ////                                                                       //// 
.................... ////  To use pin access, the following pins must be defined:               //// 
.................... ////     LCD_ENABLE_PIN                                                    //// 
.................... ////     LCD_RS_PIN                                                        //// 
.................... ////     LCD_RW_PIN                                                        //// 
.................... ////     LCD_DATA4                                                         //// 
.................... ////     LCD_DATA5                                                         //// 
.................... ////     LCD_DATA6                                                         //// 
.................... ////     LCD_DATA7                                                         //// 
.................... ////                                                                       //// 
.................... ////  Example of pin access:                                               //// 
.................... ////     #define LCD_ENABLE_PIN  PIN_E0                                    //// 
.................... ////     #define LCD_RS_PIN      PIN_E1                                    //// 
.................... ////     #define LCD_RW_PIN      PIN_E2                                    //// 
.................... ////     #define LCD_DATA4       PIN_D4                                    //// 
.................... ////     #define LCD_DATA5       PIN_D5                                    //// 
.................... ////     #define LCD_DATA6       PIN_D6                                    //// 
.................... ////     #define LCD_DATA7       PIN_D7                                    //// 
.................... ////                                                                       //// 
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2010 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef __LCD_C__ 
.................... #define __LCD_C__ 
....................  
.................... // define the pinout. 
.................... // only required if port access is being used. 
.................... typedef struct   
.................... {                            // This structure is overlayed 
....................    int1 enable;           // on to an I/O port to gain 
....................    int1 rs;               // access to the LCD pins. 
....................    int1 rw;               // The bits are allocated from 
....................    int1 unused;           // low order up.  ENABLE will 
....................    unsigned int     data : 4;         // be LSB pin of that port. 
....................   #if defined(__PCD__)       // The port used will be LCD_DATA_PORT. 
....................    unsigned int    reserved: 8; 
....................   #endif 
.................... } LCD_PIN_MAP; 
....................  
.................... // this is to improve compatability with previous LCD drivers that accepted 
.................... // a define labeled 'use_portb_lcd' that configured the LCD onto port B. 
.................... #if ((defined(use_portb_lcd)) && (use_portb_lcd==TRUE)) 
....................  #define LCD_DATA_PORT getenv("SFR:PORTB") 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
....................    // these definitions only need to be modified for baseline PICs. 
....................    // all other PICs use LCD_PIN_MAP or individual LCD_xxx pin definitions. 
.................... /*                                    EN, RS,   RW,   UNUSED,  DATA  */ 
....................  const LCD_PIN_MAP LCD_OUTPUT_MAP =  {0,  0,    0,    0,       0}; 
....................  const LCD_PIN_MAP LCD_INPUT_MAP =   {0,  0,    0,    0,       0xF}; 
.................... #endif 
....................  
.................... ////////////////////// END CONFIGURATION /////////////////////////////////// 
....................  
.................... #ifndef LCD_ENABLE_PIN 
....................    #define lcd_output_enable(x) lcdlat.enable=x 
....................    #define lcd_enable_tris()   lcdtris.enable=0 
.................... #else 
....................    #define lcd_output_enable(x) output_bit(LCD_ENABLE_PIN, x) 
....................    #define lcd_enable_tris()  output_drive(LCD_ENABLE_PIN) 
.................... #endif 
....................  
.................... #ifndef LCD_RS_PIN 
....................    #define lcd_output_rs(x) lcdlat.rs=x 
....................    #define lcd_rs_tris()   lcdtris.rs=0 
.................... #else 
....................    #define lcd_output_rs(x) output_bit(LCD_RS_PIN, x) 
....................    #define lcd_rs_tris()  output_drive(LCD_RS_PIN) 
.................... #endif 
....................  
.................... #ifndef LCD_RW_PIN 
....................    #define lcd_output_rw(x) lcdlat.rw=x 
....................    #define lcd_rw_tris()   lcdtris.rw=0 
.................... #else 
....................    #define lcd_output_rw(x) output_bit(LCD_RW_PIN, x) 
....................    #define lcd_rw_tris()  output_drive(LCD_RW_PIN) 
.................... #endif 
....................  
.................... // original version of this library incorrectly labeled LCD_DATA0 as LCD_DATA4, 
.................... // LCD_DATA1 as LCD_DATA5, and so on.  this block of code makes the driver 
.................... // compatible with any code written for the original library 
.................... #if (defined(LCD_DATA0) && defined(LCD_DATA1) && defined(LCD_DATA2) && defined(LCD_DATA3) && !defined(LCD_DATA4) && !defined(LCD_DATA5) && !defined(LCD_DATA6) && !defined(LCD_DATA7)) 
....................    #define  LCD_DATA4    LCD_DATA0 
....................    #define  LCD_DATA5    LCD_DATA1 
....................    #define  LCD_DATA6    LCD_DATA2 
....................    #define  LCD_DATA7    LCD_DATA3 
.................... #endif 
....................  
.................... #ifndef LCD_DATA4 
.................... #ifndef LCD_DATA_PORT 
....................    #if defined(__PCB__) 
....................       #define LCD_DATA_PORT      0x06     //portb 
....................       #define set_tris_lcd(x)   set_tris_b(x) 
....................    #else 
....................      #if defined(PIN_D0) 
....................       #define LCD_DATA_PORT      getenv("SFR:PORTD")     //portd 
....................      #else 
....................       #define LCD_DATA_PORT      getenv("SFR:PORTB")     //portb 
....................      #endif 
....................    #endif    
.................... #endif 
....................  
.................... #if defined(__PCB__) 
....................    LCD_PIN_MAP lcd, lcdlat; 
....................    #byte lcd = LCD_DATA_PORT 
....................    #byte lcdlat = LCD_DATA_PORT 
.................... #elif defined(__PCM__) 
....................    LCD_PIN_MAP lcd, lcdlat, lcdtris; 
....................    #byte lcd = LCD_DATA_PORT 
....................    #byte lcdlat = LCD_DATA_PORT 
....................    #byte lcdtris = LCD_DATA_PORT+0x80 
.................... #elif defined(__PCH__) 
....................    LCD_PIN_MAP lcd, lcdlat, lcdtris; 
....................    #byte lcd = LCD_DATA_PORT 
....................    #byte lcdlat = LCD_DATA_PORT+9 
....................    #byte lcdtris = LCD_DATA_PORT+0x12 
.................... #elif defined(__PCD__) 
....................    LCD_PIN_MAP lcd, lcdlat, lcdtris; 
....................    #word lcd = LCD_DATA_PORT 
....................    #word lcdlat = LCD_DATA_PORT+2 
....................    #word lcdtris = LCD_DATA_PORT-0x02 
.................... #endif 
.................... #endif   //LCD_DATA4 not defined 
....................  
.................... #ifndef LCD_TYPE 
....................    #define LCD_TYPE 2           // 0=5x7, 1=5x10, 2=2 lines 
.................... #endif 
....................  
.................... #ifndef LCD_LINE_TWO 
....................    #define LCD_LINE_TWO 0x40    // LCD RAM address for the second line 
.................... #endif 
....................  
.................... #ifndef LCD_LINE_LENGTH 
....................    #define LCD_LINE_LENGTH 20 
.................... #endif 
....................  
.................... unsigned int8 lcd_read_nibble(void); 
....................  
.................... unsigned int8 lcd_read_byte(void) 
.................... { 
....................    unsigned int8 low,high; 
....................  
....................  #if defined(__PCB__) 
....................    set_tris_lcd(LCD_INPUT_MAP); 
....................  #else 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    output_float(LCD_DATA4); 
*
0221:  BSF    07.0
....................    output_float(LCD_DATA5); 
0222:  BSF    07.1
....................    output_float(LCD_DATA6); 
0223:  BSF    07.2
....................    output_float(LCD_DATA7); 
0224:  BSF    07.3
....................   #else 
....................    lcdtris.data = 0xF; 
....................   #endif 
....................  #endif 
....................          
....................    lcd_output_rw(1); 
0225:  BCF    03.5
0226:  BSF    09.2
0227:  BSF    03.5
0228:  BCF    09.2
....................    delay_cycles(1); 
0229:  NOP
....................    lcd_output_enable(1); 
022A:  BCF    03.5
022B:  BSF    09.0
022C:  BSF    03.5
022D:  BCF    09.0
....................    delay_cycles(1); 
022E:  NOP
....................    high = lcd_read_nibble(); 
022F:  BCF    03.5
0230:  CALL   1D6
0231:  MOVF   78,W
0232:  BSF    03.6
0233:  MOVWF  69
....................        
....................    lcd_output_enable(0); 
0234:  BCF    03.6
0235:  BCF    09.0
0236:  BSF    03.5
0237:  BCF    09.0
....................    delay_cycles(1); 
0238:  NOP
....................    lcd_output_enable(1); 
0239:  BCF    03.5
023A:  BSF    09.0
023B:  BSF    03.5
023C:  BCF    09.0
....................    delay_us(1); 
023D:  GOTO   23E
023E:  GOTO   23F
023F:  NOP
....................    low = lcd_read_nibble(); 
0240:  BCF    03.5
0241:  CALL   1D6
0242:  MOVF   78,W
0243:  BSF    03.6
0244:  MOVWF  68
....................        
....................    lcd_output_enable(0); 
0245:  BCF    03.6
0246:  BCF    09.0
0247:  BSF    03.5
0248:  BCF    09.0
....................  
....................  #if defined(__PCB__) 
....................    set_tris_lcd(LCD_OUTPUT_MAP); 
....................  #else 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    output_drive(LCD_DATA4); 
0249:  BCF    03.5
024A:  BCF    31.0
024B:  MOVF   31,W
024C:  BSF    03.5
024D:  MOVWF  07
....................    output_drive(LCD_DATA5); 
024E:  BCF    03.5
024F:  BCF    31.1
0250:  MOVF   31,W
0251:  BSF    03.5
0252:  MOVWF  07
....................    output_drive(LCD_DATA6); 
0253:  BCF    03.5
0254:  BCF    31.2
0255:  MOVF   31,W
0256:  BSF    03.5
0257:  MOVWF  07
....................    output_drive(LCD_DATA7); 
0258:  BCF    03.5
0259:  BCF    31.3
025A:  MOVF   31,W
025B:  BSF    03.5
025C:  MOVWF  07
....................   #else 
....................    lcdtris.data = 0x0; 
....................   #endif 
....................  #endif 
....................  
....................    return( (high<<4) | low); 
025D:  BCF    03.5
025E:  BSF    03.6
025F:  SWAPF  69,W
0260:  MOVWF  77
0261:  MOVLW  F0
0262:  ANDWF  77,F
0263:  MOVF   77,W
0264:  IORWF  68,W
0265:  MOVWF  78
.................... } 
....................  
.................... unsigned int8 lcd_read_nibble(void) 
.................... { 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
*
01D6:  BSF    03.6
01D7:  CLRF   6A
....................    unsigned int8 n = 0x00; 
....................  
....................    /* Read the data port */ 
....................    n |= input(LCD_DATA4); 
01D8:  BCF    03.6
01D9:  BSF    31.0
01DA:  MOVF   31,W
01DB:  BSF    03.5
01DC:  MOVWF  07
01DD:  MOVLW  00
01DE:  BCF    03.5
01DF:  BTFSC  07.0
01E0:  MOVLW  01
01E1:  BSF    03.6
01E2:  IORWF  6A,F
....................    n |= input(LCD_DATA5) << 1; 
01E3:  BCF    03.6
01E4:  BSF    31.1
01E5:  MOVF   31,W
01E6:  BSF    03.5
01E7:  MOVWF  07
01E8:  MOVLW  00
01E9:  BCF    03.5
01EA:  BTFSC  07.1
01EB:  MOVLW  01
01EC:  MOVWF  77
01ED:  BCF    03.0
01EE:  RLF    77,F
01EF:  MOVF   77,W
01F0:  BSF    03.6
01F1:  IORWF  6A,F
....................    n |= input(LCD_DATA6) << 2; 
01F2:  BCF    03.6
01F3:  BSF    31.2
01F4:  MOVF   31,W
01F5:  BSF    03.5
01F6:  MOVWF  07
01F7:  MOVLW  00
01F8:  BCF    03.5
01F9:  BTFSC  07.2
01FA:  MOVLW  01
01FB:  MOVWF  77
01FC:  RLF    77,F
01FD:  RLF    77,F
01FE:  MOVLW  FC
01FF:  ANDWF  77,F
0200:  MOVF   77,W
0201:  BSF    03.6
0202:  IORWF  6A,F
....................    n |= input(LCD_DATA7) << 3; 
0203:  BCF    03.6
0204:  BSF    31.3
0205:  MOVF   31,W
0206:  BSF    03.5
0207:  MOVWF  07
0208:  MOVLW  00
0209:  BCF    03.5
020A:  BTFSC  07.3
020B:  MOVLW  01
020C:  MOVWF  77
020D:  RLF    77,F
020E:  RLF    77,F
020F:  RLF    77,F
0210:  MOVLW  F8
0211:  ANDWF  77,F
0212:  MOVF   77,W
0213:  BSF    03.6
0214:  IORWF  6A,F
....................     
....................    return(n); 
0215:  MOVF   6A,W
0216:  MOVWF  78
....................   #else 
0217:  BCF    03.6
0218:  RETURN
....................    return(lcd.data); 
....................   #endif 
.................... } 
....................  
.................... void lcd_send_nibble(unsigned int8 n) 
.................... { 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    /* Write to the data port */ 
....................    output_bit(LCD_DATA4, bit_test(n, 0)); 
*
018E:  BSF    03.6
018F:  BTFSC  69.0
0190:  GOTO   195
0191:  BCF    03.6
0192:  BCF    07.0
0193:  GOTO   197
0194:  BSF    03.6
0195:  BCF    03.6
0196:  BSF    07.0
0197:  BCF    31.0
0198:  MOVF   31,W
0199:  BSF    03.5
019A:  MOVWF  07
....................    output_bit(LCD_DATA5, bit_test(n, 1)); 
019B:  BCF    03.5
019C:  BSF    03.6
019D:  BTFSC  69.1
019E:  GOTO   1A3
019F:  BCF    03.6
01A0:  BCF    07.1
01A1:  GOTO   1A5
01A2:  BSF    03.6
01A3:  BCF    03.6
01A4:  BSF    07.1
01A5:  BCF    31.1
01A6:  MOVF   31,W
01A7:  BSF    03.5
01A8:  MOVWF  07
....................    output_bit(LCD_DATA6, bit_test(n, 2)); 
01A9:  BCF    03.5
01AA:  BSF    03.6
01AB:  BTFSC  69.2
01AC:  GOTO   1B1
01AD:  BCF    03.6
01AE:  BCF    07.2
01AF:  GOTO   1B3
01B0:  BSF    03.6
01B1:  BCF    03.6
01B2:  BSF    07.2
01B3:  BCF    31.2
01B4:  MOVF   31,W
01B5:  BSF    03.5
01B6:  MOVWF  07
....................    output_bit(LCD_DATA7, bit_test(n, 3)); 
01B7:  BCF    03.5
01B8:  BSF    03.6
01B9:  BTFSC  69.3
01BA:  GOTO   1BF
01BB:  BCF    03.6
01BC:  BCF    07.3
01BD:  GOTO   1C1
01BE:  BSF    03.6
01BF:  BCF    03.6
01C0:  BSF    07.3
01C1:  BCF    31.3
01C2:  MOVF   31,W
01C3:  BSF    03.5
01C4:  MOVWF  07
....................   #else       
....................    lcdlat.data = n; 
....................   #endif 
....................        
....................    delay_cycles(1); 
01C5:  NOP
....................    lcd_output_enable(1); 
01C6:  BCF    03.5
01C7:  BSF    09.0
01C8:  BSF    03.5
01C9:  BCF    09.0
....................    delay_us(2); 
01CA:  MOVLW  02
01CB:  MOVWF  77
01CC:  DECFSZ 77,F
01CD:  GOTO   1CC
01CE:  GOTO   1CF
01CF:  NOP
....................    lcd_output_enable(0); 
01D0:  BCF    03.5
01D1:  BCF    09.0
01D2:  BSF    03.5
01D3:  BCF    09.0
01D4:  BCF    03.5
01D5:  RETURN
.................... } 
....................  
.................... void lcd_send_byte(unsigned int8 address, unsigned int8 n) 
.................... { 
....................   #if defined(__PCB__) 
....................    set_tris_lcd(LCD_OUTPUT_MAP); 
....................   #else 
....................    lcd_enable_tris(); 
*
0219:  BSF    03.5
021A:  BCF    09.0
....................    lcd_rs_tris(); 
021B:  BCF    09.1
....................    lcd_rw_tris(); 
021C:  BCF    09.2
....................   #endif 
....................  
....................    lcd_output_rs(0); 
021D:  BCF    03.5
021E:  BCF    09.1
021F:  BSF    03.5
0220:  BCF    09.1
....................    while ( bit_test(lcd_read_byte(),7) ) ; 
*
0266:  MOVF   78,W
0267:  MOVWF  68
0268:  BTFSS  68.7
0269:  GOTO   26D
026A:  BSF    03.5
026B:  BCF    03.6
026C:  GOTO   221
....................    lcd_output_rs(address); 
026D:  MOVF   66,F
026E:  BTFSS  03.2
026F:  GOTO   274
0270:  BCF    03.6
0271:  BCF    09.1
0272:  GOTO   276
0273:  BSF    03.6
0274:  BCF    03.6
0275:  BSF    09.1
0276:  BSF    03.5
0277:  BCF    09.1
....................    delay_cycles(1); 
0278:  NOP
....................    lcd_output_rw(0); 
0279:  BCF    03.5
027A:  BCF    09.2
027B:  BSF    03.5
027C:  BCF    09.2
....................    delay_cycles(1); 
027D:  NOP
....................    lcd_output_enable(0); 
027E:  BCF    03.5
027F:  BCF    09.0
0280:  BSF    03.5
0281:  BCF    09.0
....................    lcd_send_nibble(n >> 4); 
0282:  BCF    03.5
0283:  BSF    03.6
0284:  SWAPF  67,W
0285:  MOVWF  68
0286:  MOVLW  0F
0287:  ANDWF  68,F
0288:  MOVF   68,W
0289:  MOVWF  69
028A:  BCF    03.6
028B:  CALL   18E
....................    lcd_send_nibble(n & 0xf); 
028C:  BSF    03.6
028D:  MOVF   67,W
028E:  ANDLW  0F
028F:  MOVWF  68
0290:  MOVWF  69
0291:  BCF    03.6
0292:  CALL   18E
0293:  RETURN
.................... } 
....................  
.................... #if defined(LCD_EXTENDED_NEWLINE) 
.................... unsigned int8 g_LcdX, g_LcdY; 
.................... #endif 
....................  
.................... void lcd_init(void)  
.................... { 
....................    unsigned int8 i; 
....................    unsigned int8 LCD_INIT_STRING[4] = {0x20 | (LCD_TYPE << 2), 0xc, 1, 6}; 
0294:  MOVLW  28
0295:  BSF    03.6
0296:  MOVWF  32
0297:  MOVLW  0C
0298:  MOVWF  33
0299:  MOVLW  01
029A:  MOVWF  34
029B:  MOVLW  06
029C:  MOVWF  35
....................                              // These bytes need to be sent to the LCD 
....................                              // to start it up. 
....................     
....................  
....................    lcd_output_enable(0); 
029D:  BCF    03.6
029E:  BCF    09.0
029F:  BSF    03.5
02A0:  BCF    09.0
....................    lcd_output_rs(0); 
02A1:  BCF    03.5
02A2:  BCF    09.1
02A3:  BSF    03.5
02A4:  BCF    09.1
....................    lcd_output_rw(0); 
02A5:  BCF    03.5
02A6:  BCF    09.2
02A7:  BSF    03.5
02A8:  BCF    09.2
....................  
....................  #if defined(__PCB__) 
....................    set_tris_lcd(LCD_OUTPUT_MAP); 
....................  #else 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    output_drive(LCD_DATA4); 
02A9:  BCF    03.5
02AA:  BCF    31.0
02AB:  MOVF   31,W
02AC:  BSF    03.5
02AD:  MOVWF  07
....................    output_drive(LCD_DATA5); 
02AE:  BCF    03.5
02AF:  BCF    31.1
02B0:  MOVF   31,W
02B1:  BSF    03.5
02B2:  MOVWF  07
....................    output_drive(LCD_DATA6); 
02B3:  BCF    03.5
02B4:  BCF    31.2
02B5:  MOVF   31,W
02B6:  BSF    03.5
02B7:  MOVWF  07
....................    output_drive(LCD_DATA7); 
02B8:  BCF    03.5
02B9:  BCF    31.3
02BA:  MOVF   31,W
02BB:  BSF    03.5
02BC:  MOVWF  07
....................   #else 
....................    lcdtris.data = 0x0; 
....................   #endif 
....................    lcd_enable_tris(); 
02BD:  BCF    09.0
....................    lcd_rs_tris(); 
02BE:  BCF    09.1
....................    lcd_rw_tris(); 
02BF:  BCF    09.2
....................  #endif 
....................      
....................    delay_ms(15); 
02C0:  MOVLW  0F
02C1:  BCF    03.5
02C2:  BSF    03.6
02C3:  MOVWF  62
02C4:  BCF    03.6
02C5:  CALL   17A
....................    for(i=1;i<=3;++i) 
02C6:  MOVLW  01
02C7:  BSF    03.6
02C8:  MOVWF  31
02C9:  MOVF   31,W
02CA:  SUBLW  03
02CB:  BTFSS  03.0
02CC:  GOTO   2D9
....................    { 
....................        lcd_send_nibble(3); 
02CD:  MOVLW  03
02CE:  MOVWF  69
02CF:  BCF    03.6
02D0:  CALL   18E
....................        delay_ms(5); 
02D1:  MOVLW  05
02D2:  BSF    03.6
02D3:  MOVWF  62
02D4:  BCF    03.6
02D5:  CALL   17A
02D6:  BSF    03.6
02D7:  INCF   31,F
02D8:  GOTO   2C9
....................    } 
....................     
....................    lcd_send_nibble(2); 
02D9:  MOVLW  02
02DA:  MOVWF  69
02DB:  BCF    03.6
02DC:  CALL   18E
....................    delay_ms(5); 
02DD:  MOVLW  05
02DE:  BSF    03.6
02DF:  MOVWF  62
02E0:  BCF    03.6
02E1:  CALL   17A
....................    for(i=0;i<=3;++i) 
02E2:  BSF    03.6
02E3:  CLRF   31
02E4:  MOVF   31,W
02E5:  SUBLW  03
02E6:  BTFSS  03.0
02E7:  GOTO   2F6
....................       lcd_send_byte(0,LCD_INIT_STRING[i]); 
02E8:  MOVLW  32
02E9:  ADDWF  31,W
02EA:  MOVWF  04
02EB:  BSF    03.7
02EC:  MOVF   00,W
02ED:  MOVWF  36
02EE:  CLRF   66
02EF:  MOVF   36,W
02F0:  MOVWF  67
02F1:  BCF    03.6
02F2:  CALL   219
....................  
....................   #if defined(LCD_EXTENDED_NEWLINE) 
02F3:  BSF    03.6
02F4:  INCF   31,F
02F5:  GOTO   2E4
02F6:  BCF    03.6
02F7:  BSF    0A.3
02F8:  BSF    0A.4
02F9:  GOTO   3CF (RETURN)
....................    g_LcdX = 0; 
....................    g_LcdY = 0; 
....................   #endif 
.................... } 
....................  
.................... void lcd_gotoxy(unsigned int8 x, unsigned int8 y) 
.................... { 
....................    unsigned int8 address; 
....................     
....................    if(y!=1) 
02FA:  BSF    03.6
02FB:  DECFSZ 63,W
02FC:  GOTO   2FE
02FD:  GOTO   301
....................       address=LCD_LINE_TWO; 
02FE:  MOVLW  40
02FF:  MOVWF  64
0300:  GOTO   302
....................    else 
....................       address=0; 
0301:  CLRF   64
....................       
....................    address+=x-1; 
0302:  MOVLW  01
0303:  SUBWF  62,W
0304:  ADDWF  64,F
....................    lcd_send_byte(0,0x80|address); 
0305:  MOVF   64,W
0306:  IORLW  80
0307:  MOVWF  65
0308:  CLRF   66
0309:  MOVF   65,W
030A:  MOVWF  67
030B:  BCF    03.6
030C:  CALL   219
....................  
....................   #if defined(LCD_EXTENDED_NEWLINE) 
030D:  RETURN
....................    g_LcdX = x - 1; 
....................    g_LcdY = y - 1; 
....................   #endif 
.................... } 
....................  
.................... void lcd_putc(char c) 
.................... { 
....................    switch (c) 
030E:  BSF    03.6
030F:  MOVF   61,W
0310:  XORLW  07
0311:  BCF    03.6
0312:  BTFSC  03.2
0313:  GOTO   31E
0314:  XORLW  0B
0315:  BTFSC  03.2
0316:  GOTO   325
0317:  XORLW  06
0318:  BTFSC  03.2
0319:  GOTO   331
031A:  XORLW  02
031B:  BTFSC  03.2
031C:  GOTO   339
031D:  GOTO   340
....................    { 
....................       case '\a'   :  lcd_gotoxy(1,1);     break; 
031E:  MOVLW  01
031F:  BSF    03.6
0320:  MOVWF  62
0321:  MOVWF  63
0322:  BCF    03.6
0323:  CALL   2FA
0324:  GOTO   347
....................  
....................       case '\f'   :  lcd_send_byte(0,1); 
0325:  BSF    03.6
0326:  CLRF   66
0327:  MOVLW  01
0328:  MOVWF  67
0329:  BCF    03.6
032A:  CALL   219
....................                      delay_ms(2); 
032B:  MOVLW  02
032C:  BSF    03.6
032D:  MOVWF  62
032E:  BCF    03.6
032F:  CALL   17A
....................                     #if defined(LCD_EXTENDED_NEWLINE) 
....................                      g_LcdX = 0; 
....................                      g_LcdY = 0; 
....................                     #endif 
....................                      break; 
0330:  GOTO   347
....................  
....................      #if defined(LCD_EXTENDED_NEWLINE) 
....................       case '\r'   :  lcd_gotoxy(1, g_LcdY+1);   break; 
....................       case '\n'   : 
....................          while (g_LcdX++ < LCD_LINE_LENGTH) 
....................          { 
....................             lcd_send_byte(1, ' '); 
....................          } 
....................          lcd_gotoxy(1, g_LcdY+2); 
....................          break; 
....................      #else 
....................       case '\n'   : lcd_gotoxy(1,2);        break; 
0331:  MOVLW  01
0332:  BSF    03.6
0333:  MOVWF  62
0334:  MOVLW  02
0335:  MOVWF  63
0336:  BCF    03.6
0337:  CALL   2FA
0338:  GOTO   347
....................      #endif 
....................       
....................       case '\b'   : lcd_send_byte(0,0x10);  break; 
0339:  BSF    03.6
033A:  CLRF   66
033B:  MOVLW  10
033C:  MOVWF  67
033D:  BCF    03.6
033E:  CALL   219
033F:  GOTO   347
....................       
....................      #if defined(LCD_EXTENDED_NEWLINE) 
....................       default     :  
....................          if (g_LcdX < LCD_LINE_LENGTH) 
....................          { 
....................             lcd_send_byte(1, c); 
....................             g_LcdX++; 
....................          } 
....................          break; 
....................      #else 
....................       default     : lcd_send_byte(1,c);     break; 
0340:  MOVLW  01
0341:  BSF    03.6
0342:  MOVWF  66
0343:  MOVF   61,W
0344:  MOVWF  67
0345:  BCF    03.6
0346:  CALL   219
....................      #endif 
....................    } 
0347:  RETURN
.................... } 
....................   
.................... char lcd_getc(unsigned int8 x, unsigned int8 y) 
.................... { 
....................    char value; 
....................  
....................    lcd_gotoxy(x,y); 
....................    while ( bit_test(lcd_read_byte(),7) ); // wait until busy flag is low 
....................    lcd_output_rs(1); 
....................    value = lcd_read_byte(); 
....................    lcd_output_rs(0); 
....................     
....................    return(value); 
.................... } 
....................  
.................... // write a custom character to the ram 
.................... // which is 0-7 and specifies which character array we are modifying. 
.................... // ptr points to an array of 8 bytes, where each byte is the next row of 
.................... //    pixels.  only bits 0-4 are used.  the last row is the cursor row, and 
.................... //    usually you will want to leave this byte 0x00. 
.................... void lcd_set_cgram_char(unsigned int8 which, unsigned int8 *ptr) 
.................... { 
....................    unsigned int i; 
....................  
....................    which <<= 3; 
....................    which &= 0x38; 
....................  
....................    lcd_send_byte(0, 0x40 | which);  //set cgram address 
....................  
....................    for(i=0; i<8; i++) 
....................    { 
....................       lcd_send_byte(1, *ptr++); 
....................    } 
....................    
....................    #if defined(LCD_EXTENDED_NEWLINE) 
....................     lcd_gotoxy(g_LcdX+1, g_LcdY+1);  //set ddram address 
....................    #endif 
.................... } 
....................  
.................... void lcd_cursor_on(int1 on) 
.................... { 
....................    if (on) 
....................    { 
....................       lcd_send_byte(0,0x0F);           //turn LCD cursor ON 
....................    } 
....................    else 
....................    { 
....................       lcd_send_byte(0,0x0C);           //turn LCD cursor OFF 
....................    } 
.................... } 
....................  
.................... #endif 
....................  
.................... #BIT TMR1IF = 0x0C.0 //bit thu 0 (TMR1IF) cua PIR1 
....................  
.................... #INCLUDE <khaibaobien.c> // VARIABLE. 
....................  
....................  
....................  
.................... //UNSIGNED INT16 KQADC; 
.................... //float KET_QUA_ANALOG[]={0,0,0,0,0}; 
.................... //float KET_QUA_ANALOG_TEMP[]={0,0,0,0,0}; 
....................  
.................... UNSIGNED INT8 CONFIG_FUN=0; 
.................... UNSIGNED INT8 VT=0, KYTU=0;// KYTU[30],  
.................... UNSIGNED INT8 LENH_DIEU_KHIEN = 0; 
.................... UNSIGNED INT8 ID_GATEWAY[6] = {3,8,6,9,0,7}; 
*
1B1E:  MOVLW  03
1B1F:  MOVWF  36
1B20:  MOVLW  08
1B21:  MOVWF  37
1B22:  MOVLW  06
1B23:  MOVWF  38
1B24:  MOVLW  09
1B25:  MOVWF  39
1B26:  CLRF   3A
1B27:  MOVLW  07
1B28:  MOVWF  3B
.................... UNSIGNED INT8 ID_NODE[4] = {0,1,5,2}; 
1B29:  CLRF   3C
1B2A:  MOVLW  01
1B2B:  MOVWF  3D
1B2C:  MOVLW  05
1B2D:  MOVWF  3E
1B2E:  MOVLW  02
1B2F:  MOVWF  3F
.................... UNSIGNED INT8 LEN_PACKAGES = 0; 
.................... UNSIGNED INT8 LENHDIEUKHIEN =0, DODAI_DATA_NHAN =0; 
.................... UNSIGNED INT8 SOLUONGTHIETBI_CONFIG=0, SOLUONGCAMBIEN_CONFIG = 3; 
.................... SIGNED INT8 SOSANH_IDNODE=0, SOSANH_IDGW=0; 
.................... //INT1 TT_THIETBI [8]={0,0,0,0,0,0,0,0}; 
.................... INT1 TT_THIETBI_TEMP [8]={0,0,0,0,0,0,0,0}; 
1B30:  CLRF   47
.................... INT1 TTNHAN = 0, TT_CONFIG=0, TT_CONTROL=0,TT_CONFIG_DONE=0, TT_FUN=0, TT_STT=0 , TT_CONFIG_OKE_UART = 0, TT_SW = 0,TT_SEND_ANALOG = 0; 
....................  
.................... CHAR *ID_NODE_CHAR[]= "0589"; 
1B31:  MOVLW  30
1B32:  MOVWF  4C
1B33:  MOVLW  35
1B34:  MOVWF  4D
1B35:  MOVLW  38
1B36:  MOVWF  4E
1B37:  MOVLW  39
1B38:  MOVWF  4F
1B39:  CLRF   50
1B3A:  CLRF   4B
1B3B:  MOVLW  4C
1B3C:  MOVWF  4A
.................... CHAR *ID_GATEWAY_CHAR[]= "127102"; 
1B3D:  MOVLW  31
1B3E:  MOVWF  53
1B3F:  MOVLW  32
1B40:  MOVWF  54
1B41:  MOVLW  37
1B42:  MOVWF  55
1B43:  MOVLW  31
1B44:  MOVWF  56
1B45:  MOVLW  30
1B46:  MOVWF  57
1B47:  MOVLW  32
1B48:  MOVWF  58
1B49:  CLRF   59
1B4A:  CLRF   52
1B4B:  MOVLW  53
1B4C:  MOVWF  51
.................... CHAR *ID_NODE_NHAN[]= "0000"; 
1B4D:  MOVLW  30
1B4E:  MOVWF  5C
1B4F:  MOVWF  5D
1B50:  MOVWF  5E
1B51:  MOVWF  5F
1B52:  CLRF   60
1B53:  CLRF   5B
1B54:  MOVLW  5C
1B55:  MOVWF  5A
.................... CHAR *ID_GW_NHAN[]= "000000"; 
1B56:  MOVLW  30
1B57:  MOVWF  63
1B58:  MOVWF  64
1B59:  MOVWF  65
1B5A:  MOVWF  66
1B5B:  MOVWF  67
1B5C:  MOVWF  68
1B5D:  CLRF   69
1B5E:  CLRF   62
1B5F:  MOVLW  63
1B60:  MOVWF  61
.................... CHAR KYTUCHAR[50]="HIHI"; 
1B61:  MOVLW  48
1B62:  BSF    03.5
1B63:  MOVWF  20
1B64:  MOVLW  49
1B65:  MOVWF  21
1B66:  MOVLW  48
1B67:  MOVWF  22
1B68:  MOVLW  49
1B69:  MOVWF  23
1B6A:  CLRF   24
.................... CHAR KYTUCHAR2[25]="HIHI"; 
1B6B:  MOVLW  48
1B6C:  MOVWF  52
1B6D:  MOVLW  49
1B6E:  MOVWF  53
1B6F:  MOVLW  48
1B70:  MOVWF  54
1B71:  MOVLW  49
1B72:  MOVWF  55
1B73:  CLRF   56
.................... //CHAR *DATA_NHANDUOC[]={"IDGW","IDNODE","COMMAN","DATA"}; 
.................... CHAR *TEMP_CHAR[]="0000";   
1B74:  MOVLW  30
1B75:  BCF    03.5
1B76:  MOVWF  6C
1B77:  MOVWF  6D
1B78:  MOVWF  6E
1B79:  MOVWF  6F
1B7A:  CLRF   70
1B7B:  CLRF   6B
1B7C:  MOVLW  6C
1B7D:  MOVWF  6A
.................... CHAR *TEMP_CHAR2[]="2700";  
1B7E:  MOVLW  32
1B7F:  BSF    03.5
1B80:  MOVWF  6B
1B81:  MOVLW  37
1B82:  MOVWF  6C
1B83:  MOVLW  30
1B84:  MOVWF  6D
1B85:  MOVWF  6E
1B86:  CLRF   6F
1B87:  CLRF   72
1B88:  MOVLW  EB
1B89:  MOVWF  71
.................... //CHAR *TEMP_CHAR3[]="000000";  
....................  
....................  
....................  
.................... //#INCLUDE <CONFIG_NODE.C> // CU HINH NODE. 
.................... #INCLUDE <config_1.C> // CU HINH NODE. 
.................... VOID READ_EEPROMP_DATA_NODE(){    
....................    FOR (int j = 0; j < 4; j++) 
*
0398:  BSF    03.6
0399:  CLRF   31
039A:  MOVF   31,W
039B:  SUBLW  03
039C:  BTFSS  03.0
039D:  GOTO   3AF
....................    { 
....................       ID_NODE[j] = read_eeprom(10+j); 
039E:  MOVLW  3C
039F:  ADDWF  31,W
03A0:  MOVWF  04
03A1:  BCF    03.7
03A2:  MOVLW  0A
03A3:  ADDWF  31,W
03A4:  MOVWF  34
03A5:  MOVF   34,W
03A6:  MOVWF  0D
03A7:  BSF    03.5
03A8:  BCF    0C.7
03A9:  BSF    0C.0
03AA:  BCF    03.5
03AB:  MOVF   0C,W
03AC:  MOVWF  00
03AD:  INCF   31,F
03AE:  GOTO   39A
....................    }   
....................    FOR (j = 0; j < 6; j++) 
03AF:  CLRF   31
03B0:  MOVF   31,W
03B1:  SUBLW  05
03B2:  BTFSS  03.0
03B3:  GOTO   3C5
....................    { 
....................       ID_GATEWAY[j] = read_eeprom(14+j); 
03B4:  MOVLW  36
03B5:  ADDWF  31,W
03B6:  MOVWF  04
03B7:  BCF    03.7
03B8:  MOVLW  0E
03B9:  ADDWF  31,W
03BA:  MOVWF  34
03BB:  MOVF   34,W
03BC:  MOVWF  0D
03BD:  BSF    03.5
03BE:  BCF    0C.7
03BF:  BSF    0C.0
03C0:  BCF    03.5
03C1:  MOVF   0C,W
03C2:  MOVWF  00
03C3:  INCF   31,F
03C4:  GOTO   3B0
....................    }   
03C5:  BCF    03.6
03C6:  BSF    0A.3
03C7:  BSF    0A.4
03C8:  GOTO   423 (RETURN)
.................... } 
....................  
.................... //--------------------------------------------------------------------// 
.................... VOID CHON_ID() 
.................... { 
....................    // TT_CONFIG_DONE; 
....................    TT_CONFIG_DONE = 0; 
*
0893:  BCF    48.3
....................    TT_STT = 1; 
0894:  BSF    48.5
....................    UNSIGNED INT8 NUM = 0; 
0895:  BSF    03.6
0896:  CLRF   31
....................    TEMP_CHAR = "0"; 
0897:  CLRF   32
0898:  CLRF   33
0899:  MOVLW  6A
089A:  MOVWF  04
089B:  BCF    03.7
089C:  MOVF   32,W
089D:  ADDWF  04,F
089E:  MOVF   33,W
089F:  BCF    0A.3
08A0:  BCF    03.6
08A1:  CALL   058
08A2:  BSF    0A.3
08A3:  MOVWF  00
08A4:  IORLW  00
08A5:  BTFSC  03.2
08A6:  GOTO   0AC
08A7:  BSF    03.6
08A8:  INCF   33,F
08A9:  INCF   32,F
08AA:  GOTO   099
08AB:  BCF    03.6
....................    LCD_GOTOXY (1, 2) ; 
08AC:  MOVLW  01
08AD:  BSF    03.6
08AE:  MOVWF  62
08AF:  MOVLW  02
08B0:  MOVWF  63
08B1:  BCF    0A.3
08B2:  BCF    03.6
08B3:  CALL   2FA
08B4:  BSF    0A.3
....................    DELAY_MS (10); 
08B5:  MOVLW  0A
08B6:  BSF    03.6
08B7:  MOVWF  62
08B8:  BCF    0A.3
08B9:  BCF    03.6
08BA:  CALL   17A
08BB:  BSF    0A.3
....................    PRINTF (LCD_PUTC, "NODE: "); 
08BC:  MOVLW  7E
08BD:  BSF    03.6
08BE:  MOVWF  0D
08BF:  MOVLW  00
08C0:  MOVWF  0F
08C1:  BCF    0A.3
08C2:  BCF    03.6
08C3:  CALL   348
08C4:  BSF    0A.3
....................    PRINTF (LCD_PUTC, ID_NODE_CHAR); 
08C5:  MOVLW  4A
08C6:  MOVWF  04
08C7:  BCF    03.7
08C8:  BCF    0A.3
08C9:  CALL   75F
08CA:  BSF    0A.3
....................    PRINTF (LCD_PUTC, "          "); 
08CB:  MOVLW  82
08CC:  BSF    03.6
08CD:  MOVWF  0D
08CE:  MOVLW  00
08CF:  MOVWF  0F
08D0:  BCF    0A.3
08D1:  BCF    03.6
08D2:  CALL   348
08D3:  BSF    0A.3
....................    LCD_GOTOXY (1, 1) ; 
08D4:  MOVLW  01
08D5:  BSF    03.6
08D6:  MOVWF  62
08D7:  MOVWF  63
08D8:  BCF    0A.3
08D9:  BCF    03.6
08DA:  CALL   2FA
08DB:  BSF    0A.3
....................    PRINTF (LCD_PUTC, "      _              ");//6 SPACE PHIA TRUOC "_" 
08DC:  MOVLW  88
08DD:  BSF    03.6
08DE:  MOVWF  0D
08DF:  MOVLW  00
08E0:  MOVWF  0F
08E1:  BCF    0A.3
08E2:  BCF    03.6
08E3:  CALL   348
08E4:  BSF    0A.3
....................    //ID_GW = "1234";     
....................  
....................    WHILE (TT_STT) 
08E5:  BTFSS  48.5
08E6:  GOTO   175
....................    { 
....................       IF (!INPUT (BT2_PIN)) //NEU NUT BAM DUOC BAM 
08E7:  BSF    03.5
08E8:  BSF    06.2
08E9:  BCF    03.5
08EA:  BTFSC  06.2
08EB:  GOTO   110
....................       { 
....................           
....................          NUM++; 
08EC:  BSF    03.6
08ED:  INCF   31,F
....................          NUM = NUM % 4; 
08EE:  MOVLW  03
08EF:  ANDWF  31,F
....................          LCD_GOTOXY (3 + NUM, 1); 
08F0:  ADDWF  31,W
08F1:  MOVWF  32
08F2:  MOVWF  62
08F3:  MOVLW  01
08F4:  MOVWF  63
08F5:  BCF    0A.3
08F6:  BCF    03.6
08F7:  CALL   2FA
08F8:  BSF    0A.3
....................          PRINTF (LCD_PUTC, "    _    ");//4SPACE 
08F9:  MOVLW  93
08FA:  BSF    03.6
08FB:  MOVWF  0D
08FC:  MOVLW  00
08FD:  MOVWF  0F
08FE:  BCF    0A.3
08FF:  BCF    03.6
0900:  CALL   348
0901:  BSF    0A.3
....................          DELAY_MS (300);  
0902:  MOVLW  02
0903:  BSF    03.6
0904:  MOVWF  32
0905:  MOVLW  96
0906:  MOVWF  62
0907:  BCF    0A.3
0908:  BCF    03.6
0909:  CALL   17A
090A:  BSF    0A.3
090B:  BSF    03.6
090C:  DECFSZ 32,F
090D:  GOTO   105
....................       } 
090E:  GOTO   173
090F:  BCF    03.6
....................  
....................       ELSE IF (!INPUT (BT3_PIN)) 
0910:  BSF    03.5
0911:  BSF    06.3
0912:  BCF    03.5
0913:  BTFSC  06.3
0914:  GOTO   174
....................       { 
....................          ID_NODE[NUM]++; 
0915:  MOVLW  3C
0916:  BSF    03.6
0917:  ADDWF  31,W
0918:  MOVWF  04
0919:  BCF    03.7
091A:  INCF   00,F
....................          ID_NODE[NUM] = ID_NODE[NUM] % 10; 
091B:  MOVLW  3C
091C:  ADDWF  31,W
091D:  MOVWF  78
091E:  CLRF   7A
091F:  BTFSC  03.0
0920:  INCF   7A,F
0921:  MOVF   78,W
0922:  MOVWF  32
0923:  MOVF   7A,W
0924:  MOVWF  33
0925:  MOVLW  3C
0926:  ADDWF  31,W
0927:  MOVWF  04
0928:  BCF    03.7
0929:  MOVF   00,W
092A:  MOVWF  35
092B:  MOVLW  0A
092C:  MOVWF  36
092D:  BCF    0A.3
092E:  BCF    03.6
092F:  CALL   77C
0930:  BSF    0A.3
0931:  MOVF   77,W
0932:  BSF    03.6
0933:  MOVWF  34
0934:  MOVF   32,W
0935:  MOVWF  04
0936:  BCF    03.7
0937:  BTFSC  33.0
0938:  BSF    03.7
0939:  MOVF   34,W
093A:  MOVWF  00
....................          ITOA (ID_NODE[NUM], 10, TEMP_CHAR); 
093B:  MOVLW  3C
093C:  ADDWF  31,W
093D:  MOVWF  04
093E:  BCF    03.7
093F:  MOVF   00,W
0940:  MOVWF  32
0941:  CLRF   67
0942:  CLRF   66
0943:  CLRF   65
0944:  MOVF   32,W
0945:  MOVWF  64
0946:  MOVLW  0A
0947:  MOVWF  68
0948:  CLRF   6A
0949:  MOVLW  6A
094A:  MOVWF  69
094B:  BCF    0A.3
094C:  BCF    03.6
094D:  CALL   447
094E:  BSF    0A.3
....................          LCD_GOTOXY (7 + NUM, 2); 
094F:  MOVLW  07
0950:  BSF    03.6
0951:  ADDWF  31,W
0952:  MOVWF  32
0953:  MOVWF  62
0954:  MOVLW  02
0955:  MOVWF  63
0956:  BCF    0A.3
0957:  BCF    03.6
0958:  CALL   2FA
0959:  BSF    0A.3
....................          DELAY_MS (10); 
095A:  MOVLW  0A
095B:  BSF    03.6
095C:  MOVWF  62
095D:  BCF    0A.3
095E:  BCF    03.6
095F:  CALL   17A
0960:  BSF    0A.3
....................          PRINTF (LCD_PUTC, TEMP_CHAR); 
0961:  MOVLW  6A
0962:  MOVWF  04
0963:  BCF    03.7
0964:  BCF    0A.3
0965:  CALL   75F
0966:  BSF    0A.3
....................          DELAY_MS (300); 
0967:  MOVLW  02
0968:  BSF    03.6
0969:  MOVWF  32
096A:  MOVLW  96
096B:  MOVWF  62
096C:  BCF    0A.3
096D:  BCF    03.6
096E:  CALL   17A
096F:  BSF    0A.3
0970:  BSF    03.6
0971:  DECFSZ 32,F
0972:  GOTO   16A
0973:  BCF    03.6
....................       } 
0974:  GOTO   0E5
....................    } 
.................... } 
....................  
.................... VOID NHAPID_GW() 
*
0976:  BSF    03.6
0977:  CLRF   31
.................... { 
....................    UNSIGNED INT8 NUM = 0; 
....................    TEMP_CHAR = "0"; 
0978:  CLRF   32
0979:  CLRF   33
097A:  MOVLW  6A
097B:  MOVWF  04
097C:  BCF    03.7
097D:  MOVF   32,W
097E:  ADDWF  04,F
097F:  MOVF   33,W
0980:  BCF    0A.3
0981:  BCF    03.6
0982:  CALL   058
0983:  BSF    0A.3
0984:  MOVWF  00
0985:  IORLW  00
0986:  BTFSC  03.2
0987:  GOTO   18D
0988:  BSF    03.6
0989:  INCF   33,F
098A:  INCF   32,F
098B:  GOTO   17A
098C:  BCF    03.6
....................    TT_CONFIG_DONE = 0; 
098D:  BCF    48.3
....................    TT_STT = 1; 
098E:  BSF    48.5
....................    LCD_GOTOXY (1, 2) ; 
098F:  MOVLW  01
0990:  BSF    03.6
0991:  MOVWF  62
0992:  MOVLW  02
0993:  MOVWF  63
0994:  BCF    0A.3
0995:  BCF    03.6
0996:  CALL   2FA
0997:  BSF    0A.3
....................    DELAY_MS (10); 
0998:  MOVLW  0A
0999:  BSF    03.6
099A:  MOVWF  62
099B:  BCF    0A.3
099C:  BCF    03.6
099D:  CALL   17A
099E:  BSF    0A.3
....................    PRINTF (LCD_PUTC, "ID_GW:"); 
099F:  MOVLW  98
09A0:  BSF    03.6
09A1:  MOVWF  0D
09A2:  MOVLW  00
09A3:  MOVWF  0F
09A4:  BCF    0A.3
09A5:  BCF    03.6
09A6:  CALL   348
09A7:  BSF    0A.3
....................    PRINTF (LCD_PUTC, ID_GATEWAY_CHAR); 
09A8:  MOVLW  51
09A9:  MOVWF  04
09AA:  BCF    03.7
09AB:  BCF    0A.3
09AC:  CALL   75F
09AD:  BSF    0A.3
....................    PRINTF (LCD_PUTC, "          "); 
09AE:  MOVLW  9C
09AF:  BSF    03.6
09B0:  MOVWF  0D
09B1:  MOVLW  00
09B2:  MOVWF  0F
09B3:  BCF    0A.3
09B4:  BCF    03.6
09B5:  CALL   348
09B6:  BSF    0A.3
....................    LCD_GOTOXY (1, 1) ; 
09B7:  MOVLW  01
09B8:  BSF    03.6
09B9:  MOVWF  62
09BA:  MOVWF  63
09BB:  BCF    0A.3
09BC:  BCF    03.6
09BD:  CALL   2FA
09BE:  BSF    0A.3
....................    PRINTF (LCD_PUTC, "      _                ");//6 SPACE PHIA TRUOC "_" 
09BF:  MOVLW  A2
09C0:  BSF    03.6
09C1:  MOVWF  0D
09C2:  MOVLW  00
09C3:  MOVWF  0F
09C4:  BCF    0A.3
09C5:  BCF    03.6
09C6:  CALL   348
09C7:  BSF    0A.3
....................    //ID_GW = "1234";     
....................  
....................    WHILE (TT_STT) 
09C8:  BTFSS  48.5
09C9:  GOTO   262
....................    { 
....................       IF (!INPUT (BT2_PIN)) //NEU NUT BAM DUOC BAM 
09CA:  BSF    03.5
09CB:  BSF    06.2
09CC:  BCF    03.5
09CD:  BTFSC  06.2
09CE:  GOTO   1FD
....................       { 
....................           
....................          NUM++; 
09CF:  BSF    03.6
09D0:  INCF   31,F
....................          NUM = NUM % 6; 
09D1:  MOVF   31,W
09D2:  MOVWF  35
09D3:  MOVLW  06
09D4:  MOVWF  36
09D5:  BCF    0A.3
09D6:  BCF    03.6
09D7:  CALL   77C
09D8:  BSF    0A.3
09D9:  MOVF   77,W
09DA:  BSF    03.6
09DB:  MOVWF  31
....................          LCD_GOTOXY (3 + NUM, 1); 
09DC:  MOVLW  03
09DD:  ADDWF  31,W
09DE:  MOVWF  32
09DF:  MOVWF  62
09E0:  MOVLW  01
09E1:  MOVWF  63
09E2:  BCF    0A.3
09E3:  BCF    03.6
09E4:  CALL   2FA
09E5:  BSF    0A.3
....................          PRINTF (LCD_PUTC, "    _        ");//4SPACE 
09E6:  MOVLW  AE
09E7:  BSF    03.6
09E8:  MOVWF  0D
09E9:  MOVLW  00
09EA:  MOVWF  0F
09EB:  BCF    0A.3
09EC:  BCF    03.6
09ED:  CALL   348
09EE:  BSF    0A.3
....................          DELAY_MS (300);  
09EF:  MOVLW  02
09F0:  BSF    03.6
09F1:  MOVWF  32
09F2:  MOVLW  96
09F3:  MOVWF  62
09F4:  BCF    0A.3
09F5:  BCF    03.6
09F6:  CALL   17A
09F7:  BSF    0A.3
09F8:  BSF    03.6
09F9:  DECFSZ 32,F
09FA:  GOTO   1F2
....................       } 
09FB:  GOTO   260
09FC:  BCF    03.6
....................  
....................       ELSE IF (!INPUT (BT3_PIN)) 
09FD:  BSF    03.5
09FE:  BSF    06.3
09FF:  BCF    03.5
0A00:  BTFSC  06.3
0A01:  GOTO   261
....................       { 
....................          ID_GATEWAY[NUM]++; 
0A02:  MOVLW  36
0A03:  BSF    03.6
0A04:  ADDWF  31,W
0A05:  MOVWF  04
0A06:  BCF    03.7
0A07:  INCF   00,F
....................          ID_GATEWAY[NUM] = ID_GATEWAY[NUM] % 10; 
0A08:  MOVLW  36
0A09:  ADDWF  31,W
0A0A:  MOVWF  78
0A0B:  CLRF   7A
0A0C:  BTFSC  03.0
0A0D:  INCF   7A,F
0A0E:  MOVF   78,W
0A0F:  MOVWF  32
0A10:  MOVF   7A,W
0A11:  MOVWF  33
0A12:  MOVLW  36
0A13:  ADDWF  31,W
0A14:  MOVWF  04
0A15:  BCF    03.7
0A16:  MOVF   00,W
0A17:  MOVWF  35
0A18:  MOVLW  0A
0A19:  MOVWF  36
0A1A:  BCF    0A.3
0A1B:  BCF    03.6
0A1C:  CALL   77C
0A1D:  BSF    0A.3
0A1E:  MOVF   77,W
0A1F:  BSF    03.6
0A20:  MOVWF  34
0A21:  MOVF   32,W
0A22:  MOVWF  04
0A23:  BCF    03.7
0A24:  BTFSC  33.0
0A25:  BSF    03.7
0A26:  MOVF   34,W
0A27:  MOVWF  00
....................          ITOA (ID_GATEWAY[NUM], 10, TEMP_CHAR); 
0A28:  MOVLW  36
0A29:  ADDWF  31,W
0A2A:  MOVWF  04
0A2B:  BCF    03.7
0A2C:  MOVF   00,W
0A2D:  MOVWF  32
0A2E:  CLRF   67
0A2F:  CLRF   66
0A30:  CLRF   65
0A31:  MOVF   32,W
0A32:  MOVWF  64
0A33:  MOVLW  0A
0A34:  MOVWF  68
0A35:  CLRF   6A
0A36:  MOVLW  6A
0A37:  MOVWF  69
0A38:  BCF    0A.3
0A39:  BCF    03.6
0A3A:  CALL   447
0A3B:  BSF    0A.3
....................          LCD_GOTOXY (7 + NUM, 2); 
0A3C:  MOVLW  07
0A3D:  BSF    03.6
0A3E:  ADDWF  31,W
0A3F:  MOVWF  32
0A40:  MOVWF  62
0A41:  MOVLW  02
0A42:  MOVWF  63
0A43:  BCF    0A.3
0A44:  BCF    03.6
0A45:  CALL   2FA
0A46:  BSF    0A.3
....................          DELAY_MS (10); 
0A47:  MOVLW  0A
0A48:  BSF    03.6
0A49:  MOVWF  62
0A4A:  BCF    0A.3
0A4B:  BCF    03.6
0A4C:  CALL   17A
0A4D:  BSF    0A.3
....................          PRINTF (LCD_PUTC, TEMP_CHAR); 
0A4E:  MOVLW  6A
0A4F:  MOVWF  04
0A50:  BCF    03.7
0A51:  BCF    0A.3
0A52:  CALL   75F
0A53:  BSF    0A.3
....................          DELAY_MS (300); 
0A54:  MOVLW  02
0A55:  BSF    03.6
0A56:  MOVWF  32
0A57:  MOVLW  96
0A58:  MOVWF  62
0A59:  BCF    0A.3
0A5A:  BCF    03.6
0A5B:  CALL   17A
0A5C:  BSF    0A.3
0A5D:  BSF    03.6
0A5E:  DECFSZ 32,F
0A5F:  GOTO   257
0A60:  BCF    03.6
....................       } 
0A61:  GOTO   1C8
....................    } 
.................... } 
....................  
.................... VOID BUTT_OKE() 
.................... { 
....................    TT_CONFIG_DONE = 0; 
*
013D:  BCF    03.5
013E:  BCF    03.6
013F:  BCF    48.3
....................    TT_FUN = 0;//BREAK WHILE BUTT_FUN 
0140:  BCF    48.4
....................    TT_STT = 0;// BREAK WHILE CHONID/NHAPID_GW 
0141:  BCF    48.5
.................... } 
....................  
.................... VOID SELLECT_FUN() 
.................... { 
....................    TT_CONFIG_DONE = 0; 
*
088B:  BCF    48.3
....................  
....................    SWITCH (CONFIG_FUN) 
088C:  MOVF   32,W
088D:  BTFSC  03.2
088E:  GOTO   093
088F:  XORLW  01
0890:  BTFSC  03.2
0891:  GOTO   176
0892:  GOTO   262
....................    { 
....................       CASE 0: 
....................       CHON_ID (); 
....................       BREAK; 
*
0975:  GOTO   262
....................  
....................       CASE 1:     
....................       NHAPID_GW (); 
....................       BREAK; 
....................    } 
.................... } 
....................  
.................... VOID BUTT_FUN() 
.................... { 
....................    TT_FUN = 1; 
*
0800:  BSF    48.4
....................    LCD_GOTOXY (1, 1) ; 
0801:  MOVLW  01
0802:  BSF    03.6
0803:  MOVWF  62
0804:  MOVWF  63
0805:  BCF    0A.3
0806:  BCF    03.6
0807:  CALL   2FA
0808:  BSF    0A.3
....................    DELAY_MS (10); 
0809:  MOVLW  0A
080A:  BSF    03.6
080B:  MOVWF  62
080C:  BCF    0A.3
080D:  BCF    03.6
080E:  CALL   17A
080F:  BSF    0A.3
....................    PRINTF (LCD_PUTC, "CONFIG:        "); 
0810:  MOVLW  B5
0811:  BSF    03.6
0812:  MOVWF  0D
0813:  MOVLW  00
0814:  MOVWF  0F
0815:  BCF    0A.3
0816:  BCF    03.6
0817:  CALL   348
0818:  BSF    0A.3
....................  
....................    // HIEN THI LCD 
....................    LCD_GOTOXY (1, 2) ; 
0819:  MOVLW  01
081A:  BSF    03.6
081B:  MOVWF  62
081C:  MOVLW  02
081D:  MOVWF  63
081E:  BCF    0A.3
081F:  BCF    03.6
0820:  CALL   2FA
0821:  BSF    0A.3
....................    DELAY_MS (10); 
0822:  MOVLW  0A
0823:  BSF    03.6
0824:  MOVWF  62
0825:  BCF    0A.3
0826:  BCF    03.6
0827:  CALL   17A
0828:  BSF    0A.3
....................    PRINTF (LCD_PUTC, "CASE:          ") ; 
0829:  MOVLW  BD
082A:  BSF    03.6
082B:  MOVWF  0D
082C:  MOVLW  00
082D:  MOVWF  0F
082E:  BCF    0A.3
082F:  BCF    03.6
0830:  CALL   348
0831:  BSF    0A.3
....................  
....................    WHILE (TT_FUN) 
0832:  BTFSS  48.4
0833:  GOTO   089
....................    { 
....................       IF (INPUT (BT2_PIN) == 0) //NEU NUT BAM DUOC BAM 
0834:  BSF    03.5
0835:  BSF    06.2
0836:  BCF    03.5
0837:  BTFSC  06.2
0838:  GOTO   088
....................       { 
....................          CONFIG_FUN ++; 
0839:  INCF   32,F
....................          CONFIG_FUN = CONFIG_FUN % 2; 
083A:  MOVLW  01
083B:  ANDWF  32,F
....................          DELAY_MS (300); 
083C:  MOVLW  02
083D:  BSF    03.6
083E:  MOVWF  31
083F:  MOVLW  96
0840:  MOVWF  62
0841:  BCF    0A.3
0842:  BCF    03.6
0843:  CALL   17A
0844:  BSF    0A.3
0845:  BSF    03.6
0846:  DECFSZ 31,F
0847:  GOTO   03F
....................          //HIEN THI 
....................          LCD_GOTOXY (6, 2) ; 
0848:  MOVLW  06
0849:  MOVWF  62
084A:  MOVLW  02
084B:  MOVWF  63
084C:  BCF    0A.3
084D:  BCF    03.6
084E:  CALL   2FA
084F:  BSF    0A.3
....................          ITOA (CONFIG_FUN, 10, TEMP_CHAR); 
0850:  BSF    03.6
0851:  CLRF   67
0852:  CLRF   66
0853:  CLRF   65
0854:  BCF    03.6
0855:  MOVF   32,W
0856:  BSF    03.6
0857:  MOVWF  64
0858:  MOVLW  0A
0859:  MOVWF  68
085A:  CLRF   6A
085B:  MOVLW  6A
085C:  MOVWF  69
085D:  BCF    0A.3
085E:  BCF    03.6
085F:  CALL   447
0860:  BSF    0A.3
....................          DELAY_MS (10); 
0861:  MOVLW  0A
0862:  BSF    03.6
0863:  MOVWF  62
0864:  BCF    0A.3
0865:  BCF    03.6
0866:  CALL   17A
0867:  BSF    0A.3
....................          PRINTF (LCD_PUTC, TEMP_CHAR); 
0868:  MOVLW  6A
0869:  MOVWF  04
086A:  BCF    03.7
086B:  BCF    0A.3
086C:  CALL   75F
086D:  BSF    0A.3
....................  
....................          SWITCH (CONFIG_FUN) 
086E:  MOVF   32,W
086F:  BTFSC  03.2
0870:  GOTO   075
0871:  XORLW  01
0872:  BTFSC  03.2
0873:  GOTO   07F
0874:  GOTO   088
....................          { 
....................             CASE 0: 
....................             PRINTF (LCD_PUTC, " - ID-NODE      "); 
0875:  MOVLW  C5
0876:  BSF    03.6
0877:  MOVWF  0D
0878:  MOVLW  00
0879:  MOVWF  0F
087A:  BCF    0A.3
087B:  BCF    03.6
087C:  CALL   348
087D:  BSF    0A.3
....................             BREAK; 
087E:  GOTO   088
....................  
....................             CASE 1: 
....................             PRINTF (LCD_PUTC, " - ID-GW       "); 
087F:  MOVLW  CE
0880:  BSF    03.6
0881:  MOVWF  0D
0882:  MOVLW  00
0883:  MOVWF  0F
0884:  BCF    0A.3
0885:  BCF    03.6
0886:  CALL   348
0887:  BSF    0A.3
....................             BREAK;             
....................          } 
....................       } 
0888:  GOTO   032
....................    } 
....................  
....................    ////// 
....................    IF (!TT_CONFIG_DONE) 
0889:  BTFSC  48.3
088A:  GOTO   262
....................    { 
....................       SELLECT_FUN (); 
....................    } 
*
0A62:  BSF    0A.3
0A63:  BSF    0A.4
0A64:  GOTO   42E (RETURN)
.................... } 
.................... VOID XULY_IDNODE_NHAP(){ 
....................    //*TEMP_CHAR3 = "\0"; 
....................    *ID_NODE_CHAR = "\0"; 
*
06AE:  CLRF   7A
06AF:  MOVLW  4A
06B0:  MOVWF  5F
06B1:  MOVF   7A,W
06B2:  MOVWF  60
06B3:  MOVF   5F,W
06B4:  MOVWF  04
06B5:  BCF    03.7
06B6:  BTFSC  60.0
06B7:  BSF    03.7
06B8:  CLRF   00
....................    FOR (int j = 0; j < 4; j++) 
06B9:  CLRF   5E
06BA:  MOVF   5E,W
06BB:  SUBLW  03
06BC:  BTFSS  03.0
06BD:  GOTO   703
....................    { 
....................       write_eeprom(10+j, ID_NODE[j]); 
06BE:  MOVLW  0A
06BF:  ADDWF  5E,W
06C0:  MOVWF  5F
06C1:  MOVLW  3C
06C2:  ADDWF  5E,W
06C3:  MOVWF  04
06C4:  BCF    03.7
06C5:  MOVF   00,W
06C6:  MOVWF  60
06C7:  BCF    03.6
06C8:  MOVF   0B,W
06C9:  MOVWF  77
06CA:  BCF    0B.7
06CB:  BSF    03.6
06CC:  MOVF   5F,W
06CD:  MOVWF  0D
06CE:  MOVF   60,W
06CF:  MOVWF  0C
06D0:  BSF    03.5
06D1:  BCF    0C.7
06D2:  BSF    0C.2
06D3:  MOVLW  55
06D4:  MOVWF  0D
06D5:  MOVLW  AA
06D6:  MOVWF  0D
06D7:  BSF    0C.1
06D8:  BTFSC  0C.1
06D9:  GOTO   6D8
06DA:  BCF    0C.2
06DB:  MOVF   77,W
06DC:  BCF    03.5
06DD:  BCF    03.6
06DE:  IORWF  0B,F
....................       ITOA (ID_NODE[j], 10, TEMP_CHAR); 
06DF:  MOVLW  3C
06E0:  BSF    03.6
06E1:  ADDWF  5E,W
06E2:  MOVWF  04
06E3:  BCF    03.7
06E4:  MOVF   00,W
06E5:  MOVWF  5F
06E6:  CLRF   67
06E7:  CLRF   66
06E8:  CLRF   65
06E9:  MOVF   5F,W
06EA:  MOVWF  64
06EB:  MOVLW  0A
06EC:  MOVWF  68
06ED:  CLRF   6A
06EE:  MOVLW  6A
06EF:  MOVWF  69
06F0:  BCF    03.6
06F1:  CALL   447
....................       DELAY_MS (1); 
06F2:  MOVLW  01
06F3:  BSF    03.6
06F4:  MOVWF  62
06F5:  BCF    03.6
06F6:  CALL   17A
....................       STRCAT (ID_NODE_CHAR, TEMP_CHAR); 
06F7:  BSF    03.6
06F8:  CLRF   60
06F9:  MOVLW  4A
06FA:  MOVWF  5F
06FB:  CLRF   62
06FC:  MOVLW  6A
06FD:  MOVWF  61
06FE:  BCF    03.6
06FF:  CALL   5A5
0700:  BSF    03.6
0701:  INCF   5E,F
0702:  GOTO   6BA
....................    }   
....................    //ID_NODE_CHAR = TEMP_CHAR3;    
....................    //STRCPY(ID_NODE_CHAR,TEMP_CHAR3); 
....................    //strcpy 
.................... } 
.................... VOID XULY_IDGW_NHAP(){ 
....................  
....................    *ID_GATEWAY_CHAR = "\0"; 
*
0656:  CLRF   7A
0657:  MOVLW  51
0658:  MOVWF  5F
0659:  MOVF   7A,W
065A:  MOVWF  60
065B:  MOVF   5F,W
065C:  MOVWF  04
065D:  BCF    03.7
065E:  BTFSC  60.0
065F:  BSF    03.7
0660:  CLRF   00
....................    FOR (int j = 0; j < 6; j++) 
0661:  CLRF   5E
0662:  MOVF   5E,W
0663:  SUBLW  05
0664:  BTFSS  03.0
0665:  GOTO   6AB
....................    { 
....................       write_eeprom(14+j, ID_GATEWAY[j]); 
0666:  MOVLW  0E
0667:  ADDWF  5E,W
0668:  MOVWF  5F
0669:  MOVLW  36
066A:  ADDWF  5E,W
066B:  MOVWF  04
066C:  BCF    03.7
066D:  MOVF   00,W
066E:  MOVWF  60
066F:  BCF    03.6
0670:  MOVF   0B,W
0671:  MOVWF  77
0672:  BCF    0B.7
0673:  BSF    03.6
0674:  MOVF   5F,W
0675:  MOVWF  0D
0676:  MOVF   60,W
0677:  MOVWF  0C
0678:  BSF    03.5
0679:  BCF    0C.7
067A:  BSF    0C.2
067B:  MOVLW  55
067C:  MOVWF  0D
067D:  MOVLW  AA
067E:  MOVWF  0D
067F:  BSF    0C.1
0680:  BTFSC  0C.1
0681:  GOTO   680
0682:  BCF    0C.2
0683:  MOVF   77,W
0684:  BCF    03.5
0685:  BCF    03.6
0686:  IORWF  0B,F
....................       ITOA (ID_GATEWAY[j], 10, TEMP_CHAR); 
0687:  MOVLW  36
0688:  BSF    03.6
0689:  ADDWF  5E,W
068A:  MOVWF  04
068B:  BCF    03.7
068C:  MOVF   00,W
068D:  MOVWF  5F
068E:  CLRF   67
068F:  CLRF   66
0690:  CLRF   65
0691:  MOVF   5F,W
0692:  MOVWF  64
0693:  MOVLW  0A
0694:  MOVWF  68
0695:  CLRF   6A
0696:  MOVLW  6A
0697:  MOVWF  69
0698:  BCF    03.6
0699:  CALL   447
....................       DELAY_MS (1); 
069A:  MOVLW  01
069B:  BSF    03.6
069C:  MOVWF  62
069D:  BCF    03.6
069E:  CALL   17A
....................       STRCAT (ID_GATEWAY_CHAR, TEMP_CHAR); 
069F:  BSF    03.6
06A0:  CLRF   60
06A1:  MOVLW  51
06A2:  MOVWF  5F
06A3:  CLRF   62
06A4:  MOVLW  6A
06A5:  MOVWF  61
06A6:  BCF    03.6
06A7:  CALL   5A5
06A8:  BSF    03.6
06A9:  INCF   5E,F
06AA:  GOTO   662
....................    }   
.................... } 
....................  
....................  
.................... VOID CONFIG_DONE() 
.................... { 
....................    TT_FUN = 0; 
*
0601:  BCF    48.4
....................    TT_STT = 0; 
0602:  BCF    48.5
....................    CHAR *PACKAGE_CONFIG[]={"*", "LENGHT","CF", "ID_GW1234" ,"ID_NODE","#"}; 
0603:  MOVLW  2A
0604:  BSF    03.6
0605:  MOVWF  3D
0606:  CLRF   3E
0607:  MOVLW  4C
0608:  MOVWF  3F
0609:  MOVLW  45
060A:  MOVWF  40
060B:  MOVLW  4E
060C:  MOVWF  41
060D:  MOVLW  47
060E:  MOVWF  42
060F:  MOVLW  48
0610:  MOVWF  43
0611:  MOVLW  54
0612:  MOVWF  44
0613:  CLRF   45
0614:  MOVLW  43
0615:  MOVWF  46
0616:  MOVLW  46
0617:  MOVWF  47
0618:  CLRF   48
0619:  MOVLW  49
061A:  MOVWF  49
061B:  MOVLW  44
061C:  MOVWF  4A
061D:  MOVLW  5F
061E:  MOVWF  4B
061F:  MOVLW  47
0620:  MOVWF  4C
0621:  MOVLW  57
0622:  MOVWF  4D
0623:  MOVLW  31
0624:  MOVWF  4E
0625:  MOVLW  32
0626:  MOVWF  4F
0627:  MOVLW  33
0628:  MOVWF  50
0629:  MOVLW  34
062A:  MOVWF  51
062B:  CLRF   52
062C:  MOVLW  49
062D:  MOVWF  53
062E:  MOVLW  44
062F:  MOVWF  54
0630:  MOVLW  5F
0631:  MOVWF  55
0632:  MOVLW  4E
0633:  MOVWF  56
0634:  MOVLW  4F
0635:  MOVWF  57
0636:  MOVLW  44
0637:  MOVWF  58
0638:  MOVLW  45
0639:  MOVWF  59
063A:  CLRF   5A
063B:  MOVLW  23
063C:  MOVWF  5B
063D:  CLRF   5C
063E:  MOVLW  01
063F:  MOVWF  32
0640:  MOVLW  3D
0641:  MOVWF  31
0642:  MOVLW  01
0643:  MOVWF  34
0644:  MOVLW  3F
0645:  MOVWF  33
0646:  MOVLW  01
0647:  MOVWF  36
0648:  MOVLW  46
0649:  MOVWF  35
064A:  MOVLW  01
064B:  MOVWF  38
064C:  MOVLW  49
064D:  MOVWF  37
064E:  MOVLW  01
064F:  MOVWF  3A
0650:  MOVLW  53
0651:  MOVWF  39
0652:  MOVLW  01
0653:  MOVWF  3C
0654:  MOVLW  5B
0655:  MOVWF  3B
....................    XULY_IDGW_NHAP(); 
....................    PACKAGE_CONFIG[3] = ID_GATEWAY_CHAR; 
*
06AB:  CLRF   38
06AC:  MOVLW  51
06AD:  MOVWF  37
....................     
....................     
....................    XULY_IDNODE_NHAP(); 
....................  
....................    PACKAGE_CONFIG[4] = ID_NODE_CHAR;     
*
0703:  CLRF   3A
0704:  MOVLW  4A
0705:  MOVWF  39
....................       /*     
....................    LEN_PACKAGES = 0; 
....................    PACKAGE_CONFIG[1] = "12"; //DO DAI CUA LENGHT CO DO DAI = 2 
....................    FOR (int J = 0; J < 5; J++) 
....................    { 
....................       LEN_PACKAGES += strlen(PACKAGE_CONFIG[J]); 
....................    }    
....................    */ 
....................    LEN_PACKAGES = 20; //5 @ 
0706:  MOVLW  14
0707:  BCF    03.6
0708:  MOVWF  40
....................    ITOA (LEN_PACKAGES, 10, TEMP_CHAR); 
0709:  BSF    03.6
070A:  CLRF   67
070B:  CLRF   66
070C:  CLRF   65
070D:  BCF    03.6
070E:  MOVF   40,W
070F:  BSF    03.6
0710:  MOVWF  64
0711:  MOVLW  0A
0712:  MOVWF  68
0713:  CLRF   6A
0714:  MOVLW  6A
0715:  MOVWF  69
0716:  BCF    03.6
0717:  CALL   447
....................     
....................    PACKAGE_CONFIG[1] = TEMP_CHAR; 
0718:  BSF    03.6
0719:  CLRF   34
071A:  MOVLW  6A
071B:  MOVWF  33
....................     
....................    FOR (INT J = 0; J < 6; J++) 
071C:  CLRF   5D
071D:  MOVF   5D,W
071E:  SUBLW  05
071F:  BTFSS  03.0
0720:  GOTO   739
....................    { 
....................       PRINTF (PACKAGE_CONFIG[J]); 
0721:  BCF    03.0
0722:  RLF    5D,W
0723:  ADDLW  31
0724:  MOVWF  04
0725:  BSF    03.7
0726:  INCF   04,F
0727:  MOVF   00,W
0728:  MOVWF  5F
0729:  DECF   04,F
072A:  MOVF   00,W
072B:  MOVWF  5E
072C:  MOVWF  04
072D:  BCF    03.7
072E:  BTFSC  5F.0
072F:  BSF    03.7
0730:  BCF    03.6
0731:  CALL   5E3
....................       PRINTF ("@"); 
0732:  MOVLW  40
0733:  BTFSS  0C.4
0734:  GOTO   733
0735:  MOVWF  19
0736:  BSF    03.6
0737:  INCF   5D,F
0738:  GOTO   71D
....................    } 
....................  
....................  
....................    LCD_GOTOXY (1, 1) ; 
0739:  MOVLW  01
073A:  MOVWF  62
073B:  MOVWF  63
073C:  BCF    03.6
073D:  CALL   2FA
....................    DELAY_MS (10); 
073E:  MOVLW  0A
073F:  BSF    03.6
0740:  MOVWF  62
0741:  BCF    03.6
0742:  CALL   17A
....................    PRINTF (LCD_PUTC, "WAITING ....        ") ; 
0743:  MOVLW  D6
0744:  BSF    03.6
0745:  MOVWF  0D
0746:  MOVLW  00
0747:  MOVWF  0F
0748:  BCF    03.6
0749:  CALL   348
....................    LCD_GOTOXY (1, 2) ; 
074A:  MOVLW  01
074B:  BSF    03.6
074C:  MOVWF  62
074D:  MOVLW  02
074E:  MOVWF  63
074F:  BCF    03.6
0750:  CALL   2FA
....................    DELAY_MS (10); 
0751:  MOVLW  0A
0752:  BSF    03.6
0753:  MOVWF  62
0754:  BCF    03.6
0755:  CALL   17A
....................    PRINTF (LCD_PUTC, "WAITING ....        ") ;    
0756:  MOVLW  E1
0757:  BSF    03.6
0758:  MOVWF  0D
0759:  MOVLW  00
075A:  MOVWF  0F
075B:  BCF    03.6
075C:  CALL   348
....................    TT_CONFIG_DONE = 0; 
075D:  BCF    48.3
075E:  RETURN
.................... } 
....................  
....................  
....................  VOID XACNHANCONFIG() 
....................  {    
....................    KYTU=0;          
*
1128:  CLRF   34
....................    LCD_GOTOXY (1, 1) ; 
1129:  MOVLW  01
112A:  BSF    03.6
112B:  MOVWF  62
112C:  MOVWF  63
112D:  BCF    0A.4
112E:  BCF    03.6
112F:  CALL   2FA
1130:  BSF    0A.4
....................    DELAY_MS (10); 
1131:  MOVLW  0A
1132:  BSF    03.6
1133:  MOVWF  62
1134:  BCF    0A.4
1135:  BCF    03.6
1136:  CALL   17A
1137:  BSF    0A.4
....................    TEMP_CHAR = "_"; 
1138:  BSF    03.6
1139:  CLRF   3D
113A:  CLRF   3E
113B:  MOVLW  6A
113C:  MOVWF  04
113D:  BCF    03.7
113E:  MOVF   3D,W
113F:  ADDWF  04,F
1140:  MOVF   3E,W
1141:  BCF    0A.4
1142:  BCF    03.6
1143:  CALL   05E
1144:  BSF    0A.4
1145:  MOVWF  00
1146:  IORLW  00
1147:  BTFSC  03.2
1148:  GOTO   14E
1149:  BSF    03.6
114A:  INCF   3E,F
114B:  INCF   3D,F
114C:  GOTO   13B
114D:  BCF    03.6
....................    CHAR * TOKEN; 
....................    TOKEN = STRTOK (KYTUCHAR2, TEMP_CHAR);    
114E:  BSF    03.6
114F:  CLRF   3E
1150:  MOVLW  D2
1151:  MOVWF  3D
1152:  CLRF   40
1153:  MOVLW  6A
1154:  MOVWF  3F
1155:  BCF    0A.4
1156:  BSF    0A.3
1157:  BCF    03.6
1158:  CALL   265
1159:  BSF    0A.4
115A:  BCF    0A.3
115B:  MOVF   79,W
115C:  BSF    03.6
115D:  MOVWF  3C
115E:  MOVF   78,W
115F:  MOVWF  3B
....................     WHILE (TOKEN != NULL) 
1160:  MOVF   3B,F
1161:  BTFSS  03.2
1162:  GOTO   166
1163:  MOVF   3C,F
1164:  BTFSC  03.2
1165:  GOTO   1BB
....................     {                 
....................        SWITCH(KYTU) 
1166:  BCF    03.6
1167:  MOVF   34,W
1168:  BTFSC  03.2
1169:  GOTO   171
116A:  XORLW  01
116B:  BTFSC  03.2
116C:  GOTO   18B
116D:  XORLW  03
116E:  BTFSC  03.2
116F:  GOTO   199
1170:  GOTO   1A6
....................        { 
....................          CASE 0: 
....................          DELAY_MS (1); 
1171:  MOVLW  01
1172:  BSF    03.6
1173:  MOVWF  62
1174:  BCF    0A.4
1175:  BCF    03.6
1176:  CALL   17A
1177:  BSF    0A.4
....................          PRINTF (LCD_PUTC,TOKEN); 
1178:  BSF    03.6
1179:  MOVF   3B,W
117A:  MOVWF  04
117B:  BCF    03.7
117C:  BTFSC  3C.0
117D:  BSF    03.7
117E:  BCF    0A.4
117F:  BCF    03.6
1180:  CALL   75F
1181:  BSF    0A.4
....................          PRINTF (LCD_PUTC,"            "); 
1182:  MOVLW  EC
1183:  BSF    03.6
1184:  MOVWF  0D
1185:  MOVLW  00
1186:  MOVWF  0F
1187:  BCF    0A.4
1188:  BCF    03.6
1189:  CALL   348
118A:  BSF    0A.4
....................          CASE 1:  
....................          SOLUONGTHIETBI_CONFIG = ATOI(TOKEN); 
118B:  BSF    03.6
118C:  MOVF   3C,W
118D:  MOVWF  3E
118E:  MOVF   3B,W
118F:  MOVWF  3D
1190:  BCF    0A.4
1191:  BSF    0A.3
1192:  BCF    03.6
1193:  CALL   356
1194:  BSF    0A.4
1195:  BCF    0A.3
1196:  MOVF   78,W
1197:  MOVWF  43
....................          BREAK;                      
1198:  GOTO   1A6
....................          CASE 2: 
....................          SOLUONGCAMBIEN_CONFIG = ATOI(TOKEN); 
1199:  BSF    03.6
119A:  MOVF   3C,W
119B:  MOVWF  3E
119C:  MOVF   3B,W
119D:  MOVWF  3D
119E:  BCF    0A.4
119F:  BSF    0A.3
11A0:  BCF    03.6
11A1:  CALL   356
11A2:  BSF    0A.4
11A3:  BCF    0A.3
11A4:  MOVF   78,W
11A5:  MOVWF  44
....................          BREAK;               
....................        }  
....................       TOKEN = STRTOK(NULL, TEMP_CHAR); 
11A6:  BSF    03.6
11A7:  CLRF   3E
11A8:  CLRF   3D
11A9:  CLRF   40
11AA:  MOVLW  6A
11AB:  MOVWF  3F
11AC:  BCF    0A.4
11AD:  BSF    0A.3
11AE:  BCF    03.6
11AF:  CALL   265
11B0:  BSF    0A.4
11B1:  BCF    0A.3
11B2:  MOVF   79,W
11B3:  BSF    03.6
11B4:  MOVWF  3C
11B5:  MOVF   78,W
11B6:  MOVWF  3B
....................       KYTU++;         
11B7:  BCF    03.6
11B8:  INCF   34,F
11B9:  BSF    03.6
11BA:  GOTO   160
....................     }           
....................    DELAY_MS (1);       
11BB:  MOVLW  01
11BC:  MOVWF  62
11BD:  BCF    0A.4
11BE:  BCF    03.6
11BF:  CALL   17A
11C0:  BSF    0A.4
....................    LCD_GOTOXY (1, 2) ; 
11C1:  MOVLW  01
11C2:  BSF    03.6
11C3:  MOVWF  62
11C4:  MOVLW  02
11C5:  MOVWF  63
11C6:  BCF    0A.4
11C7:  BCF    03.6
11C8:  CALL   2FA
11C9:  BSF    0A.4
....................    DELAY_MS (10); 
11CA:  MOVLW  0A
11CB:  BSF    03.6
11CC:  MOVWF  62
11CD:  BCF    0A.4
11CE:  BCF    03.6
11CF:  CALL   17A
11D0:  BSF    0A.4
....................    PRINTF (LCD_PUTC,"TB: ");    
11D1:  MOVLW  F3
11D2:  BSF    03.6
11D3:  MOVWF  0D
11D4:  MOVLW  00
11D5:  MOVWF  0F
11D6:  BCF    0A.4
11D7:  BCF    03.6
11D8:  CALL   348
11D9:  BSF    0A.4
....................    ITOA (SOLUONGTHIETBI_CONFIG, 10, TEMP_CHAR);    
11DA:  BSF    03.6
11DB:  CLRF   67
11DC:  CLRF   66
11DD:  CLRF   65
11DE:  BCF    03.6
11DF:  MOVF   43,W
11E0:  BSF    03.6
11E1:  MOVWF  64
11E2:  MOVLW  0A
11E3:  MOVWF  68
11E4:  CLRF   6A
11E5:  MOVLW  6A
11E6:  MOVWF  69
11E7:  BCF    0A.4
11E8:  BCF    03.6
11E9:  CALL   447
11EA:  BSF    0A.4
....................    PRINTF (LCD_PUTC,TEMP_CHAR);    
11EB:  MOVLW  6A
11EC:  MOVWF  04
11ED:  BCF    03.7
11EE:  BCF    0A.4
11EF:  CALL   75F
11F0:  BSF    0A.4
....................    PRINTF (LCD_PUTC,"    CB:");    
11F1:  MOVLW  F6
11F2:  BSF    03.6
11F3:  MOVWF  0D
11F4:  MOVLW  00
11F5:  MOVWF  0F
11F6:  BCF    0A.4
11F7:  BCF    03.6
11F8:  CALL   348
11F9:  BSF    0A.4
....................    ITOA (SOLUONGCAMBIEN_CONFIG, 10, TEMP_CHAR);    
11FA:  BSF    03.6
11FB:  CLRF   67
11FC:  CLRF   66
11FD:  CLRF   65
11FE:  BCF    03.6
11FF:  MOVF   44,W
1200:  BSF    03.6
1201:  MOVWF  64
1202:  MOVLW  0A
1203:  MOVWF  68
1204:  CLRF   6A
1205:  MOVLW  6A
1206:  MOVWF  69
1207:  BCF    0A.4
1208:  BCF    03.6
1209:  CALL   447
120A:  BSF    0A.4
....................    PRINTF (LCD_PUTC,TEMP_CHAR);       
120B:  MOVLW  6A
120C:  MOVWF  04
120D:  BCF    03.7
120E:  BCF    0A.4
120F:  CALL   75F
1210:  BSF    0A.4
....................    TT_CONFIG_OKE_UART = 1; 
1211:  BSF    48.6
....................     
....................  }  
.................... //--------------------------------------------------------------------// 
....................  
.................... #INCLUDE <DIEU_KHIEN.C> 
.................... VOID READ_BTN_STATE() 
*
0E42:  BSF    03.6
0E43:  CLRF   31
0E44:  MOVLW  34
0E45:  MOVWF  32
.................... { 
....................     
....................    INT TB = 0; 
....................    INT ID_TB =52; 
....................    FOR (TB = 0; TB < SOLUONGTHIETBI_CONFIG; TB++) 
0E46:  CLRF   31
0E47:  BCF    03.6
0E48:  MOVF   43,W
0E49:  BSF    03.6
0E4A:  SUBWF  31,W
0E4B:  BTFSC  03.0
0E4C:  GOTO   687
....................    {   IF (TB>3) ID_TB = 64; 
0E4D:  MOVF   31,W
0E4E:  SUBLW  03
0E4F:  BTFSC  03.0
0E50:  GOTO   653
0E51:  MOVLW  40
0E52:  MOVWF  32
....................        IF (!INPUT (ID_TB + TB)) 
0E53:  MOVF   31,W
0E54:  ADDWF  32,W
0E55:  MOVWF  33
0E56:  MOVWF  3E
0E57:  MOVLW  01
0E58:  MOVWF  3F
0E59:  CLRF   41
0E5A:  MOVLW  80
0E5B:  MOVWF  40
0E5C:  BCF    03.6
0E5D:  CALL   439
0E5E:  BSF    03.6
0E5F:  MOVF   33,W
0E60:  MOVWF  41
0E61:  CLRF   43
0E62:  CLRF   42
0E63:  BCF    03.6
0E64:  CALL   45B
0E65:  BTFSC  78.0
0E66:  GOTO   684
....................       {   
....................          DELAY_MS(200); 
0E67:  MOVLW  C8
0E68:  BSF    03.6
0E69:  MOVWF  62
0E6A:  BCF    0A.3
0E6B:  BCF    03.6
0E6C:  CALL   17A
0E6D:  BSF    0A.3
....................          TT_THIETBI_TEMP[TB] = ~TT_THIETBI_TEMP[TB];          
0E6E:  BSF    03.6
0E6F:  MOVF   31,W
0E70:  MOVWF  41
0E71:  CLRF   43
0E72:  MOVLW  47
0E73:  MOVWF  42
0E74:  BCF    03.6
0E75:  CALL   45B
0E76:  MOVLW  00
0E77:  BTFSS  78.0
0E78:  MOVLW  01
0E79:  BSF    03.6
0E7A:  MOVWF  33
0E7B:  MOVF   31,W
0E7C:  MOVWF  3E
0E7D:  MOVF   33,W
0E7E:  MOVWF  3F
0E7F:  CLRF   41
0E80:  MOVLW  47
0E81:  MOVWF  40
0E82:  BCF    03.6
0E83:  CALL   439
....................       } 
0E84:  BSF    03.6
0E85:  INCF   31,F
0E86:  GOTO   647
....................    } 
0E87:  BCF    03.6
0E88:  BSF    0A.3
0E89:  BSF    0A.4
0E8A:  GOTO   446 (RETURN)
.................... /* 
....................    FOR (TB = 0; TB < 4; TB++) 
....................    { 
....................  
....................       IF (!INPUT (68 + TB)) 
....................       { 
....................           DELAY_MS(200); 
....................           TT_THIETBI_TEMP[TB + 4] = ~TT_THIETBI_TEMP[TB + 4];            
....................       } 
....................    } 
.................... */ 
.................... } 
.................... INT BIN_TO_DEC() 
*
0CC6:  BSF    03.6
0CC7:  CLRF   3E
0CC8:  MOVLW  01
0CC9:  MOVWF  3F
.................... { 
....................    INT8 DEC_VL = 0 ;  
....................    INT8 BASE = 1; 
....................    INT8 I; 
....................    FOR (I=0;I<8;I++) 
0CCA:  CLRF   40
0CCB:  MOVF   40,W
0CCC:  SUBLW  07
0CCD:  BTFSS  03.0
0CCE:  GOTO   4EA
....................    { 
....................    DEC_VL = DEC_VL+ BASE*TT_THIETBI_TEMP[I]; 
0CCF:  MOVF   40,W
0CD0:  MOVWF  41
0CD1:  CLRF   43
0CD2:  MOVLW  47
0CD3:  MOVWF  42
0CD4:  BCF    03.6
0CD5:  CALL   45B
0CD6:  MOVLW  00
0CD7:  BTFSC  78.0
0CD8:  MOVLW  01
0CD9:  BSF    03.6
0CDA:  MOVWF  41
0CDB:  MOVF   3F,W
0CDC:  MOVWF  44
0CDD:  MOVF   41,W
0CDE:  MOVWF  45
0CDF:  BCF    0A.3
0CE0:  BCF    03.6
0CE1:  CALL   793
0CE2:  BSF    0A.3
0CE3:  MOVF   78,W
0CE4:  BSF    03.6
0CE5:  ADDWF  3E,F
....................    BASE = BASE*2; 
0CE6:  BCF    03.0
0CE7:  RLF    3F,F
0CE8:  INCF   40,F
0CE9:  GOTO   4CB
....................    } 
....................    RETURN DEC_VL; 
0CEA:  MOVF   3E,W
0CEB:  MOVWF  78
....................  
.................... } 
....................   
....................  VOID XUAT_DIEU_KHIEN() 
....................  { 
....................    LENH_DIEU_KHIEN = BIN_TO_DEC(); 
0CEC:  MOVF   78,W
0CED:  BCF    03.6
0CEE:  MOVWF  35
....................    XUATTRANGTHAI (LENH_DIEU_KHIEN) ;   
0CEF:  MOVF   35,W
0CF0:  BSF    03.6
0CF1:  MOVWF  3E
....................    FOR (INT ST=0;ST<8;ST++){ 
*
0D16:  BSF    03.6
0D17:  CLRF   3D
0D18:  MOVF   3D,W
0D19:  SUBLW  07
0D1A:  BTFSS  03.0
0D1B:  GOTO   54F
....................       TEMP_CHAR = "0"; 
0D1C:  CLRF   3E
0D1D:  CLRF   3F
0D1E:  MOVLW  6A
0D1F:  MOVWF  04
0D20:  BCF    03.7
0D21:  MOVF   3E,W
0D22:  ADDWF  04,F
0D23:  MOVF   3F,W
0D24:  BCF    0A.3
0D25:  BCF    03.6
0D26:  CALL   058
0D27:  BSF    0A.3
0D28:  MOVWF  00
0D29:  IORLW  00
0D2A:  BTFSC  03.2
0D2B:  GOTO   531
0D2C:  BSF    03.6
0D2D:  INCF   3F,F
0D2E:  INCF   3E,F
0D2F:  GOTO   51E
0D30:  BCF    03.6
....................       ITOA(TT_THIETBI_TEMP[ST],10,TEMP_CHAR);       
0D31:  BSF    03.6
0D32:  MOVF   3D,W
0D33:  MOVWF  41
0D34:  CLRF   43
0D35:  MOVLW  47
0D36:  MOVWF  42
0D37:  BCF    03.6
0D38:  CALL   45B
0D39:  MOVLW  00
0D3A:  BTFSC  78.0
0D3B:  MOVLW  01
0D3C:  BSF    03.6
0D3D:  MOVWF  3E
0D3E:  CLRF   67
0D3F:  CLRF   66
0D40:  CLRF   65
0D41:  MOVF   3E,W
0D42:  MOVWF  64
0D43:  MOVLW  0A
0D44:  MOVWF  68
0D45:  CLRF   6A
0D46:  MOVLW  6A
0D47:  MOVWF  69
0D48:  BCF    0A.3
0D49:  BCF    03.6
0D4A:  CALL   447
0D4B:  BSF    0A.3
0D4C:  BSF    03.6
0D4D:  INCF   3D,F
0D4E:  GOTO   518
....................    } 
....................    //CHAR *PACKAGE_CONFIG[]={"*", "LENGHT","CF", "ID_GW1234" ,"ID_NODE","#"}; 
....................    IF(LENH_DIEU_KHIEN<10) TEMP_CHAR ="22"; 
0D4F:  BCF    03.6
0D50:  MOVF   35,W
0D51:  SUBLW  09
0D52:  BTFSS  03.0
0D53:  GOTO   56B
0D54:  BSF    03.6
0D55:  CLRF   3E
0D56:  CLRF   3F
0D57:  MOVLW  6A
0D58:  MOVWF  04
0D59:  BCF    03.7
0D5A:  MOVF   3E,W
0D5B:  ADDWF  04,F
0D5C:  MOVF   3F,W
0D5D:  BCF    0A.3
0D5E:  BCF    03.6
0D5F:  CALL   064
0D60:  BSF    0A.3
0D61:  MOVWF  00
0D62:  IORLW  00
0D63:  BTFSC  03.2
0D64:  GOTO   56A
0D65:  BSF    03.6
0D66:  INCF   3F,F
0D67:  INCF   3E,F
0D68:  GOTO   557
0D69:  BCF    03.6
0D6A:  GOTO   5A0
....................    ELSE IF(LENH_DIEU_KHIEN>=10 && LENH_DIEU_KHIEN <100) TEMP_CHAR ="23"; 
0D6B:  MOVF   35,W
0D6C:  SUBLW  09
0D6D:  BTFSC  03.0
0D6E:  GOTO   58A
0D6F:  MOVF   35,W
0D70:  SUBLW  63
0D71:  BTFSS  03.0
0D72:  GOTO   58A
0D73:  BSF    03.6
0D74:  CLRF   3E
0D75:  CLRF   3F
0D76:  MOVLW  6A
0D77:  MOVWF  04
0D78:  BCF    03.7
0D79:  MOVF   3E,W
0D7A:  ADDWF  04,F
0D7B:  MOVF   3F,W
0D7C:  BCF    0A.3
0D7D:  BCF    03.6
0D7E:  CALL   06B
0D7F:  BSF    0A.3
0D80:  MOVWF  00
0D81:  IORLW  00
0D82:  BTFSC  03.2
0D83:  GOTO   589
0D84:  BSF    03.6
0D85:  INCF   3F,F
0D86:  INCF   3E,F
0D87:  GOTO   576
0D88:  BCF    03.6
0D89:  GOTO   5A0
....................    ELSE TEMP_CHAR ="24";     
0D8A:  BSF    03.6
0D8B:  CLRF   3E
0D8C:  CLRF   3F
0D8D:  MOVLW  6A
0D8E:  MOVWF  04
0D8F:  BCF    03.7
0D90:  MOVF   3E,W
0D91:  ADDWF  04,F
0D92:  MOVF   3F,W
0D93:  BCF    0A.3
0D94:  BCF    03.6
0D95:  CALL   072
0D96:  BSF    0A.3
0D97:  MOVWF  00
0D98:  IORLW  00
0D99:  BTFSC  03.2
0D9A:  GOTO   5A0
0D9B:  BSF    03.6
0D9C:  INCF   3F,F
0D9D:  INCF   3E,F
0D9E:  GOTO   58D
0D9F:  BCF    03.6
....................    PRINTF ("*@"); 
0DA0:  MOVLW  2A
0DA1:  BTFSS  0C.4
0DA2:  GOTO   5A1
0DA3:  MOVWF  19
0DA4:  MOVLW  40
0DA5:  BTFSS  0C.4
0DA6:  GOTO   5A5
0DA7:  MOVWF  19
....................    PRINTF (TEMP_CHAR); 
0DA8:  MOVLW  6A
0DA9:  MOVWF  04
0DAA:  BCF    03.7
0DAB:  BCF    0A.3
0DAC:  CALL   5E3
0DAD:  BSF    0A.3
....................    PRINTF ("@DK@"); 
0DAE:  MOVLW  FA
0DAF:  BSF    03.6
0DB0:  MOVWF  0D
0DB1:  MOVLW  00
0DB2:  MOVWF  0F
0DB3:  BCF    03.6
0DB4:  CALL   474
....................    PRINTF (ID_GATEWAY_CHAR); 
0DB5:  MOVLW  51
0DB6:  MOVWF  04
0DB7:  BCF    03.7
0DB8:  BCF    0A.3
0DB9:  CALL   5E3
0DBA:  BSF    0A.3
....................    PRINTF ("@"); 
0DBB:  MOVLW  40
0DBC:  BTFSS  0C.4
0DBD:  GOTO   5BC
0DBE:  MOVWF  19
....................    PRINTF (ID_NODE_CHAR); 
0DBF:  MOVLW  4A
0DC0:  MOVWF  04
0DC1:  BCF    03.7
0DC2:  BCF    0A.3
0DC3:  CALL   5E3
0DC4:  BSF    0A.3
....................    PRINTF ("@"); 
0DC5:  MOVLW  40
0DC6:  BTFSS  0C.4
0DC7:  GOTO   5C6
0DC8:  MOVWF  19
....................    ITOA(LENH_DIEU_KHIEN,10,TEMP_CHAR); 
0DC9:  BSF    03.6
0DCA:  CLRF   67
0DCB:  CLRF   66
0DCC:  CLRF   65
0DCD:  BCF    03.6
0DCE:  MOVF   35,W
0DCF:  BSF    03.6
0DD0:  MOVWF  64
0DD1:  MOVLW  0A
0DD2:  MOVWF  68
0DD3:  CLRF   6A
0DD4:  MOVLW  6A
0DD5:  MOVWF  69
0DD6:  BCF    0A.3
0DD7:  BCF    03.6
0DD8:  CALL   447
0DD9:  BSF    0A.3
....................    PRINTF (TEMP_CHAR); 
0DDA:  MOVLW  6A
0DDB:  MOVWF  04
0DDC:  BCF    03.7
0DDD:  BCF    0A.3
0DDE:  CALL   5E3
0DDF:  BSF    0A.3
....................    PRINTF ("@#"); 
0DE0:  MOVLW  40
0DE1:  BTFSS  0C.4
0DE2:  GOTO   5E1
0DE3:  MOVWF  19
0DE4:  MOVLW  23
0DE5:  BTFSS  0C.4
0DE6:  GOTO   5E5
0DE7:  MOVWF  19
....................     
....................     
....................    LCD_GOTOXY (1, 2) ; 
0DE8:  MOVLW  01
0DE9:  BSF    03.6
0DEA:  MOVWF  62
0DEB:  MOVLW  02
0DEC:  MOVWF  63
0DED:  BCF    0A.3
0DEE:  BCF    03.6
0DEF:  CALL   2FA
0DF0:  BSF    0A.3
....................    DELAY_MS (10); 
0DF1:  MOVLW  0A
0DF2:  BSF    03.6
0DF3:  MOVWF  62
0DF4:  BCF    0A.3
0DF5:  BCF    03.6
0DF6:  CALL   17A
0DF7:  BSF    0A.3
....................    PRINTF (LCD_PUTC, "SW: ");     
0DF8:  MOVLW  FD
0DF9:  BSF    03.6
0DFA:  MOVWF  0D
0DFB:  MOVLW  00
0DFC:  MOVWF  0F
0DFD:  BCF    0A.3
0DFE:  BCF    03.6
0DFF:  CALL   348
0E00:  BSF    0A.3
....................    FOR (ST=0;ST<8;ST++){ 
0E01:  BSF    03.6
0E02:  CLRF   3D
0E03:  MOVF   3D,W
0E04:  SUBLW  07
0E05:  BTFSS  03.0
0E06:  GOTO   640
....................       TEMP_CHAR = "0"; 
0E07:  CLRF   3E
0E08:  CLRF   3F
0E09:  MOVLW  6A
0E0A:  MOVWF  04
0E0B:  BCF    03.7
0E0C:  MOVF   3E,W
0E0D:  ADDWF  04,F
0E0E:  MOVF   3F,W
0E0F:  BCF    0A.3
0E10:  BCF    03.6
0E11:  CALL   058
0E12:  BSF    0A.3
0E13:  MOVWF  00
0E14:  IORLW  00
0E15:  BTFSC  03.2
0E16:  GOTO   61C
0E17:  BSF    03.6
0E18:  INCF   3F,F
0E19:  INCF   3E,F
0E1A:  GOTO   609
0E1B:  BCF    03.6
....................       ITOA(TT_THIETBI_TEMP[ST],10,TEMP_CHAR); 
0E1C:  BSF    03.6
0E1D:  MOVF   3D,W
0E1E:  MOVWF  41
0E1F:  CLRF   43
0E20:  MOVLW  47
0E21:  MOVWF  42
0E22:  BCF    03.6
0E23:  CALL   45B
0E24:  MOVLW  00
0E25:  BTFSC  78.0
0E26:  MOVLW  01
0E27:  BSF    03.6
0E28:  MOVWF  3E
0E29:  CLRF   67
0E2A:  CLRF   66
0E2B:  CLRF   65
0E2C:  MOVF   3E,W
0E2D:  MOVWF  64
0E2E:  MOVLW  0A
0E2F:  MOVWF  68
0E30:  CLRF   6A
0E31:  MOVLW  6A
0E32:  MOVWF  69
0E33:  BCF    0A.3
0E34:  BCF    03.6
0E35:  CALL   447
0E36:  BSF    0A.3
....................       PRINTF (LCD_PUTC, TEMP_CHAR); 
0E37:  MOVLW  6A
0E38:  MOVWF  04
0E39:  BCF    03.7
0E3A:  BCF    0A.3
0E3B:  CALL   75F
0E3C:  BSF    0A.3
0E3D:  BSF    03.6
0E3E:  INCF   3D,F
0E3F:  GOTO   603
....................    }    
0E40:  BCF    03.6
0E41:  RETURN
....................     
....................  } 
....................  VOID DIEUKHIENTHIETBI () 
*
1213:  BSF    03.6
1214:  CLRF   3B
....................  { 
....................     INT MA_DEC = 0; 
....................     MA_DEC = ATOI (KYTUCHAR2); 
1215:  CLRF   3E
1216:  MOVLW  D2
1217:  MOVWF  3D
1218:  BCF    0A.4
1219:  BSF    0A.3
121A:  BCF    03.6
121B:  CALL   356
121C:  BSF    0A.4
121D:  BCF    0A.3
121E:  MOVF   78,W
121F:  BSF    03.6
1220:  MOVWF  3B
....................  
....................    UNSIGNED INT8   SB;    
....................    #BIT BSERI  = MA_DEC.0 
....................     
....................    FOR (SB=0;SB<8;SB++) 
1221:  CLRF   3C
1222:  MOVF   3C,W
1223:  SUBLW  07
1224:  BTFSS  03.0
1225:  GOTO   23C
....................       {                                                     
....................          TT_THIETBI_TEMP[SB] = BSERI; 
1226:  MOVLW  00
1227:  BTFSC  3B.0
1228:  MOVLW  01
1229:  MOVWF  3D
122A:  MOVF   3C,W
122B:  MOVWF  3E
122C:  MOVF   3D,W
122D:  MOVWF  3F
122E:  CLRF   41
122F:  MOVLW  47
1230:  MOVWF  40
1231:  BCF    0A.4
1232:  BSF    0A.3
1233:  BCF    03.6
1234:  CALL   439
1235:  BSF    0A.4
1236:  BCF    0A.3
....................          MA_DEC=MA_DEC>>1;  
1237:  BCF    03.0
1238:  BSF    03.6
1239:  RRF    3B,F
123A:  INCF   3C,F
123B:  GOTO   222
....................      }     
....................     XUAT_DIEU_KHIEN(); 
123C:  BCF    0A.4
123D:  BSF    0A.3
123E:  BCF    03.6
123F:  CALL   4C6
1240:  BSF    0A.4
1241:  BCF    0A.3
....................  } 
....................  
....................  
.................... //#INCLUDE <analog.C> 
.................... #INCLUDE <analog_ds18b20.c> 
.................... #include "types.h" 
.................... /*** FILEHEADER **************************************************************** 
....................  * 
....................  *	FILENAME:    types.h 
....................  *	DATE:        21.11.2004 
....................  *	AUTHOR:		 Christian Stadler 
....................  * 
....................  *	DESCRIPTION: Definition of common types. 
....................  * 
....................  ******************************************************************************/ 
....................  
.................... /*** HISTORY OF CHANGE ********************************************************* 
....................  * 
....................  *	$Log: /pic/_inc/types.h $ 
....................  *  
....................  * 3     1.11.10 11:42 Stadler 
....................  * - type definitons dependend on compiler 
....................  *  
....................  * 2     26.02.05 18:44 Stadler 
....................  * added bool type 
....................  *  
....................  ******************************************************************************/ 
....................  
.................... #ifndef _TYPES_H 
.................... #define _TYPES_H 
....................  
.................... /*---------------------------------------------------------------------------*/ 
.................... /* Type definitions for Microchip C18 Compiler                               */ 
.................... /*---------------------------------------------------------------------------*/ 
.................... #if defined(__18CXX) 
....................  
.................... typedef unsigned char bool; 
.................... typedef signed char sint8; 
.................... typedef signed int sint16; 
.................... typedef signed long sint32; 
.................... typedef unsigned char  uint8; 
.................... typedef unsigned int uint16; 
.................... typedef unsigned long uint32; 
....................  
.................... #endif /* #if defined(__18CXX) */ 
....................  
....................  
....................  
.................... /*---------------------------------------------------------------------------*/ 
.................... /* Type definitions for CCS C Compiler                                       */ 
.................... /*---------------------------------------------------------------------------*/ 
.................... #if (defined(__PCB__) || defined(__PCH__) || defined(__PCM__)) 
....................  
.................... typedef int1 bool; 
.................... typedef signed int8 sint8; 
.................... typedef signed int16 sint16; 
.................... typedef signed int32 sint32; 
.................... typedef unsigned int8  uint8; 
.................... typedef unsigned int16 uint16; 
.................... typedef unsigned int32 uint32; 
....................  
.................... #endif /* (defined(__PCB__) || defined(__PCH__) || defined(__PCM__)) */ 
....................  
.................... #endif /*_TYPES_H */ 
....................  
.................... #define DS1820_DATAPIN  PIN_A0 
.................... #include <ds18b20.h> 
....................    /*** FILEHEADER **************************************************************** 
....................  * 
....................  *    FILENAME:    ds1820.h 
....................  *    DATE:        25.02.2005 
....................  *    AUTHOR:      Christian Stadler 
....................  * 
....................  *    DESCRIPTION: Driver for DS1820 1-Wire Temperature sensor (Dallas) 
....................  * 
....................  ******************************************************************************/ 
....................  
.................... /*** HISTORY OF CHANGE ********************************************************* 
....................  * 
....................  *    $Log: /pic/_drv/ds1820.h $ 
....................  *  
....................  * 9     13.11.10 20:02 Stadler 
....................  * - changed interrupt lock and delay functions to #defines to remove 
....................  * function call overhead 
....................  *  
....................  * 8     6.11.10 10:24 Stadler 
....................  * - adjusted 1-wire timing 
....................  *  
....................  * 7     5.11.10 22:55 Stadler 
....................  * - changed driver API 
....................  *  
....................  * 6     5.11.10 21:59 Stadler 
....................  * - added DS18B20 support 
....................  * - fixed problem with ROM search algorithm 
....................  *  
....................  * 5     2.11.10 20:25 Stadler 
....................  * - changed function DS1820_FindFirstDev to DS1820_FindFirstDevice 
....................  * - changed function DS1820_FindNextDev to DS1820_FindNextDevice 
....................  * - updated code style 
....................  *  
....................  * 4     31.10.10 17:12 Stadler 
....................  * - introduced DS1820_DelayUs 
....................  *  
....................  * 3     25.10.10 13:09 Stadler 
....................  * - added interrupt lock 
....................  *  
....................  * 2     12.03.05 11:24 Stadler 
....................  * - added EEPROM write function 
....................  * - added "Search ROM Algorithm" to control multiple devices 
....................  * 
....................  * 1     26.02.05 18:18 Stadler 
....................  * Driver for DS1820 1-Wire Temperature sensor (Dallas) 
....................  * 
....................  ******************************************************************************/ 
....................  
.................... #ifndef _DS1820_H 
.................... #define _DS1820_H 
....................  
....................  
.................... /* check configuration of driver */ 
.................... #ifndef DS1820_DATAPIN 
.................... #error DS1820 data pin not defined! 
.................... #endif 
....................  
....................  
.................... #define TEMP_RES              0x100 /* temperature resolution => 1/256C = 0.0039C */ 
....................  
....................  
.................... /* -------------------------------------------------------------------------- */ 
.................... /*                         DS1820 Timing Parameters                           */ 
.................... /* -------------------------------------------------------------------------- */ 
....................  
.................... #define DS1820_RST_PULSE       480   /* master reset pulse time in [us] */ 
.................... #define DS1820_MSTR_BITSTART   2     /* delay time for bit start by master */ 
.................... #define DS1820_PRESENCE_WAIT   40    /* delay after master reset pulse in [us] */ 
.................... #define DS1820_PRESENCE_FIN    480   /* dealy after reading of presence pulse [us] */ 
.................... #define DS1820_BITREAD_DLY     5     /* bit read delay */ 
.................... #define DS1820_BITWRITE_DLY    100   /* bit write delay */ 
....................  
....................  
.................... /* -------------------------------------------------------------------------- */ 
.................... /*                            DS1820 Registers                                */ 
.................... /* -------------------------------------------------------------------------- */ 
....................  
.................... #define DS1820_REG_TEMPLSB    0 
.................... #define DS1820_REG_TEMPMSB    1 
.................... #define DS1820_REG_CNTREMAIN  6 
.................... #define DS1820_REG_CNTPERSEC  7 
.................... #define DS1820_SCRPADMEM_LEN  9     /* length of scratchpad memory */ 
....................  
.................... #define DS1820_ADDR_LEN       8 
....................  
....................  
.................... /* -------------------------------------------------------------------------- */ 
.................... /*                            DS1820 Commands                                 */ 
.................... /* -------------------------------------------------------------------------- */ 
....................  
.................... #define DS1820_CMD_SEARCHROM     0xF0 
.................... #define DS1820_CMD_READROM       0x33 
.................... #define DS1820_CMD_MATCHROM      0x55 
.................... #define DS1820_CMD_SKIPROM       0xCC 
.................... #define DS1820_CMD_ALARMSEARCH   0xEC 
.................... #define DS1820_CMD_CONVERTTEMP   0x44 
.................... #define DS1820_CMD_WRITESCRPAD   0x4E 
.................... #define DS1820_CMD_READSCRPAD    0xBE 
.................... #define DS1820_CMD_COPYSCRPAD    0x48 
.................... #define DS1820_CMD_RECALLEE      0xB8 
....................  
....................  
.................... #define DS1820_FAMILY_CODE_DS18B20      0x28 
.................... #define DS1820_FAMILY_CODE_DS18S20      0x10 
....................  
....................  
.................... /* -------------------------------------------------------------------------- */ 
.................... /*                            static variables                                */ 
.................... /* -------------------------------------------------------------------------- */ 
....................  
.................... static bool bDoneFlag; 
*
1B8A:  BCF    03.5
1B8B:  BCF    49.1
.................... static uint8 nLastDiscrepancy_u8; 
1B8C:  CLRF   73
.................... static uint8 nRomAddr_au8[DS1820_ADDR_LEN]; 
1B8D:  BSF    03.6
1B8E:  CLRF   10
1B8F:  CLRF   11
1B90:  CLRF   12
1B91:  CLRF   13
1B92:  CLRF   14
1B93:  CLRF   15
1B94:  CLRF   16
1B95:  CLRF   17
....................  
....................  
....................  
.................... /* -------------------------------------------------------------------------- */ 
.................... /*                           Low-Level Functions                              */ 
.................... /* -------------------------------------------------------------------------- */ 
....................  
....................  
.................... /******************************************************************************* 
....................  * FUNCTION:   DS1820_DelayUs 
....................  * PURPOSE:    Delay for the given number of micro seconds. 
....................  * 
....................  * INPUT:      dly_us      number of micro seconds to delay 
....................  * OUTPUT:     - 
....................  * RETURN:     - 
....................  ******************************************************************************/ 
.................... #define DS1820_DelayUs(dly_us)       delay_us(dly_us) 
....................  
....................  
.................... /******************************************************************************* 
....................  * FUNCTION:   DS1820_DelayMs 
....................  * PURPOSE:    Delay for the given number of milliseconds. 
....................  * 
....................  * INPUT:      dly_ms      number of milliseconds to delay 
....................  * OUTPUT:     - 
....................  * RETURN:     - 
....................  ******************************************************************************/ 
.................... #define DS1820_DelayMs(dly_ms)   delay_ms(dly_ms) 
....................  
....................  
.................... /******************************************************************************* 
....................  * FUNCTION:   DS1820_DisableInterrupts 
....................  * PURPOSE:    Disable interrupts 
....................  * 
....................  * INPUT:      - 
....................  * OUTPUT:     - 
....................  * RETURN:     - 
....................  ******************************************************************************/ 
.................... #ifdef DS1820_INTERRUPT_LOCK 
.................... #define DS1820_DisableInterrupts()  disable_interrupts(GLOBAL) 
.................... #else 
.................... #define DS1820_DisableInterrupts() 
.................... #endif 
....................  
....................  
....................  
.................... /******************************************************************************* 
....................  * FUNCTION:   DS1820_EnableInterrupts 
....................  * PURPOSE:    Enable interrupts 
....................  * 
....................  * INPUT:      - 
....................  * OUTPUT:     - 
....................  * RETURN:     - 
....................  ******************************************************************************/ 
.................... #ifdef DS1820_INTERRUPT_LOCK 
.................... #define DS1820_EnableInterrupts()   enable_interrupts(GLOBAL) 
.................... #else 
.................... #define DS1820_EnableInterrupts() 
.................... #endif 
....................  
....................  
.................... /******************************************************************************* 
....................  * FUNCTION:   DS1820_Reset 
....................  * PURPOSE:    Initializes the DS1820 device. 
....................  * 
....................  * INPUT:      - 
....................  * OUTPUT:     - 
....................  * RETURN:     FALSE if at least one device is on the 1-wire bus, TRUE otherwise 
....................  ******************************************************************************/ 
.................... bool DS1820_Reset(void) 
.................... { 
....................    bool bPresPulse; 
....................  
....................    DS1820_DisableInterrupts(); 
....................     
....................    /* reset pulse */ 
....................    output_low(DS1820_DATAPIN); 
*
0E9C:  BSF    03.5
0E9D:  BCF    05.0
0E9E:  BCF    03.5
0E9F:  BCF    05.0
....................    DS1820_DelayUs(DS1820_RST_PULSE); 
0EA0:  MOVLW  02
0EA1:  BSF    03.6
0EA2:  MOVWF  44
0EA3:  MOVLW  EF
0EA4:  MOVWF  45
0EA5:  BCF    03.6
0EA6:  CALL   68B
0EA7:  BSF    03.6
0EA8:  DECFSZ 44,F
0EA9:  GOTO   6A3
....................    output_high(DS1820_DATAPIN); 
0EAA:  BSF    03.5
0EAB:  BCF    03.6
0EAC:  BCF    05.0
0EAD:  BCF    03.5
0EAE:  BSF    05.0
....................  
....................    /* wait until pullup pull 1-wire bus to high */ 
....................    DS1820_DelayUs(DS1820_PRESENCE_WAIT); 
0EAF:  MOVLW  42
0EB0:  MOVWF  77
0EB1:  DECFSZ 77,F
0EB2:  GOTO   6B1
0EB3:  NOP
....................  
....................    /* get presence pulse */ 
....................    bPresPulse = input(DS1820_DATAPIN); 
0EB4:  BSF    03.5
0EB5:  BSF    05.0
0EB6:  BCF    03.5
0EB7:  BSF    03.6
0EB8:  BCF    43.0
0EB9:  BCF    03.6
0EBA:  BTFSS  05.0
0EBB:  GOTO   6BF
0EBC:  BSF    03.6
0EBD:  BSF    43.0
0EBE:  BCF    03.6
....................  
....................    DS1820_DelayUs(424); 
0EBF:  MOVLW  02
0EC0:  BSF    03.6
0EC1:  MOVWF  44
0EC2:  MOVLW  D3
0EC3:  MOVWF  45
0EC4:  BCF    03.6
0EC5:  CALL   68B
0EC6:  BSF    03.6
0EC7:  DECFSZ 44,F
0EC8:  GOTO   6C2
....................     
....................    DS1820_EnableInterrupts(); 
....................  
....................    return bPresPulse; 
0EC9:  MOVLW  00
0ECA:  BTFSC  43.0
0ECB:  MOVLW  01
0ECC:  MOVWF  78
0ECD:  BCF    03.6
0ECE:  RETURN
.................... } 
....................  
....................  
.................... /******************************************************************************* 
....................  * FUNCTION:   DS1820_ReadBit 
....................  * PURPOSE:    Reads a single bit from the DS1820 device. 
....................  * 
....................  * INPUT:      - 
....................  * OUTPUT:     - 
....................  * RETURN:     bool        value of the bit which as been read form the DS1820 
....................  ******************************************************************************/ 
.................... bool DS1820_ReadBit(void) 
.................... { 
....................    bool bBit; 
....................  
....................    DS1820_DisableInterrupts(); 
....................     
....................    output_low(DS1820_DATAPIN); 
*
0F0E:  BSF    03.5
0F0F:  BCF    05.0
0F10:  BCF    03.5
0F11:  BCF    05.0
....................    DS1820_DelayUs(DS1820_MSTR_BITSTART); 
0F12:  MOVLW  02
0F13:  MOVWF  77
0F14:  DECFSZ 77,F
0F15:  GOTO   714
0F16:  GOTO   717
0F17:  NOP
....................    input(DS1820_DATAPIN); 
0F18:  BSF    03.5
0F19:  BSF    05.0
....................    DS1820_DelayUs(DS1820_BITREAD_DLY); 
0F1A:  MOVLW  07
0F1B:  MOVWF  77
0F1C:  DECFSZ 77,F
0F1D:  GOTO   71C
0F1E:  GOTO   71F
0F1F:  NOP
....................  
....................    bBit = input(DS1820_DATAPIN); 
0F20:  BSF    05.0
0F21:  BCF    03.5
0F22:  BSF    03.6
0F23:  BCF    47.0
0F24:  BCF    03.6
0F25:  BTFSS  05.0
0F26:  GOTO   72A
0F27:  BSF    03.6
0F28:  BSF    47.0
0F29:  BCF    03.6
....................     
....................    DS1820_EnableInterrupts(); 
....................  
....................    return (bBit); 
0F2A:  MOVLW  00
0F2B:  BSF    03.6
0F2C:  BTFSC  47.0
0F2D:  MOVLW  01
0F2E:  MOVWF  78
0F2F:  BCF    03.6
0F30:  RETURN
.................... } 
....................  
....................  
.................... /******************************************************************************* 
....................  * FUNCTION:   DS1820_WriteBit 
....................  * PURPOSE:    Writes a single bit to the DS1820 device. 
....................  * 
....................  * INPUT:      bBit        value of bit to be written 
....................  * OUTPUT:     - 
....................  * RETURN:     - 
....................  ******************************************************************************/ 
.................... void DS1820_WriteBit(bool bBit) 
.................... { 
....................    DS1820_DisableInterrupts(); 
....................     
....................    output_low(DS1820_DATAPIN); 
*
0ECF:  BSF    03.5
0ED0:  BCF    05.0
0ED1:  BCF    03.5
0ED2:  BCF    05.0
....................    DS1820_DelayUs(DS1820_MSTR_BITSTART); 
0ED3:  MOVLW  02
0ED4:  MOVWF  77
0ED5:  DECFSZ 77,F
0ED6:  GOTO   6D5
0ED7:  GOTO   6D8
0ED8:  NOP
....................  
....................    if (bBit != FALSE) 
0ED9:  BSF    03.6
0EDA:  MOVF   49,F
0EDB:  BTFSC  03.2
0EDC:  GOTO   6E3
....................    { 
....................       output_high(DS1820_DATAPIN); 
0EDD:  BSF    03.5
0EDE:  BCF    03.6
0EDF:  BCF    05.0
0EE0:  BCF    03.5
0EE1:  BSF    05.0
0EE2:  BSF    03.6
....................    } 
....................  
....................    DS1820_DelayUs(DS1820_BITWRITE_DLY); 
0EE3:  MOVLW  A6
0EE4:  MOVWF  77
0EE5:  DECFSZ 77,F
0EE6:  GOTO   6E5
0EE7:  NOP
....................    output_high(DS1820_DATAPIN); 
0EE8:  BSF    03.5
0EE9:  BCF    03.6
0EEA:  BCF    05.0
0EEB:  BCF    03.5
0EEC:  BSF    05.0
....................     
....................    DS1820_EnableInterrupts(); 
0EED:  RETURN
.................... } 
....................  
....................  
.................... /******************************************************************************* 
....................  * FUNCTION:   DS1820_ReadByte 
....................  * PURPOSE:    Reads a single byte from the DS1820 device. 
....................  * 
....................  * INPUT:      - 
....................  * OUTPUT:     - 
....................  * RETURN:     uint8          byte which has been read from the DS1820 
....................  ******************************************************************************/ 
.................... uint8 DS1820_ReadByte(void) 
*
1462:  CLRF   46
.................... { 
....................    uint8 i; 
....................    uint8 value = 0; 
....................  
....................    for (i=0 ; i < 8; i++) 
1463:  CLRF   45
1464:  MOVF   45,W
1465:  SUBLW  07
1466:  BTFSS  03.0
1467:  GOTO   487
....................    { 
....................       if ( DS1820_ReadBit() ) 
1468:  BCF    0A.4
1469:  BSF    0A.3
146A:  BCF    03.6
146B:  CALL   70E
146C:  BSF    0A.4
146D:  BCF    0A.3
146E:  MOVF   78,F
146F:  BTFSC  03.2
1470:  GOTO   47F
....................       { 
....................          value |= (1 << i); 
1471:  MOVLW  01
1472:  MOVWF  77
1473:  BSF    03.6
1474:  MOVF   45,W
1475:  MOVWF  78
1476:  BTFSC  03.2
1477:  GOTO   47C
1478:  BCF    03.0
1479:  RLF    77,F
147A:  DECFSZ 78,F
147B:  GOTO   478
147C:  MOVF   77,W
147D:  IORWF  46,F
147E:  BCF    03.6
....................       } 
....................       DS1820_DelayUs(120); 
147F:  MOVLW  C7
1480:  MOVWF  77
1481:  DECFSZ 77,F
1482:  GOTO   481
1483:  GOTO   484
1484:  BSF    03.6
1485:  INCF   45,F
1486:  GOTO   464
....................    } 
....................    return(value); 
1487:  MOVF   46,W
1488:  MOVWF  78
.................... } 
....................  
....................  
.................... /******************************************************************************* 
....................  * FUNCTION:   DS1820_WriteByte 
....................  * PURPOSE:    Writes a single byte to the DS1820 device. 
....................  * 
....................  * INPUT:      val_u8         byte to be written 
....................  * OUTPUT:     - 
....................  * RETURN:     - 
....................  ******************************************************************************/ 
.................... void DS1820_WriteByte(uint8 val_u8) 
.................... { 
....................    uint8 i; 
....................    uint8 temp; 
....................  
....................    for (i=0; i < 8; i++)      /* writes byte, one bit at a time */ 
*
0EEE:  BSF    03.6
0EEF:  CLRF   47
0EF0:  MOVF   47,W
0EF1:  SUBLW  07
0EF2:  BTFSS  03.0
0EF3:  GOTO   707
....................    { 
....................       temp = val_u8 >> i;     /* shifts val right 'i' spaces */ 
0EF4:  MOVF   46,W
0EF5:  MOVWF  48
0EF6:  MOVF   47,W
0EF7:  MOVWF  78
0EF8:  BTFSC  03.2
0EF9:  GOTO   6FE
0EFA:  BCF    03.0
0EFB:  RRF    48,F
0EFC:  DECFSZ 78,F
0EFD:  GOTO   6FA
....................       temp &= 0x01;           /* copy that bit to temp */ 
0EFE:  MOVLW  01
0EFF:  ANDWF  48,F
....................       DS1820_WriteBit(temp);  /* write bit in temp into */ 
0F00:  MOVF   48,W
0F01:  MOVWF  49
0F02:  BCF    03.6
0F03:  CALL   6CF
0F04:  BSF    03.6
0F05:  INCF   47,F
0F06:  GOTO   6F0
....................    } 
....................  
....................    DS1820_DelayUs(105); 
0F07:  MOVLW  AE
0F08:  MOVWF  77
0F09:  DECFSZ 77,F
0F0A:  GOTO   709
0F0B:  GOTO   70C
0F0C:  BCF    03.6
0F0D:  RETURN
.................... } 
....................  
....................  
....................  
.................... /* -------------------------------------------------------------------------- */ 
.................... /*                             API Interface                                  */ 
.................... /* -------------------------------------------------------------------------- */ 
....................  
....................  
.................... /******************************************************************************* 
....................  * FUNCTION:   DS1820_AddrDevice 
....................  * PURPOSE:    Addresses a single or all devices on the 1-wire bus. 
....................  * 
....................  * INPUT:      nAddrMethod       use DS1820_CMD_MATCHROM to select a single 
....................  *                               device or DS1820_CMD_SKIPROM to select all 
....................  * OUTPUT:     - 
....................  * RETURN:     - 
....................  ******************************************************************************/ 
.................... void DS1820_AddrDevice(uint8 nAddrMethod) 
.................... { 
....................    uint8 i; 
....................     
....................    if (nAddrMethod == DS1820_CMD_MATCHROM) 
*
0FDA:  BSF    03.6
0FDB:  MOVF   43,W
0FDC:  SUBLW  55
0FDD:  BTFSS  03.2
0FDE:  GOTO   7F6
....................    { 
....................       DS1820_WriteByte(DS1820_CMD_MATCHROM);     /* address single devices on bus */ 
0FDF:  MOVLW  55
0FE0:  MOVWF  46
0FE1:  BCF    03.6
0FE2:  CALL   6EE
....................       for (i = 0; i < DS1820_ADDR_LEN; i ++) 
0FE3:  BSF    03.6
0FE4:  CLRF   44
0FE5:  MOVF   44,W
0FE6:  SUBLW  07
0FE7:  BTFSS  03.0
0FE8:  GOTO   7F5
....................       { 
....................          DS1820_WriteByte(nRomAddr_au8[i]); 
0FE9:  MOVLW  10
0FEA:  ADDWF  44,W
0FEB:  MOVWF  04
0FEC:  BSF    03.7
0FED:  MOVF   00,W
0FEE:  MOVWF  45
0FEF:  MOVWF  46
0FF0:  BCF    03.6
0FF1:  CALL   6EE
0FF2:  BSF    03.6
0FF3:  INCF   44,F
0FF4:  GOTO   7E5
....................       } 
....................    } 
0FF5:  GOTO   7FB
....................    else 
....................    { 
....................       DS1820_WriteByte(DS1820_CMD_SKIPROM);     /* address all devices on bus */ 
0FF6:  MOVLW  CC
0FF7:  MOVWF  46
0FF8:  BCF    03.6
0FF9:  CALL   6EE
0FFA:  BSF    03.6
....................    } 
0FFB:  BCF    03.6
0FFC:  RETURN
.................... } 
....................  
....................  
.................... /******************************************************************************* 
....................  * FUNCTION:   DS1820_FindNextDevice 
....................  * PURPOSE:    Finds next device connected to the 1-wire bus. 
....................  * 
....................  * INPUT:      - 
....................  * OUTPUT:     nRomAddr_au8[]       ROM code of the next device 
....................  * RETURN:     bool                 TRUE if there are more devices on the 1-wire 
....................  *                                  bus, FALSE otherwise 
....................  ******************************************************************************/ 
.................... bool DS1820_FindNextDevice(void) 
*
0F31:  MOVLW  01
0F32:  BSF    03.6
0F33:  MOVWF  37
0F34:  MOVWF  38
0F35:  CLRF   39
0F36:  BCF    3A.2
.................... { 
....................     uint8 state_u8; 
....................     uint8 byteidx_u8; 
....................     uint8 mask_u8 = 1; 
....................     uint8 bitpos_u8 = 1; 
....................     uint8 nDiscrepancyMarker_u8 = 0; 
....................     bool bit_b; 
....................     bool bStatus; 
....................     bool next_b = FALSE; 
....................  
....................     /* init ROM address */ 
....................     for (byteidx_u8=0; byteidx_u8 < 8; byteidx_u8 ++) 
0F37:  CLRF   36
0F38:  MOVF   36,W
0F39:  SUBLW  07
0F3A:  BTFSS  03.0
0F3B:  GOTO   743
....................     { 
....................         nRomAddr_au8[byteidx_u8] = 0x00; 
0F3C:  MOVLW  10
0F3D:  ADDWF  36,W
0F3E:  MOVWF  04
0F3F:  BSF    03.7
0F40:  CLRF   00
0F41:  INCF   36,F
0F42:  GOTO   738
....................     } 
....................  
....................     bStatus = DS1820_Reset();        /* reset the 1-wire */ 
0F43:  BCF    03.6
0F44:  CALL   69C
0F45:  BSF    03.6
0F46:  BCF    3A.1
0F47:  BTFSC  78.0
0F48:  BSF    3A.1
....................  
....................     if (bStatus || bDoneFlag)        /* no device found */ 
0F49:  BTFSC  3A.1
0F4A:  GOTO   74F
0F4B:  BCF    03.6
0F4C:  BTFSS  49.1
0F4D:  GOTO   754
0F4E:  BSF    03.6
....................     { 
....................         nLastDiscrepancy_u8 = 0;     /* reset the search */ 
0F4F:  CLRF   73
....................         return FALSE; 
0F50:  MOVLW  00
0F51:  MOVWF  78
0F52:  GOTO   7D8
0F53:  BCF    03.6
....................     } 
....................  
....................     /* send search rom command */ 
....................     DS1820_WriteByte(DS1820_CMD_SEARCHROM); 
0F54:  MOVLW  F0
0F55:  BSF    03.6
0F56:  MOVWF  46
0F57:  BCF    03.6
0F58:  CALL   6EE
....................  
....................     byteidx_u8 = 0; 
0F59:  BSF    03.6
0F5A:  CLRF   36
....................     do 
....................     { 
....................         state_u8 = 0; 
0F5B:  CLRF   35
....................  
....................         /* read bit */ 
....................         if ( DS1820_ReadBit() != 0 ) 
0F5C:  BCF    03.6
0F5D:  CALL   70E
0F5E:  MOVF   78,F
0F5F:  BTFSC  03.2
0F60:  GOTO   765
....................         { 
....................             state_u8 = 2; 
0F61:  MOVLW  02
0F62:  BSF    03.6
0F63:  MOVWF  35
0F64:  BCF    03.6
....................         } 
....................         DS1820_DelayUs(120); 
0F65:  MOVLW  C7
0F66:  MOVWF  77
0F67:  DECFSZ 77,F
0F68:  GOTO   767
0F69:  GOTO   76A
....................  
....................         /* read bit complement */ 
....................         if ( DS1820_ReadBit() != 0 ) 
0F6A:  CALL   70E
0F6B:  MOVF   78,F
0F6C:  BTFSC  03.2
0F6D:  GOTO   771
....................         { 
....................             state_u8 |= 1; 
0F6E:  BSF    03.6
0F6F:  BSF    35.0
0F70:  BCF    03.6
....................         } 
....................         DS1820_DelayUs(120); 
0F71:  MOVLW  C7
0F72:  MOVWF  77
0F73:  DECFSZ 77,F
0F74:  GOTO   773
0F75:  GOTO   776
....................  
....................         /* description for values of state_u8: */ 
....................         /* 00    There are devices connected to the bus which have conflicting */ 
....................         /*       bits in the current ROM code bit position. */ 
....................         /* 01    All devices connected to the bus have a 0 in this bit position. */ 
....................         /* 10    All devices connected to the bus have a 1 in this bit position. */ 
....................         /* 11    There are no devices connected to the 1-wire bus. */ 
....................  
....................         /* if there are no devices on the bus */ 
....................         if (state_u8 == 3) 
0F76:  BSF    03.6
0F77:  MOVF   35,W
0F78:  SUBLW  03
0F79:  BTFSS  03.2
0F7A:  GOTO   77D
....................         { 
....................             break; 
0F7B:  GOTO   7C5
....................         } 
0F7C:  GOTO   7C1
....................         else 
....................         { 
....................             /* devices have the same logical value at this position */ 
....................             if (state_u8 > 0) 
0F7D:  MOVF   35,F
0F7E:  BTFSC  03.2
0F7F:  GOTO   787
....................             { 
....................                 /* get bit value */ 
....................                 bit_b = (bool)(state_u8 >> 1); 
0F80:  BCF    3A.0
0F81:  BCF    03.0
0F82:  RRF    35,W
0F83:  MOVWF  78
0F84:  BTFSC  78.0
0F85:  BSF    3A.0
....................             } 
0F86:  GOTO   79E
....................             /* devices have confilcting bits in the current ROM code */ 
....................             else 
....................             { 
....................                 /* if there was a conflict on the last iteration */ 
....................                 if (bitpos_u8 < nLastDiscrepancy_u8) 
0F87:  MOVF   73,W
0F88:  SUBWF  38,W
0F89:  BTFSC  03.0
0F8A:  GOTO   795
....................                 { 
....................                     /* take same bit as in last iteration */ 
....................                     bit_b = ( (nRomAddr_au8[byteidx_u8] & mask_u8) > 0 ); 
0F8B:  BCF    3A.0
0F8C:  MOVLW  10
0F8D:  ADDWF  36,W
0F8E:  MOVWF  04
0F8F:  BSF    03.7
0F90:  MOVF   00,W
0F91:  ANDWF  37,W
0F92:  BTFSS  03.2
0F93:  BSF    3A.0
....................                 } 
0F94:  GOTO   79A
....................                 else 
....................                 { 
....................                     bit_b = (bitpos_u8 == nLastDiscrepancy_u8); 
0F95:  BCF    3A.0
0F96:  MOVF   73,W
0F97:  SUBWF  38,W
0F98:  BTFSC  03.2
0F99:  BSF    3A.0
....................                 } 
....................  
....................                 if (bit_b == 0) 
0F9A:  BTFSC  3A.0
0F9B:  GOTO   79E
....................                 { 
....................                     nDiscrepancyMarker_u8 = bitpos_u8; 
0F9C:  MOVF   38,W
0F9D:  MOVWF  39
....................                 } 
....................             } 
....................  
....................             /* store bit in ROM address */ 
....................            if (bit_b != 0) 
0F9E:  BTFSS  3A.0
0F9F:  GOTO   7A8
....................            { 
....................                nRomAddr_au8[byteidx_u8] |= mask_u8; 
0FA0:  MOVLW  10
0FA1:  ADDWF  36,W
0FA2:  MOVWF  04
0FA3:  BSF    03.7
0FA4:  MOVF   00,W
0FA5:  IORWF  37,W
0FA6:  MOVWF  00
....................            } 
0FA7:  GOTO   7B0
....................            else 
....................            { 
....................                nRomAddr_au8[byteidx_u8] &= ~mask_u8; 
0FA8:  MOVLW  10
0FA9:  ADDWF  36,W
0FAA:  MOVWF  04
0FAB:  BSF    03.7
0FAC:  MOVF   37,W
0FAD:  XORLW  FF
0FAE:  ANDWF  00,W
0FAF:  MOVWF  00
....................            } 
....................  
....................            DS1820_WriteBit(bit_b); 
0FB0:  MOVLW  00
0FB1:  BTFSC  3A.0
0FB2:  MOVLW  01
0FB3:  MOVWF  3B
0FB4:  MOVWF  49
0FB5:  BCF    03.6
0FB6:  CALL   6CF
....................  
....................            /* increment bit position */ 
....................            bitpos_u8 ++; 
0FB7:  BSF    03.6
0FB8:  INCF   38,F
....................  
....................            /* calculate next mask value */ 
....................            mask_u8 = mask_u8 << 1; 
0FB9:  BCF    03.0
0FBA:  RLF    37,F
....................  
....................            /* check if this byte has finished */ 
....................            if (mask_u8 == 0) 
0FBB:  MOVF   37,F
0FBC:  BTFSS  03.2
0FBD:  GOTO   7C1
....................            { 
....................                byteidx_u8 ++;  /* advance to next byte of ROM mask */ 
0FBE:  INCF   36,F
....................                mask_u8 = 1;    /* update mask */ 
0FBF:  MOVLW  01
0FC0:  MOVWF  37
....................            } 
....................         } 
....................     } while (byteidx_u8 < DS1820_ADDR_LEN); 
0FC1:  MOVF   36,W
0FC2:  SUBLW  07
0FC3:  BTFSC  03.0
0FC4:  GOTO   75B
....................  
....................  
....................     /* if search was unsuccessful then */ 
....................     if (bitpos_u8 < 65) 
0FC5:  MOVF   38,W
0FC6:  SUBLW  40
0FC7:  BTFSS  03.0
0FC8:  GOTO   7CB
....................     { 
....................         /* reset the last discrepancy to 0 */ 
....................         nLastDiscrepancy_u8 = 0; 
0FC9:  CLRF   73
....................     } 
0FCA:  GOTO   7D4
....................     else 
....................     { 
....................         /* search was successful */ 
....................         nLastDiscrepancy_u8 = nDiscrepancyMarker_u8; 
0FCB:  MOVF   39,W
0FCC:  MOVWF  73
....................         bDoneFlag = (nLastDiscrepancy_u8 == 0); 
0FCD:  BCF    03.6
0FCE:  BCF    49.1
0FCF:  MOVF   73,F
0FD0:  BTFSC  03.2
0FD1:  BSF    49.1
....................  
....................         /* indicates search is not complete yet, more parts remain */ 
....................         next_b = TRUE; 
0FD2:  BSF    03.6
0FD3:  BSF    3A.2
....................     } 
....................  
....................     return next_b; 
0FD4:  MOVLW  00
0FD5:  BTFSC  3A.2
0FD6:  MOVLW  01
0FD7:  MOVWF  78
0FD8:  BCF    03.6
0FD9:  RETURN
.................... } 
....................  
....................  
.................... /******************************************************************************* 
....................  * FUNCTION:   DS1820_FindFirstDevice 
....................  * PURPOSE:    Starts the device search on the 1-wire bus. 
....................  * 
....................  * INPUT:      - 
....................  * OUTPUT:     nRomAddr_au8[]       ROM code of the first device 
....................  * RETURN:     bool                 TRUE if there are more devices on the 1-wire 
....................  *                                  bus, FALSE otherwise 
....................  ******************************************************************************/ 
.................... bool DS1820_FindFirstDevice(void) 
.................... { 
....................     nLastDiscrepancy_u8 = 0; 
*
13F0:  CLRF   73
....................     bDoneFlag = FALSE; 
13F1:  BCF    03.6
13F2:  BCF    49.1
....................  
....................     return ( DS1820_FindNextDevice() ); 
13F3:  BCF    0A.4
13F4:  BSF    0A.3
13F5:  CALL   731
13F6:  BSF    0A.4
13F7:  BCF    0A.3
13F8:  MOVF   78,W
.................... } 
....................  
....................  
.................... /******************************************************************************* 
....................  * FUNCTION:   DS1820_WriteEEPROM 
....................  * PURPOSE:    Writes to the DS1820 EEPROM memory (2 bytes available). 
....................  * 
....................  * INPUT:      nTHigh         high byte of EEPROM 
....................  *             nTLow          low byte of EEPROM 
....................  * OUTPUT:     - 
....................  * RETURN:     - 
....................  ******************************************************************************/ 
....................  /* HOANG BO NO DI 
.................... void DS1820_WriteEEPROM(uint8 nTHigh, uint8 nTLow) 
.................... { 
....................     // --- write to scratchpad -----------------------------------------------  
....................     DS1820_Reset(); 
....................     DS1820_AddrDevice(DS1820_CMD_MATCHROM); 
....................     DS1820_WriteByte(DS1820_CMD_WRITESCRPAD); // start conversion / 
....................     DS1820_WriteByte(nTHigh); 
....................     DS1820_WriteByte(nTLow); 
....................  
....................     DS1820_DelayUs(10); 
....................  
....................     DS1820_Reset(); 
....................     DS1820_AddrDevice(DS1820_CMD_MATCHROM); 
....................     DS1820_WriteByte(DS1820_CMD_COPYSCRPAD); // start conversion / 
....................  
....................     delay_ms(10); 
.................... } 
.................... */ 
....................  
.................... /******************************************************************************* 
....................  * FUNCTION:   DS1820_GetTempRaw 
....................  * PURPOSE:    Get temperature raw value from single DS1820 device. 
....................  * 
....................  *             Scratchpad Memory Layout 
....................  *             Byte  Register 
....................  *             0     Temperature_LSB 
....................  *             1     Temperature_MSB 
....................  *             2     Temp Alarm High / User Byte 1 
....................  *             3     Temp Alarm Low / User Byte 2 
....................  *             4     Reserved 
....................  *             5     Reserved 
....................  *             6     Count_Remain 
....................  *             7     Count_per_C 
....................  *             8     CRC 
....................  * 
....................  *             Temperature calculation for DS18S20 (Family Code 0x10): 
....................  *             ======================================================= 
....................  *                                             (Count_per_C - Count_Remain) 
....................  *             Temperature = temp_raw - 0.25 + ---------------------------- 
....................  *                                                     Count_per_C 
....................  * 
....................  *             Where temp_raw is the value from the temp_MSB and temp_LSB with 
....................  *             the least significant bit removed (the 0.5C bit). 
....................  * 
....................  * 
....................  *             Temperature calculation for DS18B20 (Family Code 0x28): 
....................  *             ======================================================= 
....................  *                      bit7   bit6   bit5   bit4   bit3   bit2   bit1   bit0 
....................  *             LSB      2^3    2^2    2^1    2^0    2^-1   2^-2   2^-3   2^-4 
....................  *                      bit15  bit14  bit13  bit12  bit3   bit2   bit1   bit0 
....................  *             MSB      S      S      S      S      S      2^6    2^5    2^4 
....................  * 
....................  *             The temperature data is stored as a 16-bit sign-extended twos 
....................  *             complement number in the temperature register. The sign bits (S) 
....................  *             indicate if the temperature is positive or negative: for 
....................  *             positive numbers S = 0 and for negative numbers S = 1. 
....................  * 
....................  * RETURN:     sint16         raw temperature value with a resolution 
....................  *                            of 1/256C 
....................  ******************************************************************************/ 
....................   
.................... sint16 DS1820_GetTempRaw(void) 
.................... { 
....................     uint8 i; 
....................     uint16 temp_u16; 
....................     uint16 highres_u16; 
....................     uint8 scrpad[DS1820_SCRPADMEM_LEN]; 
....................  
....................     /* --- start temperature conversion -------------------------------------- */ 
....................     DS1820_Reset(); 
*
1411:  BCF    0A.4
1412:  BSF    0A.3
1413:  BCF    03.6
1414:  CALL   69C
1415:  BSF    0A.4
1416:  BCF    0A.3
....................     DS1820_AddrDevice(DS1820_CMD_MATCHROM);     /* address the device */ 
1417:  MOVLW  55
1418:  BSF    03.6
1419:  MOVWF  43
141A:  BCF    0A.4
141B:  BSF    0A.3
141C:  BCF    03.6
141D:  CALL   7DA
141E:  BSF    0A.4
141F:  BCF    0A.3
....................     output_high(DS1820_DATAPIN); 
1420:  BSF    03.5
1421:  BCF    05.0
1422:  BCF    03.5
1423:  BSF    05.0
....................     DS1820_WriteByte(DS1820_CMD_CONVERTTEMP);   /* start conversion */ 
1424:  MOVLW  44
1425:  BSF    03.6
1426:  MOVWF  46
1427:  BCF    0A.4
1428:  BSF    0A.3
1429:  BCF    03.6
142A:  CALL   6EE
142B:  BSF    0A.4
142C:  BCF    0A.3
....................     //DS1820_DelayMs(DS1820_TEMPCONVERT_DLY);   /* wait for temperature conversion */ 
....................     DS1820_DelayMs(750); 
142D:  MOVLW  03
142E:  BSF    03.6
142F:  MOVWF  43
1430:  MOVLW  FA
1431:  MOVWF  62
1432:  BCF    0A.4
1433:  BCF    03.6
1434:  CALL   17A
1435:  BSF    0A.4
1436:  BSF    03.6
1437:  DECFSZ 43,F
1438:  GOTO   430
....................  
....................  
....................     /* --- read sratchpad ---------------------------------------------------- */ 
....................     DS1820_Reset(); 
1439:  BCF    0A.4
143A:  BSF    0A.3
143B:  BCF    03.6
143C:  CALL   69C
143D:  BSF    0A.4
143E:  BCF    0A.3
....................     DS1820_AddrDevice(DS1820_CMD_MATCHROM);   /* address the device */ 
143F:  MOVLW  55
1440:  BSF    03.6
1441:  MOVWF  43
1442:  BCF    0A.4
1443:  BSF    0A.3
1444:  BCF    03.6
1445:  CALL   7DA
1446:  BSF    0A.4
1447:  BCF    0A.3
....................     DS1820_WriteByte(DS1820_CMD_READSCRPAD);  /* read scratch pad */ 
1448:  MOVLW  BE
1449:  BSF    03.6
144A:  MOVWF  46
144B:  BCF    0A.4
144C:  BSF    0A.3
144D:  BCF    03.6
144E:  CALL   6EE
144F:  BSF    0A.4
1450:  BCF    0A.3
....................  
....................     /* read scratch pad data */ 
....................     for (i=0; i < DS1820_SCRPADMEM_LEN; i++) 
1451:  BSF    03.6
1452:  CLRF   35
1453:  MOVF   35,W
1454:  SUBLW  08
1455:  BTFSS  03.0
1456:  GOTO   492
....................     { 
....................         scrpad[i] = DS1820_ReadByte(); 
1457:  MOVLW  3A
1458:  ADDWF  35,W
1459:  MOVWF  78
145A:  MOVLW  01
145B:  MOVWF  7A
145C:  BTFSC  03.0
145D:  INCF   7A,F
145E:  MOVF   78,W
145F:  MOVWF  43
1460:  MOVF   7A,W
1461:  MOVWF  44
*
1489:  MOVF   43,W
148A:  MOVWF  04
148B:  BCF    03.7
148C:  BTFSC  44.0
148D:  BSF    03.7
148E:  MOVF   78,W
148F:  MOVWF  00
1490:  INCF   35,F
1491:  GOTO   453
....................     } 
....................  
....................  
....................     /* --- calculate temperature --------------------------------------------- */ 
....................     /* Formular for temperature calculation: */ 
....................     /* Temp = Temp_read - 0.25 + ((Count_per_C - Count_Remain)/Count_per_C) */ 
....................  
....................     /* get raw value of temperature (0.5C resolution) */ 
....................     temp_u16 = 0; 
1492:  CLRF   37
1493:  CLRF   36
....................     temp_u16 = (uint16)((uint16)scrpad[DS1820_REG_TEMPMSB] << 8); 
1494:  CLRF   44
1495:  MOVF   3B,W
1496:  MOVWF  37
1497:  CLRF   36
....................     temp_u16 |= (uint16)(scrpad[DS1820_REG_TEMPLSB]); 
1498:  CLRF   7A
1499:  MOVF   3A,W
149A:  IORWF  36,F
149B:  MOVF   7A,W
149C:  IORWF  37,F
....................  
....................     if (nRomAddr_au8[0] == DS1820_FAMILY_CODE_DS18S20) 
149D:  MOVF   10,W
149E:  SUBLW  10
149F:  BTFSS  03.2
14A0:  GOTO   4F3
....................     { 
....................         /* get temperature value in 1C resolution */ 
....................         temp_u16 >>= 1; 
14A1:  BCF    03.0
14A2:  RRF    37,F
14A3:  RRF    36,F
....................      
....................         /* temperature resolution is TEMP_RES (0x100), so 1C equals 0x100 */ 
....................         /* => convert to temperature to 1/256C resolution */ 
....................         temp_u16 = ((uint16)temp_u16 << 8); 
14A4:  MOVF   36,W
14A5:  MOVWF  37
14A6:  CLRF   36
....................      
....................         /* now substract 0.25C */ 
....................         temp_u16 -= ((uint16)TEMP_RES >> 2); 
14A7:  MOVLW  40
14A8:  SUBWF  36,F
14A9:  MOVLW  00
14AA:  BTFSS  03.0
14AB:  MOVLW  01
14AC:  SUBWF  37,F
....................      
....................         /* now calculate high resolution */ 
....................         highres_u16 = scrpad[DS1820_REG_CNTPERSEC] - scrpad[DS1820_REG_CNTREMAIN]; 
14AD:  MOVF   40,W
14AE:  SUBWF  41,W
14AF:  MOVWF  38
14B0:  CLRF   39
....................         highres_u16 = ((uint16)highres_u16 << 8); 
14B1:  MOVF   38,W
14B2:  MOVWF  39
14B3:  CLRF   38
....................         if (scrpad[DS1820_REG_CNTPERSEC]) 
14B4:  MOVF   41,F
14B5:  BTFSC  03.2
14B6:  GOTO   4EC
....................         { 
....................             highres_u16 = highres_u16 / (uint16)scrpad[DS1820_REG_CNTPERSEC]; 
14B7:  CLRF   7A
14B8:  MOVF   41,W
14B9:  MOVWF  43
14BA:  MOVF   7A,W
14BB:  MOVWF  44
14BC:  MOVF   39,W
14BD:  MOVWF  46
14BE:  MOVF   38,W
14BF:  MOVWF  45
14C0:  MOVF   44,W
14C1:  MOVWF  48
14C2:  MOVF   43,W
14C3:  MOVWF  47
*
14E8:  MOVF   79,W
14E9:  MOVWF  39
14EA:  MOVF   78,W
14EB:  MOVWF  38
....................         } 
....................      
....................         /* now calculate result */ 
....................         highres_u16 = highres_u16 + temp_u16; 
14EC:  MOVF   36,W
14ED:  ADDWF  38,F
14EE:  MOVF   37,W
14EF:  BTFSC  03.0
14F0:  INCFSZ 37,W
14F1:  ADDWF  39,F
....................     } 
14F2:  GOTO   501
....................     else 
....................     { 
....................         /* 12 bit temperature value has 0.0625C resolution */ 
....................         /* shift left by 4 to get 1/256C resolution */ 
....................         highres_u16 = temp_u16; 
14F3:  MOVF   37,W
14F4:  MOVWF  39
14F5:  MOVF   36,W
14F6:  MOVWF  38
....................         highres_u16 <<= 4; 
14F7:  RLF    38,F
14F8:  RLF    39,F
14F9:  RLF    38,F
14FA:  RLF    39,F
14FB:  RLF    38,F
14FC:  RLF    39,F
14FD:  RLF    38,F
14FE:  RLF    39,F
14FF:  MOVLW  F0
1500:  ANDWF  38,F
....................     } 
....................  
....................     return (highres_u16); 
1501:  MOVF   38,W
1502:  MOVWF  78
1503:  MOVF   39,W
1504:  MOVWF  79
.................... } 
....................  
....................  
.................... /******************************************************************************* 
....................  * FUNCTION:   DS1820_GetTempFloat 
....................  * PURPOSE:    Converts internal temperature value to string (physical value). 
....................  * 
....................  * INPUT:      none 
....................  * OUTPUT:     none 
....................  * RETURN:     float          temperature value with as float value 
....................  ******************************************************************************/ 
.................... float DS1820_GetTempFloat(void) 
.................... { 
....................     return ((float)DS1820_GetTempRaw() / (float)TEMP_RES); 
1505:  MOVF   79,W
1506:  MOVWF  36
1507:  MOVF   78,W
1508:  MOVWF  35
*
152D:  MOVF   7A,W
152E:  MOVWF  38
152F:  MOVF   79,W
1530:  MOVWF  37
1531:  MOVF   78,W
1532:  MOVWF  36
1533:  MOVF   77,W
1534:  MOVWF  35
1535:  MOVF   38,W
1536:  MOVWF  3C
1537:  MOVF   37,W
1538:  MOVWF  3B
1539:  MOVF   36,W
153A:  MOVWF  3A
153B:  MOVF   35,W
153C:  MOVWF  39
153D:  CLRF   40
153E:  CLRF   3F
153F:  CLRF   3E
1540:  MOVLW  87
1541:  MOVWF  3D
.................... } 
....................  
....................  
.................... /******************************************************************************* 
....................  * FUNCTION:   DS1820_GetTempString 
....................  * PURPOSE:    Converts internal temperature value to string (physical value). 
....................  * 
....................  * INPUT:      tRaw_s16       internal temperature value 
....................  * OUTPUT:     strTemp_pc     user string buffer to write temperature value 
....................  * RETURN:     sint16         temperature value with an internal resolution 
....................  *                            of TEMP_RES 
....................  ******************************************************************************/ 
....................  
....................  
.................... #endif /* _DS1820_H */ 
....................  
....................  
....................  
....................  
....................  
.................... float KET_QUA_ANALOG[]={0,0,0,0,0}; 
*
1B96:  CLRF   18
1B97:  CLRF   19
1B98:  CLRF   1A
1B99:  CLRF   1B
1B9A:  CLRF   1C
1B9B:  CLRF   1D
1B9C:  CLRF   1E
1B9D:  CLRF   1F
1B9E:  CLRF   20
1B9F:  CLRF   21
1BA0:  CLRF   22
1BA1:  CLRF   23
1BA2:  CLRF   24
1BA3:  CLRF   25
1BA4:  CLRF   26
1BA5:  CLRF   27
1BA6:  CLRF   28
1BA7:  CLRF   29
1BA8:  CLRF   2A
1BA9:  CLRF   2B
....................  
....................  
.................... //int16 temperature_raw; /*Du lieu nhiet do (resolution 1 / 256C) */ 
.................... float temperature_float; /* Gia tri nhiet do do duoc */ 
.................... //char temperature[8];  /* Mang luu gia tri nhiet do*/ 
.................... unsigned int8 sensor_count = 0; 
.................... float KET_QUA_ANALOG_TEMP=0; 
....................  
....................  
....................  
....................  
....................  VOID READ_ANALOG () 
*
13EB:  BSF    03.6
13EC:  CLRF   34
13ED:  CLRF   33
13EE:  CLRF   32
13EF:  CLRF   31
....................  { 
....................    /* 
....................    FOR (INT I =0; I<5; I++){ 
....................    KET_QUA_ANALOG[I]=0; 
....................    } 
....................    */ 
....................    float CHENH_LECH = 0; 
....................    if ( DS1820_FindFirstDevice() ){ 
*
13F9:  MOVF   78,F
13FA:  BTFSC  03.2
13FB:  GOTO   6E0
....................       do 
....................       {                
....................          KET_QUA_ANALOG_TEMP = KET_QUA_ANALOG[sensor_count]; 
13FC:  RLF    74,W
13FD:  MOVWF  77
13FE:  RLF    77,F
13FF:  MOVLW  FC
1400:  ANDWF  77,F
1401:  MOVF   77,W
1402:  ADDLW  18
1403:  MOVWF  04
1404:  BSF    03.7
1405:  MOVF   00,W
1406:  BSF    03.6
1407:  MOVWF  2C
1408:  INCF   04,F
1409:  MOVF   00,W
140A:  MOVWF  2D
140B:  INCF   04,F
140C:  MOVF   00,W
140D:  MOVWF  2E
140E:  INCF   04,F
140F:  MOVF   00,W
1410:  MOVWF  2F
....................          //temperature_raw = DS1820_GetTempRaw(); 
....................          //DS1820_GetTempString(temperature_raw, temperature); 
....................          temperature_float = DS1820_GetTempFloat(); 
*
160B:  MOVF   7A,W
160C:  MOVWF  7E
160D:  MOVF   79,W
160E:  MOVWF  7D
160F:  MOVF   78,W
1610:  MOVWF  7C
1611:  MOVF   77,W
1612:  MOVWF  7B
....................          //fprintf(UART, "Sensor %d: %fC \n\r", sensor_count, temperature_float);     
....................  
....................          KET_QUA_ANALOG[sensor_count] = temperature_float  ; 
1613:  RLF    74,W
1614:  MOVWF  77
1615:  RLF    77,F
1616:  MOVLW  FC
1617:  ANDWF  77,F
1618:  MOVF   77,W
1619:  ADDLW  18
161A:  MOVWF  04
161B:  BSF    03.7
161C:  MOVF   7B,W
161D:  MOVWF  00
161E:  INCF   04,F
161F:  MOVF   7C,W
1620:  MOVWF  00
1621:  INCF   04,F
1622:  MOVF   7D,W
1623:  MOVWF  00
1624:  INCF   04,F
1625:  MOVF   7E,W
1626:  MOVWF  00
....................  
....................          CHENH_LECH = ABS( KET_QUA_ANALOG[sensor_count] -KET_QUA_ANALOG_TEMP );                   
1627:  RLF    74,W
1628:  MOVWF  77
1629:  RLF    77,F
162A:  MOVLW  FC
162B:  ANDWF  77,F
162C:  MOVF   77,W
162D:  ADDLW  18
162E:  MOVWF  04
162F:  BSF    03.7
1630:  MOVF   00,W
1631:  MOVWF  35
1632:  INCF   04,F
1633:  MOVF   00,W
1634:  MOVWF  36
1635:  INCF   04,F
1636:  MOVF   00,W
1637:  MOVWF  37
1638:  INCF   04,F
1639:  MOVF   00,W
163A:  MOVWF  38
163B:  CLRF   3A
163C:  MOVF   04,W
163D:  MOVWF  39
163E:  BCF    3A.0
163F:  BTFSC  03.7
1640:  BSF    3A.0
1641:  BSF    03.1
1642:  MOVF   38,W
1643:  BSF    03.5
1644:  MOVWF  1B
1645:  BCF    03.5
1646:  MOVF   37,W
1647:  BSF    03.5
1648:  MOVWF  1A
1649:  BCF    03.5
164A:  MOVF   36,W
164B:  BSF    03.5
164C:  MOVWF  19
164D:  BCF    03.5
164E:  MOVF   35,W
164F:  BSF    03.5
1650:  MOVWF  18
1651:  BCF    03.5
1652:  MOVF   2F,W
1653:  BSF    03.5
1654:  MOVWF  1F
1655:  BCF    03.5
1656:  MOVF   2E,W
1657:  BSF    03.5
1658:  MOVWF  1E
1659:  BCF    03.5
165A:  MOVF   2D,W
165B:  BSF    03.5
165C:  MOVWF  1D
165D:  BCF    03.5
165E:  MOVF   2C,W
165F:  BSF    03.5
1660:  MOVWF  1C
1661:  BCF    03.5
1662:  BCF    03.6
1663:  CALL   2A1
1664:  BSF    03.6
1665:  MOVF   39,W
1666:  MOVWF  04
1667:  BCF    03.7
1668:  BTFSC  3A.0
1669:  BSF    03.7
166A:  MOVF   7A,W
166B:  MOVWF  38
166C:  MOVF   79,W
166D:  MOVWF  37
166E:  MOVF   78,W
166F:  MOVWF  36
1670:  MOVF   77,W
1671:  MOVWF  35
1672:  MOVWF  77
1673:  MOVF   36,W
1674:  MOVWF  78
1675:  BCF    78.7
1676:  MOVF   38,W
1677:  MOVWF  34
1678:  MOVF   37,W
1679:  MOVWF  33
167A:  MOVF   78,W
167B:  MOVWF  32
167C:  MOVF   77,W
167D:  MOVWF  31
....................          IF (CHENH_LECH>0.2){ 
167E:  MOVLW  CD
167F:  MOVWF  38
1680:  MOVLW  CC
1681:  MOVWF  37
1682:  MOVLW  4C
1683:  MOVWF  36
1684:  MOVLW  7C
1685:  MOVWF  35
1686:  MOVF   34,W
1687:  MOVWF  3C
1688:  MOVF   33,W
1689:  MOVWF  3B
168A:  MOVF   32,W
168B:  MOVWF  3A
168C:  MOVF   31,W
168D:  MOVWF  39
*
16CC:  BTFSS  03.0
16CD:  GOTO   6D1
....................             TT_SEND_ANALOG = 1; 
16CE:  BCF    03.6
16CF:  BSF    49.0
16D0:  BSF    03.6
....................          } 
....................          //KET_QUA_ANALOG_TEMP[sensor_count] = KET_QUA_ANALOG[sensor_count];          
....................  
....................          sensor_count ++; 
16D1:  INCF   74,F
....................       } 
....................       while ( DS1820_FindNextDevice() && SOLUONGCAMBIEN_CONFIG > sensor_count); 
16D2:  BCF    0A.4
16D3:  BSF    0A.3
16D4:  BCF    03.6
16D5:  CALL   731
16D6:  BSF    0A.4
16D7:  BCF    0A.3
16D8:  MOVF   78,F
16D9:  BTFSC  03.2
16DA:  GOTO   6DF
16DB:  MOVF   44,W
16DC:  SUBWF  74,W
16DD:  BTFSS  03.0
16DE:  GOTO   3FC
....................       sensor_count = 0; 
16DF:  CLRF   74
....................    }      
16E0:  BSF    0A.3
16E1:  BSF    0A.4
16E2:  GOTO   456 (RETURN)
....................  } 
....................  
....................  
....................  VOID SEND_ANALOG_UART () 
....................  { 
....................     TT_SEND_ANALOG = 0; 
*
19E3:  BCF    49.0
....................     OUTPUT_TOGGLE (PIN_C4) ; 
19E4:  BCF    31.4
19E5:  MOVF   31,W
19E6:  BSF    03.5
19E7:  MOVWF  07
19E8:  MOVLW  10
19E9:  BCF    03.5
19EA:  XORWF  07,F
....................     //CHAR * PACKAGE_SS[] ={" * ", "26", "SS", "IDGW12", "NODE", "ZZ", "AA", "VV", "CC", "SS"}; 
....................     CHAR * PACKAGE_SS[] ={"IDGW12", "NODE", "ZZZZZ", "AAAAA", "VVVVV", "CCCCC"}; 
19EB:  MOVLW  49
19EC:  BSF    03.6
19ED:  MOVWF  3D
19EE:  MOVLW  44
19EF:  MOVWF  3E
19F0:  MOVLW  47
19F1:  MOVWF  3F
19F2:  MOVLW  57
19F3:  MOVWF  40
19F4:  MOVLW  31
19F5:  MOVWF  41
19F6:  MOVLW  32
19F7:  MOVWF  42
19F8:  CLRF   43
19F9:  MOVLW  4E
19FA:  MOVWF  44
19FB:  MOVLW  4F
19FC:  MOVWF  45
19FD:  MOVLW  44
19FE:  MOVWF  46
19FF:  MOVLW  45
1A00:  MOVWF  47
1A01:  CLRF   48
1A02:  MOVLW  5A
1A03:  MOVWF  49
1A04:  MOVWF  4A
1A05:  MOVWF  4B
1A06:  MOVWF  4C
1A07:  MOVWF  4D
1A08:  CLRF   4E
1A09:  MOVLW  41
1A0A:  MOVWF  4F
1A0B:  MOVWF  50
1A0C:  MOVWF  51
1A0D:  MOVWF  52
1A0E:  MOVWF  53
1A0F:  CLRF   54
1A10:  MOVLW  56
1A11:  MOVWF  55
1A12:  MOVWF  56
1A13:  MOVWF  57
1A14:  MOVWF  58
1A15:  MOVWF  59
1A16:  CLRF   5A
1A17:  MOVLW  43
1A18:  MOVWF  5B
1A19:  MOVWF  5C
1A1A:  MOVWF  5D
1A1B:  MOVWF  5E
1A1C:  MOVWF  5F
1A1D:  CLRF   60
1A1E:  MOVLW  01
1A1F:  MOVWF  32
1A20:  MOVLW  3D
1A21:  MOVWF  31
1A22:  MOVLW  01
1A23:  MOVWF  34
1A24:  MOVLW  44
1A25:  MOVWF  33
1A26:  MOVLW  01
1A27:  MOVWF  36
1A28:  MOVLW  49
1A29:  MOVWF  35
1A2A:  MOVLW  01
1A2B:  MOVWF  38
1A2C:  MOVLW  4F
1A2D:  MOVWF  37
1A2E:  MOVLW  01
1A2F:  MOVWF  3A
1A30:  MOVLW  55
1A31:  MOVWF  39
1A32:  MOVLW  01
1A33:  MOVWF  3C
1A34:  MOVLW  5B
1A35:  MOVWF  3B
....................     PACKAGE_SS[0] = ID_GATEWAY_CHAR; 
1A36:  CLRF   32
1A37:  MOVLW  51
1A38:  MOVWF  31
....................     PACKAGE_SS[1] = ID_NODE_CHAR; 
1A39:  CLRF   34
1A3A:  MOVLW  4A
1A3B:  MOVWF  33
....................     UNSIGNED INT8 DO_DAI = 20; 
....................     UNSIGNED INT8 I = 0; 
....................     UNSIGNED INT8 K = 2;     
1A3C:  MOVLW  14
1A3D:  MOVWF  61
1A3E:  CLRF   62
1A3F:  MOVLW  02
1A40:  MOVWF  63
....................    WHILE (I < SOLUONGCAMBIEN_CONFIG){ 
1A41:  BCF    03.6
1A42:  MOVF   44,W
1A43:  BSF    03.6
1A44:  SUBWF  62,W
1A45:  BTFSC  03.0
1A46:  GOTO   280
....................       sprintf(PACKAGE_SS[K], "%g", KET_QUA_ANALOG[I]); 
1A47:  BCF    03.0
1A48:  RLF    63,W
1A49:  ADDLW  31
1A4A:  MOVWF  04
1A4B:  BSF    03.7
1A4C:  INCF   04,F
1A4D:  MOVF   00,W
1A4E:  MOVWF  65
1A4F:  DECF   04,F
1A50:  MOVF   00,W
1A51:  MOVWF  64
1A52:  RLF    62,W
1A53:  MOVWF  77
1A54:  RLF    77,F
1A55:  MOVLW  FC
1A56:  ANDWF  77,F
1A57:  MOVF   77,W
1A58:  ADDLW  18
1A59:  MOVWF  04
1A5A:  BSF    03.7
1A5B:  MOVF   00,W
1A5C:  MOVWF  66
1A5D:  INCF   04,F
1A5E:  MOVF   00,W
1A5F:  MOVWF  67
1A60:  INCF   04,F
1A61:  MOVF   00,W
1A62:  MOVWF  68
1A63:  INCF   04,F
1A64:  MOVF   00,W
1A65:  MOVWF  69
1A66:  MOVF   65,W
1A67:  MOVWF  76
1A68:  MOVF   64,W
1A69:  MOVWF  75
1A6A:  MOVLW  89
1A6B:  MOVWF  04
1A6C:  MOVF   69,W
1A6D:  MOVWF  6D
1A6E:  MOVF   68,W
1A6F:  MOVWF  6C
1A70:  MOVF   67,W
1A71:  MOVWF  6B
1A72:  MOVF   66,W
1A73:  MOVWF  6A
1A74:  MOVLW  02
1A75:  MOVWF  6E
1A76:  BCF    03.6
1A77:  GOTO   000
....................       //DO_DAI = DO_DAI + strlen(PACKAGE_SS[K])+1;     
....................       DO_DAI = DO_DAI + 5+1;     
1A78:  MOVLW  05
1A79:  BSF    03.6
1A7A:  ADDWF  61,W
1A7B:  ADDLW  01
1A7C:  MOVWF  61
....................       I++; 
1A7D:  INCF   62,F
....................       K++; 
1A7E:  INCF   63,F
1A7F:  GOTO   241
....................    } 
....................     ITOA (DO_DAI, 10, TEMP_CHAR2) ; 
1A80:  CLRF   67
1A81:  CLRF   66
1A82:  CLRF   65
1A83:  MOVF   61,W
1A84:  MOVWF  64
1A85:  MOVLW  0A
1A86:  MOVWF  68
1A87:  CLRF   6A
1A88:  MOVLW  71
1A89:  MOVWF  69
1A8A:  BCF    0A.4
1A8B:  BCF    0A.3
1A8C:  BCF    03.6
1A8D:  CALL   447
1A8E:  BSF    0A.4
1A8F:  BSF    0A.3
....................     PRINTF ("*@"); 
1A90:  MOVLW  2A
1A91:  BTFSS  0C.4
1A92:  GOTO   291
1A93:  MOVWF  19
1A94:  MOVLW  40
1A95:  BTFSS  0C.4
1A96:  GOTO   295
1A97:  MOVWF  19
....................     PRINTF (TEMP_CHAR2); 
1A98:  MOVLW  71
1A99:  MOVWF  04
1A9A:  BCF    03.7
1A9B:  BCF    0A.4
1A9C:  BCF    0A.3
1A9D:  CALL   5E3
1A9E:  BSF    0A.4
1A9F:  BSF    0A.3
....................     PRINTF ("@SS@"); 
1AA0:  MOVLW  00
1AA1:  BSF    03.6
1AA2:  MOVWF  0D
1AA3:  MOVLW  01
1AA4:  MOVWF  0F
1AA5:  BCF    0A.4
1AA6:  BCF    03.6
1AA7:  CALL   474
1AA8:  BSF    0A.4
....................     FOR (I = 0; I < 2 + SOLUONGCAMBIEN_CONFIG; I++) 
1AA9:  BSF    03.6
1AAA:  CLRF   62
1AAB:  MOVLW  02
1AAC:  BCF    03.6
1AAD:  ADDWF  44,W
1AAE:  BSF    03.6
1AAF:  SUBWF  62,W
1AB0:  BTFSC  03.0
1AB1:  GOTO   2CE
....................     { 
....................        PRINTF (PACKAGE_SS[I]); 
1AB2:  BCF    03.0
1AB3:  RLF    62,W
1AB4:  ADDLW  31
1AB5:  MOVWF  04
1AB6:  BSF    03.7
1AB7:  INCF   04,F
1AB8:  MOVF   00,W
1AB9:  MOVWF  65
1ABA:  DECF   04,F
1ABB:  MOVF   00,W
1ABC:  MOVWF  64
1ABD:  MOVWF  04
1ABE:  BCF    03.7
1ABF:  BTFSC  65.0
1AC0:  BSF    03.7
1AC1:  BCF    0A.4
1AC2:  BCF    0A.3
1AC3:  BCF    03.6
1AC4:  CALL   5E3
1AC5:  BSF    0A.4
1AC6:  BSF    0A.3
....................        PRINTF ("@"); 
1AC7:  MOVLW  40
1AC8:  BTFSS  0C.4
1AC9:  GOTO   2C8
1ACA:  MOVWF  19
1ACB:  BSF    03.6
1ACC:  INCF   62,F
1ACD:  GOTO   2AB
....................     } 
....................  
....................     PRINTF ("#"); 
1ACE:  MOVLW  23
1ACF:  BCF    03.6
1AD0:  BTFSS  0C.4
1AD1:  GOTO   2D0
1AD2:  MOVWF  19
....................     OUTPUT_TOGGLE (PIN_C4) ; 
1AD3:  BCF    31.4
1AD4:  MOVF   31,W
1AD5:  BSF    03.5
1AD6:  MOVWF  07
1AD7:  MOVLW  10
1AD8:  BCF    03.5
1AD9:  XORWF  07,F
1ADA:  BSF    0A.3
1ADB:  BSF    0A.4
1ADC:  GOTO   45B (RETURN)
....................  
....................  } 
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
.................... VOID QUET_PHIM() 
*
0103:  BSF    03.5
0104:  BSF    03.6
0105:  CLRF   2A
.................... { 
....................    INT BDT = 0; 
....................    WHILE (!INPUT (BT1_PIN)) //NEU NUT BAM DUOC BAM 
0106:  BCF    03.6
0107:  BSF    06.1
0108:  BCF    03.5
0109:  BTFSC  06.1
010A:  GOTO   124
....................    { 
....................       IF (TMR1IF) 
010B:  BTFSS  0C.0
010C:  GOTO   11F
....................       { 
....................          OUTPUT_TOGGLE (PIN_C4); 
010D:  BCF    31.4
010E:  MOVF   31,W
010F:  BSF    03.5
0110:  MOVWF  07
0111:  MOVLW  10
0112:  BCF    03.5
0113:  XORWF  07,F
....................          TMR1IF = 0; SET_TIMER1 (3036); BDT++; 
0114:  BCF    0C.0
0115:  CLRF   0E
0116:  MOVLW  0B
0117:  MOVWF  0F
0118:  MOVLW  DC
0119:  MOVWF  0E
011A:  BSF    03.5
011B:  BSF    03.6
011C:  INCF   2A,F
011D:  BCF    03.5
011E:  BCF    03.6
....................       } 
011F:  BSF    03.5
0120:  BSF    03.6
0121:  GOTO   106
0122:  BCF    03.5
0123:  BCF    03.6
....................    } 
....................  
....................    IF (BDT > 10) 
0124:  BSF    03.5
0125:  BSF    03.6
0126:  MOVF   2A,W
0127:  SUBLW  0A
0128:  BTFSC  03.0
0129:  GOTO   135
....................    { 
....................       //CONFIG NODE 
....................       TT_CONFIG = ~TT_CONFIG; // VAO TRANG THAI CONFIG 
012A:  MOVLW  02
012B:  BCF    03.5
012C:  BCF    03.6
012D:  XORWF  48,F
....................       TT_CONTROL = ~TT_CONTROL; 
012E:  MOVLW  04
012F:  XORWF  48,F
....................       //CONFIG_DONE (); 
....................       TT_CONFIG_DONE = 1; 
0130:  BSF    48.3
....................       TT_FUN = 0; 
0131:  BCF    48.4
....................    } 
0132:  GOTO   14F
0133:  BSF    03.5
0134:  BSF    03.6
....................  
....................    ELSE IF (BDT > 1&&BDT < 10) 
0135:  MOVF   2A,W
0136:  SUBLW  01
0137:  BTFSC  03.0
0138:  GOTO   145
0139:  MOVF   2A,W
013A:  SUBLW  09
013B:  BTFSS  03.0
013C:  GOTO   145
....................    { 
....................       BUTT_OKE (); //OKE 
....................    } 
*
0142:  GOTO   14F
0143:  BSF    03.5
0144:  BSF    03.6
....................  
....................    ELSE 
....................    {             
....................       //TMR1IF = 0; SET_TIMER1 (0);       
....................       TT_SW = 1; 
0145:  BCF    03.5
0146:  BCF    03.6
0147:  BSF    48.7
....................       OUTPUT_TOGGLE (PIN_C4); 
0148:  BCF    31.4
0149:  MOVF   31,W
014A:  BSF    03.5
014B:  MOVWF  07
014C:  MOVLW  10
014D:  BCF    03.5
014E:  XORWF  07,F
....................       //READ_BTN_STATE () ;       
....................    } 
.................... } 
....................  
.................... #INT_EXT 
....................  
....................  VOID NGAT_NGOAI  () 
....................  { 
....................     QUET_PHIM (); 
....................  } 
....................  
014F:  BCF    0B.1
0150:  BCF    0A.3
0151:  BCF    0A.4
0152:  GOTO   031
....................  #INT_RDA 
....................  VOID NGAT  () 
....................  { 
....................     KYTUCHAR[VT] = GETCH (); 
0153:  MOVLW  A0
0154:  ADDWF  33,W
0155:  MOVWF  04
0156:  BCF    03.7
0157:  BTFSS  0C.5
0158:  GOTO   157
0159:  MOVF   1A,W
015A:  MOVWF  00
....................  
....................     IF (KYTUCHAR[VT] == '.') 
015B:  MOVLW  A0
015C:  ADDWF  33,W
015D:  MOVWF  04
015E:  BCF    03.7
015F:  MOVF   00,W
0160:  SUBLW  2E
0161:  BTFSS  03.2
0162:  GOTO   16B
....................     { 
....................        KYTUCHAR[VT] = '\0'; 
0163:  MOVLW  A0
0164:  ADDWF  33,W
0165:  MOVWF  04
0166:  BCF    03.7
0167:  CLRF   00
....................        VT = 0; 
0168:  CLRF   33
....................        TTNHAN = 1; 
0169:  BSF    48.0
....................     } 
016A:  GOTO   16C
....................  
....................     ELSE 
....................     VT++; 
016B:  INCF   33,F
016C:  BCF    0C.5
016D:  BCF    0A.3
016E:  BCF    0A.4
016F:  GOTO   031
....................  } 
....................  
....................  VOID XU_LY_UART () 
*
1000:  MOVLW  2A
1001:  BSF    03.6
1002:  MOVWF  31
....................  { 
....................     //ID_NODE_NHAN = KYTU[1] - 48; 
....................     //ID_DEVICE_NHAN = KYTU[2] - 48 + 64; 
....................     //TT_DEVICE_NHAN = KYTU[3] - 48; // - 48 ASCII -- > S?. + 64 -- > PORT_D (D0 = 64) 
....................     /* TINH DO DAI*/ 
....................      
....................     CHAR CH = '*'; 
....................     CHAR * RET; 
....................     * ID_NODE_NHAN = '\0'; 
1003:  CLRF   7A
1004:  MOVLW  5A
1005:  MOVWF  04
1006:  BCF    03.7
1007:  BTFSC  7A.0
1008:  BSF    03.7
1009:  CLRF   00
....................     * ID_GW_NHAN = '\0'; 
100A:  CLRF   7A
100B:  MOVLW  61
100C:  MOVWF  04
100D:  BCF    03.7
100E:  BTFSC  7A.0
100F:  BSF    03.7
1010:  CLRF   00
....................     KYTUCHAR2 = ""; 
1011:  CLRF   3B
1012:  CLRF   3C
1013:  MOVLW  D2
1014:  MOVWF  04
1015:  BCF    03.7
1016:  MOVF   3B,W
1017:  ADDWF  04,F
1018:  MOVF   3C,W
1019:  BCF    0A.4
101A:  BCF    03.6
101B:  CALL   079
101C:  BSF    0A.4
101D:  MOVWF  00
101E:  IORLW  00
101F:  BTFSC  03.2
1020:  GOTO   026
1021:  BSF    03.6
1022:  INCF   3C,F
1023:  INCF   3B,F
1024:  GOTO   013
1025:  BCF    03.6
....................     UNSIGNED INT8 LEN_RET; 
....................     RET = STRCHR (KYTUCHAR, CH); 
1026:  BSF    03.6
1027:  CLRF   3C
1028:  MOVLW  A0
1029:  MOVWF  3B
102A:  MOVF   31,W
102B:  MOVWF  3D
*
104D:  MOVF   79,W
104E:  MOVWF  33
104F:  MOVF   78,W
1050:  MOVWF  32
....................     LEN_RET = STRLEN (RET); 
1051:  MOVF   33,W
1052:  MOVWF  3C
1053:  MOVF   32,W
1054:  MOVWF  3B
*
1072:  MOVF   78,W
1073:  MOVWF  34
....................  
....................     /* LAY TOKEN DAU TIEN */ 
....................     KYTU = 0; 
1074:  BCF    03.6
1075:  CLRF   34
....................     CHAR *_CHAR_TACH_ = "#"; 
1076:  MOVLW  23
1077:  BSF    03.6
1078:  MOVWF  37
1079:  CLRF   38
107A:  MOVLW  01
107B:  MOVWF  36
107C:  MOVLW  37
107D:  MOVWF  35
107E:  CLRF   3E
107F:  MOVLW  A0
1080:  MOVWF  3D
1081:  MOVF   36,W
1082:  MOVWF  40
1083:  MOVF   35,W
1084:  MOVWF  3F
1085:  BCF    0A.4
1086:  BSF    0A.3
1087:  BCF    03.6
1088:  CALL   265
1089:  BSF    0A.4
108A:  BCF    0A.3
....................     //CHAR * TOKEN = "123456"; 
....................     CHAR *TOKEN = STRTOK (KYTUCHAR, _CHAR_TACH_); 
108B:  MOVF   79,W
108C:  BSF    03.6
108D:  MOVWF  3A
108E:  MOVF   78,W
108F:  MOVWF  39
....................  
....................     /* DUYET QUA CAC TOKEN CON LAI */ 
....................     WHILE (TOKEN != NULL) 
1090:  MOVF   39,F
1091:  BTFSS  03.2
1092:  GOTO   096
1093:  MOVF   3A,F
1094:  BTFSC  03.2
1095:  GOTO   0F6
....................     { 
....................        SWITCH (KYTU) 
1096:  MOVLW  01
1097:  BCF    03.6
1098:  SUBWF  34,W
1099:  ADDLW  FB
109A:  BTFSC  03.0
109B:  GOTO   0E0
109C:  ADDLW  05
109D:  GOTO   298
....................        { 
....................           //CASE 0: 
....................           //BREAK; 
....................  
....................           CASE 1: 
....................           //strncpy (ID_GW_NHAN, TOKEN, 6); 
....................           STRCAT (ID_GW_NHAN, TOKEN); 
109E:  BSF    03.6
109F:  CLRF   60
10A0:  MOVLW  61
10A1:  MOVWF  5F
10A2:  MOVF   3A,W
10A3:  MOVWF  62
10A4:  MOVF   39,W
10A5:  MOVWF  61
10A6:  BCF    0A.4
10A7:  BCF    03.6
10A8:  CALL   5A5
10A9:  BSF    0A.4
....................           BREAK; 
10AA:  GOTO   0E0
....................  
....................           CASE 2: 
....................           STRCAT (ID_NODE_NHAN, TOKEN); 
10AB:  BSF    03.6
10AC:  CLRF   60
10AD:  MOVLW  5A
10AE:  MOVWF  5F
10AF:  MOVF   3A,W
10B0:  MOVWF  62
10B1:  MOVF   39,W
10B2:  MOVWF  61
10B3:  BCF    0A.4
10B4:  BCF    03.6
10B5:  CALL   5A5
10B6:  BSF    0A.4
....................           BREAK; 
10B7:  GOTO   0E0
....................  
....................           CASE 3: 
....................           LENHDIEUKHIEN = ATOI (TOKEN); 
10B8:  BSF    03.6
10B9:  MOVF   3A,W
10BA:  MOVWF  3E
10BB:  MOVF   39,W
10BC:  MOVWF  3D
10BD:  BCF    0A.4
10BE:  BSF    0A.3
10BF:  BCF    03.6
10C0:  CALL   356
10C1:  BSF    0A.4
10C2:  BCF    0A.3
10C3:  MOVF   78,W
10C4:  MOVWF  41
....................           BREAK; 
10C5:  GOTO   0E0
....................  
....................           CASE 4: 
....................           DODAI_DATA_NHAN = ATOI (TOKEN); 
10C6:  BSF    03.6
10C7:  MOVF   3A,W
10C8:  MOVWF  3E
10C9:  MOVF   39,W
10CA:  MOVWF  3D
10CB:  BCF    0A.4
10CC:  BSF    0A.3
10CD:  BCF    03.6
10CE:  CALL   356
10CF:  BSF    0A.4
10D0:  BCF    0A.3
10D1:  MOVF   78,W
10D2:  MOVWF  42
....................           BREAK; 
10D3:  GOTO   0E0
....................  
....................           CASE 5: 
....................           STRCAT (KYTUCHAR2, TOKEN); 
10D4:  BSF    03.6
10D5:  CLRF   60
10D6:  MOVLW  D2
10D7:  MOVWF  5F
10D8:  MOVF   3A,W
10D9:  MOVWF  62
10DA:  MOVF   39,W
10DB:  MOVWF  61
10DC:  BCF    0A.4
10DD:  BCF    03.6
10DE:  CALL   5A5
10DF:  BSF    0A.4
....................           BREAK; 
....................        } 
....................        TOKEN = STRTOK (NULL, _CHAR_TACH_); 
10E0:  BSF    03.6
10E1:  CLRF   3E
10E2:  CLRF   3D
10E3:  MOVF   36,W
10E4:  MOVWF  40
10E5:  MOVF   35,W
10E6:  MOVWF  3F
10E7:  BCF    0A.4
10E8:  BSF    0A.3
10E9:  BCF    03.6
10EA:  CALL   265
10EB:  BSF    0A.4
10EC:  BCF    0A.3
10ED:  MOVF   79,W
10EE:  BSF    03.6
10EF:  MOVWF  3A
10F0:  MOVF   78,W
10F1:  MOVWF  39
....................        KYTU++; 
10F2:  BCF    03.6
10F3:  INCF   34,F
10F4:  BSF    03.6
10F5:  GOTO   090
....................     } 
....................  
....................     /* SO SANH ID returns - 1 IF s1 < s2, 0 if s1 = s2, 1 if s1 > s2 */ 
....................     SOSANH_IDGW = STRCMP (ID_GW_NHAN, ID_GATEWAY_CHAR); 
10F6:  CLRF   3C
10F7:  MOVLW  61
10F8:  MOVWF  3B
10F9:  CLRF   3E
10FA:  MOVLW  51
10FB:  MOVWF  3D
10FC:  BCF    0A.4
10FD:  BCF    03.6
10FE:  CALL   7BA
10FF:  BSF    0A.4
1100:  MOVF   78,W
1101:  MOVWF  46
....................     SOSANH_IDNODE = STRCMP (ID_NODE_NHAN, ID_NODE_CHAR);         
1102:  BSF    03.6
1103:  CLRF   3C
1104:  MOVLW  5A
1105:  MOVWF  3B
1106:  CLRF   3E
1107:  MOVLW  4A
1108:  MOVWF  3D
1109:  BCF    0A.4
110A:  BCF    03.6
110B:  CALL   7BA
110C:  BSF    0A.4
110D:  MOVF   78,W
110E:  MOVWF  45
....................     IF (SOSANH_IDGW == 0&&SOSANH_IDNODE == 0&&LEN_RET == DODAI_DATA_NHAN) 
110F:  MOVF   46,F
1110:  BTFSS  03.2
1111:  GOTO   243
1112:  MOVF   45,F
1113:  BTFSS  03.2
1114:  GOTO   243
1115:  MOVF   42,W
1116:  BSF    03.6
1117:  SUBWF  34,W
1118:  BTFSC  03.2
1119:  GOTO   11C
111A:  BCF    03.6
111B:  GOTO   243
....................     //IF (LEN_RET == DODAI_DATA_NHAN) 
....................     { 
....................        SWITCH (LENHDIEUKHIEN) 
111C:  BCF    03.6
111D:  MOVF   41,W
111E:  BTFSC  03.2
111F:  GOTO   127
1120:  XORLW  01
1121:  BTFSC  03.2
1122:  GOTO   128
1123:  XORLW  03
1124:  BTFSC  03.2
1125:  GOTO   213
1126:  GOTO   242
....................        { 
....................           CASE 0: 
....................           BREAK; 
1127:  GOTO   242
....................  
....................           CASE 1: 
....................           XACNHANCONFIG () ; 
....................           BREAK; 
*
1212:  GOTO   242
....................  
....................           CASE 2: 
....................           DIEUKHIENTHIETBI () ; 
....................           BREAK; 
....................        } 
....................     } 
*
1242:  GOTO   295
....................  
....................     ELSE 
....................     { 
....................        DELAY_MS (10); 
1243:  MOVLW  0A
1244:  BSF    03.6
1245:  MOVWF  62
1246:  BCF    0A.4
1247:  BCF    03.6
1248:  CALL   17A
1249:  BSF    0A.4
....................        OUTPUT_TOGGLE (PIN_C4); 
124A:  BCF    31.4
124B:  MOVF   31,W
124C:  BSF    03.5
124D:  MOVWF  07
124E:  MOVLW  10
124F:  BCF    03.5
1250:  XORWF  07,F
....................        DELAY_MS (100); 
1251:  MOVLW  64
1252:  BSF    03.6
1253:  MOVWF  62
1254:  BCF    0A.4
1255:  BCF    03.6
1256:  CALL   17A
1257:  BSF    0A.4
....................        OUTPUT_TOGGLE (PIN_C4); 
1258:  BCF    31.4
1259:  MOVF   31,W
125A:  BSF    03.5
125B:  MOVWF  07
125C:  MOVLW  10
125D:  BCF    03.5
125E:  XORWF  07,F
....................        DELAY_MS (200); 
125F:  MOVLW  C8
1260:  BSF    03.6
1261:  MOVWF  62
1262:  BCF    0A.4
1263:  BCF    03.6
1264:  CALL   17A
1265:  BSF    0A.4
....................        OUTPUT_TOGGLE (PIN_C4); 
1266:  BCF    31.4
1267:  MOVF   31,W
1268:  BSF    03.5
1269:  MOVWF  07
126A:  MOVLW  10
126B:  BCF    03.5
126C:  XORWF  07,F
....................        DELAY_MS (300); 
126D:  MOVLW  02
126E:  BSF    03.6
126F:  MOVWF  3B
1270:  MOVLW  96
1271:  MOVWF  62
1272:  BCF    0A.4
1273:  BCF    03.6
1274:  CALL   17A
1275:  BSF    0A.4
1276:  BSF    03.6
1277:  DECFSZ 3B,F
1278:  GOTO   270
....................        OUTPUT_TOGGLE (PIN_C4);        
1279:  BCF    03.6
127A:  BCF    31.4
127B:  MOVF   31,W
127C:  BSF    03.5
127D:  MOVWF  07
127E:  MOVLW  10
127F:  BCF    03.5
1280:  XORWF  07,F
....................        DELAY_MS (400); 
1281:  MOVLW  02
1282:  BSF    03.6
1283:  MOVWF  3B
1284:  MOVLW  C8
1285:  MOVWF  62
1286:  BCF    0A.4
1287:  BCF    03.6
1288:  CALL   17A
1289:  BSF    0A.4
128A:  BSF    03.6
128B:  DECFSZ 3B,F
128C:  GOTO   284
....................        OUTPUT_TOGGLE (PIN_C4);        
128D:  BCF    03.6
128E:  BCF    31.4
128F:  MOVF   31,W
1290:  BSF    03.5
1291:  MOVWF  07
1292:  MOVLW  10
1293:  BCF    03.5
1294:  XORWF  07,F
....................        /* DATA RCV SAI ID NODE, ID GW HOAC LA SAI DO DAI*/ 
....................     } 
1295:  BSF    0A.3
1296:  BSF    0A.4
1297:  GOTO   43F (RETURN)
....................  
....................  } 
....................  
....................  VOID MAIN () 
*
1ADD:  MOVF   03,W
1ADE:  ANDLW  1F
1ADF:  MOVWF  03
1AE0:  BSF    03.5
1AE1:  BSF    03.6
1AE2:  BSF    07.3
1AE3:  MOVLW  08
1AE4:  BCF    03.6
1AE5:  MOVWF  19
1AE6:  MOVLW  02
1AE7:  MOVWF  1A
1AE8:  MOVLW  A6
1AE9:  MOVWF  18
1AEA:  MOVLW  90
1AEB:  BCF    03.5
1AEC:  MOVWF  18
1AED:  MOVLW  FF
1AEE:  MOVWF  31
1AEF:  CLRF   32
1AF0:  CLRF   33
1AF1:  CLRF   34
1AF2:  CLRF   35
1AF3:  CLRF   40
1AF4:  CLRF   41
1AF5:  CLRF   42
1AF6:  CLRF   43
1AF7:  MOVLW  03
1AF8:  MOVWF  44
1AF9:  CLRF   45
1AFA:  CLRF   46
1AFB:  BCF    48.0
1AFC:  BCF    48.1
1AFD:  BCF    48.2
1AFE:  BCF    48.3
1AFF:  BCF    48.4
1B00:  BCF    48.5
1B01:  BCF    48.6
1B02:  BCF    48.7
1B03:  BCF    49.0
1B04:  CLRF   74
1B05:  BSF    03.6
1B06:  CLRF   2F
1B07:  CLRF   2E
1B08:  CLRF   2D
1B09:  CLRF   2C
1B0A:  CLRF   76
1B0B:  CLRF   75
1B0C:  BSF    03.5
1B0D:  MOVF   09,W
1B0E:  ANDLW  C0
1B0F:  MOVWF  09
1B10:  BCF    03.6
1B11:  BCF    1F.4
1B12:  BCF    1F.5
1B13:  MOVLW  00
1B14:  BSF    03.6
1B15:  MOVWF  08
1B16:  BCF    03.5
1B17:  CLRF   07
1B18:  CLRF   08
1B19:  CLRF   09
1B1A:  BCF    03.7
....................  { 
....................     SET_TRIS_D (0XF0); 
*
1BAA:  MOVLW  F0
1BAB:  BSF    03.5
1BAC:  BCF    03.6
1BAD:  MOVWF  08
....................     SET_TRIS_B (0XFF); 
1BAE:  MOVLW  FF
1BAF:  MOVWF  06
....................     SET_TRIS_E (0); 
1BB0:  BCF    09.0
1BB1:  BCF    09.1
1BB2:  BCF    09.2
1BB3:  BCF    09.3
....................     SET_TRIS_C (0X80); 
1BB4:  MOVLW  80
1BB5:  MOVWF  07
1BB6:  BCF    03.5
1BB7:  MOVWF  31
....................     SET_TRIS_A (0XFF); 
1BB8:  MOVLW  FF
1BB9:  BSF    03.5
1BBA:  MOVWF  05
....................     //SETUP_ADC (ADC_CLOCK_DIV_8);// use ds18b20 nn bo cai dong nay 
....................      
....................      
....................      
....................     //SETUP_TIMER_0(T0_INTERNAL | T0_DIV_1); 
....................     //ENABLE_INTERRUPTS (INT_TIMER0); 
....................      
....................     ENABLE_INTERRUPTS (INT_EXT); //CHO PHEP NGAT NGOAI 
1BBB:  BCF    03.5
1BBC:  BSF    0B.4
....................     ENABLE_INTERRUPTS (INT_EXT_H2L); //NGAT XAY RA KHI CO XUNG TU CAO XUONG THAP 
1BBD:  BSF    0B.4
1BBE:  BSF    03.5
1BBF:  BCF    01.6
....................     ENABLE_INTERRUPTS (INT_RDA); 
1BC0:  BSF    0C.5
....................     ENABLE_INTERRUPTS (GLOBAL); 
1BC1:  MOVLW  C0
1BC2:  BCF    03.5
1BC3:  IORWF  0B,F
....................      
....................     SETUP_TIMER_1 (T1_INTERNAL|T1_DIV_BY_8); 
1BC4:  MOVLW  35
1BC5:  MOVWF  10
....................     //SET_TIMER1 (0); 
....................     SET_TIMER1 (3036); 
1BC6:  CLRF   0E
1BC7:  MOVLW  0B
1BC8:  MOVWF  0F
1BC9:  MOVLW  DC
1BCA:  MOVWF  0E
....................     TMR1IF = 0; 
1BCB:  BCF    0C.0
....................     LCD_INIT (); // KHOI TAO LCD 
1BCC:  BCF    0A.4
1BCD:  BCF    0A.3
1BCE:  GOTO   294
1BCF:  BSF    0A.4
1BD0:  BSF    0A.3
....................     TT_CONFIG = 0; 
1BD1:  BCF    48.1
....................     TT_CONFIG_DONE = 0; 
1BD2:  BCF    48.3
....................     TT_CONTROL = 1; 
1BD3:  BSF    48.2
....................     OUTPUT_HIGH (PIN_D3) ; 
1BD4:  BSF    03.5
1BD5:  BCF    08.3
1BD6:  BCF    03.5
1BD7:  BSF    08.3
....................     TTNHAN = 0; 
1BD8:  BCF    48.0
....................  
....................  
....................        
....................       LCD_GOTOXY (1, 2) ; 
1BD9:  MOVLW  01
1BDA:  BSF    03.6
1BDB:  MOVWF  62
1BDC:  MOVLW  02
1BDD:  MOVWF  63
1BDE:  BCF    0A.4
1BDF:  BCF    0A.3
1BE0:  BCF    03.6
1BE1:  CALL   2FA
1BE2:  BSF    0A.4
1BE3:  BSF    0A.3
....................       DELAY_MS (10); 
1BE4:  MOVLW  0A
1BE5:  BSF    03.6
1BE6:  MOVWF  62
1BE7:  BCF    0A.4
1BE8:  BCF    0A.3
1BE9:  BCF    03.6
1BEA:  CALL   17A
1BEB:  BSF    0A.4
1BEC:  BSF    0A.3
....................       PRINTF (LCD_PUTC, "hihihoang");     
1BED:  MOVLW  70
1BEE:  BSF    03.6
1BEF:  MOVWF  0D
1BF0:  MOVLW  01
1BF1:  MOVWF  0F
1BF2:  BCF    0A.4
1BF3:  BCF    0A.3
1BF4:  BCF    03.6
1BF5:  CALL   348
1BF6:  BSF    0A.4
1BF7:  BSF    0A.3
....................       FOR (INT ABCD = 0; ABCD <10; ABCD ++){ 
1BF8:  BSF    03.6
1BF9:  CLRF   30
1BFA:  MOVF   30,W
1BFB:  SUBLW  09
1BFC:  BTFSS  03.0
1BFD:  GOTO   416
....................           
....................          OUTPUT_TOGGLE (PIN_C4); 
1BFE:  BCF    03.6
1BFF:  BCF    31.4
1C00:  MOVF   31,W
1C01:  BSF    03.5
1C02:  MOVWF  07
1C03:  MOVLW  10
1C04:  BCF    03.5
1C05:  XORWF  07,F
....................          DELAY_MS(500); 
1C06:  MOVLW  02
1C07:  BSF    03.6
1C08:  MOVWF  31
1C09:  MOVLW  FA
1C0A:  MOVWF  62
1C0B:  BCF    0A.4
1C0C:  BCF    0A.3
1C0D:  BCF    03.6
1C0E:  CALL   17A
1C0F:  BSF    0A.4
1C10:  BSF    0A.3
1C11:  BSF    03.6
1C12:  DECFSZ 31,F
1C13:  GOTO   409
1C14:  INCF   30,F
1C15:  GOTO   3FA
....................       } 
....................       PRINTF (LCD_PUTC, "CHAOHOANG");         
1C16:  MOVLW  75
1C17:  MOVWF  0D
1C18:  MOVLW  01
1C19:  MOVWF  0F
1C1A:  BCF    0A.4
1C1B:  BCF    0A.3
1C1C:  BCF    03.6
1C1D:  CALL   348
1C1E:  BSF    0A.4
1C1F:  BSF    0A.3
....................     READ_EEPROMP_DATA_NODE(); 
1C20:  BCF    0A.4
1C21:  BCF    0A.3
1C22:  GOTO   398
1C23:  BSF    0A.4
1C24:  BSF    0A.3
....................     CONFIG_DONE(); 
1C25:  BCF    0A.4
1C26:  BCF    0A.3
1C27:  CALL   601
1C28:  BSF    0A.4
1C29:  BSF    0A.3
....................  
....................     WHILE (TRUE) 
....................     { 
....................        IF (TT_CONFIG)   {BUTT_FUN (); } // GOI HAM CHON LENH (SWITCH CASE) 
1C2A:  BTFSS  48.1
1C2B:  GOTO   430
1C2C:  BCF    0A.4
1C2D:  GOTO   000
1C2E:  BSF    0A.4
1C2F:  GOTO   465
....................        ELSE IF (TT_CONFIG_DONE) { CONFIG_DONE (); } 
1C30:  BTFSS  48.3
1C31:  GOTO   438
1C32:  BCF    0A.4
1C33:  BCF    0A.3
1C34:  CALL   601
1C35:  BSF    0A.4
1C36:  BSF    0A.3
1C37:  GOTO   465
....................        ELSE 
....................        { 
....................           WHILE (!TT_CONFIG) 
1C38:  BTFSC  48.1
1C39:  GOTO   465
....................           { 
....................              IF (TTNHAN == 1) 
1C3A:  BTFSS  48.0
1C3B:  GOTO   440
....................              { 
....................                 TTNHAN = 0; 
1C3C:  BCF    48.0
....................                 XU_LY_UART () ; 
1C3D:  BCF    0A.3
1C3E:  GOTO   000
1C3F:  BSF    0A.3
....................              } 
....................              IF (TT_CONFIG_OKE_UART == 1) 
1C40:  BTFSS  48.6
1C41:  GOTO   464
....................              { 
....................                  
....................                IF (TT_SW) 
1C42:  BTFSS  48.7
1C43:  GOTO   44B
....................                { 
....................                   READ_BTN_STATE(); 
1C44:  BCF    0A.4
1C45:  GOTO   642
1C46:  BSF    0A.4
....................                   TT_SW = 0;              
1C47:  BCF    48.7
....................                   XUAT_DIEU_KHIEN();               
1C48:  BCF    0A.4
1C49:  CALL   4C6
1C4A:  BSF    0A.4
....................                }                 
....................                 DELAY_MS (100) ; 
1C4B:  MOVLW  64
1C4C:  BSF    03.6
1C4D:  MOVWF  62
1C4E:  BCF    0A.4
1C4F:  BCF    0A.3
1C50:  BCF    03.6
1C51:  CALL   17A
1C52:  BSF    0A.4
1C53:  BSF    0A.3
....................                 READ_ANALOG () ; 
1C54:  BCF    0A.3
1C55:  GOTO   3EB
1C56:  BSF    0A.3
....................  
....................                 IF (TT_SEND_ANALOG) 
1C57:  BTFSS  49.0
1C58:  GOTO   464
....................                 { 
....................                   TT_SEND_ANALOG = 0; 
1C59:  BCF    49.0
....................                    SEND_ANALOG_UART () ; 
1C5A:  GOTO   1E3
....................                    DELAY_MS (200) ; 
1C5B:  MOVLW  C8
1C5C:  BSF    03.6
1C5D:  MOVWF  62
1C5E:  BCF    0A.4
1C5F:  BCF    0A.3
1C60:  BCF    03.6
1C61:  CALL   17A
1C62:  BSF    0A.4
1C63:  BSF    0A.3
....................                 } 
....................              } 
1C64:  GOTO   438
....................           } 
....................        } 
1C65:  GOTO   42A
....................     } 
....................  } 
....................  
1C66:  SLEEP
....................  

Configuration Fuses:
   Word  1: 2FE2   HS NOWDT PUT MCLR NOPROTECT NOCPD BROWNOUT IESO FCMEN NOLVP NODEBUG
   Word  2: 3FFF   BORV40 NOWRT
