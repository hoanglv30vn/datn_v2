CCS PCM C Compiler, Version 5.015, 5967               28-Oct-21 15:34

               Filename:   E:\DATN\NODE\pic\pic16f887\hellopic.lst

               ROM used:   3335 words (41%)
                           Largest free fragment is 2048
               RAM used:   142 (39%) at main() level
                           194 (53%) worst case
               Stack used: 7 locations (6 in main + 1 for interrupts)
               Stack size: 8

*
0000:  MOVLW  0B
0001:  MOVWF  0A
0002:  GOTO   355
0003:  NOP
0004:  MOVWF  7F
0005:  SWAPF  03,W
0006:  CLRF   03
0007:  MOVWF  21
0008:  MOVF   0A,W
0009:  MOVWF  20
000A:  CLRF   0A
000B:  MOVF   04,W
000C:  MOVWF  22
000D:  MOVF   77,W
000E:  MOVWF  23
000F:  MOVF   78,W
0010:  MOVWF  24
0011:  MOVF   79,W
0012:  MOVWF  25
0013:  MOVF   7A,W
0014:  MOVWF  26
0015:  BSF    03.6
0016:  MOVF   0D,W
0017:  BCF    03.6
0018:  MOVWF  27
0019:  BSF    03.6
001A:  MOVF   0F,W
001B:  BCF    03.6
001C:  MOVWF  28
001D:  BSF    03.6
001E:  MOVF   0C,W
001F:  BCF    03.6
0020:  MOVWF  29
0021:  BSF    03.6
0022:  MOVF   0E,W
0023:  BCF    03.6
0024:  MOVWF  2A
0025:  BCF    03.7
0026:  BCF    03.5
0027:  BTFSS  0B.4
0028:  GOTO   02B
0029:  BTFSC  0B.1
002A:  GOTO   052
002B:  MOVLW  8C
002C:  MOVWF  04
002D:  BTFSS  00.5
002E:  GOTO   031
002F:  BTFSC  0C.5
0030:  GOTO   055
0031:  MOVF   22,W
0032:  MOVWF  04
0033:  MOVF   23,W
0034:  MOVWF  77
0035:  MOVF   24,W
0036:  MOVWF  78
0037:  MOVF   25,W
0038:  MOVWF  79
0039:  MOVF   26,W
003A:  MOVWF  7A
003B:  MOVF   27,W
003C:  BSF    03.6
003D:  MOVWF  0D
003E:  BCF    03.6
003F:  MOVF   28,W
0040:  BSF    03.6
0041:  MOVWF  0F
0042:  BCF    03.6
0043:  MOVF   29,W
0044:  BSF    03.6
0045:  MOVWF  0C
0046:  BCF    03.6
0047:  MOVF   2A,W
0048:  BSF    03.6
0049:  MOVWF  0E
004A:  BCF    03.6
004B:  MOVF   20,W
004C:  MOVWF  0A
004D:  SWAPF  21,W
004E:  MOVWF  03
004F:  SWAPF  7F,F
0050:  SWAPF  7F,W
0051:  RETFIE
0052:  BCF    0A.3
0053:  BCF    0A.4
0054:  GOTO   0D2
0055:  BCF    0A.3
0056:  BCF    0A.4
0057:  GOTO   103
....................  
.................... #INCLUDE <thuvien.c> 
.................... #INCLUDE <16F887.H> 
.................... //////////// Standard Header file for the PIC16F887 device //////////////// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2013 Custom Computer Services          //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... #device PIC16F887 
0058:  BCF    0A.0
0059:  BCF    0A.1
005A:  BCF    0A.2
005B:  ADDWF  02,F
005C:  RETLW  30
005D:  RETLW  00
005E:  BCF    0A.0
005F:  BCF    0A.1
0060:  BCF    0A.2
0061:  ADDWF  02,F
0062:  RETLW  5F
0063:  RETLW  00
0064:  DATA CE,27
0065:  DATA C4,22
0066:  DATA 3A,10
0067:  DATA 00,00
0068:  DATA 30,18
0069:  DATA 30,18
006A:  DATA 20,10
006B:  DATA 20,10
006C:  DATA 20,10
006D:  DATA 20,10
006E:  DATA 20,10
006F:  DATA 00,01
0070:  DATA 20,10
0071:  DATA 20,10
0072:  DATA 20,10
0073:  DATA 5F,10
0074:  DATA 20,10
0075:  DATA 20,10
0076:  DATA 20,10
0077:  DATA 20,10
0078:  DATA 20,10
0079:  DATA 20,10
007A:  DATA 20,00
007B:  DATA 20,10
007C:  DATA 20,10
007D:  DATA 5F,10
007E:  DATA 20,10
007F:  DATA 20,00
0080:  DATA 49,22
0081:  DATA DF,23
0082:  DATA 57,1D
0083:  DATA 00,01
0084:  DATA 30,18
0085:  DATA 30,18
0086:  DATA 30,18
0087:  DATA 20,10
0088:  DATA 20,10
0089:  DATA 20,10
008A:  DATA 20,10
008B:  DATA 00,01
008C:  DATA 20,10
008D:  DATA 20,10
008E:  DATA 20,10
008F:  DATA 5F,10
0090:  DATA 20,10
0091:  DATA 20,10
0092:  DATA 20,10
0093:  DATA 20,10
0094:  DATA 20,10
0095:  DATA 20,10
0096:  DATA 20,10
0097:  DATA 20,00
0098:  DATA 20,10
0099:  DATA 20,10
009A:  DATA 5F,10
009B:  DATA 20,10
009C:  DATA 20,00
009D:  DATA C3,27
009E:  DATA 4E,23
009F:  DATA C9,23
00A0:  DATA 3A,10
00A1:  DATA 20,10
00A2:  DATA 20,10
00A3:  DATA 20,10
00A4:  DATA 20,00
00A5:  DATA C3,20
00A6:  DATA D3,22
00A7:  DATA 3A,10
00A8:  DATA 20,10
00A9:  DATA 20,10
00AA:  DATA 20,10
00AB:  DATA 20,10
00AC:  DATA 20,00
00AD:  DATA A0,16
00AE:  DATA A0,24
00AF:  DATA C4,16
00B0:  DATA CE,27
00B1:  DATA C4,22
00B2:  DATA 20,10
00B3:  DATA 20,10
00B4:  DATA 20,10
00B5:  DATA 00,01
00B6:  DATA A0,16
00B7:  DATA A0,24
00B8:  DATA C4,16
00B9:  DATA C7,2B
00BA:  DATA 20,10
00BB:  DATA 20,10
00BC:  DATA 20,10
00BD:  DATA 20,00
00BE:  DATA C3,27
00BF:  DATA 4E,23
00C0:  DATA C9,23
00C1:  DATA 20,22
00C2:  DATA 4F,27
00C3:  DATA 45,10
00C4:  DATA 20,10
00C5:  DATA 20,10
00C6:  DATA 20,10
00C7:  DATA 20,00
00C8:  DATA C3,27
00C9:  DATA 4E,23
00CA:  DATA C9,23
00CB:  DATA 20,22
00CC:  DATA 4F,27
00CD:  DATA 45,10
00CE:  DATA 20,10
00CF:  DATA 20,10
00D0:  DATA 20,10
00D1:  DATA 20,00
*
02DF:  MOVF   0B,W
02E0:  BSF    03.5
02E1:  MOVWF  55
02E2:  BCF    03.5
02E3:  BCF    0B.7
02E4:  BSF    03.5
02E5:  BSF    03.6
02E6:  BSF    0C.7
02E7:  BSF    0C.0
02E8:  NOP
02E9:  NOP
02EA:  BCF    03.6
02EB:  BTFSS  55.7
02EC:  GOTO   2F0
02ED:  BCF    03.5
02EE:  BSF    0B.7
02EF:  BSF    03.5
02F0:  BCF    03.5
02F1:  BSF    03.6
02F2:  MOVF   0C,W
02F3:  ANDLW  7F
02F4:  BTFSC  03.2
02F5:  GOTO   351
02F6:  BSF    03.5
02F7:  BCF    03.6
02F8:  MOVWF  55
02F9:  BCF    03.5
02FA:  BSF    03.6
02FB:  MOVF   0D,W
02FC:  BSF    03.5
02FD:  BCF    03.6
02FE:  MOVWF  56
02FF:  BCF    03.5
0300:  BSF    03.6
0301:  MOVF   0F,W
0302:  BSF    03.5
0303:  BCF    03.6
0304:  MOVWF  57
0305:  MOVF   55,W
0306:  MOVWF  58
0307:  BCF    03.5
0308:  CALL   2A5
0309:  BSF    03.5
030A:  MOVF   56,W
030B:  BCF    03.5
030C:  BSF    03.6
030D:  MOVWF  0D
030E:  BSF    03.5
030F:  BCF    03.6
0310:  MOVF   57,W
0311:  BCF    03.5
0312:  BSF    03.6
0313:  MOVWF  0F
0314:  BCF    03.6
0315:  MOVF   0B,W
0316:  BSF    03.5
0317:  MOVWF  58
0318:  BCF    03.5
0319:  BCF    0B.7
031A:  BSF    03.5
031B:  BSF    03.6
031C:  BSF    0C.7
031D:  BSF    0C.0
031E:  NOP
031F:  NOP
0320:  BCF    03.6
0321:  BTFSS  58.7
0322:  GOTO   326
0323:  BCF    03.5
0324:  BSF    0B.7
0325:  BSF    03.5
0326:  BCF    03.5
0327:  BSF    03.6
0328:  RLF    0C,W
0329:  RLF    0E,W
032A:  ANDLW  7F
032B:  BTFSC  03.2
032C:  GOTO   351
032D:  BSF    03.5
032E:  BCF    03.6
032F:  MOVWF  55
0330:  BCF    03.5
0331:  BSF    03.6
0332:  MOVF   0D,W
0333:  BSF    03.5
0334:  BCF    03.6
0335:  MOVWF  56
0336:  BCF    03.5
0337:  BSF    03.6
0338:  MOVF   0F,W
0339:  BSF    03.5
033A:  BCF    03.6
033B:  MOVWF  57
033C:  MOVF   55,W
033D:  MOVWF  58
033E:  BCF    03.5
033F:  CALL   2A5
0340:  BSF    03.5
0341:  MOVF   56,W
0342:  BCF    03.5
0343:  BSF    03.6
0344:  MOVWF  0D
0345:  BSF    03.5
0346:  BCF    03.6
0347:  MOVF   57,W
0348:  BCF    03.5
0349:  BSF    03.6
034A:  MOVWF  0F
034B:  INCF   0D,F
034C:  BTFSC  03.2
034D:  INCF   0F,F
034E:  BCF    03.6
034F:  GOTO   2DF
0350:  BSF    03.6
0351:  BCF    03.6
0352:  RETURN
0353:  BTFSC  03.1
0354:  GOTO   358
0355:  MOVLW  20
0356:  MOVWF  04
0357:  BSF    03.7
0358:  BSF    03.6
0359:  MOVF   1B,W
035A:  XORWF  1F,W
035B:  ANDLW  80
035C:  MOVWF  25
035D:  BTFSS  1B.7
035E:  GOTO   36A
035F:  COMF   18,F
0360:  COMF   19,F
0361:  COMF   1A,F
0362:  COMF   1B,F
0363:  INCF   18,F
0364:  BTFSC  03.2
0365:  INCF   19,F
0366:  BTFSC  03.2
0367:  INCF   1A,F
0368:  BTFSC  03.2
0369:  INCF   1B,F
036A:  BTFSS  1F.7
036B:  GOTO   377
036C:  COMF   1C,F
036D:  COMF   1D,F
036E:  COMF   1E,F
036F:  COMF   1F,F
0370:  INCF   1C,F
0371:  BTFSC  03.2
0372:  INCF   1D,F
0373:  BTFSC  03.2
0374:  INCF   1E,F
0375:  BTFSC  03.2
0376:  INCF   1F,F
0377:  CLRF   77
0378:  CLRF   78
0379:  CLRF   79
037A:  CLRF   7A
037B:  CLRF   20
037C:  CLRF   21
037D:  CLRF   22
037E:  CLRF   23
037F:  MOVF   1F,W
0380:  IORWF  1E,W
0381:  IORWF  1D,W
0382:  IORWF  1C,W
0383:  BTFSC  03.2
0384:  GOTO   3B5
0385:  MOVLW  20
0386:  MOVWF  24
0387:  BCF    03.0
0388:  RLF    18,F
0389:  RLF    19,F
038A:  RLF    1A,F
038B:  RLF    1B,F
038C:  RLF    20,F
038D:  RLF    21,F
038E:  RLF    22,F
038F:  RLF    23,F
0390:  MOVF   1F,W
0391:  SUBWF  23,W
0392:  BTFSS  03.2
0393:  GOTO   39E
0394:  MOVF   1E,W
0395:  SUBWF  22,W
0396:  BTFSS  03.2
0397:  GOTO   39E
0398:  MOVF   1D,W
0399:  SUBWF  21,W
039A:  BTFSS  03.2
039B:  GOTO   39E
039C:  MOVF   1C,W
039D:  SUBWF  20,W
039E:  BTFSS  03.0
039F:  GOTO   3AF
03A0:  MOVF   1C,W
03A1:  SUBWF  20,F
03A2:  MOVF   1D,W
03A3:  BTFSS  03.0
03A4:  INCFSZ 1D,W
03A5:  SUBWF  21,F
03A6:  MOVF   1E,W
03A7:  BTFSS  03.0
03A8:  INCFSZ 1E,W
03A9:  SUBWF  22,F
03AA:  MOVF   1F,W
03AB:  BTFSS  03.0
03AC:  INCFSZ 1F,W
03AD:  SUBWF  23,F
03AE:  BSF    03.0
03AF:  RLF    77,F
03B0:  RLF    78,F
03B1:  RLF    79,F
03B2:  RLF    7A,F
03B3:  DECFSZ 24,F
03B4:  GOTO   387
03B5:  BTFSS  25.7
03B6:  GOTO   3C2
03B7:  COMF   77,F
03B8:  COMF   78,F
03B9:  COMF   79,F
03BA:  COMF   7A,F
03BB:  INCF   77,F
03BC:  BTFSC  03.2
03BD:  INCF   78,F
03BE:  BTFSC  03.2
03BF:  INCF   79,F
03C0:  BTFSC  03.2
03C1:  INCF   7A,F
03C2:  MOVF   20,W
03C3:  MOVWF  00
03C4:  INCF   04,F
03C5:  MOVF   21,W
03C6:  MOVWF  00
03C7:  INCF   04,F
03C8:  MOVF   22,W
03C9:  MOVWF  00
03CA:  INCF   04,F
03CB:  MOVF   23,W
03CC:  MOVWF  00
03CD:  BCF    03.6
03CE:  RETURN
*
03F6:  MOVLW  20
03F7:  MOVWF  1C
03F8:  CLRF   18
03F9:  CLRF   19
03FA:  CLRF   1A
03FB:  CLRF   1B
03FC:  MOVF   13,W
03FD:  MOVWF  7A
03FE:  MOVF   12,W
03FF:  MOVWF  79
0400:  MOVF   11,W
0401:  MOVWF  78
0402:  MOVF   10,W
0403:  MOVWF  77
0404:  BCF    03.0
0405:  BTFSS  77.0
0406:  GOTO   415
0407:  MOVF   14,W
0408:  ADDWF  18,F
0409:  MOVF   15,W
040A:  BTFSC  03.0
040B:  INCFSZ 15,W
040C:  ADDWF  19,F
040D:  MOVF   16,W
040E:  BTFSC  03.0
040F:  INCFSZ 16,W
0410:  ADDWF  1A,F
0411:  MOVF   17,W
0412:  BTFSC  03.0
0413:  INCFSZ 17,W
0414:  ADDWF  1B,F
0415:  RRF    1B,F
0416:  RRF    1A,F
0417:  RRF    19,F
0418:  RRF    18,F
0419:  RRF    7A,F
041A:  RRF    79,F
041B:  RRF    78,F
041C:  RRF    77,F
041D:  DECFSZ 1C,F
041E:  GOTO   404
*
0531:  MOVF   00,F
0532:  BTFSC  03.2
0533:  GOTO   54D
0534:  BSF    03.5
0535:  CLRF   56
0536:  MOVF   04,W
0537:  MOVWF  55
0538:  BCF    56.0
0539:  BTFSC  03.7
053A:  BSF    56.0
053B:  MOVF   00,W
053C:  MOVWF  58
053D:  BCF    03.5
053E:  CALL   2A5
053F:  BSF    03.5
0540:  MOVF   55,W
0541:  MOVWF  04
0542:  BCF    03.7
0543:  BTFSC  56.0
0544:  BSF    03.7
0545:  INCF   04,F
0546:  BTFSS  03.2
0547:  GOTO   54B
0548:  BCF    03.5
0549:  INCF   05,F
054A:  BSF    03.5
054B:  BCF    03.5
054C:  GOTO   531
054D:  RETURN
054E:  BSF    03.5
054F:  MOVF   59,W
0550:  CLRF   78
0551:  SUBWF  58,W
0552:  BTFSC  03.0
0553:  GOTO   557
0554:  MOVF   58,W
0555:  MOVWF  77
0556:  GOTO   563
0557:  CLRF   77
0558:  MOVLW  08
0559:  MOVWF  5A
055A:  RLF    58,F
055B:  RLF    77,F
055C:  MOVF   59,W
055D:  SUBWF  77,W
055E:  BTFSC  03.0
055F:  MOVWF  77
0560:  RLF    78,F
0561:  DECFSZ 5A,F
0562:  GOTO   55A
0563:  BCF    03.5
0564:  RETURN
*
07CD:  BSF    03.5
07CE:  MOVF   54,W
07CF:  ANDLW  07
07D0:  MOVWF  77
07D1:  RRF    54,W
07D2:  MOVWF  78
07D3:  RRF    78,F
07D4:  RRF    78,F
07D5:  MOVLW  1F
07D6:  ANDWF  78,F
07D7:  MOVF   78,W
07D8:  ADDWF  56,W
07D9:  MOVWF  04
07DA:  BCF    03.7
07DB:  BTFSC  57.0
07DC:  BSF    03.7
07DD:  CLRF   78
07DE:  INCF   78,F
07DF:  INCF   77,F
07E0:  GOTO   7E2
07E1:  RLF    78,F
07E2:  DECFSZ 77,F
07E3:  GOTO   7E1
07E4:  MOVF   55,F
07E5:  BTFSC  03.2
07E6:  GOTO   7EA
07E7:  MOVF   78,W
07E8:  IORWF  00,F
07E9:  GOTO   7ED
07EA:  COMF   78,F
07EB:  MOVF   78,W
07EC:  ANDWF  00,F
07ED:  BCF    03.5
07EE:  RETURN
*
090B:  MOVF   00,F
090C:  BTFSC  03.2
090D:  GOTO   126
090E:  CLRF   58
090F:  MOVF   04,W
0910:  MOVWF  57
0911:  BCF    58.0
0912:  BTFSC  03.7
0913:  BSF    58.0
0914:  MOVF   00,W
0915:  BCF    03.5
0916:  BTFSS  0C.4
0917:  GOTO   116
0918:  MOVWF  19
0919:  BSF    03.5
091A:  MOVF   57,W
091B:  MOVWF  04
091C:  BCF    03.7
091D:  BTFSC  58.0
091E:  BSF    03.7
091F:  INCF   04,F
0920:  BTFSS  03.2
0921:  GOTO   125
0922:  BCF    03.5
0923:  INCF   05,F
0924:  BSF    03.5
0925:  GOTO   10B
*
0AC2:  CLRF   77
0AC3:  CLRF   78
0AC4:  MOVF   5B,W
0AC5:  BCF    03.0
0AC6:  BTFSC  5C.0
0AC7:  ADDWF  77,F
0AC8:  RRF    77,F
0AC9:  RRF    78,F
0ACA:  BTFSC  5C.1
0ACB:  ADDWF  77,F
0ACC:  RRF    77,F
0ACD:  RRF    78,F
0ACE:  BTFSC  5C.2
0ACF:  ADDWF  77,F
0AD0:  RRF    77,F
0AD1:  RRF    78,F
0AD2:  BTFSC  5C.3
0AD3:  ADDWF  77,F
0AD4:  RRF    77,F
0AD5:  RRF    78,F
0AD6:  BTFSC  5C.4
0AD7:  ADDWF  77,F
0AD8:  RRF    77,F
0AD9:  RRF    78,F
0ADA:  BTFSC  5C.5
0ADB:  ADDWF  77,F
0ADC:  RRF    77,F
0ADD:  RRF    78,F
0ADE:  BTFSC  5C.6
0ADF:  ADDWF  77,F
0AE0:  RRF    77,F
0AE1:  RRF    78,F
0AE2:  BTFSC  5C.7
0AE3:  ADDWF  77,F
0AE4:  RRF    77,F
0AE5:  RRF    78,F
*
0D10:  BSF    0A.0
0D11:  BCF    0A.1
0D12:  BSF    0A.2
0D13:  ADDWF  02,F
0D14:  GOTO   4B1
0D15:  GOTO   4B2
0D16:  GOTO   4BC
0D17:  GOTO   4C7
....................  
.................... #list 
....................  
.................... #DEVICE ADC=10 
.................... #INCLUDE <STRING.H> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
*
0762:  BSF    03.5
0763:  MOVF   57,W
0764:  MOVWF  5B
0765:  MOVF   56,W
0766:  MOVWF  5A
0767:  MOVF   5B,W
0768:  MOVWF  7A
0769:  MOVF   5A,W
076A:  MOVWF  04
076B:  BCF    03.7
076C:  BTFSC  7A.0
076D:  BSF    03.7
076E:  MOVF   00,F
076F:  BTFSC  03.2
0770:  GOTO   775
0771:  INCF   5A,F
0772:  BTFSC  03.2
0773:  INCF   5B,F
0774:  GOTO   767
....................    while(*s2 != '\0') 
0775:  MOVF   59,W
0776:  MOVWF  7A
0777:  MOVF   58,W
0778:  MOVWF  04
0779:  BCF    03.7
077A:  BTFSC  7A.0
077B:  BSF    03.7
077C:  MOVF   00,F
077D:  BTFSC  03.2
077E:  GOTO   794
....................    { 
....................       *s = *s2; 
077F:  MOVF   58,W
0780:  MOVWF  04
0781:  BCF    03.7
0782:  BTFSC  59.0
0783:  BSF    03.7
0784:  MOVF   00,W
0785:  MOVWF  5E
0786:  MOVF   5A,W
0787:  MOVWF  04
0788:  BCF    03.7
0789:  BTFSC  5B.0
078A:  BSF    03.7
078B:  MOVF   5E,W
078C:  MOVWF  00
....................       ++s; 
078D:  INCF   5A,F
078E:  BTFSC  03.2
078F:  INCF   5B,F
....................       ++s2; 
0790:  INCF   58,F
0791:  BTFSC  03.2
0792:  INCF   59,F
0793:  GOTO   775
....................    } 
....................  
....................    *s = '\0'; 
0794:  MOVF   5A,W
0795:  MOVWF  04
0796:  BCF    03.7
0797:  BTFSC  5B.0
0798:  BSF    03.7
0799:  CLRF   00
....................    return(s1); 
079A:  MOVF   56,W
079B:  MOVWF  78
079C:  MOVF   57,W
079D:  MOVWF  79
079E:  BCF    03.5
079F:  RETURN
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
*
09EE:  MOVF   5D,W
09EF:  MOVWF  61
09F0:  MOVF   5C,W
09F1:  MOVWF  60
09F2:  MOVF   61,W
09F3:  MOVWF  7A
09F4:  MOVF   60,W
09F5:  MOVWF  04
09F6:  BCF    03.7
09F7:  BTFSC  7A.0
09F8:  BSF    03.7
09F9:  MOVF   00,F
09FA:  BTFSC  03.2
09FB:  GOTO   22B
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
09FC:  MOVF   5F,W
09FD:  MOVWF  63
09FE:  MOVF   5E,W
09FF:  MOVWF  62
0A00:  MOVF   63,W
0A01:  MOVWF  7A
0A02:  MOVF   62,W
0A03:  MOVWF  04
0A04:  BCF    03.7
0A05:  BTFSC  7A.0
0A06:  BSF    03.7
0A07:  MOVF   00,F
0A08:  BTFSC  03.2
0A09:  GOTO   227
....................          if (*sc1 == *sc2) 
0A0A:  MOVF   61,W
0A0B:  MOVWF  7A
0A0C:  MOVF   60,W
0A0D:  MOVWF  04
0A0E:  BCF    03.7
0A0F:  BTFSC  7A.0
0A10:  BSF    03.7
0A11:  MOVF   00,W
0A12:  MOVWF  64
0A13:  MOVF   63,W
0A14:  MOVWF  7A
0A15:  MOVF   62,W
0A16:  MOVWF  04
0A17:  BCF    03.7
0A18:  BTFSC  7A.0
0A19:  BSF    03.7
0A1A:  MOVF   00,W
0A1B:  SUBWF  64,W
0A1C:  BTFSS  03.2
0A1D:  GOTO   223
....................             return(sc1); 
0A1E:  MOVF   60,W
0A1F:  MOVWF  78
0A20:  MOVF   61,W
0A21:  MOVWF  79
0A22:  GOTO   22E
0A23:  INCF   62,F
0A24:  BTFSC  03.2
0A25:  INCF   63,F
0A26:  GOTO   200
0A27:  INCF   60,F
0A28:  BTFSC  03.2
0A29:  INCF   61,F
0A2A:  GOTO   1F2
....................    return(0); 
0A2B:  MOVLW  00
0A2C:  MOVWF  78
0A2D:  MOVWF  79
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
*
097B:  MOVF   5D,W
097C:  MOVWF  61
097D:  MOVF   5C,W
097E:  MOVWF  60
097F:  MOVF   61,W
0980:  MOVWF  7A
0981:  MOVF   60,W
0982:  MOVWF  04
0983:  BCF    03.7
0984:  BTFSC  7A.0
0985:  BSF    03.7
0986:  MOVF   00,F
0987:  BTFSC  03.2
0988:  GOTO   1C0
....................       for (sc2 = s2; ; sc2++) 
0989:  MOVF   5F,W
098A:  MOVWF  63
098B:  MOVF   5E,W
098C:  MOVWF  62
....................     if (*sc2 == '\0') 
098D:  MOVF   63,W
098E:  MOVWF  7A
098F:  MOVF   62,W
0990:  MOVWF  04
0991:  BCF    03.7
0992:  BTFSC  7A.0
0993:  BSF    03.7
0994:  MOVF   00,F
0995:  BTFSS  03.2
0996:  GOTO   1A4
....................        return(sc1 - s1); 
0997:  MOVF   5C,W
0998:  SUBWF  60,W
0999:  MOVWF  77
099A:  MOVF   61,W
099B:  MOVWF  7A
099C:  MOVF   5D,W
099D:  BTFSS  03.0
099E:  INCFSZ 5D,W
099F:  SUBWF  7A,F
09A0:  MOVF   77,W
09A1:  MOVWF  78
09A2:  GOTO   1CB
09A3:  GOTO   1B8
....................          else if (*sc1 == *sc2) 
09A4:  MOVF   61,W
09A5:  MOVWF  7A
09A6:  MOVF   60,W
09A7:  MOVWF  04
09A8:  BCF    03.7
09A9:  BTFSC  7A.0
09AA:  BSF    03.7
09AB:  MOVF   00,W
09AC:  MOVWF  64
09AD:  MOVF   63,W
09AE:  MOVWF  7A
09AF:  MOVF   62,W
09B0:  MOVWF  04
09B1:  BCF    03.7
09B2:  BTFSC  7A.0
09B3:  BSF    03.7
09B4:  MOVF   00,W
09B5:  SUBWF  64,W
09B6:  BTFSC  03.2
....................             break; 
09B7:  GOTO   1BC
09B8:  INCF   62,F
09B9:  BTFSC  03.2
09BA:  INCF   63,F
09BB:  GOTO   18D
09BC:  INCF   60,F
09BD:  BTFSC  03.2
09BE:  INCF   61,F
09BF:  GOTO   17F
....................    return(sc1 - s1); 
09C0:  MOVF   5C,W
09C1:  SUBWF  60,W
09C2:  MOVWF  77
09C3:  MOVF   61,W
09C4:  MOVWF  7A
09C5:  MOVF   5D,W
09C6:  BTFSS  03.0
09C7:  INCFSZ 5D,W
09C8:  SUBWF  7A,F
09C9:  MOVF   77,W
09CA:  MOVWF  78
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
*
0B81:  BCF    03.6
0B82:  CLRF   2B
0B83:  CLRF   2C
....................  
....................    beg = (s1)? s1: save; 
*
0962:  BSF    03.5
0963:  MOVF   54,W
0964:  IORWF  55,W
0965:  BTFSC  03.2
0966:  GOTO   16B
0967:  MOVF   55,W
0968:  MOVWF  7A
0969:  MOVF   54,W
096A:  GOTO   170
096B:  BCF    03.5
096C:  MOVF   2C,W
096D:  MOVWF  7A
096E:  MOVF   2B,W
096F:  BSF    03.5
0970:  MOVWF  58
0971:  MOVF   7A,W
0972:  MOVWF  59
....................    beg += strspn(beg, s2); 
0973:  MOVF   59,W
0974:  MOVWF  5D
0975:  MOVF   58,W
0976:  MOVWF  5C
0977:  MOVF   57,W
0978:  MOVWF  5F
0979:  MOVF   56,W
097A:  MOVWF  5E
*
09CB:  MOVF   78,W
09CC:  ADDWF  58,F
09CD:  BTFSC  03.0
09CE:  INCF   59,F
....................    if (*beg == '\0') 
09CF:  MOVF   59,W
09D0:  MOVWF  7A
09D1:  MOVF   58,W
09D2:  MOVWF  04
09D3:  BCF    03.7
09D4:  BTFSC  7A.0
09D5:  BSF    03.7
09D6:  MOVF   00,F
09D7:  BTFSS  03.2
09D8:  GOTO   1E6
....................    { 
....................       *save = ' '; 
09D9:  BCF    03.5
09DA:  MOVF   2B,W
09DB:  MOVWF  04
09DC:  BCF    03.7
09DD:  BTFSC  2C.0
09DE:  BSF    03.7
09DF:  MOVLW  20
09E0:  MOVWF  00
....................       return(0); 
09E1:  MOVLW  00
09E2:  MOVWF  78
09E3:  MOVWF  79
09E4:  GOTO   252
09E5:  BSF    03.5
....................    } 
....................    end = strpbrk(beg, s2); 
09E6:  MOVF   59,W
09E7:  MOVWF  5D
09E8:  MOVF   58,W
09E9:  MOVWF  5C
09EA:  MOVF   57,W
09EB:  MOVWF  5F
09EC:  MOVF   56,W
09ED:  MOVWF  5E
*
0A2E:  MOVF   79,W
0A2F:  MOVWF  5B
0A30:  MOVF   78,W
0A31:  MOVWF  5A
....................    if (*end != '\0') 
0A32:  MOVF   5B,W
0A33:  MOVWF  7A
0A34:  MOVF   5A,W
0A35:  MOVWF  04
0A36:  BCF    03.7
0A37:  BTFSC  7A.0
0A38:  BSF    03.7
0A39:  MOVF   00,F
0A3A:  BTFSC  03.2
0A3B:  GOTO   245
....................    { 
....................       *end = '\0'; 
0A3C:  MOVF   5A,W
0A3D:  MOVWF  04
0A3E:  BCF    03.7
0A3F:  BTFSC  5B.0
0A40:  BSF    03.7
0A41:  CLRF   00
....................       end++; 
0A42:  INCF   5A,F
0A43:  BTFSC  03.2
0A44:  INCF   5B,F
....................    } 
....................    save = end; 
0A45:  MOVF   5B,W
0A46:  BCF    03.5
0A47:  MOVWF  2C
0A48:  BSF    03.5
0A49:  MOVF   5A,W
0A4A:  BCF    03.5
0A4B:  MOVWF  2B
....................    return(beg); 
0A4C:  BSF    03.5
0A4D:  MOVF   58,W
0A4E:  MOVWF  78
0A4F:  MOVF   59,W
0A50:  MOVWF  79
0A51:  BCF    03.5
0A52:  RETURN
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
*
08BB:  MOVF   58,W
08BC:  MOVWF  5A
08BD:  MOVF   57,W
08BE:  MOVWF  59
08BF:  MOVF   5A,W
08C0:  MOVWF  7A
08C1:  MOVF   59,W
08C2:  MOVWF  04
08C3:  BCF    03.7
08C4:  BTFSC  7A.0
08C5:  BSF    03.7
08C6:  MOVF   00,F
08C7:  BTFSC  03.2
08C8:  GOTO   0CD
08C9:  INCF   59,F
08CA:  BTFSC  03.2
08CB:  INCF   5A,F
08CC:  GOTO   0BF
....................    return(sc - s); 
08CD:  MOVF   57,W
08CE:  SUBWF  59,W
08CF:  MOVWF  77
08D0:  MOVF   5A,W
08D1:  MOVWF  7A
08D2:  MOVF   58,W
08D3:  BTFSS  03.0
08D4:  INCFSZ 58,W
08D5:  SUBWF  7A,F
08D6:  MOVF   77,W
08D7:  MOVWF  78
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #INCLUDE <STDLIB.H> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... /* Standart template: float strtof(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... float strtof(char *s,char *endptr); 
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s,char *endptr); 
.................... float64 strtod(char *s,char *endptr); 
.................... #else 
.................... //provided for compatibility 
.................... #define strtof48(s, e) strtof(s, e) 
.................... #define strtod(s, e) strtof(s, e) 
.................... #endif 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof(s)   strtof(s, 0) 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof48(s) strtof48(s, 0) 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof64(s) strtod(s, 0) 
.................... #endif 
....................  
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float atoe(char * s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s); 
.................... #endif 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... unsigned int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................  
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
*
0A53:  BSF    03.5
0A54:  CLRF   59
....................    sign = 0; 
0A55:  CLRF   57
....................    base = 10; 
0A56:  MOVLW  0A
0A57:  MOVWF  58
....................    result = 0; 
0A58:  CLRF   56
....................  
....................    if (!s) 
0A59:  MOVF   54,W
0A5A:  IORWF  55,W
0A5B:  BTFSS  03.2
0A5C:  GOTO   260
....................       return 0; 
0A5D:  MOVLW  00
0A5E:  MOVWF  78
0A5F:  GOTO   353
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
0A60:  MOVF   59,W
0A61:  INCF   59,F
0A62:  ADDWF  54,W
0A63:  MOVWF  04
0A64:  BCF    03.7
0A65:  BTFSC  55.0
0A66:  BSF    03.7
0A67:  MOVF   00,W
0A68:  MOVWF  5A
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
0A69:  MOVF   5A,W
0A6A:  SUBLW  2D
0A6B:  BTFSS  03.2
0A6C:  GOTO   279
....................    { 
....................       sign = 1;         // Set the sign to negative 
0A6D:  MOVLW  01
0A6E:  MOVWF  57
....................       c = s[index++]; 
0A6F:  MOVF   59,W
0A70:  INCF   59,F
0A71:  ADDWF  54,W
0A72:  MOVWF  04
0A73:  BCF    03.7
0A74:  BTFSC  55.0
0A75:  BSF    03.7
0A76:  MOVF   00,W
0A77:  MOVWF  5A
....................    } 
0A78:  GOTO   286
....................    else if (c == '+') 
0A79:  MOVF   5A,W
0A7A:  SUBLW  2B
0A7B:  BTFSS  03.2
0A7C:  GOTO   286
....................    { 
....................       c = s[index++]; 
0A7D:  MOVF   59,W
0A7E:  INCF   59,F
0A7F:  ADDWF  54,W
0A80:  MOVWF  04
0A81:  BCF    03.7
0A82:  BTFSC  55.0
0A83:  BSF    03.7
0A84:  MOVF   00,W
0A85:  MOVWF  5A
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
0A86:  MOVF   5A,W
0A87:  SUBLW  2F
0A88:  BTFSC  03.0
0A89:  GOTO   349
0A8A:  MOVF   5A,W
0A8B:  SUBLW  39
0A8C:  BTFSS  03.0
0A8D:  GOTO   349
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
0A8E:  MOVF   5A,W
0A8F:  SUBLW  30
0A90:  BTFSS  03.2
0A91:  GOTO   2B2
0A92:  MOVF   59,W
0A93:  ADDWF  54,W
0A94:  MOVWF  04
0A95:  BCF    03.7
0A96:  BTFSC  55.0
0A97:  BSF    03.7
0A98:  MOVF   00,W
0A99:  SUBLW  78
0A9A:  BTFSC  03.2
0A9B:  GOTO   2A6
0A9C:  MOVF   59,W
0A9D:  ADDWF  54,W
0A9E:  MOVWF  04
0A9F:  BCF    03.7
0AA0:  BTFSC  55.0
0AA1:  BSF    03.7
0AA2:  MOVF   00,W
0AA3:  SUBLW  58
0AA4:  BTFSS  03.2
0AA5:  GOTO   2B2
....................       { 
....................          base = 16; 
0AA6:  MOVLW  10
0AA7:  MOVWF  58
....................          index++; 
0AA8:  INCF   59,F
....................          c = s[index++]; 
0AA9:  MOVF   59,W
0AAA:  INCF   59,F
0AAB:  ADDWF  54,W
0AAC:  MOVWF  04
0AAD:  BCF    03.7
0AAE:  BTFSC  55.0
0AAF:  BSF    03.7
0AB0:  MOVF   00,W
0AB1:  MOVWF  5A
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
0AB2:  MOVF   58,W
0AB3:  SUBLW  0A
0AB4:  BTFSS  03.2
0AB5:  GOTO   2F7
....................       { 
....................          while (c >= '0' && c <= '9') 
0AB6:  MOVF   5A,W
0AB7:  SUBLW  2F
0AB8:  BTFSC  03.0
0AB9:  GOTO   2F6
0ABA:  MOVF   5A,W
0ABB:  SUBLW  39
0ABC:  BTFSS  03.0
0ABD:  GOTO   2F6
....................          { 
....................             result = 10*result + (c - '0'); 
0ABE:  MOVLW  0A
0ABF:  MOVWF  5B
0AC0:  MOVF   56,W
0AC1:  MOVWF  5C
*
0AE6:  MOVF   78,W
0AE7:  MOVWF  5B
0AE8:  MOVLW  30
0AE9:  SUBWF  5A,W
0AEA:  ADDWF  5B,W
0AEB:  MOVWF  56
....................             c = s[index++]; 
0AEC:  MOVF   59,W
0AED:  INCF   59,F
0AEE:  ADDWF  54,W
0AEF:  MOVWF  04
0AF0:  BCF    03.7
0AF1:  BTFSC  55.0
0AF2:  BSF    03.7
0AF3:  MOVF   00,W
0AF4:  MOVWF  5A
0AF5:  GOTO   2B6
....................          } 
....................       } 
0AF6:  GOTO   349
....................       else if (base == 16)    // The number is a hexa number 
0AF7:  MOVF   58,W
0AF8:  SUBLW  10
0AF9:  BTFSS  03.2
0AFA:  GOTO   349
....................       { 
....................          c = toupper(c); 
0AFB:  MOVF   5A,W
0AFC:  SUBLW  60
0AFD:  BTFSC  03.0
0AFE:  GOTO   306
0AFF:  MOVF   5A,W
0B00:  SUBLW  7A
0B01:  BTFSS  03.0
0B02:  GOTO   306
0B03:  MOVF   5A,W
0B04:  ANDLW  DF
0B05:  GOTO   307
0B06:  MOVF   5A,W
0B07:  MOVWF  5A
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
0B08:  MOVF   5A,W
0B09:  SUBLW  2F
0B0A:  BTFSC  03.0
0B0B:  GOTO   310
0B0C:  MOVF   5A,W
0B0D:  SUBLW  39
0B0E:  BTFSC  03.0
0B0F:  GOTO   318
0B10:  MOVF   5A,W
0B11:  SUBLW  40
0B12:  BTFSC  03.0
0B13:  GOTO   349
0B14:  MOVF   5A,W
0B15:  SUBLW  46
0B16:  BTFSS  03.0
0B17:  GOTO   349
....................          { 
....................             if (c >= '0' && c <= '9') 
0B18:  MOVF   5A,W
0B19:  SUBLW  2F
0B1A:  BTFSC  03.0
0B1B:  GOTO   329
0B1C:  MOVF   5A,W
0B1D:  SUBLW  39
0B1E:  BTFSS  03.0
0B1F:  GOTO   329
....................                result = (result << 4) + (c - '0'); 
0B20:  SWAPF  56,W
0B21:  MOVWF  5B
0B22:  MOVLW  F0
0B23:  ANDWF  5B,F
0B24:  MOVLW  30
0B25:  SUBWF  5A,W
0B26:  ADDWF  5B,W
0B27:  MOVWF  56
0B28:  GOTO   332
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
0B29:  SWAPF  56,W
0B2A:  MOVWF  5B
0B2B:  MOVLW  F0
0B2C:  ANDWF  5B,F
0B2D:  MOVLW  41
0B2E:  SUBWF  5A,W
0B2F:  ADDLW  0A
0B30:  ADDWF  5B,W
0B31:  MOVWF  56
....................  
....................             c = s[index++]; 
0B32:  MOVF   59,W
0B33:  INCF   59,F
0B34:  ADDWF  54,W
0B35:  MOVWF  04
0B36:  BCF    03.7
0B37:  BTFSC  55.0
0B38:  BSF    03.7
0B39:  MOVF   00,W
0B3A:  MOVWF  5A
....................             c = toupper(c); 
0B3B:  MOVF   5A,W
0B3C:  SUBLW  60
0B3D:  BTFSC  03.0
0B3E:  GOTO   346
0B3F:  MOVF   5A,W
0B40:  SUBLW  7A
0B41:  BTFSS  03.0
0B42:  GOTO   346
0B43:  MOVF   5A,W
0B44:  ANDLW  DF
0B45:  GOTO   347
0B46:  MOVF   5A,W
0B47:  MOVWF  5A
0B48:  GOTO   308
....................          } 
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
0B49:  DECFSZ 57,W
0B4A:  GOTO   351
0B4B:  MOVF   58,W
0B4C:  SUBLW  0A
0B4D:  BTFSS  03.2
0B4E:  GOTO   351
....................        result = -result; 
0B4F:  COMF   56,F
0B50:  INCF   56,F
....................  
....................    return(result); 
0B51:  MOVF   56,W
0B52:  MOVWF  78
0B53:  BCF    03.5
0B54:  RETURN
.................... } 
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
*
03CF:  BSF    03.5
03D0:  CLRF   61
03D1:  CLRF   60
03D2:  CLRF   5F
03D3:  MOVLW  01
03D4:  MOVWF  5E
03D5:  CLRF   63
03D6:  CLRF   64
.................... { 
....................      unsigned int32 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
03D7:  BTFSS  5A.7
03D8:  GOTO   429
....................          sign=1;        // Check for negative number 
03D9:  MOVLW  01
03DA:  MOVWF  63
....................          num*=-1; 
03DB:  MOVF   5A,W
03DC:  BCF    03.5
03DD:  BSF    03.6
03DE:  MOVWF  13
03DF:  BSF    03.5
03E0:  BCF    03.6
03E1:  MOVF   59,W
03E2:  BCF    03.5
03E3:  BSF    03.6
03E4:  MOVWF  12
03E5:  BSF    03.5
03E6:  BCF    03.6
03E7:  MOVF   58,W
03E8:  BCF    03.5
03E9:  BSF    03.6
03EA:  MOVWF  11
03EB:  BSF    03.5
03EC:  BCF    03.6
03ED:  MOVF   57,W
03EE:  BCF    03.5
03EF:  BSF    03.6
03F0:  MOVWF  10
03F1:  MOVLW  FF
03F2:  MOVWF  17
03F3:  MOVWF  16
03F4:  MOVWF  15
03F5:  MOVWF  14
*
041F:  MOVF   7A,W
0420:  BSF    03.5
0421:  BCF    03.6
0422:  MOVWF  5A
0423:  MOVF   79,W
0424:  MOVWF  59
0425:  MOVF   78,W
0426:  MOVWF  58
0427:  MOVF   77,W
0428:  MOVWF  57
....................      } 
....................  
....................      while(temp>0) { 
0429:  MOVF   5E,F
042A:  BTFSS  03.2
042B:  GOTO   435
042C:  MOVF   5F,F
042D:  BTFSS  03.2
042E:  GOTO   435
042F:  MOVF   60,F
0430:  BTFSS  03.2
0431:  GOTO   435
0432:  MOVF   61,F
0433:  BTFSC  03.2
0434:  GOTO   4DB
....................          temp=(num/base); 
0435:  BCF    03.1
0436:  MOVF   5A,W
0437:  BCF    03.5
0438:  BSF    03.6
0439:  MOVWF  1B
043A:  BSF    03.5
043B:  BCF    03.6
043C:  MOVF   59,W
043D:  BCF    03.5
043E:  BSF    03.6
043F:  MOVWF  1A
0440:  BSF    03.5
0441:  BCF    03.6
0442:  MOVF   58,W
0443:  BCF    03.5
0444:  BSF    03.6
0445:  MOVWF  19
0446:  BSF    03.5
0447:  BCF    03.6
0448:  MOVF   57,W
0449:  BCF    03.5
044A:  BSF    03.6
044B:  MOVWF  18
044C:  CLRF   1F
044D:  CLRF   1E
044E:  CLRF   1D
044F:  BSF    03.5
0450:  BCF    03.6
0451:  MOVF   5B,W
0452:  BCF    03.5
0453:  BSF    03.6
0454:  MOVWF  1C
0455:  BCF    03.6
0456:  CALL   353
0457:  MOVF   7A,W
0458:  BSF    03.5
0459:  MOVWF  61
045A:  MOVF   79,W
045B:  MOVWF  60
045C:  MOVF   78,W
045D:  MOVWF  5F
045E:  MOVF   77,W
045F:  MOVWF  5E
....................          s[cnt]=(num%base)+'0';    // Conversion 
0460:  MOVF   64,W
0461:  ADDWF  5C,W
0462:  MOVWF  78
0463:  MOVF   5D,W
0464:  MOVWF  7A
0465:  BTFSC  03.0
0466:  INCF   7A,F
0467:  MOVF   78,W
0468:  BCF    03.5
0469:  BSF    03.6
046A:  MOVWF  10
046B:  MOVF   7A,W
046C:  MOVWF  11
046D:  CLRF   13
046E:  MOVF   04,W
046F:  MOVWF  12
0470:  BCF    13.0
0471:  BTFSC  03.7
0472:  BSF    13.0
0473:  BSF    03.1
0474:  MOVLW  14
0475:  MOVWF  04
0476:  BSF    03.7
0477:  BSF    03.5
0478:  BCF    03.6
0479:  MOVF   5A,W
047A:  BCF    03.5
047B:  BSF    03.6
047C:  MOVWF  1B
047D:  BSF    03.5
047E:  BCF    03.6
047F:  MOVF   59,W
0480:  BCF    03.5
0481:  BSF    03.6
0482:  MOVWF  1A
0483:  BSF    03.5
0484:  BCF    03.6
0485:  MOVF   58,W
0486:  BCF    03.5
0487:  BSF    03.6
0488:  MOVWF  19
0489:  BSF    03.5
048A:  BCF    03.6
048B:  MOVF   57,W
048C:  BCF    03.5
048D:  BSF    03.6
048E:  MOVWF  18
048F:  CLRF   1F
0490:  CLRF   1E
0491:  CLRF   1D
0492:  BSF    03.5
0493:  BCF    03.6
0494:  MOVF   5B,W
0495:  BCF    03.5
0496:  BSF    03.6
0497:  MOVWF  1C
0498:  BCF    03.6
0499:  CALL   353
049A:  BSF    03.6
049B:  MOVF   12,W
049C:  MOVWF  04
049D:  BCF    03.7
049E:  BTFSC  13.0
049F:  BSF    03.7
04A0:  MOVLW  30
04A1:  ADDWF  14,W
04A2:  MOVWF  77
04A3:  MOVF   15,W
04A4:  MOVWF  78
04A5:  MOVLW  00
04A6:  BTFSC  03.0
04A7:  MOVLW  01
04A8:  ADDWF  78,F
04A9:  MOVF   16,W
04AA:  MOVWF  79
04AB:  MOVLW  00
04AC:  BTFSC  03.0
04AD:  MOVLW  01
04AE:  ADDWF  79,F
04AF:  MOVF   17,W
04B0:  MOVWF  7A
04B1:  MOVLW  00
04B2:  BTFSC  03.0
04B3:  MOVLW  01
04B4:  ADDWF  7A,F
04B5:  MOVF   10,W
04B6:  MOVWF  04
04B7:  BCF    03.7
04B8:  BTFSC  11.0
04B9:  BSF    03.7
04BA:  MOVF   77,W
04BB:  MOVWF  00
....................  
....................          if(s[cnt]>0x39) 
04BC:  BSF    03.5
04BD:  BCF    03.6
04BE:  MOVF   64,W
04BF:  ADDWF  5C,W
04C0:  MOVWF  04
04C1:  BCF    03.7
04C2:  BTFSC  5D.0
04C3:  BSF    03.7
04C4:  MOVF   00,W
04C5:  SUBLW  39
04C6:  BTFSC  03.0
04C7:  GOTO   4D1
....................             s[cnt]+=0x7; 
04C8:  MOVF   64,W
04C9:  ADDWF  5C,W
04CA:  MOVWF  04
04CB:  BCF    03.7
04CC:  BTFSC  5D.0
04CD:  BSF    03.7
04CE:  MOVLW  07
04CF:  ADDWF  00,W
04D0:  MOVWF  00
....................  
....................          cnt++; 
04D1:  INCF   64,F
....................          num=temp; 
04D2:  MOVF   61,W
04D3:  MOVWF  5A
04D4:  MOVF   60,W
04D5:  MOVWF  59
04D6:  MOVF   5F,W
04D7:  MOVWF  58
04D8:  MOVF   5E,W
04D9:  MOVWF  57
04DA:  GOTO   429
....................      } 
....................  
....................      if(sign==1) { 
04DB:  DECFSZ 63,W
04DC:  GOTO   4E6
....................          s[cnt]=0x2D;      // Negative sign 
04DD:  MOVF   64,W
04DE:  ADDWF  5C,W
04DF:  MOVWF  04
04E0:  BCF    03.7
04E1:  BTFSC  5D.0
04E2:  BSF    03.7
04E3:  MOVLW  2D
04E4:  MOVWF  00
....................          cnt++; 
04E5:  INCF   64,F
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
04E6:  CLRF   62
04E7:  BCF    03.0
04E8:  RRF    64,W
04E9:  SUBWF  62,W
04EA:  BTFSC  03.0
04EB:  GOTO   524
....................  
....................          c=s[i]; 
04EC:  MOVF   62,W
04ED:  ADDWF  5C,W
04EE:  MOVWF  04
04EF:  BCF    03.7
04F0:  BTFSC  5D.0
04F1:  BSF    03.7
04F2:  MOVF   00,W
04F3:  MOVWF  65
....................          s[i]=s[cnt-i-1];        // Reverse the number 
04F4:  MOVF   62,W
04F5:  ADDWF  5C,W
04F6:  MOVWF  78
04F7:  MOVF   5D,W
04F8:  MOVWF  7A
04F9:  BTFSC  03.0
04FA:  INCF   7A,F
04FB:  MOVF   78,W
04FC:  BCF    03.5
04FD:  BSF    03.6
04FE:  MOVWF  10
04FF:  MOVF   7A,W
0500:  MOVWF  11
0501:  BSF    03.5
0502:  BCF    03.6
0503:  MOVF   62,W
0504:  SUBWF  64,W
0505:  ADDLW  FF
0506:  ADDWF  5C,W
0507:  MOVWF  04
0508:  BCF    03.7
0509:  BTFSC  5D.0
050A:  BSF    03.7
050B:  MOVF   00,W
050C:  BCF    03.5
050D:  BSF    03.6
050E:  MOVWF  12
050F:  MOVF   10,W
0510:  MOVWF  04
0511:  BCF    03.7
0512:  BTFSC  11.0
0513:  BSF    03.7
0514:  MOVF   12,W
0515:  MOVWF  00
....................          s[cnt-i-1]=c; 
0516:  BSF    03.5
0517:  BCF    03.6
0518:  MOVF   62,W
0519:  SUBWF  64,W
051A:  ADDLW  FF
051B:  ADDWF  5C,W
051C:  MOVWF  04
051D:  BCF    03.7
051E:  BTFSC  5D.0
051F:  BSF    03.7
0520:  MOVF   65,W
0521:  MOVWF  00
0522:  INCF   62,F
0523:  GOTO   4E7
....................      } 
....................      s[cnt]='\0';     // End the string 
0524:  MOVF   64,W
0525:  ADDWF  5C,W
0526:  MOVWF  04
0527:  BCF    03.7
0528:  BTFSC  5D.0
0529:  BSF    03.7
052A:  CLRF   00
....................      return s; 
052B:  MOVF   5C,W
052C:  MOVWF  78
052D:  MOVF   5D,W
052E:  MOVWF  79
052F:  BCF    03.5
0530:  RETURN
.................... } 
....................  
.................... #if defined(__PCD__) 
....................  
.................... char * itoa(signed int48 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int48 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... char * itoa(signed int64 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int64 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................       
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1;         
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................              
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #endif 
....................  
.................... float strtof(char *s, char *endptr) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s, char *endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float48)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float48)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s, char *endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float64)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float64)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtoulGO; 
....................  
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................    { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... int8 mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #if !defined(__PCD__) 
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2);  
.................... #else  
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2);  
.................... #endif 
....................  
....................  
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    unsigned int8 t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=1; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = 0; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
.................... #INCLUDE <STDIO.H> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDIO 
.................... #define _STDIO 
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #ifndef getc 
.................... #define getc getch 
.................... #define getchar getch 
.................... #define puts(s) {printf(s); putchar(13); putchar(10);} 
.................... #define putc putchar 
.................... #endif 
.................... /* maps error number to an error message. Writes a sequence of characters to 
.................... stderr stream thus: if s is not null then string pointed to by s follwed by 
.................... a colon (:) and a space and the appropriate error message returned by strerror 
.................... function with argument errno 
....................  
.................... Returns: no value 
.................... */ 
....................  
.................... #ifdef _ERRNO 
.................... void perror(char *s) 
.................... { 
....................   if(s) 
....................   fprintf(STDERR,"%s: ",s); 
....................   fprintf(STDERR,"%s\r\n",strerror(errno)); 
.................... } 
.................... #endif 
.................... #endif 
....................  
.................... #FUSES NOWDT, PUT, HS 
.................... #USE DELAY(CLOCK=20M) 
*
0120:  MOVLW  D9
0121:  MOVWF  04
0122:  BCF    03.7
0123:  MOVF   00,W
0124:  BTFSC  03.2
0125:  GOTO   133
0126:  MOVLW  06
0127:  MOVWF  78
0128:  CLRF   77
0129:  DECFSZ 77,F
012A:  GOTO   129
012B:  DECFSZ 78,F
012C:  GOTO   128
012D:  MOVLW  7B
012E:  MOVWF  77
012F:  DECFSZ 77,F
0130:  GOTO   12F
0131:  DECFSZ 00,F
0132:  GOTO   126
0133:  RETURN
.................... #USE RS232(BAUD=9600,XMIT=PIN_C6,RCV=PIN_C7) 
.................... #DEFINE BT1_PIN PIN_B1 
.................... #DEFINE BT2_PIN PIN_B2 
.................... #DEFINE BT3_PIN PIN_B3 
.................... #DEFINE LCD_ENABLE_PIN  PIN_E0                                    
.................... #DEFINE LCD_RS_PIN      PIN_E1                                 
.................... #DEFINE LCD_RW_PIN      PIN_E2   
.................... #DEFINE LCD_DATA4       PIN_C0                                
.................... #DEFINE LCD_DATA5       PIN_C1                                  
.................... #DEFINE LCD_DATA6       PIN_C2                                    
.................... #DEFINE LCD_DATA7       PIN_C3   
.................... #INCLUDE <LCD.C> 
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... ////                             LCD.C                                     //// 
.................... ////                 Driver for common LCD modules                         //// 
.................... ////                                                                       //// 
.................... ////  lcd_init()   Must be called before any other function.               //// 
.................... ////                                                                       //// 
.................... ////  lcd_putc(c)  Will display c on the next position of the LCD.         //// 
.................... ////                 \a  Set cursor position to upper left                 //// 
.................... ////                 \f  Clear display, set cursor to upper left           //// 
.................... ////                 \n  Go to start of second line                        //// 
.................... ////                 \b  Move back one position                            //// 
.................... ////              If LCD_EXTENDED_NEWLINE is defined, the \n character     //// 
.................... ////              will erase all remanining characters on the current      //// 
.................... ////              line, and move the cursor to the beginning of the next   //// 
.................... ////              line.                                                    //// 
.................... ////              If LCD_EXTENDED_NEWLINE is defined, the \r character     //// 
.................... ////              will move the cursor to the start of the current         //// 
.................... ////              line.                                                    //// 
.................... ////                                                                       //// 
.................... ////  lcd_gotoxy(x,y) Set write position on LCD (upper left is 1,1)        //// 
.................... ////                                                                       //// 
.................... ////  lcd_getc(x,y)   Returns character at position x,y on LCD             //// 
.................... ////                                                                       //// 
.................... ////  lcd_cursor_on(int1 on)   Turn the cursor on (on=TRUE) or off         //// 
.................... ////              (on=FALSE).                                              //// 
.................... ////                                                                       //// 
.................... ////  lcd_set_cgram_char(w, *p)   Write a custom character to the CGRAM.   //// 
.................... ////                                                                       //// 
.................... ////                                                                       //// 
.................... ////  CONFIGURATION                                                        //// 
.................... ////  The LCD can be configured in one of two ways: a.) port access or     //// 
.................... ////  b.) pin access.  Port access requires the entire 7 bit interface     //// 
.................... ////  connected to one GPIO port, and the data bits (D4:D7 of the LCD)     //// 
.................... ////  connected to sequential pins on the GPIO.  Pin access                //// 
.................... ////  has no requirements, all 7 bits of the control interface can         //// 
.................... ////  can be connected to any GPIO using several ports.                    //// 
.................... ////                                                                       //// 
.................... ////  To use port access, #define LCD_DATA_PORT to the SFR location of     //// 
.................... ////  of the GPIO port that holds the interface, -AND- edit LCD_PIN_MAP    //// 
.................... ////  of this file to configure the pin order.  If you are using a         //// 
.................... ////  baseline PIC (PCB), then LCD_OUTPUT_MAP and LCD_INPUT_MAP also must  //// 
.................... ////  be defined.                                                          //// 
.................... ////                                                                       //// 
.................... ////  Example of port access:                                              //// 
.................... ////     #define LCD_DATA_PORT getenv("SFR:PORTD")                         //// 
.................... ////                                                                       //// 
.................... ////  To use pin access, the following pins must be defined:               //// 
.................... ////     LCD_ENABLE_PIN                                                    //// 
.................... ////     LCD_RS_PIN                                                        //// 
.................... ////     LCD_RW_PIN                                                        //// 
.................... ////     LCD_DATA4                                                         //// 
.................... ////     LCD_DATA5                                                         //// 
.................... ////     LCD_DATA6                                                         //// 
.................... ////     LCD_DATA7                                                         //// 
.................... ////                                                                       //// 
.................... ////  Example of pin access:                                               //// 
.................... ////     #define LCD_ENABLE_PIN  PIN_E0                                    //// 
.................... ////     #define LCD_RS_PIN      PIN_E1                                    //// 
.................... ////     #define LCD_RW_PIN      PIN_E2                                    //// 
.................... ////     #define LCD_DATA4       PIN_D4                                    //// 
.................... ////     #define LCD_DATA5       PIN_D5                                    //// 
.................... ////     #define LCD_DATA6       PIN_D6                                    //// 
.................... ////     #define LCD_DATA7       PIN_D7                                    //// 
.................... ////                                                                       //// 
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2010 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef __LCD_C__ 
.................... #define __LCD_C__ 
....................  
.................... // define the pinout. 
.................... // only required if port access is being used. 
.................... typedef struct   
.................... {                            // This structure is overlayed 
....................    int1 enable;           // on to an I/O port to gain 
....................    int1 rs;               // access to the LCD pins. 
....................    int1 rw;               // The bits are allocated from 
....................    int1 unused;           // low order up.  ENABLE will 
....................    unsigned int     data : 4;         // be LSB pin of that port. 
....................   #if defined(__PCD__)       // The port used will be LCD_DATA_PORT. 
....................    unsigned int    reserved: 8; 
....................   #endif 
.................... } LCD_PIN_MAP; 
....................  
.................... // this is to improve compatability with previous LCD drivers that accepted 
.................... // a define labeled 'use_portb_lcd' that configured the LCD onto port B. 
.................... #if ((defined(use_portb_lcd)) && (use_portb_lcd==TRUE)) 
....................  #define LCD_DATA_PORT getenv("SFR:PORTB") 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
....................    // these definitions only need to be modified for baseline PICs. 
....................    // all other PICs use LCD_PIN_MAP or individual LCD_xxx pin definitions. 
.................... /*                                    EN, RS,   RW,   UNUSED,  DATA  */ 
....................  const LCD_PIN_MAP LCD_OUTPUT_MAP =  {0,  0,    0,    0,       0}; 
....................  const LCD_PIN_MAP LCD_INPUT_MAP =   {0,  0,    0,    0,       0xF}; 
.................... #endif 
....................  
.................... ////////////////////// END CONFIGURATION /////////////////////////////////// 
....................  
.................... #ifndef LCD_ENABLE_PIN 
....................    #define lcd_output_enable(x) lcdlat.enable=x 
....................    #define lcd_enable_tris()   lcdtris.enable=0 
.................... #else 
....................    #define lcd_output_enable(x) output_bit(LCD_ENABLE_PIN, x) 
....................    #define lcd_enable_tris()  output_drive(LCD_ENABLE_PIN) 
.................... #endif 
....................  
.................... #ifndef LCD_RS_PIN 
....................    #define lcd_output_rs(x) lcdlat.rs=x 
....................    #define lcd_rs_tris()   lcdtris.rs=0 
.................... #else 
....................    #define lcd_output_rs(x) output_bit(LCD_RS_PIN, x) 
....................    #define lcd_rs_tris()  output_drive(LCD_RS_PIN) 
.................... #endif 
....................  
.................... #ifndef LCD_RW_PIN 
....................    #define lcd_output_rw(x) lcdlat.rw=x 
....................    #define lcd_rw_tris()   lcdtris.rw=0 
.................... #else 
....................    #define lcd_output_rw(x) output_bit(LCD_RW_PIN, x) 
....................    #define lcd_rw_tris()  output_drive(LCD_RW_PIN) 
.................... #endif 
....................  
.................... // original version of this library incorrectly labeled LCD_DATA0 as LCD_DATA4, 
.................... // LCD_DATA1 as LCD_DATA5, and so on.  this block of code makes the driver 
.................... // compatible with any code written for the original library 
.................... #if (defined(LCD_DATA0) && defined(LCD_DATA1) && defined(LCD_DATA2) && defined(LCD_DATA3) && !defined(LCD_DATA4) && !defined(LCD_DATA5) && !defined(LCD_DATA6) && !defined(LCD_DATA7)) 
....................    #define  LCD_DATA4    LCD_DATA0 
....................    #define  LCD_DATA5    LCD_DATA1 
....................    #define  LCD_DATA6    LCD_DATA2 
....................    #define  LCD_DATA7    LCD_DATA3 
.................... #endif 
....................  
.................... #ifndef LCD_DATA4 
.................... #ifndef LCD_DATA_PORT 
....................    #if defined(__PCB__) 
....................       #define LCD_DATA_PORT      0x06     //portb 
....................       #define set_tris_lcd(x)   set_tris_b(x) 
....................    #else 
....................      #if defined(PIN_D0) 
....................       #define LCD_DATA_PORT      getenv("SFR:PORTD")     //portd 
....................      #else 
....................       #define LCD_DATA_PORT      getenv("SFR:PORTB")     //portb 
....................      #endif 
....................    #endif    
.................... #endif 
....................  
.................... #if defined(__PCB__) 
....................    LCD_PIN_MAP lcd, lcdlat; 
....................    #byte lcd = LCD_DATA_PORT 
....................    #byte lcdlat = LCD_DATA_PORT 
.................... #elif defined(__PCM__) 
....................    LCD_PIN_MAP lcd, lcdlat, lcdtris; 
....................    #byte lcd = LCD_DATA_PORT 
....................    #byte lcdlat = LCD_DATA_PORT 
....................    #byte lcdtris = LCD_DATA_PORT+0x80 
.................... #elif defined(__PCH__) 
....................    LCD_PIN_MAP lcd, lcdlat, lcdtris; 
....................    #byte lcd = LCD_DATA_PORT 
....................    #byte lcdlat = LCD_DATA_PORT+9 
....................    #byte lcdtris = LCD_DATA_PORT+0x12 
.................... #elif defined(__PCD__) 
....................    LCD_PIN_MAP lcd, lcdlat, lcdtris; 
....................    #word lcd = LCD_DATA_PORT 
....................    #word lcdlat = LCD_DATA_PORT+2 
....................    #word lcdtris = LCD_DATA_PORT-0x02 
.................... #endif 
.................... #endif   //LCD_DATA4 not defined 
....................  
.................... #ifndef LCD_TYPE 
....................    #define LCD_TYPE 2           // 0=5x7, 1=5x10, 2=2 lines 
.................... #endif 
....................  
.................... #ifndef LCD_LINE_TWO 
....................    #define LCD_LINE_TWO 0x40    // LCD RAM address for the second line 
.................... #endif 
....................  
.................... #ifndef LCD_LINE_LENGTH 
....................    #define LCD_LINE_LENGTH 20 
.................... #endif 
....................  
.................... unsigned int8 lcd_read_nibble(void); 
....................  
.................... unsigned int8 lcd_read_byte(void) 
.................... { 
....................    unsigned int8 low,high; 
....................  
....................  #if defined(__PCB__) 
....................    set_tris_lcd(LCD_INPUT_MAP); 
....................  #else 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    output_float(LCD_DATA4); 
*
01C1:  BSF    07.0
....................    output_float(LCD_DATA5); 
01C2:  BSF    07.1
....................    output_float(LCD_DATA6); 
01C3:  BSF    07.2
....................    output_float(LCD_DATA7); 
01C4:  BSF    07.3
....................   #else 
....................    lcdtris.data = 0xF; 
....................   #endif 
....................  #endif 
....................          
....................    lcd_output_rw(1); 
01C5:  BCF    03.5
01C6:  BSF    09.2
01C7:  BSF    03.5
01C8:  BCF    09.2
....................    delay_cycles(1); 
01C9:  NOP
....................    lcd_output_enable(1); 
01CA:  BCF    03.5
01CB:  BSF    09.0
01CC:  BSF    03.5
01CD:  BCF    09.0
....................    delay_cycles(1); 
01CE:  NOP
....................    high = lcd_read_nibble(); 
01CF:  BCF    03.5
01D0:  CALL   176
01D1:  MOVF   78,W
01D2:  BSF    03.5
01D3:  MOVWF  60
....................        
....................    lcd_output_enable(0); 
01D4:  BCF    03.5
01D5:  BCF    09.0
01D6:  BSF    03.5
01D7:  BCF    09.0
....................    delay_cycles(1); 
01D8:  NOP
....................    lcd_output_enable(1); 
01D9:  BCF    03.5
01DA:  BSF    09.0
01DB:  BSF    03.5
01DC:  BCF    09.0
....................    delay_us(1); 
01DD:  GOTO   1DE
01DE:  GOTO   1DF
01DF:  NOP
....................    low = lcd_read_nibble(); 
01E0:  BCF    03.5
01E1:  CALL   176
01E2:  MOVF   78,W
01E3:  BSF    03.5
01E4:  MOVWF  5F
....................        
....................    lcd_output_enable(0); 
01E5:  BCF    03.5
01E6:  BCF    09.0
01E7:  BSF    03.5
01E8:  BCF    09.0
....................  
....................  #if defined(__PCB__) 
....................    set_tris_lcd(LCD_OUTPUT_MAP); 
....................  #else 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    output_drive(LCD_DATA4); 
01E9:  BCF    03.5
01EA:  BCF    31.0
01EB:  MOVF   31,W
01EC:  BSF    03.5
01ED:  MOVWF  07
....................    output_drive(LCD_DATA5); 
01EE:  BCF    03.5
01EF:  BCF    31.1
01F0:  MOVF   31,W
01F1:  BSF    03.5
01F2:  MOVWF  07
....................    output_drive(LCD_DATA6); 
01F3:  BCF    03.5
01F4:  BCF    31.2
01F5:  MOVF   31,W
01F6:  BSF    03.5
01F7:  MOVWF  07
....................    output_drive(LCD_DATA7); 
01F8:  BCF    03.5
01F9:  BCF    31.3
01FA:  MOVF   31,W
01FB:  BSF    03.5
01FC:  MOVWF  07
....................   #else 
....................    lcdtris.data = 0x0; 
....................   #endif 
....................  #endif 
....................  
....................    return( (high<<4) | low); 
01FD:  SWAPF  60,W
01FE:  MOVWF  77
01FF:  MOVLW  F0
0200:  ANDWF  77,F
0201:  MOVF   77,W
0202:  IORWF  5F,W
0203:  MOVWF  78
.................... } 
....................  
.................... unsigned int8 lcd_read_nibble(void) 
.................... { 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
*
0176:  BSF    03.5
0177:  CLRF   61
....................    unsigned int8 n = 0x00; 
....................  
....................    /* Read the data port */ 
....................    n |= input(LCD_DATA4); 
0178:  BCF    03.5
0179:  BSF    31.0
017A:  MOVF   31,W
017B:  BSF    03.5
017C:  MOVWF  07
017D:  MOVLW  00
017E:  BCF    03.5
017F:  BTFSC  07.0
0180:  MOVLW  01
0181:  BSF    03.5
0182:  IORWF  61,F
....................    n |= input(LCD_DATA5) << 1; 
0183:  BCF    03.5
0184:  BSF    31.1
0185:  MOVF   31,W
0186:  BSF    03.5
0187:  MOVWF  07
0188:  MOVLW  00
0189:  BCF    03.5
018A:  BTFSC  07.1
018B:  MOVLW  01
018C:  MOVWF  77
018D:  BCF    03.0
018E:  RLF    77,F
018F:  MOVF   77,W
0190:  BSF    03.5
0191:  IORWF  61,F
....................    n |= input(LCD_DATA6) << 2; 
0192:  BCF    03.5
0193:  BSF    31.2
0194:  MOVF   31,W
0195:  BSF    03.5
0196:  MOVWF  07
0197:  MOVLW  00
0198:  BCF    03.5
0199:  BTFSC  07.2
019A:  MOVLW  01
019B:  MOVWF  77
019C:  RLF    77,F
019D:  RLF    77,F
019E:  MOVLW  FC
019F:  ANDWF  77,F
01A0:  MOVF   77,W
01A1:  BSF    03.5
01A2:  IORWF  61,F
....................    n |= input(LCD_DATA7) << 3; 
01A3:  BCF    03.5
01A4:  BSF    31.3
01A5:  MOVF   31,W
01A6:  BSF    03.5
01A7:  MOVWF  07
01A8:  MOVLW  00
01A9:  BCF    03.5
01AA:  BTFSC  07.3
01AB:  MOVLW  01
01AC:  MOVWF  77
01AD:  RLF    77,F
01AE:  RLF    77,F
01AF:  RLF    77,F
01B0:  MOVLW  F8
01B1:  ANDWF  77,F
01B2:  MOVF   77,W
01B3:  BSF    03.5
01B4:  IORWF  61,F
....................     
....................    return(n); 
01B5:  MOVF   61,W
01B6:  MOVWF  78
....................   #else 
01B7:  BCF    03.5
01B8:  RETURN
....................    return(lcd.data); 
....................   #endif 
.................... } 
....................  
.................... void lcd_send_nibble(unsigned int8 n) 
.................... { 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    /* Write to the data port */ 
....................    output_bit(LCD_DATA4, bit_test(n, 0)); 
*
0134:  BSF    03.5
0135:  BTFSC  60.0
0136:  GOTO   13B
0137:  BCF    03.5
0138:  BCF    07.0
0139:  GOTO   13D
013A:  BSF    03.5
013B:  BCF    03.5
013C:  BSF    07.0
013D:  BCF    31.0
013E:  MOVF   31,W
013F:  BSF    03.5
0140:  MOVWF  07
....................    output_bit(LCD_DATA5, bit_test(n, 1)); 
0141:  BTFSC  60.1
0142:  GOTO   147
0143:  BCF    03.5
0144:  BCF    07.1
0145:  GOTO   149
0146:  BSF    03.5
0147:  BCF    03.5
0148:  BSF    07.1
0149:  BCF    31.1
014A:  MOVF   31,W
014B:  BSF    03.5
014C:  MOVWF  07
....................    output_bit(LCD_DATA6, bit_test(n, 2)); 
014D:  BTFSC  60.2
014E:  GOTO   153
014F:  BCF    03.5
0150:  BCF    07.2
0151:  GOTO   155
0152:  BSF    03.5
0153:  BCF    03.5
0154:  BSF    07.2
0155:  BCF    31.2
0156:  MOVF   31,W
0157:  BSF    03.5
0158:  MOVWF  07
....................    output_bit(LCD_DATA7, bit_test(n, 3)); 
0159:  BTFSC  60.3
015A:  GOTO   15F
015B:  BCF    03.5
015C:  BCF    07.3
015D:  GOTO   161
015E:  BSF    03.5
015F:  BCF    03.5
0160:  BSF    07.3
0161:  BCF    31.3
0162:  MOVF   31,W
0163:  BSF    03.5
0164:  MOVWF  07
....................   #else       
....................    lcdlat.data = n; 
....................   #endif 
....................        
....................    delay_cycles(1); 
0165:  NOP
....................    lcd_output_enable(1); 
0166:  BCF    03.5
0167:  BSF    09.0
0168:  BSF    03.5
0169:  BCF    09.0
....................    delay_us(2); 
016A:  MOVLW  02
016B:  MOVWF  77
016C:  DECFSZ 77,F
016D:  GOTO   16C
016E:  GOTO   16F
016F:  NOP
....................    lcd_output_enable(0); 
0170:  BCF    03.5
0171:  BCF    09.0
0172:  BSF    03.5
0173:  BCF    09.0
0174:  BCF    03.5
0175:  RETURN
.................... } 
....................  
.................... void lcd_send_byte(unsigned int8 address, unsigned int8 n) 
.................... { 
....................   #if defined(__PCB__) 
....................    set_tris_lcd(LCD_OUTPUT_MAP); 
....................   #else 
....................    lcd_enable_tris(); 
*
01B9:  BSF    03.5
01BA:  BCF    09.0
....................    lcd_rs_tris(); 
01BB:  BCF    09.1
....................    lcd_rw_tris(); 
01BC:  BCF    09.2
....................   #endif 
....................  
....................    lcd_output_rs(0); 
01BD:  BCF    03.5
01BE:  BCF    09.1
01BF:  BSF    03.5
01C0:  BCF    09.1
....................    while ( bit_test(lcd_read_byte(),7) ) ; 
*
0204:  MOVF   78,W
0205:  MOVWF  5F
0206:  BTFSC  5F.7
0207:  GOTO   1C1
....................    lcd_output_rs(address); 
0208:  MOVF   5D,F
0209:  BTFSS  03.2
020A:  GOTO   20F
020B:  BCF    03.5
020C:  BCF    09.1
020D:  GOTO   211
020E:  BSF    03.5
020F:  BCF    03.5
0210:  BSF    09.1
0211:  BSF    03.5
0212:  BCF    09.1
....................    delay_cycles(1); 
0213:  NOP
....................    lcd_output_rw(0); 
0214:  BCF    03.5
0215:  BCF    09.2
0216:  BSF    03.5
0217:  BCF    09.2
....................    delay_cycles(1); 
0218:  NOP
....................    lcd_output_enable(0); 
0219:  BCF    03.5
021A:  BCF    09.0
021B:  BSF    03.5
021C:  BCF    09.0
....................    lcd_send_nibble(n >> 4); 
021D:  SWAPF  5E,W
021E:  MOVWF  5F
021F:  MOVLW  0F
0220:  ANDWF  5F,F
0221:  MOVF   5F,W
0222:  MOVWF  60
0223:  BCF    03.5
0224:  CALL   134
....................    lcd_send_nibble(n & 0xf); 
0225:  BSF    03.5
0226:  MOVF   5E,W
0227:  ANDLW  0F
0228:  MOVWF  5F
0229:  MOVWF  60
022A:  BCF    03.5
022B:  CALL   134
022C:  RETURN
.................... } 
....................  
.................... #if defined(LCD_EXTENDED_NEWLINE) 
.................... unsigned int8 g_LcdX, g_LcdY; 
.................... #endif 
....................  
.................... void lcd_init(void)  
.................... { 
....................    unsigned int8 i; 
....................    unsigned int8 LCD_INIT_STRING[4] = {0x20 | (LCD_TYPE << 2), 0xc, 1, 6}; 
022D:  MOVLW  28
022E:  BSF    03.5
022F:  MOVWF  55
0230:  MOVLW  0C
0231:  MOVWF  56
0232:  MOVLW  01
0233:  MOVWF  57
0234:  MOVLW  06
0235:  MOVWF  58
....................                              // These bytes need to be sent to the LCD 
....................                              // to start it up. 
....................     
....................  
....................    lcd_output_enable(0); 
0236:  BCF    03.5
0237:  BCF    09.0
0238:  BSF    03.5
0239:  BCF    09.0
....................    lcd_output_rs(0); 
023A:  BCF    03.5
023B:  BCF    09.1
023C:  BSF    03.5
023D:  BCF    09.1
....................    lcd_output_rw(0); 
023E:  BCF    03.5
023F:  BCF    09.2
0240:  BSF    03.5
0241:  BCF    09.2
....................  
....................  #if defined(__PCB__) 
....................    set_tris_lcd(LCD_OUTPUT_MAP); 
....................  #else 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    output_drive(LCD_DATA4); 
0242:  BCF    03.5
0243:  BCF    31.0
0244:  MOVF   31,W
0245:  BSF    03.5
0246:  MOVWF  07
....................    output_drive(LCD_DATA5); 
0247:  BCF    03.5
0248:  BCF    31.1
0249:  MOVF   31,W
024A:  BSF    03.5
024B:  MOVWF  07
....................    output_drive(LCD_DATA6); 
024C:  BCF    03.5
024D:  BCF    31.2
024E:  MOVF   31,W
024F:  BSF    03.5
0250:  MOVWF  07
....................    output_drive(LCD_DATA7); 
0251:  BCF    03.5
0252:  BCF    31.3
0253:  MOVF   31,W
0254:  BSF    03.5
0255:  MOVWF  07
....................   #else 
....................    lcdtris.data = 0x0; 
....................   #endif 
....................    lcd_enable_tris(); 
0256:  BCF    09.0
....................    lcd_rs_tris(); 
0257:  BCF    09.1
....................    lcd_rw_tris(); 
0258:  BCF    09.2
....................  #endif 
....................      
....................    delay_ms(15); 
0259:  MOVLW  0F
025A:  MOVWF  59
025B:  BCF    03.5
025C:  CALL   120
....................    for(i=1;i<=3;++i) 
025D:  MOVLW  01
025E:  BSF    03.5
025F:  MOVWF  54
0260:  MOVF   54,W
0261:  SUBLW  03
0262:  BTFSS  03.0
0263:  GOTO   270
....................    { 
....................        lcd_send_nibble(3); 
0264:  MOVLW  03
0265:  MOVWF  60
0266:  BCF    03.5
0267:  CALL   134
....................        delay_ms(5); 
0268:  MOVLW  05
0269:  BSF    03.5
026A:  MOVWF  59
026B:  BCF    03.5
026C:  CALL   120
026D:  BSF    03.5
026E:  INCF   54,F
026F:  GOTO   260
....................    } 
....................     
....................    lcd_send_nibble(2); 
0270:  MOVLW  02
0271:  MOVWF  60
0272:  BCF    03.5
0273:  CALL   134
....................    delay_ms(5); 
0274:  MOVLW  05
0275:  BSF    03.5
0276:  MOVWF  59
0277:  BCF    03.5
0278:  CALL   120
....................    for(i=0;i<=3;++i) 
0279:  BSF    03.5
027A:  CLRF   54
027B:  MOVF   54,W
027C:  SUBLW  03
027D:  BTFSS  03.0
027E:  GOTO   28D
....................       lcd_send_byte(0,LCD_INIT_STRING[i]); 
027F:  MOVLW  D5
0280:  ADDWF  54,W
0281:  MOVWF  04
0282:  BCF    03.7
0283:  MOVF   00,W
0284:  MOVWF  59
0285:  CLRF   5D
0286:  MOVF   59,W
0287:  MOVWF  5E
0288:  BCF    03.5
0289:  CALL   1B9
....................  
....................   #if defined(LCD_EXTENDED_NEWLINE) 
028A:  BSF    03.5
028B:  INCF   54,F
028C:  GOTO   27B
028D:  BCF    03.5
028E:  BSF    0A.3
028F:  BCF    0A.4
0290:  GOTO   444 (RETURN)
....................    g_LcdX = 0; 
....................    g_LcdY = 0; 
....................   #endif 
.................... } 
....................  
.................... void lcd_gotoxy(unsigned int8 x, unsigned int8 y) 
.................... { 
....................    unsigned int8 address; 
....................     
....................    if(y!=1) 
0291:  BSF    03.5
0292:  DECFSZ 5A,W
0293:  GOTO   295
0294:  GOTO   298
....................       address=LCD_LINE_TWO; 
0295:  MOVLW  40
0296:  MOVWF  5B
0297:  GOTO   299
....................    else 
....................       address=0; 
0298:  CLRF   5B
....................       
....................    address+=x-1; 
0299:  MOVLW  01
029A:  SUBWF  59,W
029B:  ADDWF  5B,F
....................    lcd_send_byte(0,0x80|address); 
029C:  MOVF   5B,W
029D:  IORLW  80
029E:  MOVWF  5C
029F:  CLRF   5D
02A0:  MOVF   5C,W
02A1:  MOVWF  5E
02A2:  BCF    03.5
02A3:  CALL   1B9
....................  
....................   #if defined(LCD_EXTENDED_NEWLINE) 
02A4:  RETURN
....................    g_LcdX = x - 1; 
....................    g_LcdY = y - 1; 
....................   #endif 
.................... } 
....................  
.................... void lcd_putc(char c) 
.................... { 
....................    switch (c) 
02A5:  BSF    03.5
02A6:  MOVF   58,W
02A7:  XORLW  07
02A8:  BCF    03.5
02A9:  BTFSC  03.2
02AA:  GOTO   2B5
02AB:  XORLW  0B
02AC:  BTFSC  03.2
02AD:  GOTO   2BC
02AE:  XORLW  06
02AF:  BTFSC  03.2
02B0:  GOTO   2C8
02B1:  XORLW  02
02B2:  BTFSC  03.2
02B3:  GOTO   2D0
02B4:  GOTO   2D7
....................    { 
....................       case '\a'   :  lcd_gotoxy(1,1);     break; 
02B5:  MOVLW  01
02B6:  BSF    03.5
02B7:  MOVWF  59
02B8:  MOVWF  5A
02B9:  BCF    03.5
02BA:  CALL   291
02BB:  GOTO   2DE
....................  
....................       case '\f'   :  lcd_send_byte(0,1); 
02BC:  BSF    03.5
02BD:  CLRF   5D
02BE:  MOVLW  01
02BF:  MOVWF  5E
02C0:  BCF    03.5
02C1:  CALL   1B9
....................                      delay_ms(2); 
02C2:  MOVLW  02
02C3:  BSF    03.5
02C4:  MOVWF  59
02C5:  BCF    03.5
02C6:  CALL   120
....................                     #if defined(LCD_EXTENDED_NEWLINE) 
....................                      g_LcdX = 0; 
....................                      g_LcdY = 0; 
....................                     #endif 
....................                      break; 
02C7:  GOTO   2DE
....................  
....................      #if defined(LCD_EXTENDED_NEWLINE) 
....................       case '\r'   :  lcd_gotoxy(1, g_LcdY+1);   break; 
....................       case '\n'   : 
....................          while (g_LcdX++ < LCD_LINE_LENGTH) 
....................          { 
....................             lcd_send_byte(1, ' '); 
....................          } 
....................          lcd_gotoxy(1, g_LcdY+2); 
....................          break; 
....................      #else 
....................       case '\n'   : lcd_gotoxy(1,2);        break; 
02C8:  MOVLW  01
02C9:  BSF    03.5
02CA:  MOVWF  59
02CB:  MOVLW  02
02CC:  MOVWF  5A
02CD:  BCF    03.5
02CE:  CALL   291
02CF:  GOTO   2DE
....................      #endif 
....................       
....................       case '\b'   : lcd_send_byte(0,0x10);  break; 
02D0:  BSF    03.5
02D1:  CLRF   5D
02D2:  MOVLW  10
02D3:  MOVWF  5E
02D4:  BCF    03.5
02D5:  CALL   1B9
02D6:  GOTO   2DE
....................       
....................      #if defined(LCD_EXTENDED_NEWLINE) 
....................       default     :  
....................          if (g_LcdX < LCD_LINE_LENGTH) 
....................          { 
....................             lcd_send_byte(1, c); 
....................             g_LcdX++; 
....................          } 
....................          break; 
....................      #else 
....................       default     : lcd_send_byte(1,c);     break; 
02D7:  MOVLW  01
02D8:  BSF    03.5
02D9:  MOVWF  5D
02DA:  MOVF   58,W
02DB:  MOVWF  5E
02DC:  BCF    03.5
02DD:  CALL   1B9
....................      #endif 
....................    } 
02DE:  RETURN
.................... } 
....................   
.................... char lcd_getc(unsigned int8 x, unsigned int8 y) 
.................... { 
....................    char value; 
....................  
....................    lcd_gotoxy(x,y); 
....................    while ( bit_test(lcd_read_byte(),7) ); // wait until busy flag is low 
....................    lcd_output_rs(1); 
....................    value = lcd_read_byte(); 
....................    lcd_output_rs(0); 
....................     
....................    return(value); 
.................... } 
....................  
.................... // write a custom character to the ram 
.................... // which is 0-7 and specifies which character array we are modifying. 
.................... // ptr points to an array of 8 bytes, where each byte is the next row of 
.................... //    pixels.  only bits 0-4 are used.  the last row is the cursor row, and 
.................... //    usually you will want to leave this byte 0x00. 
.................... void lcd_set_cgram_char(unsigned int8 which, unsigned int8 *ptr) 
.................... { 
....................    unsigned int i; 
....................  
....................    which <<= 3; 
....................    which &= 0x38; 
....................  
....................    lcd_send_byte(0, 0x40 | which);  //set cgram address 
....................  
....................    for(i=0; i<8; i++) 
....................    { 
....................       lcd_send_byte(1, *ptr++); 
....................    } 
....................    
....................    #if defined(LCD_EXTENDED_NEWLINE) 
....................     lcd_gotoxy(g_LcdX+1, g_LcdY+1);  //set ddram address 
....................    #endif 
.................... } 
....................  
.................... void lcd_cursor_on(int1 on) 
.................... { 
....................    if (on) 
....................    { 
....................       lcd_send_byte(0,0x0F);           //turn LCD cursor ON 
....................    } 
....................    else 
....................    { 
....................       lcd_send_byte(0,0x0C);           //turn LCD cursor OFF 
....................    } 
.................... } 
....................  
.................... #endif 
....................  
.................... #BIT TMR1IF = 0x0C.0 //bit thu 0 (TMR1IF) cua PIR1 
....................  
.................... #INCLUDE <khaibaobien.c> // VARIABLE. 
.................... UNSIGNED INT16 KQADC,AN0, AN1; 
.................... UNSIGNED INT8 CONFIG_FUN=0; 
.................... UNSIGNED INT8 VT=0, KYTU=0;// KYTU[30],  
.................... UNSIGNED INT8 ID_NODE_NHAN, ID_DEVICE_NHAN, TT_DEVICE_NHAN; 
.................... UNSIGNED INT8 ID_GATEWAY[6] = {5,7,3,5,4,5}; 
*
0B84:  MOVLW  05
0B85:  MOVWF  3E
0B86:  MOVLW  07
0B87:  MOVWF  3F
0B88:  MOVLW  03
0B89:  MOVWF  40
0B8A:  MOVLW  05
0B8B:  MOVWF  41
0B8C:  MOVLW  04
0B8D:  MOVWF  42
0B8E:  MOVLW  05
0B8F:  MOVWF  43
.................... UNSIGNED INT8 ID_NODE[4] = {0,0,0,0}; 
0B90:  CLRF   44
0B91:  CLRF   45
0B92:  CLRF   46
0B93:  CLRF   47
.................... UNSIGNED INT8 LEN_PACKAGES = 0; 
.................... INT1 TTNHAN = 0, TT_CONFIG=0, TT_CONTROL=0,TT_CONFIG_DONE=0, TT_FUN=0, TT_STT=0; 
....................  
.................... CHAR *ID_NODE_CHAR[]= "0000"; 
0B94:  MOVLW  30
0B95:  MOVWF  4C
0B96:  MOVWF  4D
0B97:  MOVWF  4E
0B98:  MOVWF  4F
0B99:  CLRF   50
0B9A:  CLRF   4B
0B9B:  MOVLW  4C
0B9C:  MOVWF  4A
.................... CHAR *ID_GATEWAY_CHAR[]= "000000"; 
0B9D:  MOVLW  30
0B9E:  MOVWF  53
0B9F:  MOVWF  54
0BA0:  MOVWF  55
0BA1:  MOVWF  56
0BA2:  MOVWF  57
0BA3:  MOVWF  58
0BA4:  CLRF   59
0BA5:  CLRF   52
0BA6:  MOVLW  53
0BA7:  MOVWF  51
.................... CHAR KYTUCHAR[20]="HIHI"; 
0BA8:  MOVLW  48
0BA9:  MOVWF  5A
0BAA:  MOVLW  49
0BAB:  MOVWF  5B
0BAC:  MOVLW  48
0BAD:  MOVWF  5C
0BAE:  MOVLW  49
0BAF:  MOVWF  5D
0BB0:  CLRF   5E
.................... //CHAR *DATA_NHANDUOC[]={"IDGW","IDNODE","COMMAN","DATA"}; 
.................... CHAR *PACKAGE_CONFIG[]={"*", "LENGHT","C_F", "ID_GW1234" ,"ID_NODE","#"}; 
0BB1:  MOVLW  2A
0BB2:  BSF    03.5
0BB3:  MOVWF  2C
0BB4:  CLRF   2D
0BB5:  MOVLW  4C
0BB6:  MOVWF  2E
0BB7:  MOVLW  45
0BB8:  MOVWF  2F
0BB9:  MOVLW  4E
0BBA:  MOVWF  30
0BBB:  MOVLW  47
0BBC:  MOVWF  31
0BBD:  MOVLW  48
0BBE:  MOVWF  32
0BBF:  MOVLW  54
0BC0:  MOVWF  33
0BC1:  CLRF   34
0BC2:  MOVLW  43
0BC3:  MOVWF  35
0BC4:  MOVLW  5F
0BC5:  MOVWF  36
0BC6:  MOVLW  46
0BC7:  MOVWF  37
0BC8:  CLRF   38
0BC9:  MOVLW  49
0BCA:  MOVWF  39
0BCB:  MOVLW  44
0BCC:  MOVWF  3A
0BCD:  MOVLW  5F
0BCE:  MOVWF  3B
0BCF:  MOVLW  47
0BD0:  MOVWF  3C
0BD1:  MOVLW  57
0BD2:  MOVWF  3D
0BD3:  MOVLW  31
0BD4:  MOVWF  3E
0BD5:  MOVLW  32
0BD6:  MOVWF  3F
0BD7:  MOVLW  33
0BD8:  MOVWF  40
0BD9:  MOVLW  34
0BDA:  MOVWF  41
0BDB:  CLRF   42
0BDC:  MOVLW  49
0BDD:  MOVWF  43
0BDE:  MOVLW  44
0BDF:  MOVWF  44
0BE0:  MOVLW  5F
0BE1:  MOVWF  45
0BE2:  MOVLW  4E
0BE3:  MOVWF  46
0BE4:  MOVLW  4F
0BE5:  MOVWF  47
0BE6:  MOVLW  44
0BE7:  MOVWF  48
0BE8:  MOVLW  45
0BE9:  MOVWF  49
0BEA:  CLRF   4A
0BEB:  MOVLW  23
0BEC:  MOVWF  4B
0BED:  CLRF   4C
0BEE:  CLRF   21
0BEF:  MOVLW  AC
0BF0:  MOVWF  20
0BF1:  CLRF   23
0BF2:  MOVLW  AE
0BF3:  MOVWF  22
0BF4:  CLRF   25
0BF5:  MOVLW  B5
0BF6:  MOVWF  24
0BF7:  CLRF   27
0BF8:  MOVLW  B9
0BF9:  MOVWF  26
0BFA:  CLRF   29
0BFB:  MOVLW  C3
0BFC:  MOVWF  28
0BFD:  CLRF   2B
0BFE:  MOVLW  CB
0BFF:  MOVWF  2A
.................... CHAR *TEMP_CHAR[]="00"; 
0C00:  MOVLW  30
0C01:  MOVWF  70
0C02:  MOVWF  71
0C03:  CLRF   72
0C04:  BCF    03.5
0C05:  CLRF   6F
0C06:  MOVLW  70
0C07:  MOVWF  6E
.................... //CHAR *TEMP_CHAR2[]="00000000";  
.................... CHAR *TEMP_CHAR3[]="0000";  
0C08:  MOVLW  30
0C09:  BSF    03.5
0C0A:  MOVWF  4D
0C0B:  MOVWF  4E
0C0C:  MOVWF  4F
0C0D:  MOVWF  50
0C0E:  CLRF   51
0C0F:  CLRF   74
0C10:  MOVLW  CD
0C11:  MOVWF  73
....................  
....................  
....................  
.................... //#INCLUDE <CONFIG_NODE.C> // CU HINH NODE. 
.................... #INCLUDE <config_1.C> // CU HINH NODE. 
....................  
.................... //--------------------------------------------------------------------// 
.................... VOID CHON_ID() 
.................... { 
....................    // TT_CONFIG_DONE; 
....................    TT_CONFIG_DONE = 0; 
*
05DE:  BCF    49.3
....................    TT_STT = 1; 
05DF:  BSF    49.5
....................    UNSIGNED INT8 NUM = 0; 
05E0:  BSF    03.5
05E1:  CLRF   54
....................    TEMP_CHAR = "0"; 
05E2:  CLRF   55
05E3:  CLRF   56
05E4:  MOVLW  6E
05E5:  MOVWF  04
05E6:  BCF    03.7
05E7:  MOVF   55,W
05E8:  ADDWF  04,F
05E9:  MOVF   56,W
05EA:  BCF    03.5
05EB:  CALL   058
05EC:  MOVWF  00
05ED:  IORLW  00
05EE:  BTFSC  03.2
05EF:  GOTO   5F5
05F0:  BSF    03.5
05F1:  INCF   56,F
05F2:  INCF   55,F
05F3:  GOTO   5E4
05F4:  BCF    03.5
....................    LCD_GOTOXY (1, 2) ; 
05F5:  MOVLW  01
05F6:  BSF    03.5
05F7:  MOVWF  59
05F8:  MOVLW  02
05F9:  MOVWF  5A
05FA:  BCF    03.5
05FB:  CALL   291
....................    DELAY_MS (10); 
05FC:  MOVLW  0A
05FD:  BSF    03.5
05FE:  MOVWF  59
05FF:  BCF    03.5
0600:  CALL   120
....................    PRINTF (LCD_PUTC, "NODE: "); 
0601:  MOVLW  64
0602:  BSF    03.6
0603:  MOVWF  0D
0604:  MOVLW  00
0605:  MOVWF  0F
0606:  BCF    03.6
0607:  CALL   2DF
....................    PRINTF (LCD_PUTC, "0000          "); 
0608:  MOVLW  68
0609:  BSF    03.6
060A:  MOVWF  0D
060B:  MOVLW  00
060C:  MOVWF  0F
060D:  BCF    03.6
060E:  CALL   2DF
....................    LCD_GOTOXY (1, 1) ; 
060F:  MOVLW  01
0610:  BSF    03.5
0611:  MOVWF  59
0612:  MOVWF  5A
0613:  BCF    03.5
0614:  CALL   291
....................    PRINTF (LCD_PUTC, "      _              ");//6 SPACE PHIA TRUOC "_" 
0615:  MOVLW  70
0616:  BSF    03.6
0617:  MOVWF  0D
0618:  MOVLW  00
0619:  MOVWF  0F
061A:  BCF    03.6
061B:  CALL   2DF
....................    //ID_GW = "1234";     
....................  
....................    WHILE (TT_STT) 
061C:  BTFSS  49.5
061D:  GOTO   69A
....................    { 
....................       IF (!INPUT (BT2_PIN)) //NEU NUT BAM DUOC BAM 
061E:  BSF    03.5
061F:  BSF    06.2
0620:  BCF    03.5
0621:  BTFSC  06.2
0622:  GOTO   641
....................       { 
....................           
....................          NUM++; 
0623:  BSF    03.5
0624:  INCF   54,F
....................          NUM = NUM % 4; 
0625:  MOVLW  03
0626:  ANDWF  54,F
....................          LCD_GOTOXY (3 + NUM, 1); 
0627:  ADDWF  54,W
0628:  MOVWF  55
0629:  MOVWF  59
062A:  MOVLW  01
062B:  MOVWF  5A
062C:  BCF    03.5
062D:  CALL   291
....................          PRINTF (LCD_PUTC, "    _    ");//4SPACE 
062E:  MOVLW  7B
062F:  BSF    03.6
0630:  MOVWF  0D
0631:  MOVLW  00
0632:  MOVWF  0F
0633:  BCF    03.6
0634:  CALL   2DF
....................          DELAY_MS (300);  
0635:  MOVLW  02
0636:  BSF    03.5
0637:  MOVWF  55
0638:  MOVLW  96
0639:  MOVWF  59
063A:  BCF    03.5
063B:  CALL   120
063C:  BSF    03.5
063D:  DECFSZ 55,F
063E:  GOTO   638
....................       } 
063F:  GOTO   698
0640:  BCF    03.5
....................  
....................       ELSE IF (!INPUT (BT3_PIN)) 
0641:  BSF    03.5
0642:  BSF    06.3
0643:  BCF    03.5
0644:  BTFSC  06.3
0645:  GOTO   699
....................       { 
....................          ID_NODE[NUM]++; 
0646:  MOVLW  44
0647:  BSF    03.5
0648:  ADDWF  54,W
0649:  MOVWF  04
064A:  BCF    03.7
064B:  INCF   00,F
....................          ID_NODE[NUM] = ID_NODE[NUM] % 10; 
064C:  MOVLW  44
064D:  ADDWF  54,W
064E:  MOVWF  78
064F:  CLRF   7A
0650:  BTFSC  03.0
0651:  INCF   7A,F
0652:  MOVF   78,W
0653:  MOVWF  55
0654:  MOVF   7A,W
0655:  MOVWF  56
0656:  MOVLW  44
0657:  ADDWF  54,W
0658:  MOVWF  04
0659:  BCF    03.7
065A:  MOVF   00,W
065B:  MOVWF  58
065C:  MOVLW  0A
065D:  MOVWF  59
065E:  BCF    03.5
065F:  CALL   54E
0660:  MOVF   77,W
0661:  BSF    03.5
0662:  MOVWF  57
0663:  MOVF   55,W
0664:  MOVWF  04
0665:  BCF    03.7
0666:  BTFSC  56.0
0667:  BSF    03.7
0668:  MOVF   57,W
0669:  MOVWF  00
....................          ITOA (ID_NODE[NUM], 10, TEMP_CHAR); 
066A:  MOVLW  44
066B:  ADDWF  54,W
066C:  MOVWF  04
066D:  BCF    03.7
066E:  MOVF   00,W
066F:  MOVWF  55
0670:  CLRF   5A
0671:  CLRF   59
0672:  CLRF   58
0673:  MOVF   55,W
0674:  MOVWF  57
0675:  MOVLW  0A
0676:  MOVWF  5B
0677:  CLRF   5D
0678:  MOVLW  6E
0679:  MOVWF  5C
067A:  BCF    03.5
067B:  CALL   3CF
....................          LCD_GOTOXY (7 + NUM, 2); 
067C:  MOVLW  07
067D:  BSF    03.5
067E:  ADDWF  54,W
067F:  MOVWF  55
0680:  MOVWF  59
0681:  MOVLW  02
0682:  MOVWF  5A
0683:  BCF    03.5
0684:  CALL   291
....................          DELAY_MS (10); 
0685:  MOVLW  0A
0686:  BSF    03.5
0687:  MOVWF  59
0688:  BCF    03.5
0689:  CALL   120
....................          PRINTF (LCD_PUTC, TEMP_CHAR); 
068A:  MOVLW  6E
068B:  MOVWF  04
068C:  BCF    03.7
068D:  CALL   531
....................          DELAY_MS (300); 
068E:  MOVLW  02
068F:  BSF    03.5
0690:  MOVWF  55
0691:  MOVLW  96
0692:  MOVWF  59
0693:  BCF    03.5
0694:  CALL   120
0695:  BSF    03.5
0696:  DECFSZ 55,F
0697:  GOTO   691
0698:  BCF    03.5
....................       } 
0699:  GOTO   61C
....................    } 
.................... } 
....................  
.................... VOID NHAPID_GW() 
*
069B:  BSF    03.5
069C:  CLRF   54
.................... { 
....................    UNSIGNED INT8 NUM = 0; 
....................    TEMP_CHAR = "0"; 
069D:  CLRF   55
069E:  CLRF   56
069F:  MOVLW  6E
06A0:  MOVWF  04
06A1:  BCF    03.7
06A2:  MOVF   55,W
06A3:  ADDWF  04,F
06A4:  MOVF   56,W
06A5:  BCF    03.5
06A6:  CALL   058
06A7:  MOVWF  00
06A8:  IORLW  00
06A9:  BTFSC  03.2
06AA:  GOTO   6B0
06AB:  BSF    03.5
06AC:  INCF   56,F
06AD:  INCF   55,F
06AE:  GOTO   69F
06AF:  BCF    03.5
....................    TT_CONFIG_DONE = 0; 
06B0:  BCF    49.3
....................    TT_STT = 1; 
06B1:  BSF    49.5
....................    LCD_GOTOXY (1, 2) ; 
06B2:  MOVLW  01
06B3:  BSF    03.5
06B4:  MOVWF  59
06B5:  MOVLW  02
06B6:  MOVWF  5A
06B7:  BCF    03.5
06B8:  CALL   291
....................    DELAY_MS (10); 
06B9:  MOVLW  0A
06BA:  BSF    03.5
06BB:  MOVWF  59
06BC:  BCF    03.5
06BD:  CALL   120
....................    PRINTF (LCD_PUTC, "ID_GW:"); 
06BE:  MOVLW  80
06BF:  BSF    03.6
06C0:  MOVWF  0D
06C1:  MOVLW  00
06C2:  MOVWF  0F
06C3:  BCF    03.6
06C4:  CALL   2DF
....................    PRINTF (LCD_PUTC, "000000        "); 
06C5:  MOVLW  84
06C6:  BSF    03.6
06C7:  MOVWF  0D
06C8:  MOVLW  00
06C9:  MOVWF  0F
06CA:  BCF    03.6
06CB:  CALL   2DF
....................    LCD_GOTOXY (1, 1) ; 
06CC:  MOVLW  01
06CD:  BSF    03.5
06CE:  MOVWF  59
06CF:  MOVWF  5A
06D0:  BCF    03.5
06D1:  CALL   291
....................    PRINTF (LCD_PUTC, "      _                ");//6 SPACE PHIA TRUOC "_" 
06D2:  MOVLW  8C
06D3:  BSF    03.6
06D4:  MOVWF  0D
06D5:  MOVLW  00
06D6:  MOVWF  0F
06D7:  BCF    03.6
06D8:  CALL   2DF
....................    //ID_GW = "1234";     
....................  
....................    WHILE (TT_STT) 
06D9:  BTFSS  49.5
06DA:  GOTO   75F
....................    { 
....................       IF (!INPUT (BT2_PIN)) //NEU NUT BAM DUOC BAM 
06DB:  BSF    03.5
06DC:  BSF    06.2
06DD:  BCF    03.5
06DE:  BTFSC  06.2
06DF:  GOTO   706
....................       { 
....................           
....................          NUM++; 
06E0:  BSF    03.5
06E1:  INCF   54,F
....................          NUM = NUM % 6; 
06E2:  MOVF   54,W
06E3:  MOVWF  58
06E4:  MOVLW  06
06E5:  MOVWF  59
06E6:  BCF    03.5
06E7:  CALL   54E
06E8:  MOVF   77,W
06E9:  BSF    03.5
06EA:  MOVWF  54
....................          LCD_GOTOXY (3 + NUM, 1); 
06EB:  MOVLW  03
06EC:  ADDWF  54,W
06ED:  MOVWF  55
06EE:  MOVWF  59
06EF:  MOVLW  01
06F0:  MOVWF  5A
06F1:  BCF    03.5
06F2:  CALL   291
....................          PRINTF (LCD_PUTC, "    _    ");//4SPACE 
06F3:  MOVLW  98
06F4:  BSF    03.6
06F5:  MOVWF  0D
06F6:  MOVLW  00
06F7:  MOVWF  0F
06F8:  BCF    03.6
06F9:  CALL   2DF
....................          DELAY_MS (300);  
06FA:  MOVLW  02
06FB:  BSF    03.5
06FC:  MOVWF  55
06FD:  MOVLW  96
06FE:  MOVWF  59
06FF:  BCF    03.5
0700:  CALL   120
0701:  BSF    03.5
0702:  DECFSZ 55,F
0703:  GOTO   6FD
....................       } 
0704:  GOTO   75D
0705:  BCF    03.5
....................  
....................       ELSE IF (!INPUT (BT3_PIN)) 
0706:  BSF    03.5
0707:  BSF    06.3
0708:  BCF    03.5
0709:  BTFSC  06.3
070A:  GOTO   75E
....................       { 
....................          ID_GATEWAY[NUM]++; 
070B:  MOVLW  3E
070C:  BSF    03.5
070D:  ADDWF  54,W
070E:  MOVWF  04
070F:  BCF    03.7
0710:  INCF   00,F
....................          ID_GATEWAY[NUM] = ID_GATEWAY[NUM] % 10; 
0711:  MOVLW  3E
0712:  ADDWF  54,W
0713:  MOVWF  78
0714:  CLRF   7A
0715:  BTFSC  03.0
0716:  INCF   7A,F
0717:  MOVF   78,W
0718:  MOVWF  55
0719:  MOVF   7A,W
071A:  MOVWF  56
071B:  MOVLW  3E
071C:  ADDWF  54,W
071D:  MOVWF  04
071E:  BCF    03.7
071F:  MOVF   00,W
0720:  MOVWF  58
0721:  MOVLW  0A
0722:  MOVWF  59
0723:  BCF    03.5
0724:  CALL   54E
0725:  MOVF   77,W
0726:  BSF    03.5
0727:  MOVWF  57
0728:  MOVF   55,W
0729:  MOVWF  04
072A:  BCF    03.7
072B:  BTFSC  56.0
072C:  BSF    03.7
072D:  MOVF   57,W
072E:  MOVWF  00
....................          ITOA (ID_GATEWAY[NUM], 10, TEMP_CHAR); 
072F:  MOVLW  3E
0730:  ADDWF  54,W
0731:  MOVWF  04
0732:  BCF    03.7
0733:  MOVF   00,W
0734:  MOVWF  55
0735:  CLRF   5A
0736:  CLRF   59
0737:  CLRF   58
0738:  MOVF   55,W
0739:  MOVWF  57
073A:  MOVLW  0A
073B:  MOVWF  5B
073C:  CLRF   5D
073D:  MOVLW  6E
073E:  MOVWF  5C
073F:  BCF    03.5
0740:  CALL   3CF
....................          LCD_GOTOXY (7 + NUM, 2); 
0741:  MOVLW  07
0742:  BSF    03.5
0743:  ADDWF  54,W
0744:  MOVWF  55
0745:  MOVWF  59
0746:  MOVLW  02
0747:  MOVWF  5A
0748:  BCF    03.5
0749:  CALL   291
....................          DELAY_MS (10); 
074A:  MOVLW  0A
074B:  BSF    03.5
074C:  MOVWF  59
074D:  BCF    03.5
074E:  CALL   120
....................          PRINTF (LCD_PUTC, TEMP_CHAR); 
074F:  MOVLW  6E
0750:  MOVWF  04
0751:  BCF    03.7
0752:  CALL   531
....................          DELAY_MS (300); 
0753:  MOVLW  02
0754:  BSF    03.5
0755:  MOVWF  55
0756:  MOVLW  96
0757:  MOVWF  59
0758:  BCF    03.5
0759:  CALL   120
075A:  BSF    03.5
075B:  DECFSZ 55,F
075C:  GOTO   756
075D:  BCF    03.5
....................       } 
075E:  GOTO   6D9
....................    } 
.................... } 
....................  
.................... VOID BUTT_OKE() 
.................... { 
....................    TT_CONFIG_DONE = 0; 
*
00FB:  BCF    03.6
00FC:  BCF    49.3
....................    TT_FUN = 0;//BREAK WHILE BUTT_FUN 
00FD:  BCF    49.4
....................    TT_STT = 0;// BREAK WHILE CHONID/NHAPID_GW 
00FE:  BCF    49.5
.................... } 
....................  
.................... VOID SELLECT_FUN() 
.................... { 
....................    TT_CONFIG_DONE = 0; 
*
05D6:  BCF    49.3
....................  
....................    SWITCH (CONFIG_FUN) 
05D7:  MOVF   38,W
05D8:  BTFSC  03.2
05D9:  GOTO   5DE
05DA:  XORLW  01
05DB:  BTFSC  03.2
05DC:  GOTO   69B
05DD:  GOTO   75F
....................    { 
....................       CASE 0: 
....................       CHON_ID (); 
....................       BREAK; 
*
069A:  GOTO   75F
....................  
....................       CASE 1:     
....................       NHAPID_GW (); 
....................       BREAK; 
....................    } 
.................... } 
....................  
.................... VOID BUTT_FUN() 
.................... { 
....................    TT_FUN = 1; 
*
0565:  BSF    49.4
....................    LCD_GOTOXY (1, 1) ; 
0566:  MOVLW  01
0567:  BSF    03.5
0568:  MOVWF  59
0569:  MOVWF  5A
056A:  BCF    03.5
056B:  CALL   291
....................    DELAY_MS (10); 
056C:  MOVLW  0A
056D:  BSF    03.5
056E:  MOVWF  59
056F:  BCF    03.5
0570:  CALL   120
....................    PRINTF (LCD_PUTC, "CONFIG:        "); 
0571:  MOVLW  9D
0572:  BSF    03.6
0573:  MOVWF  0D
0574:  MOVLW  00
0575:  MOVWF  0F
0576:  BCF    03.6
0577:  CALL   2DF
....................  
....................    // HIEN THI LCD 
....................    LCD_GOTOXY (1, 2) ; 
0578:  MOVLW  01
0579:  BSF    03.5
057A:  MOVWF  59
057B:  MOVLW  02
057C:  MOVWF  5A
057D:  BCF    03.5
057E:  CALL   291
....................    DELAY_MS (10); 
057F:  MOVLW  0A
0580:  BSF    03.5
0581:  MOVWF  59
0582:  BCF    03.5
0583:  CALL   120
....................    PRINTF (LCD_PUTC, "CASE:          ") ; 
0584:  MOVLW  A5
0585:  BSF    03.6
0586:  MOVWF  0D
0587:  MOVLW  00
0588:  MOVWF  0F
0589:  BCF    03.6
058A:  CALL   2DF
....................  
....................    WHILE (TT_FUN) 
058B:  BTFSS  49.4
058C:  GOTO   5D4
....................    { 
....................       IF (INPUT (BT2_PIN) == 0) //NEU NUT BAM DUOC BAM 
058D:  BSF    03.5
058E:  BSF    06.2
058F:  BCF    03.5
0590:  BTFSC  06.2
0591:  GOTO   5D3
....................       { 
....................          CONFIG_FUN ++; 
0592:  INCF   38,F
....................          CONFIG_FUN = CONFIG_FUN % 2; 
0593:  MOVLW  01
0594:  ANDWF  38,F
....................          DELAY_MS (300); 
0595:  MOVLW  02
0596:  BSF    03.5
0597:  MOVWF  54
0598:  MOVLW  96
0599:  MOVWF  59
059A:  BCF    03.5
059B:  CALL   120
059C:  BSF    03.5
059D:  DECFSZ 54,F
059E:  GOTO   598
....................          //HIEN THI 
....................          LCD_GOTOXY (6, 2) ; 
059F:  MOVLW  06
05A0:  MOVWF  59
05A1:  MOVLW  02
05A2:  MOVWF  5A
05A3:  BCF    03.5
05A4:  CALL   291
....................          ITOA (CONFIG_FUN, 10, TEMP_CHAR); 
05A5:  BSF    03.5
05A6:  CLRF   5A
05A7:  CLRF   59
05A8:  CLRF   58
05A9:  BCF    03.5
05AA:  MOVF   38,W
05AB:  BSF    03.5
05AC:  MOVWF  57
05AD:  MOVLW  0A
05AE:  MOVWF  5B
05AF:  CLRF   5D
05B0:  MOVLW  6E
05B1:  MOVWF  5C
05B2:  BCF    03.5
05B3:  CALL   3CF
....................          DELAY_MS (10); 
05B4:  MOVLW  0A
05B5:  BSF    03.5
05B6:  MOVWF  59
05B7:  BCF    03.5
05B8:  CALL   120
....................          PRINTF (LCD_PUTC, TEMP_CHAR); 
05B9:  MOVLW  6E
05BA:  MOVWF  04
05BB:  BCF    03.7
05BC:  CALL   531
....................  
....................          SWITCH (CONFIG_FUN) 
05BD:  MOVF   38,W
05BE:  BTFSC  03.2
05BF:  GOTO   5C4
05C0:  XORLW  01
05C1:  BTFSC  03.2
05C2:  GOTO   5CC
05C3:  GOTO   5D3
....................          { 
....................             CASE 0: 
....................             PRINTF (LCD_PUTC, " - ID-NODE      "); 
05C4:  MOVLW  AD
05C5:  BSF    03.6
05C6:  MOVWF  0D
05C7:  MOVLW  00
05C8:  MOVWF  0F
05C9:  BCF    03.6
05CA:  CALL   2DF
....................             BREAK; 
05CB:  GOTO   5D3
....................  
....................             CASE 1: 
....................             PRINTF (LCD_PUTC, " - ID-GW       "); 
05CC:  MOVLW  B6
05CD:  BSF    03.6
05CE:  MOVWF  0D
05CF:  MOVLW  00
05D0:  MOVWF  0F
05D1:  BCF    03.6
05D2:  CALL   2DF
....................             BREAK;             
....................          } 
....................       } 
05D3:  GOTO   58B
....................    } 
....................  
....................    ////// 
....................    IF (!TT_CONFIG_DONE) 
05D4:  BTFSC  49.3
05D5:  GOTO   75F
....................    { 
....................       SELLECT_FUN (); 
....................    } 
*
075F:  BSF    0A.3
0760:  BCF    0A.4
0761:  GOTO   451 (RETURN)
.................... } 
.................... VOID XULY_IDNODE_NHAP(){ 
....................    *TEMP_CHAR3 = "\0"; 
*
083F:  CLRF   7A
0840:  MOVLW  73
0841:  MOVWF  56
0842:  MOVF   7A,W
0843:  MOVWF  57
0844:  MOVF   56,W
0845:  MOVWF  04
0846:  BCF    03.7
0847:  BTFSC  57.0
0848:  BSF    03.7
0849:  CLRF   00
....................    *ID_NODE_CHAR = "\0"; 
084A:  CLRF   7A
084B:  MOVLW  4A
084C:  MOVWF  56
084D:  MOVF   7A,W
084E:  MOVWF  57
084F:  MOVF   56,W
0850:  MOVWF  04
0851:  BCF    03.7
0852:  BTFSC  57.0
0853:  BSF    03.7
0854:  CLRF   00
....................    FOR (int j = 0; j < 4; j++) 
0855:  CLRF   55
0856:  MOVF   55,W
0857:  SUBLW  03
0858:  BTFSS  03.0
0859:  GOTO   083
....................    { 
....................       ITOA (ID_NODE[j], 10, TEMP_CHAR); 
085A:  MOVLW  44
085B:  ADDWF  55,W
085C:  MOVWF  04
085D:  BCF    03.7
085E:  MOVF   00,W
085F:  MOVWF  56
0860:  CLRF   5A
0861:  CLRF   59
0862:  CLRF   58
0863:  MOVF   56,W
0864:  MOVWF  57
0865:  MOVLW  0A
0866:  MOVWF  5B
0867:  CLRF   5D
0868:  MOVLW  6E
0869:  MOVWF  5C
086A:  BCF    0A.3
086B:  BCF    03.5
086C:  CALL   3CF
086D:  BSF    0A.3
....................       DELAY_MS (1); 
086E:  MOVLW  01
086F:  BSF    03.5
0870:  MOVWF  59
0871:  BCF    0A.3
0872:  BCF    03.5
0873:  CALL   120
0874:  BSF    0A.3
....................       STRCAT (TEMP_CHAR3, TEMP_CHAR); 
0875:  BSF    03.5
0876:  CLRF   57
0877:  MOVLW  73
0878:  MOVWF  56
0879:  CLRF   59
087A:  MOVLW  6E
087B:  MOVWF  58
087C:  BCF    0A.3
087D:  BCF    03.5
087E:  CALL   762
087F:  BSF    0A.3
0880:  BSF    03.5
0881:  INCF   55,F
0882:  GOTO   056
....................    }   
....................    //ID_NODE_CHAR = TEMP_CHAR3;    
....................    STRCPY(ID_NODE_CHAR,TEMP_CHAR3); 
0883:  CLRF   59
0884:  MOVLW  73
0885:  MOVWF  58
0886:  CLRF   57
0887:  MOVLW  4A
0888:  MOVWF  56
0889:  MOVF   58,W
088A:  MOVWF  04
088B:  BCF    03.7
088C:  BTFSC  59.0
088D:  BSF    03.7
088E:  MOVF   00,W
088F:  MOVWF  5A
0890:  MOVF   56,W
0891:  MOVWF  04
0892:  BCF    03.7
0893:  BTFSC  57.0
0894:  BSF    03.7
0895:  MOVF   5A,W
0896:  MOVWF  00
0897:  MOVF   00,F
0898:  BTFSC  03.2
0899:  GOTO   09D
089A:  INCF   56,F
089B:  INCF   58,F
089C:  GOTO   089
....................    //strcpy 
.................... } 
.................... VOID XULY_IDGW_NHAP(){ 
....................  
....................    *ID_GATEWAY_CHAR = "\0"; 
*
0802:  CLRF   7A
0803:  MOVLW  51
0804:  BSF    03.5
0805:  MOVWF  56
0806:  MOVF   7A,W
0807:  MOVWF  57
0808:  MOVF   56,W
0809:  MOVWF  04
080A:  BCF    03.7
080B:  BTFSC  57.0
080C:  BSF    03.7
080D:  CLRF   00
....................    FOR (int j = 0; j < 6; j++) 
080E:  CLRF   55
080F:  MOVF   55,W
0810:  SUBLW  05
0811:  BTFSS  03.0
0812:  GOTO   03C
....................    { 
....................       ITOA (ID_GATEWAY[j], 10, TEMP_CHAR); 
0813:  MOVLW  3E
0814:  ADDWF  55,W
0815:  MOVWF  04
0816:  BCF    03.7
0817:  MOVF   00,W
0818:  MOVWF  56
0819:  CLRF   5A
081A:  CLRF   59
081B:  CLRF   58
081C:  MOVF   56,W
081D:  MOVWF  57
081E:  MOVLW  0A
081F:  MOVWF  5B
0820:  CLRF   5D
0821:  MOVLW  6E
0822:  MOVWF  5C
0823:  BCF    0A.3
0824:  BCF    03.5
0825:  CALL   3CF
0826:  BSF    0A.3
....................       DELAY_MS (1); 
0827:  MOVLW  01
0828:  BSF    03.5
0829:  MOVWF  59
082A:  BCF    0A.3
082B:  BCF    03.5
082C:  CALL   120
082D:  BSF    0A.3
....................       STRCAT (ID_GATEWAY_CHAR, TEMP_CHAR); 
082E:  BSF    03.5
082F:  CLRF   57
0830:  MOVLW  51
0831:  MOVWF  56
0832:  CLRF   59
0833:  MOVLW  6E
0834:  MOVWF  58
0835:  BCF    0A.3
0836:  BCF    03.5
0837:  CALL   762
0838:  BSF    0A.3
0839:  BSF    03.5
083A:  INCF   55,F
083B:  GOTO   00F
....................    }   
....................     //STRCPY(ID_GATEWAY_CHAR,TEMP_CHAR2); 
.................... } 
....................  
....................  
.................... VOID CONFIG_DONE() 
.................... { 
....................    TT_FUN = 0; 
*
0800:  BCF    49.4
....................    TT_STT = 0;    
0801:  BCF    49.5
....................    XULY_IDGW_NHAP(); 
....................    PACKAGE_CONFIG[3] = ID_GATEWAY_CHAR; 
*
083C:  CLRF   27
083D:  MOVLW  51
083E:  MOVWF  26
....................     
....................    XULY_IDNODE_NHAP(); 
....................    PACKAGE_CONFIG[4] = ID_NODE_CHAR;          
*
089D:  CLRF   29
089E:  MOVLW  4A
089F:  MOVWF  28
....................    LEN_PACKAGES = 0; 
08A0:  BCF    03.5
08A1:  CLRF   48
....................    PACKAGE_CONFIG[1] = "12"; //DO DAI CUA LENGHT CO DO DAI = 2 
08A2:  MOVLW  31
08A3:  BSF    03.5
08A4:  MOVWF  22
08A5:  MOVLW  32
08A6:  MOVWF  23
....................    FOR (int J = 0; J < 6; J++) 
08A7:  CLRF   54
08A8:  MOVF   54,W
08A9:  SUBLW  05
08AA:  BTFSS  03.0
08AB:  GOTO   0DE
....................    { 
....................       LEN_PACKAGES += strlen(PACKAGE_CONFIG[J]); 
08AC:  BCF    03.0
08AD:  RLF    54,W
08AE:  ADDLW  A0
08AF:  MOVWF  04
08B0:  BCF    03.7
08B1:  INCF   04,F
08B2:  MOVF   00,W
08B3:  MOVWF  56
08B4:  DECF   04,F
08B5:  MOVF   00,W
08B6:  MOVWF  55
08B7:  MOVF   56,W
08B8:  MOVWF  58
08B9:  MOVF   55,W
08BA:  MOVWF  57
*
08D8:  MOVF   78,W
08D9:  BCF    03.5
08DA:  ADDWF  48,F
08DB:  BSF    03.5
08DC:  INCF   54,F
08DD:  GOTO   0A8
....................    }    
....................    LEN_PACKAGES = LEN_PACKAGES+5; //5 @ 
08DE:  MOVLW  05
08DF:  BCF    03.5
08E0:  ADDWF  48,F
....................    ITOA (LEN_PACKAGES, 10, TEMP_CHAR); 
08E1:  BSF    03.5
08E2:  CLRF   5A
08E3:  CLRF   59
08E4:  CLRF   58
08E5:  BCF    03.5
08E6:  MOVF   48,W
08E7:  BSF    03.5
08E8:  MOVWF  57
08E9:  MOVLW  0A
08EA:  MOVWF  5B
08EB:  CLRF   5D
08EC:  MOVLW  6E
08ED:  MOVWF  5C
08EE:  BCF    0A.3
08EF:  BCF    03.5
08F0:  CALL   3CF
08F1:  BSF    0A.3
....................    PACKAGE_CONFIG[1] = TEMP_CHAR; 
08F2:  BSF    03.5
08F3:  CLRF   23
08F4:  MOVLW  6E
08F5:  MOVWF  22
....................     
....................    FOR ( J = 0; J < 6; J++) 
08F6:  CLRF   54
08F7:  MOVF   54,W
08F8:  SUBLW  05
08F9:  BTFSS  03.0
08FA:  GOTO   12E
....................    { 
....................       PRINTF (PACKAGE_CONFIG[J]); 
08FB:  BCF    03.0
08FC:  RLF    54,W
08FD:  ADDLW  A0
08FE:  MOVWF  04
08FF:  BCF    03.7
0900:  INCF   04,F
0901:  MOVF   00,W
0902:  MOVWF  56
0903:  DECF   04,F
0904:  MOVF   00,W
0905:  MOVWF  55
0906:  MOVF   55,W
0907:  MOVWF  04
0908:  BCF    03.7
0909:  BTFSC  56.0
090A:  BSF    03.7
....................       PRINTF ("@"); 
*
0926:  MOVLW  40
0927:  BCF    03.5
0928:  BTFSS  0C.4
0929:  GOTO   128
092A:  MOVWF  19
092B:  BSF    03.5
092C:  INCF   54,F
092D:  GOTO   0F7
....................    } 
....................  
....................  
....................    LCD_GOTOXY (1, 1) ; 
092E:  MOVLW  01
092F:  MOVWF  59
0930:  MOVWF  5A
0931:  BCF    0A.3
0932:  BCF    03.5
0933:  CALL   291
0934:  BSF    0A.3
....................    DELAY_MS (10); 
0935:  MOVLW  0A
0936:  BSF    03.5
0937:  MOVWF  59
0938:  BCF    0A.3
0939:  BCF    03.5
093A:  CALL   120
093B:  BSF    0A.3
....................    PRINTF (LCD_PUTC, "CONFIG DONE        ") ; 
093C:  MOVLW  BE
093D:  BSF    03.6
093E:  MOVWF  0D
093F:  MOVLW  00
0940:  MOVWF  0F
0941:  BCF    0A.3
0942:  BCF    03.6
0943:  CALL   2DF
0944:  BSF    0A.3
....................    LCD_GOTOXY (1, 2) ; 
0945:  MOVLW  01
0946:  BSF    03.5
0947:  MOVWF  59
0948:  MOVLW  02
0949:  MOVWF  5A
094A:  BCF    0A.3
094B:  BCF    03.5
094C:  CALL   291
094D:  BSF    0A.3
....................    DELAY_MS (10); 
094E:  MOVLW  0A
094F:  BSF    03.5
0950:  MOVWF  59
0951:  BCF    0A.3
0952:  BCF    03.5
0953:  CALL   120
0954:  BSF    0A.3
....................    PRINTF (LCD_PUTC, "CONFIG DONE        ") ; 
0955:  MOVLW  C8
0956:  BSF    03.6
0957:  MOVWF  0D
0958:  MOVLW  00
0959:  MOVWF  0F
095A:  BCF    0A.3
095B:  BCF    03.6
095C:  CALL   2DF
095D:  BSF    0A.3
....................  
....................    TT_CONFIG_DONE = 0; 
095E:  BCF    49.3
095F:  BSF    0A.3
0960:  BCF    0A.4
0961:  GOTO   456 (RETURN)
.................... } 
....................  
.................... //--------------------------------------------------------------------// 
....................  
....................  
....................  
....................  
....................  
.................... VOID QUET_PHIM() 
*
00D2:  BSF    03.6
00D3:  CLRF   26
.................... { 
....................    INT BDT = 0; 
....................  
....................    WHILE (!INPUT (BT1_PIN)) //NEU NUT BAM DUOC BAM 
00D4:  BSF    03.5
00D5:  BCF    03.6
00D6:  BSF    06.1
00D7:  BCF    03.5
00D8:  BTFSC  06.1
00D9:  GOTO   0ED
....................    { 
....................       IF (TMR1IF) 
00DA:  BTFSS  0C.0
00DB:  GOTO   0EA
....................       { 
....................          OUTPUT_TOGGLE (PIN_D2); 
00DC:  BSF    03.5
00DD:  BCF    08.2
00DE:  MOVLW  04
00DF:  BCF    03.5
00E0:  XORWF  08,F
....................          TMR1IF = 0; SET_TIMER1 (3036); BDT++; 
00E1:  BCF    0C.0
00E2:  CLRF   0E
00E3:  MOVLW  0B
00E4:  MOVWF  0F
00E5:  MOVLW  DC
00E6:  MOVWF  0E
00E7:  BSF    03.6
00E8:  INCF   26,F
00E9:  BCF    03.6
....................       } 
00EA:  BSF    03.6
00EB:  GOTO   0D4
00EC:  BCF    03.6
....................    } 
....................  
....................    IF (BDT > 20) 
00ED:  BSF    03.6
00EE:  MOVF   26,W
00EF:  SUBLW  14
00F0:  BTFSC  03.0
00F1:  GOTO   0FB
....................    { 
....................       //CONFIG NODE 
....................       TT_CONFIG = ~TT_CONFIG; // VAO TRANG THAI CONFIG 
00F2:  MOVLW  02
00F3:  BCF    03.6
00F4:  XORWF  49,F
....................       TT_CONTROL = ~TT_CONTROL; 
00F5:  MOVLW  04
00F6:  XORWF  49,F
....................       //CONFIG_DONE (); 
....................       TT_CONFIG_DONE = 1; 
00F7:  BSF    49.3
....................       TT_FUN = 0; 
00F8:  BCF    49.4
....................    } 
00F9:  GOTO   0FF
00FA:  BSF    03.6
....................  
....................    ELSE 
....................    { 
....................       BUTT_OKE (); //OKE 
....................    } 
.................... } 
....................  
.................... #INT_EXT 
....................  
....................  VOID NGAT_NGOAI () 
....................  { 
....................     QUET_PHIM (); 
....................  } 
....................  
*
00FF:  BCF    0B.1
0100:  BCF    0A.3
0101:  BCF    0A.4
0102:  GOTO   031
....................  #INT_RDA 
....................  VOID NGAT () 
....................  { 
....................     KYTUCHAR[VT] = GETCH (); 
0103:  MOVLW  5A
0104:  ADDWF  39,W
0105:  MOVWF  04
0106:  BCF    03.7
0107:  BTFSS  0C.5
0108:  GOTO   107
0109:  MOVF   1A,W
010A:  MOVWF  00
....................  
....................     IF (KYTUCHAR[VT] == '.') 
010B:  MOVLW  5A
010C:  ADDWF  39,W
010D:  MOVWF  04
010E:  BCF    03.7
010F:  MOVF   00,W
0110:  SUBLW  2E
0111:  BTFSS  03.2
0112:  GOTO   11B
....................     { 
....................        KYTUCHAR[VT] = '\0'; 
0113:  MOVLW  5A
0114:  ADDWF  39,W
0115:  MOVWF  04
0116:  BCF    03.7
0117:  CLRF   00
....................        VT = 0; 
0118:  CLRF   39
....................        TTNHAN = 1; 
0119:  BSF    49.0
....................     } 
011A:  GOTO   11C
....................  
....................     ELSE 
....................     VT++; 
011B:  INCF   39,F
011C:  BCF    0C.5
011D:  BCF    0A.3
011E:  BCF    0A.4
011F:  GOTO   031
....................  } 
....................  
....................  VOID XUATLCD  () 
....................  { 
....................     LCD_GOTOXY (1, 1) ; 
*
07B6:  MOVLW  01
07B7:  BSF    03.5
07B8:  MOVWF  59
07B9:  MOVWF  5A
07BA:  BCF    03.5
07BB:  CALL   291
....................     DELAY_MS (10); 
07BC:  MOVLW  0A
07BD:  BSF    03.5
07BE:  MOVWF  59
07BF:  BCF    03.5
07C0:  CALL   120
....................     PRINTF (LCD_PUTC, KYTUCHAR); 
07C1:  MOVLW  5A
07C2:  MOVWF  04
07C3:  BCF    03.7
07C4:  CALL   531
....................     DELAY_MS (1); 
07C5:  MOVLW  01
07C6:  BSF    03.5
07C7:  MOVWF  59
07C8:  BCF    03.5
07C9:  CALL   120
07CA:  BSF    0A.3
07CB:  BCF    0A.4
07CC:  GOTO   476 (RETURN)
....................  } 
....................  
....................  INT ADC_READ (INT KENH) 
....................  { 
....................     SET_ADC_CHANNEL (KENH); 
....................     KQADC = 0; 
....................     FOR (INT I = 0; I < 100; I++) 
....................     { 
....................        KQADC = KQADC + READ_ADC () ; 
....................        DELAY_MS (1); 
....................     } 
....................  
....................     KQADC = KQADC / (100 * 2.046); 
....................     RETURN KQADC; 
....................  } 
....................  
....................  VOID CHUONG_TRINH_CON () 
....................  { 
....................     FOR (INT I = 0; I <= 30; I++) 
*
07A0:  BSF    03.5
07A1:  CLRF   54
07A2:  MOVF   54,W
07A3:  SUBLW  1E
07A4:  BTFSS  03.0
07A5:  GOTO   7B2
....................     { 
....................        OUTPUT_TOGGLE (PIN_D1); 
07A6:  BCF    08.1
07A7:  MOVLW  02
07A8:  BCF    03.5
07A9:  XORWF  08,F
....................        DELAY_MS (100); 
07AA:  MOVLW  64
07AB:  BSF    03.5
07AC:  MOVWF  59
07AD:  BCF    03.5
07AE:  CALL   120
07AF:  BSF    03.5
07B0:  INCF   54,F
07B1:  GOTO   7A2
....................     } 
07B2:  BCF    03.5
07B3:  BSF    0A.3
07B4:  BCF    0A.4
07B5:  GOTO   45B (RETURN)
....................  } 
....................  
....................  VOID MAIN  () 
*
0B55:  MOVF   03,W
0B56:  ANDLW  1F
0B57:  MOVWF  03
0B58:  BSF    03.5
0B59:  BSF    03.6
0B5A:  BSF    07.3
0B5B:  MOVLW  08
0B5C:  BCF    03.6
0B5D:  MOVWF  19
0B5E:  MOVLW  02
0B5F:  MOVWF  1A
0B60:  MOVLW  A6
0B61:  MOVWF  18
0B62:  MOVLW  90
0B63:  BCF    03.5
0B64:  MOVWF  18
0B65:  MOVLW  FF
0B66:  MOVWF  31
0B67:  CLRF   38
0B68:  CLRF   39
0B69:  CLRF   3A
0B6A:  CLRF   48
0B6B:  BCF    49.0
0B6C:  BCF    49.1
0B6D:  BCF    49.2
0B6E:  BCF    49.3
0B6F:  BCF    49.4
0B70:  BCF    49.5
0B71:  BSF    03.5
0B72:  BSF    03.6
0B73:  MOVF   09,W
0B74:  ANDLW  C0
0B75:  MOVWF  09
0B76:  BCF    03.6
0B77:  BCF    1F.4
0B78:  BCF    1F.5
0B79:  MOVLW  00
0B7A:  BSF    03.6
0B7B:  MOVWF  08
0B7C:  BCF    03.5
0B7D:  CLRF   07
0B7E:  CLRF   08
0B7F:  CLRF   09
0B80:  BCF    03.7
....................  { 
....................     SET_TRIS_D (0X00); 
*
0C12:  MOVLW  00
0C13:  MOVWF  08
....................     SET_TRIS_B (0XFF); 
0C14:  MOVLW  FF
0C15:  MOVWF  06
....................     SET_TRIS_E (0); 
0C16:  BCF    09.0
0C17:  BCF    09.1
0C18:  BCF    09.2
0C19:  BCF    09.3
....................     SET_TRIS_C (0X80); 
0C1A:  MOVLW  80
0C1B:  MOVWF  07
0C1C:  BCF    03.5
0C1D:  MOVWF  31
....................     SETUP_ADC (ADC_CLOCK_DIV_8); 
0C1E:  BSF    1F.6
0C1F:  BCF    1F.7
0C20:  BSF    03.5
0C21:  BSF    1F.7
0C22:  BCF    03.5
0C23:  BSF    1F.0
....................     SETUP_ADC_PORTS (SAN0); 
0C24:  BSF    03.5
0C25:  BSF    03.6
0C26:  MOVF   09,W
0C27:  ANDLW  C0
0C28:  MOVWF  09
0C29:  BCF    03.6
0C2A:  BCF    1F.4
0C2B:  BCF    1F.5
0C2C:  MOVLW  01
0C2D:  BSF    03.6
0C2E:  MOVWF  08
....................     ENABLE_INTERRUPTS (INT_TIMER0); 
0C2F:  BCF    03.5
0C30:  BCF    03.6
0C31:  BSF    0B.5
....................     ENABLE_INTERRUPTS (INT_EXT); //CHO PHEP NGAT NGOAI 
0C32:  BSF    0B.4
....................     ENABLE_INTERRUPTS (INT_EXT_H2L); //NGAT XAY RA KHI CO XUNG TU CAO XUONG THAP 
0C33:  BSF    0B.4
0C34:  BSF    03.5
0C35:  BCF    01.6
....................     ENABLE_INTERRUPTS (INT_RDA); 
0C36:  BSF    0C.5
....................     ENABLE_INTERRUPTS (GLOBAL); 
0C37:  MOVLW  C0
0C38:  BCF    03.5
0C39:  IORWF  0B,F
....................      
....................     SETUP_TIMER_1 (T1_INTERNAL|T1_DIV_BY_8); 
0C3A:  MOVLW  35
0C3B:  MOVWF  10
....................     //SET_TIMER1 (0); 
....................     SET_TIMER1 (3036); 
0C3C:  CLRF   0E
0C3D:  MOVLW  0B
0C3E:  MOVWF  0F
0C3F:  MOVLW  DC
0C40:  MOVWF  0E
....................     TMR1IF = 0; 
0C41:  BCF    0C.0
....................     LCD_INIT (); // KHOI TAO LCD 
0C42:  BCF    0A.3
0C43:  GOTO   22D
0C44:  BSF    0A.3
....................  
....................     TT_CONFIG = 0; 
0C45:  BCF    49.1
....................     TT_CONFIG_DONE = 0; 
0C46:  BCF    49.3
....................     TT_CONTROL = 1; 
0C47:  BSF    49.2
....................     OUTPUT_D (0X00); 
0C48:  BSF    03.5
0C49:  CLRF   08
0C4A:  BCF    03.5
0C4B:  CLRF   08
....................     TTNHAN = 0; 
0C4C:  BCF    49.0
....................      
....................      
....................      
....................     WHILE (TRUE) 
....................     { 
....................        //AN1 = ADC_READ (1) ; 
....................        //AN0 = ADC_READ (0) ; 
....................  
....................        IF (TT_CONFIG) 
0C4D:  BTFSS  49.1
0C4E:  GOTO   453
....................        { 
....................           BUTT_FUN (); // GOI HAM CHON LENH (SWITCH CASE) 
0C4F:  BCF    0A.3
0C50:  GOTO   565
0C51:  BSF    0A.3
....................        } 
0C52:  GOTO   50E
....................  
....................        ELSE IF (TT_CONFIG_DONE) 
0C53:  BTFSS  49.3
0C54:  GOTO   457
....................        { 
....................           CONFIG_DONE (); 
0C55:  GOTO   000
....................        } 
0C56:  GOTO   50E
....................  
....................         
....................        ELSE 
....................        { 
....................           WHILE (!TT_CONFIG) 
0C57:  BTFSC  49.1
0C58:  GOTO   50E
....................           { 
....................              CHUONG_TRINH_CON (); 
0C59:  BCF    0A.3
0C5A:  GOTO   7A0
0C5B:  BSF    0A.3
....................  
....................              IF (AN0 > 26) 
0C5C:  MOVF   35,F
0C5D:  BTFSS  03.2
0C5E:  GOTO   463
0C5F:  MOVF   34,W
0C60:  SUBLW  1A
0C61:  BTFSC  03.0
0C62:  GOTO   470
....................              { 
....................  
....................                  
....................                 DELAY_MS (1000); 
0C63:  MOVLW  04
0C64:  BSF    03.5
0C65:  MOVWF  54
0C66:  MOVLW  FA
0C67:  MOVWF  59
0C68:  BCF    0A.3
0C69:  BCF    03.5
0C6A:  CALL   120
0C6B:  BSF    0A.3
0C6C:  BSF    03.5
0C6D:  DECFSZ 54,F
0C6E:  GOTO   466
0C6F:  BCF    03.5
....................              } 
....................  
....................               
....................              IF (TTNHAN == 1) 
0C70:  BTFSS  49.0
0C71:  GOTO   50D
....................              { 
....................                 TTNHAN = 0; 
0C72:  BCF    49.0
....................                 KYTU = 0; 
0C73:  CLRF   3A
....................                 //TEMP_CHAR = 'K'; 
....................                 //ID_NODE_NHAN = KYTU[1] - 48; 
....................                 //ID_DEVICE_NHAN = KYTU[2] - 48 + 64; 
....................                 //TT_DEVICE_NHAN = KYTU[3] - 48; // - 48 ASCII -- > S?. + 64 -- > PORT_D (D0 = 64) 
....................                 XUATLCD (); 
0C74:  BCF    0A.3
0C75:  GOTO   7B6
0C76:  BSF    0A.3
....................                  
....................                 /* LAY TOKEN DAU TIEN */ 
....................                 TEMP_CHAR = "_"; 
0C77:  BSF    03.5
0C78:  CLRF   54
0C79:  CLRF   55
0C7A:  MOVLW  6E
0C7B:  MOVWF  04
0C7C:  BCF    03.7
0C7D:  MOVF   54,W
0C7E:  ADDWF  04,F
0C7F:  MOVF   55,W
0C80:  BCF    0A.3
0C81:  BCF    03.5
0C82:  CALL   05E
0C83:  BSF    0A.3
0C84:  MOVWF  00
0C85:  IORLW  00
0C86:  BTFSC  03.2
0C87:  GOTO   48D
0C88:  BSF    03.5
0C89:  INCF   55,F
0C8A:  INCF   54,F
0C8B:  GOTO   47A
0C8C:  BCF    03.5
....................                 CHAR * TOKEN; 
....................                 TOKEN = STRTOK (KYTUCHAR, TEMP_CHAR); 
0C8D:  BSF    03.5
0C8E:  CLRF   55
0C8F:  MOVLW  5A
0C90:  MOVWF  54
0C91:  CLRF   57
0C92:  MOVLW  6E
0C93:  MOVWF  56
0C94:  BCF    03.5
0C95:  CALL   162
0C96:  MOVF   79,W
0C97:  BSF    03.5
0C98:  MOVWF  53
0C99:  MOVF   78,W
0C9A:  MOVWF  52
....................                  
....................                 /* DUYET QUA CAC TOKEN CON LAI */ 
....................                  
....................                 LCD_GOTOXY (1, 2) ; 
0C9B:  MOVLW  01
0C9C:  MOVWF  59
0C9D:  MOVLW  02
0C9E:  MOVWF  5A
0C9F:  BCF    0A.3
0CA0:  BCF    03.5
0CA1:  CALL   291
0CA2:  BSF    0A.3
....................                 WHILE (TOKEN != NULL) 
0CA3:  BSF    03.5
0CA4:  MOVF   52,F
0CA5:  BTFSS  03.2
0CA6:  GOTO   4AA
0CA7:  MOVF   53,F
0CA8:  BTFSC  03.2
0CA9:  GOTO   4E8
....................                 {                 
....................                    SWITCH(KYTU) 
0CAA:  BCF    03.5
0CAB:  MOVF   3A,W
0CAC:  ADDLW  FC
0CAD:  BTFSC  03.0
0CAE:  GOTO   4D0
0CAF:  ADDLW  04
0CB0:  GOTO   510
....................                    { 
....................                      CASE 0: 
....................                      BREAK; 
0CB1:  GOTO   4D0
....................                      CASE 1: 
....................                      ID_NODE_NHAN = ATOI(TOKEN);   
0CB2:  BSF    03.5
0CB3:  MOVF   53,W
0CB4:  MOVWF  55
0CB5:  MOVF   52,W
0CB6:  MOVWF  54
0CB7:  BCF    03.5
0CB8:  CALL   253
0CB9:  MOVF   78,W
0CBA:  MOVWF  3B
....................                      BREAK; 
0CBB:  GOTO   4D0
....................                 
....................                      CASE 2: 
....................                      ID_DEVICE_NHAN =  ATOI(TOKEN) + 64 ; 
0CBC:  BSF    03.5
0CBD:  MOVF   53,W
0CBE:  MOVWF  55
0CBF:  MOVF   52,W
0CC0:  MOVWF  54
0CC1:  BCF    03.5
0CC2:  CALL   253
0CC3:  MOVLW  40
0CC4:  ADDWF  78,W
0CC5:  MOVWF  3C
....................                      BREAK; 
0CC6:  GOTO   4D0
....................                 
....................                      CASE 3: 
....................                      TT_DEVICE_NHAN =  ATOI(TOKEN);                  
0CC7:  BSF    03.5
0CC8:  MOVF   53,W
0CC9:  MOVWF  55
0CCA:  MOVF   52,W
0CCB:  MOVWF  54
0CCC:  BCF    03.5
0CCD:  CALL   253
0CCE:  MOVF   78,W
0CCF:  MOVWF  3D
....................                      BREAK; 
....................                 
....................                     
....................                    } 
....................                   //PRINTF (LCD_PUTC, TOKEN);    
....................                   DELAY_MS (1);                       
0CD0:  MOVLW  01
0CD1:  BSF    03.5
0CD2:  MOVWF  59
0CD3:  BCF    0A.3
0CD4:  BCF    03.5
0CD5:  CALL   120
0CD6:  BSF    0A.3
....................                   TOKEN = STRTOK(NULL, TEMP_CHAR); 
0CD7:  BSF    03.5
0CD8:  CLRF   55
0CD9:  CLRF   54
0CDA:  CLRF   57
0CDB:  MOVLW  6E
0CDC:  MOVWF  56
0CDD:  BCF    03.5
0CDE:  CALL   162
0CDF:  MOVF   79,W
0CE0:  BSF    03.5
0CE1:  MOVWF  53
0CE2:  MOVF   78,W
0CE3:  MOVWF  52
....................                   KYTU++;      
0CE4:  BCF    03.5
0CE5:  INCF   3A,F
0CE6:  GOTO   4A3
0CE7:  BSF    03.5
....................                  
....................                 } 
....................                 IF (ID_NODE_NHAN == ID_NODE) 
0CE8:  BCF    03.5
0CE9:  MOVF   3B,W
0CEA:  SUBLW  44
0CEB:  BTFSS  03.2
0CEC:  GOTO   50D
0CED:  XORLW  00
0CEE:  BTFSS  03.2
0CEF:  GOTO   50D
....................                 { 
....................                    OUTPUT_BIT (ID_DEVICE_NHAN, TT_DEVICE_NHAN); 
0CF0:  MOVF   3D,F
0CF1:  BTFSS  03.2
0CF2:  GOTO   4F5
0CF3:  MOVLW  00
0CF4:  GOTO   4F6
0CF5:  MOVLW  01
0CF6:  MOVWF  77
0CF7:  MOVF   3C,W
0CF8:  BSF    03.5
0CF9:  MOVWF  54
0CFA:  MOVF   77,W
0CFB:  MOVWF  55
0CFC:  CLRF   57
0CFD:  CLRF   56
0CFE:  BCF    0A.3
0CFF:  BCF    03.5
0D00:  CALL   7CD
0D01:  BSF    0A.3
0D02:  MOVF   3C,W
0D03:  BSF    03.5
0D04:  MOVWF  54
0D05:  CLRF   55
0D06:  CLRF   57
0D07:  MOVLW  80
0D08:  MOVWF  56
0D09:  BCF    0A.3
0D0A:  BCF    03.5
0D0B:  CALL   7CD
0D0C:  BSF    0A.3
....................                 } 
....................              } 
0D0D:  GOTO   457
....................           } 
....................        } 
0D0E:  GOTO   44D
....................     } 
....................  } 
....................  
0D0F:  SLEEP

Configuration Fuses:
   Word  1: 2FE2   HS NOWDT PUT MCLR NOPROTECT NOCPD BROWNOUT IESO FCMEN NOLVP NODEBUG
   Word  2: 3FFF   BORV40 NOWRT
