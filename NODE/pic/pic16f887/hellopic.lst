CCS PCM C Compiler, Version 5.015, 5967               26-Oct-21 14:13

               Filename:   E:\DATN\NODE\pic\pic16f887\hellopic.lst

               ROM used:   4924 words (60%)
                           Largest free fragment is 2048
               RAM used:   234 (64%) at main() level
                           279 (76%) worst case
               Stack used: 7 locations (6 in main + 1 for interrupts)
               Stack size: 8

*
0000:  MOVLW  11
0001:  MOVWF  0A
0002:  GOTO   102
0003:  NOP
0004:  MOVWF  7F
0005:  SWAPF  03,W
0006:  CLRF   03
0007:  MOVWF  21
0008:  MOVF   0A,W
0009:  MOVWF  20
000A:  CLRF   0A
000B:  MOVF   04,W
000C:  MOVWF  22
000D:  MOVF   77,W
000E:  MOVWF  23
000F:  MOVF   78,W
0010:  MOVWF  24
0011:  MOVF   79,W
0012:  MOVWF  25
0013:  MOVF   7A,W
0014:  MOVWF  26
0015:  BSF    03.6
0016:  MOVF   0D,W
0017:  BCF    03.6
0018:  MOVWF  27
0019:  BSF    03.6
001A:  MOVF   0F,W
001B:  BCF    03.6
001C:  MOVWF  28
001D:  BSF    03.6
001E:  MOVF   0C,W
001F:  BCF    03.6
0020:  MOVWF  29
0021:  BSF    03.6
0022:  MOVF   0E,W
0023:  BCF    03.6
0024:  MOVWF  2A
0025:  BCF    03.7
0026:  BCF    03.5
0027:  BTFSS  0B.4
0028:  GOTO   02B
0029:  BTFSC  0B.1
002A:  GOTO   052
002B:  MOVLW  8C
002C:  MOVWF  04
002D:  BTFSS  00.5
002E:  GOTO   031
002F:  BTFSC  0C.5
0030:  GOTO   055
0031:  MOVF   22,W
0032:  MOVWF  04
0033:  MOVF   23,W
0034:  MOVWF  77
0035:  MOVF   24,W
0036:  MOVWF  78
0037:  MOVF   25,W
0038:  MOVWF  79
0039:  MOVF   26,W
003A:  MOVWF  7A
003B:  MOVF   27,W
003C:  BSF    03.6
003D:  MOVWF  0D
003E:  BCF    03.6
003F:  MOVF   28,W
0040:  BSF    03.6
0041:  MOVWF  0F
0042:  BCF    03.6
0043:  MOVF   29,W
0044:  BSF    03.6
0045:  MOVWF  0C
0046:  BCF    03.6
0047:  MOVF   2A,W
0048:  BSF    03.6
0049:  MOVWF  0E
004A:  BCF    03.6
004B:  MOVF   20,W
004C:  MOVWF  0A
004D:  SWAPF  21,W
004E:  MOVWF  03
004F:  SWAPF  7F,F
0050:  SWAPF  7F,W
0051:  RETFIE
0052:  BCF    0A.3
0053:  BCF    0A.4
0054:  GOTO   0DC
0055:  BCF    0A.3
0056:  BCF    0A.4
0057:  GOTO   115
....................  
.................... #INCLUDE <thuvien.c> 
.................... #INCLUDE <16F887.H> 
.................... //////////// Standard Header file for the PIC16F887 device //////////////// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2013 Custom Computer Services          //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... #device PIC16F887 
0058:  BCF    0A.0
0059:  BCF    0A.1
005A:  BCF    0A.2
005B:  ADDWF  02,F
005C:  RETLW  30
005D:  RETLW  00
005E:  BCF    0A.0
005F:  BCF    0A.1
0060:  BCF    0A.2
0061:  ADDWF  02,F
0062:  RETLW  00
0063:  BCF    0A.0
0064:  BCF    0A.1
0065:  BCF    0A.2
0066:  ADDWF  02,F
0067:  RETLW  5F
0068:  RETLW  00
0069:  DATA 49,22
006A:  DATA 3A,10
006B:  DATA 20,10
006C:  DATA 20,10
006D:  DATA 20,10
006E:  DATA 20,10
006F:  DATA 20,10
0070:  DATA 20,10
0071:  DATA 00,00
0072:  DATA C4,22
0073:  DATA D6,24
0074:  DATA C3,22
0075:  DATA 3A,10
0076:  DATA 20,10
0077:  DATA 20,10
0078:  DATA 20,10
0079:  DATA 20,10
007A:  DATA 20,10
007B:  DATA 00,01
007C:  DATA D3,22
007D:  DATA CE,29
007E:  DATA 4F,29
007F:  DATA 3A,10
0080:  DATA 20,10
0081:  DATA 20,10
0082:  DATA 20,10
0083:  DATA 20,10
0084:  DATA 00,01
0085:  DATA 49,22
0086:  DATA DF,23
0087:  DATA 57,1D
0088:  DATA 20,10
0089:  DATA 30,18
008A:  DATA 30,18
008B:  DATA 20,00
008C:  DATA 20,10
008D:  DATA 20,10
008E:  DATA 20,10
008F:  DATA 20,10
0090:  DATA 5F,10
0091:  DATA 20,10
0092:  DATA 20,00
0093:  DATA 20,10
0094:  DATA 20,10
0095:  DATA 5F,10
0096:  DATA 20,10
0097:  DATA 20,00
0098:  DATA C3,27
0099:  DATA 4E,23
009A:  DATA C9,23
009B:  DATA 3A,10
009C:  DATA 20,10
009D:  DATA 20,10
009E:  DATA 20,10
009F:  DATA 20,00
00A0:  DATA C3,20
00A1:  DATA D3,22
00A2:  DATA 3A,10
00A3:  DATA 20,10
00A4:  DATA 20,10
00A5:  DATA 20,10
00A6:  DATA 20,10
00A7:  DATA 20,00
00A8:  DATA A0,16
00A9:  DATA A0,24
00AA:  DATA 44,10
00AB:  DATA 20,10
00AC:  DATA 20,10
00AD:  DATA 20,10
00AE:  DATA 20,10
00AF:  DATA 00,01
00B0:  DATA A0,16
00B1:  DATA 20,22
00B2:  DATA 45,2B
00B3:  DATA C9,21
00B4:  DATA C5,29
00B5:  DATA 20,10
00B6:  DATA 20,10
00B7:  DATA 00,01
00B8:  DATA A0,16
00B9:  DATA A0,29
00BA:  DATA 45,27
00BB:  DATA D3,27
00BC:  DATA D2,29
00BD:  DATA 20,10
00BE:  DATA 20,10
00BF:  DATA 00,01
00C0:  DATA A0,16
00C1:  DATA A0,24
00C2:  DATA 44,10
00C3:  DATA 2D,10
00C4:  DATA C7,2B
00C5:  DATA 3A,10
00C6:  DATA 20,10
00C7:  DATA 20,00
00C8:  DATA C3,27
00C9:  DATA 4E,23
00CA:  DATA C9,23
00CB:  DATA 20,22
00CC:  DATA 4F,27
00CD:  DATA 45,10
00CE:  DATA 20,10
00CF:  DATA 20,10
00D0:  DATA 20,10
00D1:  DATA 20,00
00D2:  DATA C3,27
00D3:  DATA 4E,23
00D4:  DATA C9,23
00D5:  DATA 20,22
00D6:  DATA 4F,27
00D7:  DATA 45,10
00D8:  DATA 20,10
00D9:  DATA 20,10
00DA:  DATA 20,10
00DB:  DATA 20,00
*
0404:  MOVF   0B,W
0405:  BSF    03.6
0406:  MOVWF  4D
0407:  BCF    03.6
0408:  BCF    0B.7
0409:  BSF    03.5
040A:  BSF    03.6
040B:  BSF    0C.7
040C:  BSF    0C.0
040D:  NOP
040E:  NOP
040F:  BCF    03.5
0410:  BTFSS  4D.7
0411:  GOTO   415
0412:  BCF    03.6
0413:  BSF    0B.7
0414:  BSF    03.6
0415:  MOVF   0C,W
0416:  ANDLW  7F
0417:  BTFSC  03.2
0418:  GOTO   452
0419:  MOVWF  4D
041A:  MOVF   0D,W
041B:  MOVWF  4E
041C:  MOVF   0F,W
041D:  MOVWF  4F
041E:  MOVF   4D,W
041F:  MOVWF  50
0420:  BCF    03.6
0421:  CALL   3CA
0422:  BSF    03.6
0423:  MOVF   4E,W
0424:  MOVWF  0D
0425:  MOVF   4F,W
0426:  MOVWF  0F
0427:  BCF    03.6
0428:  MOVF   0B,W
0429:  BSF    03.6
042A:  MOVWF  50
042B:  BCF    03.6
042C:  BCF    0B.7
042D:  BSF    03.5
042E:  BSF    03.6
042F:  BSF    0C.7
0430:  BSF    0C.0
0431:  NOP
0432:  NOP
0433:  BCF    03.5
0434:  BTFSS  50.7
0435:  GOTO   439
0436:  BCF    03.6
0437:  BSF    0B.7
0438:  BSF    03.6
0439:  RLF    0C,W
043A:  RLF    0E,W
043B:  ANDLW  7F
043C:  BTFSC  03.2
043D:  GOTO   452
043E:  MOVWF  4D
043F:  MOVF   0D,W
0440:  MOVWF  4E
0441:  MOVF   0F,W
0442:  MOVWF  4F
0443:  MOVF   4D,W
0444:  MOVWF  50
0445:  BCF    03.6
0446:  CALL   3CA
0447:  BSF    03.6
0448:  MOVF   4E,W
0449:  MOVWF  0D
044A:  MOVF   4F,W
044B:  MOVWF  0F
044C:  INCF   0D,F
044D:  BTFSC  03.2
044E:  INCF   0F,F
044F:  BCF    03.6
0450:  GOTO   404
0451:  BSF    03.6
0452:  BCF    03.6
0453:  RETURN
*
046D:  MOVLW  20
046E:  MOVWF  69
046F:  CLRF   65
0470:  CLRF   66
0471:  CLRF   67
0472:  CLRF   68
0473:  MOVF   60,W
0474:  MOVWF  7A
0475:  MOVF   5F,W
0476:  MOVWF  79
0477:  MOVF   5E,W
0478:  MOVWF  78
0479:  MOVF   5D,W
047A:  MOVWF  77
047B:  BCF    03.0
047C:  BTFSS  77.0
047D:  GOTO   48C
047E:  MOVF   61,W
047F:  ADDWF  65,F
0480:  MOVF   62,W
0481:  BTFSC  03.0
0482:  INCFSZ 62,W
0483:  ADDWF  66,F
0484:  MOVF   63,W
0485:  BTFSC  03.0
0486:  INCFSZ 63,W
0487:  ADDWF  67,F
0488:  MOVF   64,W
0489:  BTFSC  03.0
048A:  INCFSZ 64,W
048B:  ADDWF  68,F
048C:  RRF    68,F
048D:  RRF    67,F
048E:  RRF    66,F
048F:  RRF    65,F
0490:  RRF    7A,F
0491:  RRF    79,F
0492:  RRF    78,F
0493:  RRF    77,F
0494:  DECFSZ 69,F
0495:  GOTO   47B
*
04B8:  BTFSC  03.1
04B9:  GOTO   4BD
04BA:  MOVLW  90
04BB:  MOVWF  04
04BC:  BSF    03.7
04BD:  MOVF   68,W
04BE:  XORWF  6C,W
04BF:  ANDLW  80
04C0:  BSF    03.5
04C1:  MOVWF  15
04C2:  BCF    03.5
04C3:  BTFSS  68.7
04C4:  GOTO   4D0
04C5:  COMF   65,F
04C6:  COMF   66,F
04C7:  COMF   67,F
04C8:  COMF   68,F
04C9:  INCF   65,F
04CA:  BTFSC  03.2
04CB:  INCF   66,F
04CC:  BTFSC  03.2
04CD:  INCF   67,F
04CE:  BTFSC  03.2
04CF:  INCF   68,F
04D0:  BTFSS  6C.7
04D1:  GOTO   4DD
04D2:  COMF   69,F
04D3:  COMF   6A,F
04D4:  COMF   6B,F
04D5:  COMF   6C,F
04D6:  INCF   69,F
04D7:  BTFSC  03.2
04D8:  INCF   6A,F
04D9:  BTFSC  03.2
04DA:  INCF   6B,F
04DB:  BTFSC  03.2
04DC:  INCF   6C,F
04DD:  CLRF   77
04DE:  CLRF   78
04DF:  CLRF   79
04E0:  CLRF   7A
04E1:  BSF    03.5
04E2:  CLRF   10
04E3:  CLRF   11
04E4:  CLRF   12
04E5:  CLRF   13
04E6:  BCF    03.5
04E7:  MOVF   6C,W
04E8:  IORWF  6B,W
04E9:  IORWF  6A,W
04EA:  IORWF  69,W
04EB:  BTFSC  03.2
04EC:  GOTO   539
04ED:  MOVLW  20
04EE:  BSF    03.5
04EF:  MOVWF  14
04F0:  BCF    03.0
04F1:  BCF    03.5
04F2:  RLF    65,F
04F3:  RLF    66,F
04F4:  RLF    67,F
04F5:  RLF    68,F
04F6:  BSF    03.5
04F7:  RLF    10,F
04F8:  RLF    11,F
04F9:  RLF    12,F
04FA:  RLF    13,F
04FB:  BCF    03.5
04FC:  MOVF   6C,W
04FD:  BSF    03.5
04FE:  SUBWF  13,W
04FF:  BTFSS  03.2
0500:  GOTO   511
0501:  BCF    03.5
0502:  MOVF   6B,W
0503:  BSF    03.5
0504:  SUBWF  12,W
0505:  BTFSS  03.2
0506:  GOTO   511
0507:  BCF    03.5
0508:  MOVF   6A,W
0509:  BSF    03.5
050A:  SUBWF  11,W
050B:  BTFSS  03.2
050C:  GOTO   511
050D:  BCF    03.5
050E:  MOVF   69,W
050F:  BSF    03.5
0510:  SUBWF  10,W
0511:  BTFSS  03.0
0512:  GOTO   532
0513:  BCF    03.5
0514:  MOVF   69,W
0515:  BSF    03.5
0516:  SUBWF  10,F
0517:  BCF    03.5
0518:  MOVF   6A,W
0519:  BTFSS  03.0
051A:  INCFSZ 6A,W
051B:  GOTO   51D
051C:  GOTO   520
051D:  BSF    03.5
051E:  SUBWF  11,F
051F:  BCF    03.5
0520:  MOVF   6B,W
0521:  BTFSS  03.0
0522:  INCFSZ 6B,W
0523:  GOTO   525
0524:  GOTO   528
0525:  BSF    03.5
0526:  SUBWF  12,F
0527:  BCF    03.5
0528:  MOVF   6C,W
0529:  BTFSS  03.0
052A:  INCFSZ 6C,W
052B:  GOTO   52D
052C:  GOTO   530
052D:  BSF    03.5
052E:  SUBWF  13,F
052F:  BCF    03.5
0530:  BSF    03.0
0531:  BSF    03.5
0532:  RLF    77,F
0533:  RLF    78,F
0534:  RLF    79,F
0535:  RLF    7A,F
0536:  DECFSZ 14,F
0537:  GOTO   4F0
0538:  BCF    03.5
0539:  BSF    03.5
053A:  BTFSS  15.7
053B:  GOTO   547
053C:  COMF   77,F
053D:  COMF   78,F
053E:  COMF   79,F
053F:  COMF   7A,F
0540:  INCF   77,F
0541:  BTFSC  03.2
0542:  INCF   78,F
0543:  BTFSC  03.2
0544:  INCF   79,F
0545:  BTFSC  03.2
0546:  INCF   7A,F
0547:  MOVF   10,W
0548:  MOVWF  00
0549:  INCF   04,F
054A:  MOVF   11,W
054B:  MOVWF  00
054C:  INCF   04,F
054D:  MOVF   12,W
054E:  MOVWF  00
054F:  INCF   04,F
0550:  MOVF   13,W
0551:  MOVWF  00
*
057D:  BTFSC  03.1
057E:  GOTO   582
057F:  MOVLW  90
0580:  MOVWF  04
0581:  BSF    03.7
0582:  MOVF   68,W
0583:  XORWF  6C,W
0584:  ANDLW  80
0585:  BSF    03.5
0586:  MOVWF  15
0587:  BCF    03.5
0588:  BTFSS  68.7
0589:  GOTO   595
058A:  COMF   65,F
058B:  COMF   66,F
058C:  COMF   67,F
058D:  COMF   68,F
058E:  INCF   65,F
058F:  BTFSC  03.2
0590:  INCF   66,F
0591:  BTFSC  03.2
0592:  INCF   67,F
0593:  BTFSC  03.2
0594:  INCF   68,F
0595:  BTFSS  6C.7
0596:  GOTO   5A2
0597:  COMF   69,F
0598:  COMF   6A,F
0599:  COMF   6B,F
059A:  COMF   6C,F
059B:  INCF   69,F
059C:  BTFSC  03.2
059D:  INCF   6A,F
059E:  BTFSC  03.2
059F:  INCF   6B,F
05A0:  BTFSC  03.2
05A1:  INCF   6C,F
05A2:  CLRF   77
05A3:  CLRF   78
05A4:  CLRF   79
05A5:  CLRF   7A
05A6:  BSF    03.5
05A7:  CLRF   10
05A8:  CLRF   11
05A9:  CLRF   12
05AA:  CLRF   13
05AB:  BCF    03.5
05AC:  MOVF   6C,W
05AD:  IORWF  6B,W
05AE:  IORWF  6A,W
05AF:  IORWF  69,W
05B0:  BTFSC  03.2
05B1:  GOTO   5FE
05B2:  MOVLW  20
05B3:  BSF    03.5
05B4:  MOVWF  14
05B5:  BCF    03.0
05B6:  BCF    03.5
05B7:  RLF    65,F
05B8:  RLF    66,F
05B9:  RLF    67,F
05BA:  RLF    68,F
05BB:  BSF    03.5
05BC:  RLF    10,F
05BD:  RLF    11,F
05BE:  RLF    12,F
05BF:  RLF    13,F
05C0:  BCF    03.5
05C1:  MOVF   6C,W
05C2:  BSF    03.5
05C3:  SUBWF  13,W
05C4:  BTFSS  03.2
05C5:  GOTO   5D6
05C6:  BCF    03.5
05C7:  MOVF   6B,W
05C8:  BSF    03.5
05C9:  SUBWF  12,W
05CA:  BTFSS  03.2
05CB:  GOTO   5D6
05CC:  BCF    03.5
05CD:  MOVF   6A,W
05CE:  BSF    03.5
05CF:  SUBWF  11,W
05D0:  BTFSS  03.2
05D1:  GOTO   5D6
05D2:  BCF    03.5
05D3:  MOVF   69,W
05D4:  BSF    03.5
05D5:  SUBWF  10,W
05D6:  BTFSS  03.0
05D7:  GOTO   5F7
05D8:  BCF    03.5
05D9:  MOVF   69,W
05DA:  BSF    03.5
05DB:  SUBWF  10,F
05DC:  BCF    03.5
05DD:  MOVF   6A,W
05DE:  BTFSS  03.0
05DF:  INCFSZ 6A,W
05E0:  GOTO   5E2
05E1:  GOTO   5E5
05E2:  BSF    03.5
05E3:  SUBWF  11,F
05E4:  BCF    03.5
05E5:  MOVF   6B,W
05E6:  BTFSS  03.0
05E7:  INCFSZ 6B,W
05E8:  GOTO   5EA
05E9:  GOTO   5ED
05EA:  BSF    03.5
05EB:  SUBWF  12,F
05EC:  BCF    03.5
05ED:  MOVF   6C,W
05EE:  BTFSS  03.0
05EF:  INCFSZ 6C,W
05F0:  GOTO   5F2
05F1:  GOTO   5F5
05F2:  BSF    03.5
05F3:  SUBWF  13,F
05F4:  BCF    03.5
05F5:  BSF    03.0
05F6:  BSF    03.5
05F7:  RLF    77,F
05F8:  RLF    78,F
05F9:  RLF    79,F
05FA:  RLF    7A,F
05FB:  DECFSZ 14,F
05FC:  GOTO   5B5
05FD:  BCF    03.5
05FE:  BSF    03.5
05FF:  BTFSS  15.7
0600:  GOTO   60C
0601:  COMF   77,F
0602:  COMF   78,F
0603:  COMF   79,F
0604:  COMF   7A,F
0605:  INCF   77,F
0606:  BTFSC  03.2
0607:  INCF   78,F
0608:  BTFSC  03.2
0609:  INCF   79,F
060A:  BTFSC  03.2
060B:  INCF   7A,F
060C:  MOVF   10,W
060D:  MOVWF  00
060E:  INCF   04,F
060F:  MOVF   11,W
0610:  MOVWF  00
0611:  INCF   04,F
0612:  MOVF   12,W
0613:  MOVWF  00
0614:  INCF   04,F
0615:  MOVF   13,W
0616:  MOVWF  00
*
06A4:  BSF    03.6
06A5:  MOVF   4E,W
06A6:  ANDLW  07
06A7:  MOVWF  77
06A8:  RRF    4E,W
06A9:  MOVWF  78
06AA:  RRF    78,F
06AB:  RRF    78,F
06AC:  MOVLW  1F
06AD:  ANDWF  78,F
06AE:  MOVF   78,W
06AF:  ADDWF  4F,W
06B0:  MOVWF  04
06B1:  BCF    03.7
06B2:  BTFSC  50.0
06B3:  BSF    03.7
06B4:  MOVF   00,W
06B5:  MOVWF  78
06B6:  INCF   77,F
06B7:  GOTO   6B9
06B8:  RRF    78,F
06B9:  DECFSZ 77,F
06BA:  GOTO   6B8
06BB:  BCF    03.6
06BC:  RETURN
06BD:  BSF    03.6
06BE:  MOVF   4D,W
06BF:  ANDLW  07
06C0:  MOVWF  77
06C1:  RRF    4D,W
06C2:  MOVWF  78
06C3:  RRF    78,F
06C4:  RRF    78,F
06C5:  MOVLW  1F
06C6:  ANDWF  78,F
06C7:  MOVF   78,W
06C8:  ADDWF  4F,W
06C9:  MOVWF  04
06CA:  BCF    03.7
06CB:  BTFSC  50.0
06CC:  BSF    03.7
06CD:  CLRF   78
06CE:  INCF   78,F
06CF:  INCF   77,F
06D0:  GOTO   6D2
06D1:  RLF    78,F
06D2:  DECFSZ 77,F
06D3:  GOTO   6D1
06D4:  MOVF   4E,F
06D5:  BTFSC  03.2
06D6:  GOTO   6DA
06D7:  MOVF   78,W
06D8:  IORWF  00,F
06D9:  GOTO   6DD
06DA:  COMF   78,F
06DB:  MOVF   78,W
06DC:  ANDWF  00,F
06DD:  BCF    03.6
06DE:  RETURN
*
0736:  MOVF   00,F
0737:  BTFSC  03.2
0738:  GOTO   752
0739:  BSF    03.6
073A:  CLRF   4E
073B:  MOVF   04,W
073C:  MOVWF  4D
073D:  BCF    4E.0
073E:  BTFSC  03.7
073F:  BSF    4E.0
0740:  MOVF   00,W
0741:  MOVWF  50
0742:  BCF    03.6
0743:  CALL   3CA
0744:  BSF    03.6
0745:  MOVF   4D,W
0746:  MOVWF  04
0747:  BCF    03.7
0748:  BTFSC  4E.0
0749:  BSF    03.7
074A:  INCF   04,F
074B:  BTFSS  03.2
074C:  GOTO   750
074D:  BCF    03.6
074E:  INCF   05,F
074F:  BSF    03.6
0750:  BCF    03.6
0751:  GOTO   736
*
0780:  BSF    0A.0
0781:  BSF    0A.1
0782:  BSF    0A.2
0783:  ADDWF  02,F
0784:  GOTO   758
0785:  GOTO   760
0786:  GOTO   768
0787:  GOTO   770
0788:  MOVF   00,F
0789:  BTFSC  03.2
078A:  GOTO   7A5
078B:  BSF    03.6
078C:  CLRF   50
078D:  MOVF   04,W
078E:  MOVWF  4F
078F:  BCF    50.0
0790:  BTFSC  03.7
0791:  BSF    50.0
0792:  MOVF   00,W
0793:  BCF    03.6
0794:  BTFSS  0C.4
0795:  GOTO   794
0796:  MOVWF  19
0797:  BSF    03.6
0798:  MOVF   4F,W
0799:  MOVWF  04
079A:  BCF    03.7
079B:  BTFSC  50.0
079C:  BSF    03.7
079D:  INCF   04,F
079E:  BTFSS  03.2
079F:  GOTO   7A3
07A0:  BCF    03.6
07A1:  INCF   05,F
07A2:  BSF    03.6
07A3:  BCF    03.6
07A4:  GOTO   788
07A5:  RETURN
*
07CC:  MOVF   00,F
07CD:  BTFSC  03.2
07CE:  GOTO   7E8
07CF:  BSF    03.6
07D0:  CLRF   4E
07D1:  MOVF   04,W
07D2:  MOVWF  4D
07D3:  BCF    4E.0
07D4:  BTFSC  03.7
07D5:  BSF    4E.0
07D6:  MOVF   00,W
07D7:  MOVWF  50
07D8:  BCF    03.6
07D9:  CALL   3CA
07DA:  BSF    03.6
07DB:  MOVF   4D,W
07DC:  MOVWF  04
07DD:  BCF    03.7
07DE:  BTFSC  4E.0
07DF:  BSF    03.7
07E0:  INCF   04,F
07E1:  BTFSS  03.2
07E2:  GOTO   7E6
07E3:  BCF    03.6
07E4:  INCF   05,F
07E5:  BSF    03.6
07E6:  BCF    03.6
07E7:  GOTO   7CC
*
085D:  MOVF   00,F
085E:  BTFSC  03.2
085F:  GOTO   07B
0860:  BSF    03.6
0861:  CLRF   4E
0862:  MOVF   04,W
0863:  MOVWF  4D
0864:  BCF    4E.0
0865:  BTFSC  03.7
0866:  BSF    4E.0
0867:  MOVF   00,W
0868:  MOVWF  50
0869:  BCF    0A.3
086A:  BCF    03.6
086B:  CALL   3CA
086C:  BSF    0A.3
086D:  BSF    03.6
086E:  MOVF   4D,W
086F:  MOVWF  04
0870:  BCF    03.7
0871:  BTFSC  4E.0
0872:  BSF    03.7
0873:  INCF   04,F
0874:  BTFSS  03.2
0875:  GOTO   079
0876:  BCF    03.6
0877:  INCF   05,F
0878:  BSF    03.6
0879:  BCF    03.6
087A:  GOTO   05D
*
08DF:  MOVF   00,F
08E0:  BTFSC  03.2
08E1:  GOTO   0FD
08E2:  BSF    03.6
08E3:  CLRF   4E
08E4:  MOVF   04,W
08E5:  MOVWF  4D
08E6:  BCF    4E.0
08E7:  BTFSC  03.7
08E8:  BSF    4E.0
08E9:  MOVF   00,W
08EA:  MOVWF  50
08EB:  BCF    0A.3
08EC:  BCF    03.6
08ED:  CALL   3CA
08EE:  BSF    0A.3
08EF:  BSF    03.6
08F0:  MOVF   4D,W
08F1:  MOVWF  04
08F2:  BCF    03.7
08F3:  BTFSC  4E.0
08F4:  BSF    03.7
08F5:  INCF   04,F
08F6:  BTFSS  03.2
08F7:  GOTO   0FB
08F8:  BCF    03.6
08F9:  INCF   05,F
08FA:  BSF    03.6
08FB:  BCF    03.6
08FC:  GOTO   0DF
*
0940:  MOVF   00,F
0941:  BTFSC  03.2
0942:  GOTO   15E
0943:  BSF    03.6
0944:  CLRF   4E
0945:  MOVF   04,W
0946:  MOVWF  4D
0947:  BCF    4E.0
0948:  BTFSC  03.7
0949:  BSF    4E.0
094A:  MOVF   00,W
094B:  MOVWF  50
094C:  BCF    0A.3
094D:  BCF    03.6
094E:  CALL   3CA
094F:  BSF    0A.3
0950:  BSF    03.6
0951:  MOVF   4D,W
0952:  MOVWF  04
0953:  BCF    03.7
0954:  BTFSC  4E.0
0955:  BSF    03.7
0956:  INCF   04,F
0957:  BTFSS  03.2
0958:  GOTO   15C
0959:  BCF    03.6
095A:  INCF   05,F
095B:  BSF    03.6
095C:  BCF    03.6
095D:  GOTO   140
*
09C2:  MOVF   00,F
09C3:  BTFSC  03.2
09C4:  GOTO   1E0
09C5:  BSF    03.6
09C6:  CLRF   4E
09C7:  MOVF   04,W
09C8:  MOVWF  4D
09C9:  BCF    4E.0
09CA:  BTFSC  03.7
09CB:  BSF    4E.0
09CC:  MOVF   00,W
09CD:  MOVWF  50
09CE:  BCF    0A.3
09CF:  BCF    03.6
09D0:  CALL   3CA
09D1:  BSF    0A.3
09D2:  BSF    03.6
09D3:  MOVF   4D,W
09D4:  MOVWF  04
09D5:  BCF    03.7
09D6:  BTFSC  4E.0
09D7:  BSF    03.7
09D8:  INCF   04,F
09D9:  BTFSS  03.2
09DA:  GOTO   1DE
09DB:  BCF    03.6
09DC:  INCF   05,F
09DD:  BSF    03.6
09DE:  BCF    03.6
09DF:  GOTO   1C2
*
0A38:  MOVF   00,F
0A39:  BTFSC  03.2
0A3A:  GOTO   256
0A3B:  BSF    03.6
0A3C:  CLRF   4E
0A3D:  MOVF   04,W
0A3E:  MOVWF  4D
0A3F:  BCF    4E.0
0A40:  BTFSC  03.7
0A41:  BSF    4E.0
0A42:  MOVF   00,W
0A43:  MOVWF  50
0A44:  BCF    0A.3
0A45:  BCF    03.6
0A46:  CALL   3CA
0A47:  BSF    0A.3
0A48:  BSF    03.6
0A49:  MOVF   4D,W
0A4A:  MOVWF  04
0A4B:  BCF    03.7
0A4C:  BTFSC  4E.0
0A4D:  BSF    03.7
0A4E:  INCF   04,F
0A4F:  BTFSS  03.2
0A50:  GOTO   254
0A51:  BCF    03.6
0A52:  INCF   05,F
0A53:  BSF    03.6
0A54:  BCF    03.6
0A55:  GOTO   238
*
0A99:  MOVF   00,F
0A9A:  BTFSC  03.2
0A9B:  GOTO   2B7
0A9C:  BSF    03.6
0A9D:  CLRF   4E
0A9E:  MOVF   04,W
0A9F:  MOVWF  4D
0AA0:  BCF    4E.0
0AA1:  BTFSC  03.7
0AA2:  BSF    4E.0
0AA3:  MOVF   00,W
0AA4:  MOVWF  50
0AA5:  BCF    0A.3
0AA6:  BCF    03.6
0AA7:  CALL   3CA
0AA8:  BSF    0A.3
0AA9:  BSF    03.6
0AAA:  MOVF   4D,W
0AAB:  MOVWF  04
0AAC:  BCF    03.7
0AAD:  BTFSC  4E.0
0AAE:  BSF    03.7
0AAF:  INCF   04,F
0AB0:  BTFSS  03.2
0AB1:  GOTO   2B5
0AB2:  BCF    03.6
0AB3:  INCF   05,F
0AB4:  BSF    03.6
0AB5:  BCF    03.6
0AB6:  GOTO   299
*
0B1B:  MOVF   00,F
0B1C:  BTFSC  03.2
0B1D:  GOTO   339
0B1E:  BSF    03.6
0B1F:  CLRF   4E
0B20:  MOVF   04,W
0B21:  MOVWF  4D
0B22:  BCF    4E.0
0B23:  BTFSC  03.7
0B24:  BSF    4E.0
0B25:  MOVF   00,W
0B26:  MOVWF  50
0B27:  BCF    0A.3
0B28:  BCF    03.6
0B29:  CALL   3CA
0B2A:  BSF    0A.3
0B2B:  BSF    03.6
0B2C:  MOVF   4D,W
0B2D:  MOVWF  04
0B2E:  BCF    03.7
0B2F:  BTFSC  4E.0
0B30:  BSF    03.7
0B31:  INCF   04,F
0B32:  BTFSS  03.2
0B33:  GOTO   337
0B34:  BCF    03.6
0B35:  INCF   05,F
0B36:  BSF    03.6
0B37:  BCF    03.6
0B38:  GOTO   31B
*
0BC7:  MOVF   51,W
0BC8:  CLRF   78
0BC9:  SUBWF  50,W
0BCA:  BTFSC  03.0
0BCB:  GOTO   3CF
0BCC:  MOVF   50,W
0BCD:  MOVWF  77
0BCE:  GOTO   3DB
0BCF:  CLRF   77
0BD0:  MOVLW  08
0BD1:  MOVWF  52
0BD2:  RLF    50,F
0BD3:  RLF    77,F
0BD4:  MOVF   51,W
0BD5:  SUBWF  77,W
0BD6:  BTFSC  03.0
0BD7:  MOVWF  77
0BD8:  RLF    78,F
0BD9:  DECFSZ 52,F
0BDA:  GOTO   3D2
*
0C0D:  MOVF   00,F
0C0E:  BTFSC  03.2
0C0F:  GOTO   42B
0C10:  BSF    03.6
0C11:  CLRF   4E
0C12:  MOVF   04,W
0C13:  MOVWF  4D
0C14:  BCF    4E.0
0C15:  BTFSC  03.7
0C16:  BSF    4E.0
0C17:  MOVF   00,W
0C18:  MOVWF  50
0C19:  BCF    0A.3
0C1A:  BCF    03.6
0C1B:  CALL   3CA
0C1C:  BSF    0A.3
0C1D:  BSF    03.6
0C1E:  MOVF   4D,W
0C1F:  MOVWF  04
0C20:  BCF    03.7
0C21:  BTFSC  4E.0
0C22:  BSF    03.7
0C23:  INCF   04,F
0C24:  BTFSS  03.2
0C25:  GOTO   429
0C26:  BCF    03.6
0C27:  INCF   05,F
0C28:  BSF    03.6
0C29:  BCF    03.6
0C2A:  GOTO   40D
*
0C3C:  BCF    0A.0
0C3D:  BCF    0A.1
0C3E:  BSF    0A.2
0C3F:  ADDWF  02,F
0C40:  GOTO   007
0C41:  GOTO   089
0C42:  GOTO   1E2
0C43:  GOTO   33B
*
106F:  CLRF   77
1070:  CLRF   78
1071:  MOVF   53,W
1072:  BCF    03.0
1073:  BTFSC  54.0
1074:  ADDWF  77,F
1075:  RRF    77,F
1076:  RRF    78,F
1077:  BTFSC  54.1
1078:  ADDWF  77,F
1079:  RRF    77,F
107A:  RRF    78,F
107B:  BTFSC  54.2
107C:  ADDWF  77,F
107D:  RRF    77,F
107E:  RRF    78,F
107F:  BTFSC  54.3
1080:  ADDWF  77,F
1081:  RRF    77,F
1082:  RRF    78,F
1083:  BTFSC  54.4
1084:  ADDWF  77,F
1085:  RRF    77,F
1086:  RRF    78,F
1087:  BTFSC  54.5
1088:  ADDWF  77,F
1089:  RRF    77,F
108A:  RRF    78,F
108B:  BTFSC  54.6
108C:  ADDWF  77,F
108D:  RRF    77,F
108E:  RRF    78,F
108F:  BTFSC  54.7
1090:  ADDWF  77,F
1091:  RRF    77,F
1092:  RRF    78,F
*
13C0:  BSF    0A.0
13C1:  BSF    0A.1
13C2:  BCF    0A.2
13C3:  ADDWF  02,F
13C4:  GOTO   360
13C5:  GOTO   361
13C6:  GOTO   36B
13C7:  GOTO   376
....................  
.................... #list 
....................  
.................... #DEVICE ADC=10 
.................... #INCLUDE <STRING.H> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
*
0C79:  MOVF   4F,W
0C7A:  MOVWF  53
0C7B:  MOVF   4E,W
0C7C:  MOVWF  52
0C7D:  MOVF   53,W
0C7E:  MOVWF  7A
0C7F:  MOVF   52,W
0C80:  MOVWF  04
0C81:  BCF    03.7
0C82:  BTFSC  7A.0
0C83:  BSF    03.7
0C84:  MOVF   00,F
0C85:  BTFSC  03.2
0C86:  GOTO   48B
0C87:  INCF   52,F
0C88:  BTFSC  03.2
0C89:  INCF   53,F
0C8A:  GOTO   47D
*
0D21:  MOVF   4F,W
0D22:  MOVWF  53
0D23:  MOVF   4E,W
0D24:  MOVWF  52
0D25:  MOVF   53,W
0D26:  MOVWF  7A
0D27:  MOVF   52,W
0D28:  MOVWF  04
0D29:  BCF    03.7
0D2A:  BTFSC  7A.0
0D2B:  BSF    03.7
0D2C:  MOVF   00,F
0D2D:  BTFSC  03.2
0D2E:  GOTO   533
0D2F:  INCF   52,F
0D30:  BTFSC  03.2
0D31:  INCF   53,F
0D32:  GOTO   525
*
0D9B:  MOVF   4F,W
0D9C:  MOVWF  53
0D9D:  MOVF   4E,W
0D9E:  MOVWF  52
0D9F:  MOVF   53,W
0DA0:  MOVWF  7A
0DA1:  MOVF   52,W
0DA2:  MOVWF  04
0DA3:  BCF    03.7
0DA4:  BTFSC  7A.0
0DA5:  BSF    03.7
0DA6:  MOVF   00,F
0DA7:  BTFSC  03.2
0DA8:  GOTO   5AD
0DA9:  INCF   52,F
0DAA:  BTFSC  03.2
0DAB:  INCF   53,F
0DAC:  GOTO   59F
....................    while(*s2 != '\0') 
*
0C8B:  MOVF   51,W
0C8C:  MOVWF  7A
0C8D:  MOVF   50,W
0C8E:  MOVWF  04
0C8F:  BCF    03.7
0C90:  BTFSC  7A.0
0C91:  BSF    03.7
0C92:  MOVF   00,F
0C93:  BTFSC  03.2
0C94:  GOTO   4AA
*
0D33:  MOVF   51,W
0D34:  MOVWF  7A
0D35:  MOVF   50,W
0D36:  MOVWF  04
0D37:  BCF    03.7
0D38:  BTFSC  7A.0
0D39:  BSF    03.7
0D3A:  MOVF   00,F
0D3B:  BTFSC  03.2
0D3C:  GOTO   552
*
0DAD:  MOVF   51,W
0DAE:  MOVWF  7A
0DAF:  MOVF   50,W
0DB0:  MOVWF  04
0DB1:  BCF    03.7
0DB2:  BTFSC  7A.0
0DB3:  BSF    03.7
0DB4:  MOVF   00,F
0DB5:  BTFSC  03.2
0DB6:  GOTO   5CC
....................    { 
....................       *s = *s2; 
*
0C95:  MOVF   50,W
0C96:  MOVWF  04
0C97:  BCF    03.7
0C98:  BTFSC  51.0
0C99:  BSF    03.7
0C9A:  MOVF   00,W
0C9B:  MOVWF  56
0C9C:  MOVF   52,W
0C9D:  MOVWF  04
0C9E:  BCF    03.7
0C9F:  BTFSC  53.0
0CA0:  BSF    03.7
0CA1:  MOVF   56,W
0CA2:  MOVWF  00
*
0D3D:  MOVF   50,W
0D3E:  MOVWF  04
0D3F:  BCF    03.7
0D40:  BTFSC  51.0
0D41:  BSF    03.7
0D42:  MOVF   00,W
0D43:  MOVWF  56
0D44:  MOVF   52,W
0D45:  MOVWF  04
0D46:  BCF    03.7
0D47:  BTFSC  53.0
0D48:  BSF    03.7
0D49:  MOVF   56,W
0D4A:  MOVWF  00
*
0DB7:  MOVF   50,W
0DB8:  MOVWF  04
0DB9:  BCF    03.7
0DBA:  BTFSC  51.0
0DBB:  BSF    03.7
0DBC:  MOVF   00,W
0DBD:  MOVWF  56
0DBE:  MOVF   52,W
0DBF:  MOVWF  04
0DC0:  BCF    03.7
0DC1:  BTFSC  53.0
0DC2:  BSF    03.7
0DC3:  MOVF   56,W
0DC4:  MOVWF  00
....................       ++s; 
*
0CA3:  INCF   52,F
0CA4:  BTFSC  03.2
0CA5:  INCF   53,F
*
0D4B:  INCF   52,F
0D4C:  BTFSC  03.2
0D4D:  INCF   53,F
*
0DC5:  INCF   52,F
0DC6:  BTFSC  03.2
0DC7:  INCF   53,F
....................       ++s2; 
*
0CA6:  INCF   50,F
0CA7:  BTFSC  03.2
0CA8:  INCF   51,F
0CA9:  GOTO   48B
*
0D4E:  INCF   50,F
0D4F:  BTFSC  03.2
0D50:  INCF   51,F
0D51:  GOTO   533
*
0DC8:  INCF   50,F
0DC9:  BTFSC  03.2
0DCA:  INCF   51,F
0DCB:  GOTO   5AD
....................    } 
....................  
....................    *s = '\0'; 
*
0CAA:  MOVF   52,W
0CAB:  MOVWF  04
0CAC:  BCF    03.7
0CAD:  BTFSC  53.0
0CAE:  BSF    03.7
0CAF:  CLRF   00
*
0D52:  MOVF   52,W
0D53:  MOVWF  04
0D54:  BCF    03.7
0D55:  BTFSC  53.0
0D56:  BSF    03.7
0D57:  CLRF   00
*
0DCC:  MOVF   52,W
0DCD:  MOVWF  04
0DCE:  BCF    03.7
0DCF:  BTFSC  53.0
0DD0:  BSF    03.7
0DD1:  CLRF   00
....................    return(s1); 
*
0CB0:  MOVF   4E,W
0CB1:  MOVWF  78
0CB2:  MOVF   4F,W
0CB3:  MOVWF  79
*
0D58:  MOVF   4E,W
0D59:  MOVWF  78
0D5A:  MOVF   4F,W
0D5B:  MOVWF  79
0D5C:  BCF    03.6
*
0DD2:  MOVF   4E,W
0DD3:  MOVWF  78
0DD4:  MOVF   4F,W
0DD5:  MOVWF  79
0DD6:  BCF    03.6
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
*
0F1F:  MOVF   55,W
0F20:  MOVWF  59
0F21:  MOVF   54,W
0F22:  MOVWF  58
0F23:  MOVF   59,W
0F24:  MOVWF  7A
0F25:  MOVF   58,W
0F26:  MOVWF  04
0F27:  BCF    03.7
0F28:  BTFSC  7A.0
0F29:  BSF    03.7
0F2A:  MOVF   00,F
0F2B:  BTFSC  03.2
0F2C:  GOTO   75C
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
0F2D:  MOVF   57,W
0F2E:  MOVWF  5B
0F2F:  MOVF   56,W
0F30:  MOVWF  5A
0F31:  MOVF   5B,W
0F32:  MOVWF  7A
0F33:  MOVF   5A,W
0F34:  MOVWF  04
0F35:  BCF    03.7
0F36:  BTFSC  7A.0
0F37:  BSF    03.7
0F38:  MOVF   00,F
0F39:  BTFSC  03.2
0F3A:  GOTO   758
....................          if (*sc1 == *sc2) 
0F3B:  MOVF   59,W
0F3C:  MOVWF  7A
0F3D:  MOVF   58,W
0F3E:  MOVWF  04
0F3F:  BCF    03.7
0F40:  BTFSC  7A.0
0F41:  BSF    03.7
0F42:  MOVF   00,W
0F43:  MOVWF  5C
0F44:  MOVF   5B,W
0F45:  MOVWF  7A
0F46:  MOVF   5A,W
0F47:  MOVWF  04
0F48:  BCF    03.7
0F49:  BTFSC  7A.0
0F4A:  BSF    03.7
0F4B:  MOVF   00,W
0F4C:  SUBWF  5C,W
0F4D:  BTFSS  03.2
0F4E:  GOTO   754
....................             return(sc1); 
0F4F:  MOVF   58,W
0F50:  MOVWF  78
0F51:  MOVF   59,W
0F52:  MOVWF  79
0F53:  GOTO   75F
0F54:  INCF   5A,F
0F55:  BTFSC  03.2
0F56:  INCF   5B,F
0F57:  GOTO   731
0F58:  INCF   58,F
0F59:  BTFSC  03.2
0F5A:  INCF   59,F
0F5B:  GOTO   723
....................    return(0); 
0F5C:  MOVLW  00
0F5D:  MOVWF  78
0F5E:  MOVWF  79
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
*
0EAC:  MOVF   55,W
0EAD:  MOVWF  59
0EAE:  MOVF   54,W
0EAF:  MOVWF  58
0EB0:  MOVF   59,W
0EB1:  MOVWF  7A
0EB2:  MOVF   58,W
0EB3:  MOVWF  04
0EB4:  BCF    03.7
0EB5:  BTFSC  7A.0
0EB6:  BSF    03.7
0EB7:  MOVF   00,F
0EB8:  BTFSC  03.2
0EB9:  GOTO   6F1
....................       for (sc2 = s2; ; sc2++) 
0EBA:  MOVF   57,W
0EBB:  MOVWF  5B
0EBC:  MOVF   56,W
0EBD:  MOVWF  5A
....................     if (*sc2 == '\0') 
0EBE:  MOVF   5B,W
0EBF:  MOVWF  7A
0EC0:  MOVF   5A,W
0EC1:  MOVWF  04
0EC2:  BCF    03.7
0EC3:  BTFSC  7A.0
0EC4:  BSF    03.7
0EC5:  MOVF   00,F
0EC6:  BTFSS  03.2
0EC7:  GOTO   6D5
....................        return(sc1 - s1); 
0EC8:  MOVF   54,W
0EC9:  SUBWF  58,W
0ECA:  MOVWF  77
0ECB:  MOVF   59,W
0ECC:  MOVWF  7A
0ECD:  MOVF   55,W
0ECE:  BTFSS  03.0
0ECF:  INCFSZ 55,W
0ED0:  SUBWF  7A,F
0ED1:  MOVF   77,W
0ED2:  MOVWF  78
0ED3:  GOTO   6FC
0ED4:  GOTO   6E9
....................          else if (*sc1 == *sc2) 
0ED5:  MOVF   59,W
0ED6:  MOVWF  7A
0ED7:  MOVF   58,W
0ED8:  MOVWF  04
0ED9:  BCF    03.7
0EDA:  BTFSC  7A.0
0EDB:  BSF    03.7
0EDC:  MOVF   00,W
0EDD:  MOVWF  5C
0EDE:  MOVF   5B,W
0EDF:  MOVWF  7A
0EE0:  MOVF   5A,W
0EE1:  MOVWF  04
0EE2:  BCF    03.7
0EE3:  BTFSC  7A.0
0EE4:  BSF    03.7
0EE5:  MOVF   00,W
0EE6:  SUBWF  5C,W
0EE7:  BTFSC  03.2
....................             break; 
0EE8:  GOTO   6ED
0EE9:  INCF   5A,F
0EEA:  BTFSC  03.2
0EEB:  INCF   5B,F
0EEC:  GOTO   6BE
0EED:  INCF   58,F
0EEE:  BTFSC  03.2
0EEF:  INCF   59,F
0EF0:  GOTO   6B0
....................    return(sc1 - s1); 
0EF1:  MOVF   54,W
0EF2:  SUBWF  58,W
0EF3:  MOVWF  77
0EF4:  MOVF   59,W
0EF5:  MOVWF  7A
0EF6:  MOVF   55,W
0EF7:  BTFSS  03.0
0EF8:  INCFSZ 55,W
0EF9:  SUBWF  7A,F
0EFA:  MOVF   77,W
0EFB:  MOVWF  78
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
*
1131:  BCF    03.6
1132:  CLRF   2B
1133:  CLRF   2C
....................  
....................    beg = (s1)? s1: save; 
*
0E93:  BSF    03.6
0E94:  MOVF   4C,W
0E95:  IORWF  4D,W
0E96:  BTFSC  03.2
0E97:  GOTO   69C
0E98:  MOVF   4D,W
0E99:  MOVWF  7A
0E9A:  MOVF   4C,W
0E9B:  GOTO   6A1
0E9C:  BCF    03.6
0E9D:  MOVF   2C,W
0E9E:  MOVWF  7A
0E9F:  MOVF   2B,W
0EA0:  BSF    03.6
0EA1:  MOVWF  50
0EA2:  MOVF   7A,W
0EA3:  MOVWF  51
....................    beg += strspn(beg, s2); 
0EA4:  MOVF   51,W
0EA5:  MOVWF  55
0EA6:  MOVF   50,W
0EA7:  MOVWF  54
0EA8:  MOVF   4F,W
0EA9:  MOVWF  57
0EAA:  MOVF   4E,W
0EAB:  MOVWF  56
*
0EFC:  MOVF   78,W
0EFD:  ADDWF  50,F
0EFE:  BTFSC  03.0
0EFF:  INCF   51,F
....................    if (*beg == '\0') 
0F00:  MOVF   51,W
0F01:  MOVWF  7A
0F02:  MOVF   50,W
0F03:  MOVWF  04
0F04:  BCF    03.7
0F05:  BTFSC  7A.0
0F06:  BSF    03.7
0F07:  MOVF   00,F
0F08:  BTFSS  03.2
0F09:  GOTO   717
....................    { 
....................       *save = ' '; 
0F0A:  BCF    03.6
0F0B:  MOVF   2B,W
0F0C:  MOVWF  04
0F0D:  BCF    03.7
0F0E:  BTFSC  2C.0
0F0F:  BSF    03.7
0F10:  MOVLW  20
0F11:  MOVWF  00
....................       return(0); 
0F12:  MOVLW  00
0F13:  MOVWF  78
0F14:  MOVWF  79
0F15:  GOTO   783
0F16:  BSF    03.6
....................    } 
....................    end = strpbrk(beg, s2); 
0F17:  MOVF   51,W
0F18:  MOVWF  55
0F19:  MOVF   50,W
0F1A:  MOVWF  54
0F1B:  MOVF   4F,W
0F1C:  MOVWF  57
0F1D:  MOVF   4E,W
0F1E:  MOVWF  56
*
0F5F:  MOVF   79,W
0F60:  MOVWF  53
0F61:  MOVF   78,W
0F62:  MOVWF  52
....................    if (*end != '\0') 
0F63:  MOVF   53,W
0F64:  MOVWF  7A
0F65:  MOVF   52,W
0F66:  MOVWF  04
0F67:  BCF    03.7
0F68:  BTFSC  7A.0
0F69:  BSF    03.7
0F6A:  MOVF   00,F
0F6B:  BTFSC  03.2
0F6C:  GOTO   776
....................    { 
....................       *end = '\0'; 
0F6D:  MOVF   52,W
0F6E:  MOVWF  04
0F6F:  BCF    03.7
0F70:  BTFSC  53.0
0F71:  BSF    03.7
0F72:  CLRF   00
....................       end++; 
0F73:  INCF   52,F
0F74:  BTFSC  03.2
0F75:  INCF   53,F
....................    } 
....................    save = end; 
0F76:  MOVF   53,W
0F77:  BCF    03.6
0F78:  MOVWF  2C
0F79:  BSF    03.6
0F7A:  MOVF   52,W
0F7B:  BCF    03.6
0F7C:  MOVWF  2B
....................    return(beg); 
0F7D:  BSF    03.6
0F7E:  MOVF   50,W
0F7F:  MOVWF  78
0F80:  MOVF   51,W
0F81:  MOVWF  79
0F82:  BCF    03.6
0F83:  RETURN
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
*
0E06:  MOVF   50,W
0E07:  MOVWF  52
0E08:  MOVF   4F,W
0E09:  MOVWF  51
0E0A:  MOVF   52,W
0E0B:  MOVWF  7A
0E0C:  MOVF   51,W
0E0D:  MOVWF  04
0E0E:  BCF    03.7
0E0F:  BTFSC  7A.0
0E10:  BSF    03.7
0E11:  MOVF   00,F
0E12:  BTFSC  03.2
0E13:  GOTO   618
0E14:  INCF   51,F
0E15:  BTFSC  03.2
0E16:  INCF   52,F
0E17:  GOTO   60A
....................    return(sc - s); 
0E18:  MOVF   4F,W
0E19:  SUBWF  51,W
0E1A:  MOVWF  77
0E1B:  MOVF   52,W
0E1C:  MOVWF  7A
0E1D:  MOVF   50,W
0E1E:  BTFSS  03.0
0E1F:  INCFSZ 50,W
0E20:  SUBWF  7A,F
0E21:  MOVF   77,W
0E22:  MOVWF  78
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #INCLUDE <STDLIB.H> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... /* Standart template: float strtof(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... float strtof(char *s,char *endptr); 
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s,char *endptr); 
.................... float64 strtod(char *s,char *endptr); 
.................... #else 
.................... //provided for compatibility 
.................... #define strtof48(s, e) strtof(s, e) 
.................... #define strtod(s, e) strtof(s, e) 
.................... #endif 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof(s)   strtof(s, 0) 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof48(s) strtof48(s, 0) 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof64(s) strtod(s, 0) 
.................... #endif 
....................  
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float atoe(char * s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s); 
.................... #endif 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... unsigned int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................  
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
*
1000:  BSF    03.6
1001:  CLRF   51
....................    sign = 0; 
1002:  CLRF   4F
....................    base = 10; 
1003:  MOVLW  0A
1004:  MOVWF  50
....................    result = 0; 
1005:  CLRF   4E
....................  
....................    if (!s) 
1006:  MOVF   4C,W
1007:  IORWF  4D,W
1008:  BTFSS  03.2
1009:  GOTO   00D
....................       return 0; 
100A:  MOVLW  00
100B:  MOVWF  78
100C:  GOTO   100
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
100D:  MOVF   51,W
100E:  INCF   51,F
100F:  ADDWF  4C,W
1010:  MOVWF  04
1011:  BCF    03.7
1012:  BTFSC  4D.0
1013:  BSF    03.7
1014:  MOVF   00,W
1015:  MOVWF  52
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
1016:  MOVF   52,W
1017:  SUBLW  2D
1018:  BTFSS  03.2
1019:  GOTO   026
....................    { 
....................       sign = 1;         // Set the sign to negative 
101A:  MOVLW  01
101B:  MOVWF  4F
....................       c = s[index++]; 
101C:  MOVF   51,W
101D:  INCF   51,F
101E:  ADDWF  4C,W
101F:  MOVWF  04
1020:  BCF    03.7
1021:  BTFSC  4D.0
1022:  BSF    03.7
1023:  MOVF   00,W
1024:  MOVWF  52
....................    } 
1025:  GOTO   033
....................    else if (c == '+') 
1026:  MOVF   52,W
1027:  SUBLW  2B
1028:  BTFSS  03.2
1029:  GOTO   033
....................    { 
....................       c = s[index++]; 
102A:  MOVF   51,W
102B:  INCF   51,F
102C:  ADDWF  4C,W
102D:  MOVWF  04
102E:  BCF    03.7
102F:  BTFSC  4D.0
1030:  BSF    03.7
1031:  MOVF   00,W
1032:  MOVWF  52
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
1033:  MOVF   52,W
1034:  SUBLW  2F
1035:  BTFSC  03.0
1036:  GOTO   0F6
1037:  MOVF   52,W
1038:  SUBLW  39
1039:  BTFSS  03.0
103A:  GOTO   0F6
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
103B:  MOVF   52,W
103C:  SUBLW  30
103D:  BTFSS  03.2
103E:  GOTO   05F
103F:  MOVF   51,W
1040:  ADDWF  4C,W
1041:  MOVWF  04
1042:  BCF    03.7
1043:  BTFSC  4D.0
1044:  BSF    03.7
1045:  MOVF   00,W
1046:  SUBLW  78
1047:  BTFSC  03.2
1048:  GOTO   053
1049:  MOVF   51,W
104A:  ADDWF  4C,W
104B:  MOVWF  04
104C:  BCF    03.7
104D:  BTFSC  4D.0
104E:  BSF    03.7
104F:  MOVF   00,W
1050:  SUBLW  58
1051:  BTFSS  03.2
1052:  GOTO   05F
....................       { 
....................          base = 16; 
1053:  MOVLW  10
1054:  MOVWF  50
....................          index++; 
1055:  INCF   51,F
....................          c = s[index++]; 
1056:  MOVF   51,W
1057:  INCF   51,F
1058:  ADDWF  4C,W
1059:  MOVWF  04
105A:  BCF    03.7
105B:  BTFSC  4D.0
105C:  BSF    03.7
105D:  MOVF   00,W
105E:  MOVWF  52
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
105F:  MOVF   50,W
1060:  SUBLW  0A
1061:  BTFSS  03.2
1062:  GOTO   0A4
....................       { 
....................          while (c >= '0' && c <= '9') 
1063:  MOVF   52,W
1064:  SUBLW  2F
1065:  BTFSC  03.0
1066:  GOTO   0A3
1067:  MOVF   52,W
1068:  SUBLW  39
1069:  BTFSS  03.0
106A:  GOTO   0A3
....................          { 
....................             result = 10*result + (c - '0'); 
106B:  MOVLW  0A
106C:  MOVWF  53
106D:  MOVF   4E,W
106E:  MOVWF  54
*
1093:  MOVF   78,W
1094:  MOVWF  53
1095:  MOVLW  30
1096:  SUBWF  52,W
1097:  ADDWF  53,W
1098:  MOVWF  4E
....................             c = s[index++]; 
1099:  MOVF   51,W
109A:  INCF   51,F
109B:  ADDWF  4C,W
109C:  MOVWF  04
109D:  BCF    03.7
109E:  BTFSC  4D.0
109F:  BSF    03.7
10A0:  MOVF   00,W
10A1:  MOVWF  52
10A2:  GOTO   063
....................          } 
....................       } 
10A3:  GOTO   0F6
....................       else if (base == 16)    // The number is a hexa number 
10A4:  MOVF   50,W
10A5:  SUBLW  10
10A6:  BTFSS  03.2
10A7:  GOTO   0F6
....................       { 
....................          c = toupper(c); 
10A8:  MOVF   52,W
10A9:  SUBLW  60
10AA:  BTFSC  03.0
10AB:  GOTO   0B3
10AC:  MOVF   52,W
10AD:  SUBLW  7A
10AE:  BTFSS  03.0
10AF:  GOTO   0B3
10B0:  MOVF   52,W
10B1:  ANDLW  DF
10B2:  GOTO   0B4
10B3:  MOVF   52,W
10B4:  MOVWF  52
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
10B5:  MOVF   52,W
10B6:  SUBLW  2F
10B7:  BTFSC  03.0
10B8:  GOTO   0BD
10B9:  MOVF   52,W
10BA:  SUBLW  39
10BB:  BTFSC  03.0
10BC:  GOTO   0C5
10BD:  MOVF   52,W
10BE:  SUBLW  40
10BF:  BTFSC  03.0
10C0:  GOTO   0F6
10C1:  MOVF   52,W
10C2:  SUBLW  46
10C3:  BTFSS  03.0
10C4:  GOTO   0F6
....................          { 
....................             if (c >= '0' && c <= '9') 
10C5:  MOVF   52,W
10C6:  SUBLW  2F
10C7:  BTFSC  03.0
10C8:  GOTO   0D6
10C9:  MOVF   52,W
10CA:  SUBLW  39
10CB:  BTFSS  03.0
10CC:  GOTO   0D6
....................                result = (result << 4) + (c - '0'); 
10CD:  SWAPF  4E,W
10CE:  MOVWF  53
10CF:  MOVLW  F0
10D0:  ANDWF  53,F
10D1:  MOVLW  30
10D2:  SUBWF  52,W
10D3:  ADDWF  53,W
10D4:  MOVWF  4E
10D5:  GOTO   0DF
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
10D6:  SWAPF  4E,W
10D7:  MOVWF  53
10D8:  MOVLW  F0
10D9:  ANDWF  53,F
10DA:  MOVLW  41
10DB:  SUBWF  52,W
10DC:  ADDLW  0A
10DD:  ADDWF  53,W
10DE:  MOVWF  4E
....................  
....................             c = s[index++]; 
10DF:  MOVF   51,W
10E0:  INCF   51,F
10E1:  ADDWF  4C,W
10E2:  MOVWF  04
10E3:  BCF    03.7
10E4:  BTFSC  4D.0
10E5:  BSF    03.7
10E6:  MOVF   00,W
10E7:  MOVWF  52
....................             c = toupper(c); 
10E8:  MOVF   52,W
10E9:  SUBLW  60
10EA:  BTFSC  03.0
10EB:  GOTO   0F3
10EC:  MOVF   52,W
10ED:  SUBLW  7A
10EE:  BTFSS  03.0
10EF:  GOTO   0F3
10F0:  MOVF   52,W
10F1:  ANDLW  DF
10F2:  GOTO   0F4
10F3:  MOVF   52,W
10F4:  MOVWF  52
10F5:  GOTO   0B5
....................          } 
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
10F6:  DECFSZ 4F,W
10F7:  GOTO   0FE
10F8:  MOVF   50,W
10F9:  SUBLW  0A
10FA:  BTFSS  03.2
10FB:  GOTO   0FE
....................        result = -result; 
10FC:  COMF   4E,F
10FD:  INCF   4E,F
....................  
....................    return(result); 
10FE:  MOVF   4E,W
10FF:  MOVWF  78
1100:  BCF    03.6
1101:  RETURN
.................... } 
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
*
0454:  BSF    03.6
0455:  CLRF   58
0456:  CLRF   57
0457:  CLRF   56
0458:  MOVLW  01
0459:  MOVWF  55
045A:  CLRF   5A
045B:  CLRF   5B
.................... { 
....................      unsigned int32 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
045C:  BTFSS  51.7
045D:  GOTO   49E
....................          sign=1;        // Check for negative number 
045E:  MOVLW  01
045F:  MOVWF  5A
....................          num*=-1; 
0460:  MOVF   51,W
0461:  MOVWF  60
0462:  MOVF   50,W
0463:  MOVWF  5F
0464:  MOVF   4F,W
0465:  MOVWF  5E
0466:  MOVF   4E,W
0467:  MOVWF  5D
0468:  MOVLW  FF
0469:  MOVWF  64
046A:  MOVWF  63
046B:  MOVWF  62
046C:  MOVWF  61
*
0496:  MOVF   7A,W
0497:  MOVWF  51
0498:  MOVF   79,W
0499:  MOVWF  50
049A:  MOVF   78,W
049B:  MOVWF  4F
049C:  MOVF   77,W
049D:  MOVWF  4E
....................      } 
....................  
....................      while(temp>0) { 
049E:  MOVF   55,F
049F:  BTFSS  03.2
04A0:  GOTO   4AA
04A1:  MOVF   56,F
04A2:  BTFSS  03.2
04A3:  GOTO   4AA
04A4:  MOVF   57,F
04A5:  BTFSS  03.2
04A6:  GOTO   4AA
04A7:  MOVF   58,F
04A8:  BTFSC  03.2
04A9:  GOTO   656
....................          temp=(num/base); 
04AA:  BCF    03.1
04AB:  MOVF   51,W
04AC:  MOVWF  68
04AD:  MOVF   50,W
04AE:  MOVWF  67
04AF:  MOVF   4F,W
04B0:  MOVWF  66
04B1:  MOVF   4E,W
04B2:  MOVWF  65
04B3:  CLRF   6C
04B4:  CLRF   6B
04B5:  CLRF   6A
04B6:  MOVF   52,W
04B7:  MOVWF  69
*
0552:  MOVF   7A,W
0553:  BCF    03.5
0554:  MOVWF  58
0555:  MOVF   79,W
0556:  MOVWF  57
0557:  MOVF   78,W
0558:  MOVWF  56
0559:  MOVF   77,W
055A:  MOVWF  55
....................          s[cnt]=(num%base)+'0';    // Conversion 
055B:  MOVF   5B,W
055C:  ADDWF  53,W
055D:  MOVWF  78
055E:  MOVF   54,W
055F:  MOVWF  7A
0560:  BTFSC  03.0
0561:  INCF   7A,F
0562:  MOVF   78,W
0563:  MOVWF  5D
0564:  MOVF   7A,W
0565:  MOVWF  5E
0566:  CLRF   60
0567:  MOVF   04,W
0568:  MOVWF  5F
0569:  BCF    60.0
056A:  BTFSC  03.7
056B:  BSF    60.0
056C:  BSF    03.1
056D:  MOVLW  61
056E:  MOVWF  04
056F:  BSF    03.7
0570:  MOVF   51,W
0571:  MOVWF  68
0572:  MOVF   50,W
0573:  MOVWF  67
0574:  MOVF   4F,W
0575:  MOVWF  66
0576:  MOVF   4E,W
0577:  MOVWF  65
0578:  CLRF   6C
0579:  CLRF   6B
057A:  CLRF   6A
057B:  MOVF   52,W
057C:  MOVWF  69
*
0617:  BCF    03.5
0618:  MOVF   5F,W
0619:  MOVWF  04
061A:  BCF    03.7
061B:  BTFSC  60.0
061C:  BSF    03.7
061D:  MOVLW  30
061E:  ADDWF  61,W
061F:  MOVWF  77
0620:  MOVF   62,W
0621:  MOVWF  78
0622:  MOVLW  00
0623:  BTFSC  03.0
0624:  MOVLW  01
0625:  ADDWF  78,F
0626:  MOVF   63,W
0627:  MOVWF  79
0628:  MOVLW  00
0629:  BTFSC  03.0
062A:  MOVLW  01
062B:  ADDWF  79,F
062C:  MOVF   64,W
062D:  MOVWF  7A
062E:  MOVLW  00
062F:  BTFSC  03.0
0630:  MOVLW  01
0631:  ADDWF  7A,F
0632:  MOVF   5D,W
0633:  MOVWF  04
0634:  BCF    03.7
0635:  BTFSC  5E.0
0636:  BSF    03.7
0637:  MOVF   77,W
0638:  MOVWF  00
....................  
....................          if(s[cnt]>0x39) 
0639:  MOVF   5B,W
063A:  ADDWF  53,W
063B:  MOVWF  04
063C:  BCF    03.7
063D:  BTFSC  54.0
063E:  BSF    03.7
063F:  MOVF   00,W
0640:  SUBLW  39
0641:  BTFSC  03.0
0642:  GOTO   64C
....................             s[cnt]+=0x7; 
0643:  MOVF   5B,W
0644:  ADDWF  53,W
0645:  MOVWF  04
0646:  BCF    03.7
0647:  BTFSC  54.0
0648:  BSF    03.7
0649:  MOVLW  07
064A:  ADDWF  00,W
064B:  MOVWF  00
....................  
....................          cnt++; 
064C:  INCF   5B,F
....................          num=temp; 
064D:  MOVF   58,W
064E:  MOVWF  51
064F:  MOVF   57,W
0650:  MOVWF  50
0651:  MOVF   56,W
0652:  MOVWF  4F
0653:  MOVF   55,W
0654:  MOVWF  4E
0655:  GOTO   49E
....................      } 
....................  
....................      if(sign==1) { 
0656:  DECFSZ 5A,W
0657:  GOTO   661
....................          s[cnt]=0x2D;      // Negative sign 
0658:  MOVF   5B,W
0659:  ADDWF  53,W
065A:  MOVWF  04
065B:  BCF    03.7
065C:  BTFSC  54.0
065D:  BSF    03.7
065E:  MOVLW  2D
065F:  MOVWF  00
....................          cnt++; 
0660:  INCF   5B,F
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
0661:  CLRF   59
0662:  BCF    03.0
0663:  RRF    5B,W
0664:  SUBWF  59,W
0665:  BTFSC  03.0
0666:  GOTO   697
....................  
....................          c=s[i]; 
0667:  MOVF   59,W
0668:  ADDWF  53,W
0669:  MOVWF  04
066A:  BCF    03.7
066B:  BTFSC  54.0
066C:  BSF    03.7
066D:  MOVF   00,W
066E:  MOVWF  5C
....................          s[i]=s[cnt-i-1];        // Reverse the number 
066F:  MOVF   59,W
0670:  ADDWF  53,W
0671:  MOVWF  78
0672:  MOVF   54,W
0673:  MOVWF  7A
0674:  BTFSC  03.0
0675:  INCF   7A,F
0676:  MOVF   78,W
0677:  MOVWF  5D
0678:  MOVF   7A,W
0679:  MOVWF  5E
067A:  MOVF   59,W
067B:  SUBWF  5B,W
067C:  ADDLW  FF
067D:  ADDWF  53,W
067E:  MOVWF  04
067F:  BCF    03.7
0680:  BTFSC  54.0
0681:  BSF    03.7
0682:  MOVF   00,W
0683:  MOVWF  5F
0684:  MOVF   5D,W
0685:  MOVWF  04
0686:  BCF    03.7
0687:  BTFSC  5E.0
0688:  BSF    03.7
0689:  MOVF   5F,W
068A:  MOVWF  00
....................          s[cnt-i-1]=c; 
068B:  MOVF   59,W
068C:  SUBWF  5B,W
068D:  ADDLW  FF
068E:  ADDWF  53,W
068F:  MOVWF  04
0690:  BCF    03.7
0691:  BTFSC  54.0
0692:  BSF    03.7
0693:  MOVF   5C,W
0694:  MOVWF  00
0695:  INCF   59,F
0696:  GOTO   662
....................      } 
....................      s[cnt]='\0';     // End the string 
0697:  MOVF   5B,W
0698:  ADDWF  53,W
0699:  MOVWF  04
069A:  BCF    03.7
069B:  BTFSC  54.0
069C:  BSF    03.7
069D:  CLRF   00
....................      return s; 
069E:  MOVF   53,W
069F:  MOVWF  78
06A0:  MOVF   54,W
06A1:  MOVWF  79
06A2:  BCF    03.6
06A3:  RETURN
.................... } 
....................  
.................... #if defined(__PCD__) 
....................  
.................... char * itoa(signed int48 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int48 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... char * itoa(signed int64 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int64 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................       
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1;         
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................              
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #endif 
....................  
.................... float strtof(char *s, char *endptr) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s, char *endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float48)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float48)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s, char *endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float64)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float64)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtoulGO; 
....................  
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................    { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... int8 mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #if !defined(__PCD__) 
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2);  
.................... #else  
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2);  
.................... #endif 
....................  
....................  
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    unsigned int8 t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=1; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = 0; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
.................... #INCLUDE <STDIO.H> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDIO 
.................... #define _STDIO 
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #ifndef getc 
.................... #define getc getch 
.................... #define getchar getch 
.................... #define puts(s) {printf(s); putchar(13); putchar(10);} 
.................... #define putc putchar 
.................... #endif 
.................... /* maps error number to an error message. Writes a sequence of characters to 
.................... stderr stream thus: if s is not null then string pointed to by s follwed by 
.................... a colon (:) and a space and the appropriate error message returned by strerror 
.................... function with argument errno 
....................  
.................... Returns: no value 
.................... */ 
....................  
.................... #ifdef _ERRNO 
.................... void perror(char *s) 
.................... { 
....................   if(s) 
....................   fprintf(STDERR,"%s: ",s); 
....................   fprintf(STDERR,"%s\r\n",strerror(errno)); 
.................... } 
.................... #endif 
.................... #endif 
....................  
.................... #FUSES NOWDT, PUT, HS 
.................... #USE DELAY(CLOCK=20M) 
*
0132:  MOVLW  51
0133:  MOVWF  04
0134:  BSF    03.7
0135:  MOVF   00,W
0136:  BTFSC  03.2
0137:  GOTO   145
0138:  MOVLW  06
0139:  MOVWF  78
013A:  CLRF   77
013B:  DECFSZ 77,F
013C:  GOTO   13B
013D:  DECFSZ 78,F
013E:  GOTO   13A
013F:  MOVLW  7B
0140:  MOVWF  77
0141:  DECFSZ 77,F
0142:  GOTO   141
0143:  DECFSZ 00,F
0144:  GOTO   138
0145:  RETURN
.................... #USE RS232(BAUD=9600,XMIT=PIN_C6,RCV=PIN_C7) 
.................... #DEFINE BT1_PIN PIN_B1 
.................... #DEFINE BT2_PIN PIN_B2 
.................... #DEFINE BT3_PIN PIN_B3 
.................... #DEFINE LCD_ENABLE_PIN  PIN_E0                                    
.................... #DEFINE LCD_RS_PIN      PIN_E1                                 
.................... #DEFINE LCD_RW_PIN      PIN_E2   
.................... #DEFINE LCD_DATA4       PIN_C0                                
.................... #DEFINE LCD_DATA5       PIN_C1                                  
.................... #DEFINE LCD_DATA6       PIN_C2                                    
.................... #DEFINE LCD_DATA7       PIN_C3   
.................... #INCLUDE <LCD.C> 
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... ////                             LCD.C                                     //// 
.................... ////                 Driver for common LCD modules                         //// 
.................... ////                                                                       //// 
.................... ////  lcd_init()   Must be called before any other function.               //// 
.................... ////                                                                       //// 
.................... ////  lcd_putc(c)  Will display c on the next position of the LCD.         //// 
.................... ////                 \a  Set cursor position to upper left                 //// 
.................... ////                 \f  Clear display, set cursor to upper left           //// 
.................... ////                 \n  Go to start of second line                        //// 
.................... ////                 \b  Move back one position                            //// 
.................... ////              If LCD_EXTENDED_NEWLINE is defined, the \n character     //// 
.................... ////              will erase all remanining characters on the current      //// 
.................... ////              line, and move the cursor to the beginning of the next   //// 
.................... ////              line.                                                    //// 
.................... ////              If LCD_EXTENDED_NEWLINE is defined, the \r character     //// 
.................... ////              will move the cursor to the start of the current         //// 
.................... ////              line.                                                    //// 
.................... ////                                                                       //// 
.................... ////  lcd_gotoxy(x,y) Set write position on LCD (upper left is 1,1)        //// 
.................... ////                                                                       //// 
.................... ////  lcd_getc(x,y)   Returns character at position x,y on LCD             //// 
.................... ////                                                                       //// 
.................... ////  lcd_cursor_on(int1 on)   Turn the cursor on (on=TRUE) or off         //// 
.................... ////              (on=FALSE).                                              //// 
.................... ////                                                                       //// 
.................... ////  lcd_set_cgram_char(w, *p)   Write a custom character to the CGRAM.   //// 
.................... ////                                                                       //// 
.................... ////                                                                       //// 
.................... ////  CONFIGURATION                                                        //// 
.................... ////  The LCD can be configured in one of two ways: a.) port access or     //// 
.................... ////  b.) pin access.  Port access requires the entire 7 bit interface     //// 
.................... ////  connected to one GPIO port, and the data bits (D4:D7 of the LCD)     //// 
.................... ////  connected to sequential pins on the GPIO.  Pin access                //// 
.................... ////  has no requirements, all 7 bits of the control interface can         //// 
.................... ////  can be connected to any GPIO using several ports.                    //// 
.................... ////                                                                       //// 
.................... ////  To use port access, #define LCD_DATA_PORT to the SFR location of     //// 
.................... ////  of the GPIO port that holds the interface, -AND- edit LCD_PIN_MAP    //// 
.................... ////  of this file to configure the pin order.  If you are using a         //// 
.................... ////  baseline PIC (PCB), then LCD_OUTPUT_MAP and LCD_INPUT_MAP also must  //// 
.................... ////  be defined.                                                          //// 
.................... ////                                                                       //// 
.................... ////  Example of port access:                                              //// 
.................... ////     #define LCD_DATA_PORT getenv("SFR:PORTD")                         //// 
.................... ////                                                                       //// 
.................... ////  To use pin access, the following pins must be defined:               //// 
.................... ////     LCD_ENABLE_PIN                                                    //// 
.................... ////     LCD_RS_PIN                                                        //// 
.................... ////     LCD_RW_PIN                                                        //// 
.................... ////     LCD_DATA4                                                         //// 
.................... ////     LCD_DATA5                                                         //// 
.................... ////     LCD_DATA6                                                         //// 
.................... ////     LCD_DATA7                                                         //// 
.................... ////                                                                       //// 
.................... ////  Example of pin access:                                               //// 
.................... ////     #define LCD_ENABLE_PIN  PIN_E0                                    //// 
.................... ////     #define LCD_RS_PIN      PIN_E1                                    //// 
.................... ////     #define LCD_RW_PIN      PIN_E2                                    //// 
.................... ////     #define LCD_DATA4       PIN_D4                                    //// 
.................... ////     #define LCD_DATA5       PIN_D5                                    //// 
.................... ////     #define LCD_DATA6       PIN_D6                                    //// 
.................... ////     #define LCD_DATA7       PIN_D7                                    //// 
.................... ////                                                                       //// 
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2010 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef __LCD_C__ 
.................... #define __LCD_C__ 
....................  
.................... // define the pinout. 
.................... // only required if port access is being used. 
.................... typedef struct   
.................... {                            // This structure is overlayed 
....................    int1 enable;           // on to an I/O port to gain 
....................    int1 rs;               // access to the LCD pins. 
....................    int1 rw;               // The bits are allocated from 
....................    int1 unused;           // low order up.  ENABLE will 
....................    unsigned int     data : 4;         // be LSB pin of that port. 
....................   #if defined(__PCD__)       // The port used will be LCD_DATA_PORT. 
....................    unsigned int    reserved: 8; 
....................   #endif 
.................... } LCD_PIN_MAP; 
....................  
.................... // this is to improve compatability with previous LCD drivers that accepted 
.................... // a define labeled 'use_portb_lcd' that configured the LCD onto port B. 
.................... #if ((defined(use_portb_lcd)) && (use_portb_lcd==TRUE)) 
....................  #define LCD_DATA_PORT getenv("SFR:PORTB") 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
....................    // these definitions only need to be modified for baseline PICs. 
....................    // all other PICs use LCD_PIN_MAP or individual LCD_xxx pin definitions. 
.................... /*                                    EN, RS,   RW,   UNUSED,  DATA  */ 
....................  const LCD_PIN_MAP LCD_OUTPUT_MAP =  {0,  0,    0,    0,       0}; 
....................  const LCD_PIN_MAP LCD_INPUT_MAP =   {0,  0,    0,    0,       0xF}; 
.................... #endif 
....................  
.................... ////////////////////// END CONFIGURATION /////////////////////////////////// 
....................  
.................... #ifndef LCD_ENABLE_PIN 
....................    #define lcd_output_enable(x) lcdlat.enable=x 
....................    #define lcd_enable_tris()   lcdtris.enable=0 
.................... #else 
....................    #define lcd_output_enable(x) output_bit(LCD_ENABLE_PIN, x) 
....................    #define lcd_enable_tris()  output_drive(LCD_ENABLE_PIN) 
.................... #endif 
....................  
.................... #ifndef LCD_RS_PIN 
....................    #define lcd_output_rs(x) lcdlat.rs=x 
....................    #define lcd_rs_tris()   lcdtris.rs=0 
.................... #else 
....................    #define lcd_output_rs(x) output_bit(LCD_RS_PIN, x) 
....................    #define lcd_rs_tris()  output_drive(LCD_RS_PIN) 
.................... #endif 
....................  
.................... #ifndef LCD_RW_PIN 
....................    #define lcd_output_rw(x) lcdlat.rw=x 
....................    #define lcd_rw_tris()   lcdtris.rw=0 
.................... #else 
....................    #define lcd_output_rw(x) output_bit(LCD_RW_PIN, x) 
....................    #define lcd_rw_tris()  output_drive(LCD_RW_PIN) 
.................... #endif 
....................  
.................... // original version of this library incorrectly labeled LCD_DATA0 as LCD_DATA4, 
.................... // LCD_DATA1 as LCD_DATA5, and so on.  this block of code makes the driver 
.................... // compatible with any code written for the original library 
.................... #if (defined(LCD_DATA0) && defined(LCD_DATA1) && defined(LCD_DATA2) && defined(LCD_DATA3) && !defined(LCD_DATA4) && !defined(LCD_DATA5) && !defined(LCD_DATA6) && !defined(LCD_DATA7)) 
....................    #define  LCD_DATA4    LCD_DATA0 
....................    #define  LCD_DATA5    LCD_DATA1 
....................    #define  LCD_DATA6    LCD_DATA2 
....................    #define  LCD_DATA7    LCD_DATA3 
.................... #endif 
....................  
.................... #ifndef LCD_DATA4 
.................... #ifndef LCD_DATA_PORT 
....................    #if defined(__PCB__) 
....................       #define LCD_DATA_PORT      0x06     //portb 
....................       #define set_tris_lcd(x)   set_tris_b(x) 
....................    #else 
....................      #if defined(PIN_D0) 
....................       #define LCD_DATA_PORT      getenv("SFR:PORTD")     //portd 
....................      #else 
....................       #define LCD_DATA_PORT      getenv("SFR:PORTB")     //portb 
....................      #endif 
....................    #endif    
.................... #endif 
....................  
.................... #if defined(__PCB__) 
....................    LCD_PIN_MAP lcd, lcdlat; 
....................    #byte lcd = LCD_DATA_PORT 
....................    #byte lcdlat = LCD_DATA_PORT 
.................... #elif defined(__PCM__) 
....................    LCD_PIN_MAP lcd, lcdlat, lcdtris; 
....................    #byte lcd = LCD_DATA_PORT 
....................    #byte lcdlat = LCD_DATA_PORT 
....................    #byte lcdtris = LCD_DATA_PORT+0x80 
.................... #elif defined(__PCH__) 
....................    LCD_PIN_MAP lcd, lcdlat, lcdtris; 
....................    #byte lcd = LCD_DATA_PORT 
....................    #byte lcdlat = LCD_DATA_PORT+9 
....................    #byte lcdtris = LCD_DATA_PORT+0x12 
.................... #elif defined(__PCD__) 
....................    LCD_PIN_MAP lcd, lcdlat, lcdtris; 
....................    #word lcd = LCD_DATA_PORT 
....................    #word lcdlat = LCD_DATA_PORT+2 
....................    #word lcdtris = LCD_DATA_PORT-0x02 
.................... #endif 
.................... #endif   //LCD_DATA4 not defined 
....................  
.................... #ifndef LCD_TYPE 
....................    #define LCD_TYPE 2           // 0=5x7, 1=5x10, 2=2 lines 
.................... #endif 
....................  
.................... #ifndef LCD_LINE_TWO 
....................    #define LCD_LINE_TWO 0x40    // LCD RAM address for the second line 
.................... #endif 
....................  
.................... #ifndef LCD_LINE_LENGTH 
....................    #define LCD_LINE_LENGTH 20 
.................... #endif 
....................  
.................... unsigned int8 lcd_read_nibble(void); 
....................  
.................... unsigned int8 lcd_read_byte(void) 
.................... { 
....................    unsigned int8 low,high; 
....................  
....................  #if defined(__PCB__) 
....................    set_tris_lcd(LCD_INPUT_MAP); 
....................  #else 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    output_float(LCD_DATA4); 
*
014E:  BSF    07.0
....................    output_float(LCD_DATA5); 
014F:  BSF    07.1
....................    output_float(LCD_DATA6); 
0150:  BSF    07.2
....................    output_float(LCD_DATA7); 
0151:  BSF    07.3
....................   #else 
....................    lcdtris.data = 0xF; 
....................   #endif 
....................  #endif 
....................          
....................    lcd_output_rw(1); 
0152:  BCF    03.5
0153:  BSF    09.2
0154:  BSF    03.5
0155:  BCF    09.2
....................    delay_cycles(1); 
0156:  NOP
....................    lcd_output_enable(1); 
0157:  BCF    03.5
0158:  BSF    09.0
0159:  BSF    03.5
015A:  BCF    09.0
....................    delay_cycles(1); 
015B:  NOP
....................    high = lcd_read_nibble(); 
*
019E:  MOVF   78,W
019F:  MOVWF  58
....................        
....................    lcd_output_enable(0); 
01A0:  BCF    03.6
01A1:  BCF    09.0
01A2:  BSF    03.5
01A3:  BCF    09.0
....................    delay_cycles(1); 
01A4:  NOP
....................    lcd_output_enable(1); 
01A5:  BCF    03.5
01A6:  BSF    09.0
01A7:  BSF    03.5
01A8:  BCF    09.0
....................    delay_us(1); 
01A9:  GOTO   1AA
01AA:  GOTO   1AB
01AB:  NOP
....................    low = lcd_read_nibble(); 
*
01EE:  MOVF   78,W
01EF:  MOVWF  57
....................        
....................    lcd_output_enable(0); 
01F0:  BCF    03.6
01F1:  BCF    09.0
01F2:  BSF    03.5
01F3:  BCF    09.0
....................  
....................  #if defined(__PCB__) 
....................    set_tris_lcd(LCD_OUTPUT_MAP); 
....................  #else 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    output_drive(LCD_DATA4); 
01F4:  BCF    03.5
01F5:  BCF    31.0
01F6:  MOVF   31,W
01F7:  BSF    03.5
01F8:  MOVWF  07
....................    output_drive(LCD_DATA5); 
01F9:  BCF    03.5
01FA:  BCF    31.1
01FB:  MOVF   31,W
01FC:  BSF    03.5
01FD:  MOVWF  07
....................    output_drive(LCD_DATA6); 
01FE:  BCF    03.5
01FF:  BCF    31.2
0200:  MOVF   31,W
0201:  BSF    03.5
0202:  MOVWF  07
....................    output_drive(LCD_DATA7); 
0203:  BCF    03.5
0204:  BCF    31.3
0205:  MOVF   31,W
0206:  BSF    03.5
0207:  MOVWF  07
....................   #else 
....................    lcdtris.data = 0x0; 
....................   #endif 
....................  #endif 
....................  
....................    return( (high<<4) | low); 
0208:  BCF    03.5
0209:  BSF    03.6
020A:  SWAPF  58,W
020B:  MOVWF  77
020C:  MOVLW  F0
020D:  ANDWF  77,F
020E:  MOVF   77,W
020F:  IORWF  57,W
0210:  MOVWF  78
.................... } 
....................  
.................... unsigned int8 lcd_read_nibble(void) 
.................... { 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
*
015C:  BCF    03.5
015D:  BSF    03.6
015E:  CLRF   59
*
01AC:  BCF    03.5
01AD:  BSF    03.6
01AE:  CLRF   59
....................    unsigned int8 n = 0x00; 
....................  
....................    /* Read the data port */ 
....................    n |= input(LCD_DATA4); 
*
015F:  BCF    03.6
0160:  BSF    31.0
0161:  MOVF   31,W
0162:  BSF    03.5
0163:  MOVWF  07
0164:  MOVLW  00
0165:  BCF    03.5
0166:  BTFSC  07.0
0167:  MOVLW  01
0168:  BSF    03.6
0169:  IORWF  59,F
*
01AF:  BCF    03.6
01B0:  BSF    31.0
01B1:  MOVF   31,W
01B2:  BSF    03.5
01B3:  MOVWF  07
01B4:  MOVLW  00
01B5:  BCF    03.5
01B6:  BTFSC  07.0
01B7:  MOVLW  01
01B8:  BSF    03.6
01B9:  IORWF  59,F
....................    n |= input(LCD_DATA5) << 1; 
*
016A:  BCF    03.6
016B:  BSF    31.1
016C:  MOVF   31,W
016D:  BSF    03.5
016E:  MOVWF  07
016F:  MOVLW  00
0170:  BCF    03.5
0171:  BTFSC  07.1
0172:  MOVLW  01
0173:  MOVWF  77
0174:  BCF    03.0
0175:  RLF    77,F
0176:  MOVF   77,W
0177:  BSF    03.6
0178:  IORWF  59,F
*
01BA:  BCF    03.6
01BB:  BSF    31.1
01BC:  MOVF   31,W
01BD:  BSF    03.5
01BE:  MOVWF  07
01BF:  MOVLW  00
01C0:  BCF    03.5
01C1:  BTFSC  07.1
01C2:  MOVLW  01
01C3:  MOVWF  77
01C4:  BCF    03.0
01C5:  RLF    77,F
01C6:  MOVF   77,W
01C7:  BSF    03.6
01C8:  IORWF  59,F
....................    n |= input(LCD_DATA6) << 2; 
*
0179:  BCF    03.6
017A:  BSF    31.2
017B:  MOVF   31,W
017C:  BSF    03.5
017D:  MOVWF  07
017E:  MOVLW  00
017F:  BCF    03.5
0180:  BTFSC  07.2
0181:  MOVLW  01
0182:  MOVWF  77
0183:  RLF    77,F
0184:  RLF    77,F
0185:  MOVLW  FC
0186:  ANDWF  77,F
0187:  MOVF   77,W
0188:  BSF    03.6
0189:  IORWF  59,F
*
01C9:  BCF    03.6
01CA:  BSF    31.2
01CB:  MOVF   31,W
01CC:  BSF    03.5
01CD:  MOVWF  07
01CE:  MOVLW  00
01CF:  BCF    03.5
01D0:  BTFSC  07.2
01D1:  MOVLW  01
01D2:  MOVWF  77
01D3:  RLF    77,F
01D4:  RLF    77,F
01D5:  MOVLW  FC
01D6:  ANDWF  77,F
01D7:  MOVF   77,W
01D8:  BSF    03.6
01D9:  IORWF  59,F
....................    n |= input(LCD_DATA7) << 3; 
*
018A:  BCF    03.6
018B:  BSF    31.3
018C:  MOVF   31,W
018D:  BSF    03.5
018E:  MOVWF  07
018F:  MOVLW  00
0190:  BCF    03.5
0191:  BTFSC  07.3
0192:  MOVLW  01
0193:  MOVWF  77
0194:  RLF    77,F
0195:  RLF    77,F
0196:  RLF    77,F
0197:  MOVLW  F8
0198:  ANDWF  77,F
0199:  MOVF   77,W
019A:  BSF    03.6
019B:  IORWF  59,F
*
01DA:  BCF    03.6
01DB:  BSF    31.3
01DC:  MOVF   31,W
01DD:  BSF    03.5
01DE:  MOVWF  07
01DF:  MOVLW  00
01E0:  BCF    03.5
01E1:  BTFSC  07.3
01E2:  MOVLW  01
01E3:  MOVWF  77
01E4:  RLF    77,F
01E5:  RLF    77,F
01E6:  RLF    77,F
01E7:  MOVLW  F8
01E8:  ANDWF  77,F
01E9:  MOVF   77,W
01EA:  BSF    03.6
01EB:  IORWF  59,F
....................     
....................    return(n); 
*
019C:  MOVF   59,W
019D:  MOVWF  78
*
01EC:  MOVF   59,W
01ED:  MOVWF  78
....................   #else 
....................    return(lcd.data); 
....................   #endif 
.................... } 
....................  
.................... void lcd_send_nibble(unsigned int8 n) 
.................... { 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    /* Write to the data port */ 
....................    output_bit(LCD_DATA4, bit_test(n, 0)); 
*
0235:  BTFSC  58.0
0236:  GOTO   23B
0237:  BCF    03.6
0238:  BCF    07.0
0239:  GOTO   23D
023A:  BSF    03.6
023B:  BCF    03.6
023C:  BSF    07.0
023D:  BCF    31.0
023E:  MOVF   31,W
023F:  BSF    03.5
0240:  MOVWF  07
*
0281:  BTFSC  58.0
0282:  GOTO   287
0283:  BCF    03.6
0284:  BCF    07.0
0285:  GOTO   289
0286:  BSF    03.6
0287:  BCF    03.6
0288:  BSF    07.0
0289:  BCF    31.0
028A:  MOVF   31,W
028B:  BSF    03.5
028C:  MOVWF  07
*
0303:  BTFSC  58.0
0304:  GOTO   309
0305:  BCF    03.6
0306:  BCF    07.0
0307:  GOTO   30B
0308:  BSF    03.6
0309:  BCF    03.6
030A:  BSF    07.0
030B:  BCF    31.0
030C:  MOVF   31,W
030D:  BSF    03.5
030E:  MOVWF  07
*
0353:  BTFSC  58.0
0354:  GOTO   359
0355:  BCF    03.6
0356:  BCF    07.0
0357:  GOTO   35B
0358:  BSF    03.6
0359:  BCF    03.6
035A:  BSF    07.0
035B:  BCF    31.0
035C:  MOVF   31,W
035D:  BSF    03.5
035E:  MOVWF  07
....................    output_bit(LCD_DATA5, bit_test(n, 1)); 
*
0241:  BCF    03.5
0242:  BSF    03.6
0243:  BTFSC  58.1
0244:  GOTO   249
0245:  BCF    03.6
0246:  BCF    07.1
0247:  GOTO   24B
0248:  BSF    03.6
0249:  BCF    03.6
024A:  BSF    07.1
024B:  BCF    31.1
024C:  MOVF   31,W
024D:  BSF    03.5
024E:  MOVWF  07
*
028D:  BCF    03.5
028E:  BSF    03.6
028F:  BTFSC  58.1
0290:  GOTO   295
0291:  BCF    03.6
0292:  BCF    07.1
0293:  GOTO   297
0294:  BSF    03.6
0295:  BCF    03.6
0296:  BSF    07.1
0297:  BCF    31.1
0298:  MOVF   31,W
0299:  BSF    03.5
029A:  MOVWF  07
*
030F:  BCF    03.5
0310:  BSF    03.6
0311:  BTFSC  58.1
0312:  GOTO   317
0313:  BCF    03.6
0314:  BCF    07.1
0315:  GOTO   319
0316:  BSF    03.6
0317:  BCF    03.6
0318:  BSF    07.1
0319:  BCF    31.1
031A:  MOVF   31,W
031B:  BSF    03.5
031C:  MOVWF  07
*
035F:  BCF    03.5
0360:  BSF    03.6
0361:  BTFSC  58.1
0362:  GOTO   367
0363:  BCF    03.6
0364:  BCF    07.1
0365:  GOTO   369
0366:  BSF    03.6
0367:  BCF    03.6
0368:  BSF    07.1
0369:  BCF    31.1
036A:  MOVF   31,W
036B:  BSF    03.5
036C:  MOVWF  07
....................    output_bit(LCD_DATA6, bit_test(n, 2)); 
*
024F:  BCF    03.5
0250:  BSF    03.6
0251:  BTFSC  58.2
0252:  GOTO   257
0253:  BCF    03.6
0254:  BCF    07.2
0255:  GOTO   259
0256:  BSF    03.6
0257:  BCF    03.6
0258:  BSF    07.2
0259:  BCF    31.2
025A:  MOVF   31,W
025B:  BSF    03.5
025C:  MOVWF  07
*
029B:  BCF    03.5
029C:  BSF    03.6
029D:  BTFSC  58.2
029E:  GOTO   2A3
029F:  BCF    03.6
02A0:  BCF    07.2
02A1:  GOTO   2A5
02A2:  BSF    03.6
02A3:  BCF    03.6
02A4:  BSF    07.2
02A5:  BCF    31.2
02A6:  MOVF   31,W
02A7:  BSF    03.5
02A8:  MOVWF  07
*
031D:  BCF    03.5
031E:  BSF    03.6
031F:  BTFSC  58.2
0320:  GOTO   325
0321:  BCF    03.6
0322:  BCF    07.2
0323:  GOTO   327
0324:  BSF    03.6
0325:  BCF    03.6
0326:  BSF    07.2
0327:  BCF    31.2
0328:  MOVF   31,W
0329:  BSF    03.5
032A:  MOVWF  07
*
036D:  BCF    03.5
036E:  BSF    03.6
036F:  BTFSC  58.2
0370:  GOTO   375
0371:  BCF    03.6
0372:  BCF    07.2
0373:  GOTO   377
0374:  BSF    03.6
0375:  BCF    03.6
0376:  BSF    07.2
0377:  BCF    31.2
0378:  MOVF   31,W
0379:  BSF    03.5
037A:  MOVWF  07
....................    output_bit(LCD_DATA7, bit_test(n, 3)); 
*
025D:  BCF    03.5
025E:  BSF    03.6
025F:  BTFSC  58.3
0260:  GOTO   265
0261:  BCF    03.6
0262:  BCF    07.3
0263:  GOTO   267
0264:  BSF    03.6
0265:  BCF    03.6
0266:  BSF    07.3
0267:  BCF    31.3
0268:  MOVF   31,W
0269:  BSF    03.5
026A:  MOVWF  07
*
02A9:  BCF    03.5
02AA:  BSF    03.6
02AB:  BTFSC  58.3
02AC:  GOTO   2B1
02AD:  BCF    03.6
02AE:  BCF    07.3
02AF:  GOTO   2B3
02B0:  BSF    03.6
02B1:  BCF    03.6
02B2:  BSF    07.3
02B3:  BCF    31.3
02B4:  MOVF   31,W
02B5:  BSF    03.5
02B6:  MOVWF  07
*
032B:  BCF    03.5
032C:  BSF    03.6
032D:  BTFSC  58.3
032E:  GOTO   333
032F:  BCF    03.6
0330:  BCF    07.3
0331:  GOTO   335
0332:  BSF    03.6
0333:  BCF    03.6
0334:  BSF    07.3
0335:  BCF    31.3
0336:  MOVF   31,W
0337:  BSF    03.5
0338:  MOVWF  07
*
037B:  BCF    03.5
037C:  BSF    03.6
037D:  BTFSC  58.3
037E:  GOTO   383
037F:  BCF    03.6
0380:  BCF    07.3
0381:  GOTO   385
0382:  BSF    03.6
0383:  BCF    03.6
0384:  BSF    07.3
0385:  BCF    31.3
0386:  MOVF   31,W
0387:  BSF    03.5
0388:  MOVWF  07
....................   #else       
....................    lcdlat.data = n; 
....................   #endif 
....................        
....................    delay_cycles(1); 
*
026B:  NOP
*
02B7:  NOP
*
0339:  NOP
*
0389:  NOP
....................    lcd_output_enable(1); 
*
026C:  BCF    03.5
026D:  BSF    09.0
026E:  BSF    03.5
026F:  BCF    09.0
*
02B8:  BCF    03.5
02B9:  BSF    09.0
02BA:  BSF    03.5
02BB:  BCF    09.0
*
033A:  BCF    03.5
033B:  BSF    09.0
033C:  BSF    03.5
033D:  BCF    09.0
*
038A:  BCF    03.5
038B:  BSF    09.0
038C:  BSF    03.5
038D:  BCF    09.0
....................    delay_us(2); 
*
0270:  MOVLW  02
0271:  MOVWF  77
0272:  DECFSZ 77,F
0273:  GOTO   272
0274:  GOTO   275
0275:  NOP
*
02BC:  MOVLW  02
02BD:  MOVWF  77
02BE:  DECFSZ 77,F
02BF:  GOTO   2BE
02C0:  GOTO   2C1
02C1:  NOP
*
033E:  MOVLW  02
033F:  MOVWF  77
0340:  DECFSZ 77,F
0341:  GOTO   340
0342:  GOTO   343
0343:  NOP
*
038E:  MOVLW  02
038F:  MOVWF  77
0390:  DECFSZ 77,F
0391:  GOTO   390
0392:  GOTO   393
0393:  NOP
....................    lcd_output_enable(0); 
*
0276:  BCF    03.5
0277:  BCF    09.0
0278:  BSF    03.5
0279:  BCF    09.0
*
02C2:  BCF    03.5
02C3:  BCF    09.0
02C4:  BSF    03.5
02C5:  BCF    09.0
*
0344:  BCF    03.5
0345:  BCF    09.0
0346:  BSF    03.5
0347:  BCF    09.0
*
0394:  BCF    03.5
0395:  BCF    09.0
0396:  BSF    03.5
0397:  BCF    09.0
.................... } 
....................  
.................... void lcd_send_byte(unsigned int8 address, unsigned int8 n) 
.................... { 
....................   #if defined(__PCB__) 
....................    set_tris_lcd(LCD_OUTPUT_MAP); 
....................   #else 
....................    lcd_enable_tris(); 
*
0146:  BSF    03.5
0147:  BCF    09.0
....................    lcd_rs_tris(); 
0148:  BCF    09.1
....................    lcd_rw_tris(); 
0149:  BCF    09.2
....................   #endif 
....................  
....................    lcd_output_rs(0); 
014A:  BCF    03.5
014B:  BCF    09.1
014C:  BSF    03.5
014D:  BCF    09.1
....................    while ( bit_test(lcd_read_byte(),7) ) ; 
*
0211:  MOVF   78,W
0212:  MOVWF  57
0213:  BTFSS  57.7
0214:  GOTO   218
0215:  BSF    03.5
0216:  BCF    03.6
0217:  GOTO   14E
....................    lcd_output_rs(address); 
0218:  MOVF   55,F
0219:  BTFSS  03.2
021A:  GOTO   21F
021B:  BCF    03.6
021C:  BCF    09.1
021D:  GOTO   221
021E:  BSF    03.6
021F:  BCF    03.6
0220:  BSF    09.1
0221:  BSF    03.5
0222:  BCF    09.1
....................    delay_cycles(1); 
0223:  NOP
....................    lcd_output_rw(0); 
0224:  BCF    03.5
0225:  BCF    09.2
0226:  BSF    03.5
0227:  BCF    09.2
....................    delay_cycles(1); 
0228:  NOP
....................    lcd_output_enable(0); 
0229:  BCF    03.5
022A:  BCF    09.0
022B:  BSF    03.5
022C:  BCF    09.0
....................    lcd_send_nibble(n >> 4); 
022D:  BCF    03.5
022E:  BSF    03.6
022F:  SWAPF  56,W
0230:  MOVWF  57
0231:  MOVLW  0F
0232:  ANDWF  57,F
0233:  MOVF   57,W
0234:  MOVWF  58
....................    lcd_send_nibble(n & 0xf); 
*
027A:  BCF    03.5
027B:  BSF    03.6
027C:  MOVF   56,W
027D:  ANDLW  0F
027E:  MOVWF  57
027F:  MOVF   57,W
0280:  MOVWF  58
*
02C6:  BCF    03.5
02C7:  RETURN
.................... } 
....................  
.................... #if defined(LCD_EXTENDED_NEWLINE) 
.................... unsigned int8 g_LcdX, g_LcdY; 
.................... #endif 
....................  
.................... void lcd_init(void)  
.................... { 
....................    unsigned int8 i; 
....................    unsigned int8 LCD_INIT_STRING[4] = {0x20 | (LCD_TYPE << 2), 0xc, 1, 6}; 
02C8:  MOVLW  28
02C9:  BSF    03.6
02CA:  MOVWF  4D
02CB:  MOVLW  0C
02CC:  MOVWF  4E
02CD:  MOVLW  01
02CE:  MOVWF  4F
02CF:  MOVLW  06
02D0:  MOVWF  50
....................                              // These bytes need to be sent to the LCD 
....................                              // to start it up. 
....................     
....................  
....................    lcd_output_enable(0); 
02D1:  BCF    03.6
02D2:  BCF    09.0
02D3:  BSF    03.5
02D4:  BCF    09.0
....................    lcd_output_rs(0); 
02D5:  BCF    03.5
02D6:  BCF    09.1
02D7:  BSF    03.5
02D8:  BCF    09.1
....................    lcd_output_rw(0); 
02D9:  BCF    03.5
02DA:  BCF    09.2
02DB:  BSF    03.5
02DC:  BCF    09.2
....................  
....................  #if defined(__PCB__) 
....................    set_tris_lcd(LCD_OUTPUT_MAP); 
....................  #else 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    output_drive(LCD_DATA4); 
02DD:  BCF    03.5
02DE:  BCF    31.0
02DF:  MOVF   31,W
02E0:  BSF    03.5
02E1:  MOVWF  07
....................    output_drive(LCD_DATA5); 
02E2:  BCF    03.5
02E3:  BCF    31.1
02E4:  MOVF   31,W
02E5:  BSF    03.5
02E6:  MOVWF  07
....................    output_drive(LCD_DATA6); 
02E7:  BCF    03.5
02E8:  BCF    31.2
02E9:  MOVF   31,W
02EA:  BSF    03.5
02EB:  MOVWF  07
....................    output_drive(LCD_DATA7); 
02EC:  BCF    03.5
02ED:  BCF    31.3
02EE:  MOVF   31,W
02EF:  BSF    03.5
02F0:  MOVWF  07
....................   #else 
....................    lcdtris.data = 0x0; 
....................   #endif 
....................    lcd_enable_tris(); 
02F1:  BCF    09.0
....................    lcd_rs_tris(); 
02F2:  BCF    09.1
....................    lcd_rw_tris(); 
02F3:  BCF    09.2
....................  #endif 
....................      
....................    delay_ms(15); 
02F4:  MOVLW  0F
02F5:  BCF    03.5
02F6:  BSF    03.6
02F7:  MOVWF  51
02F8:  BCF    03.6
02F9:  CALL   132
....................    for(i=1;i<=3;++i) 
02FA:  MOVLW  01
02FB:  BSF    03.6
02FC:  MOVWF  4C
02FD:  MOVF   4C,W
02FE:  SUBLW  03
02FF:  BTFSS  03.0
0300:  GOTO   351
....................    { 
....................        lcd_send_nibble(3); 
0301:  MOVLW  03
0302:  MOVWF  58
....................        delay_ms(5); 
*
0348:  MOVLW  05
0349:  BCF    03.5
034A:  BSF    03.6
034B:  MOVWF  51
034C:  BCF    03.6
034D:  CALL   132
034E:  BSF    03.6
034F:  INCF   4C,F
0350:  GOTO   2FD
....................    } 
....................     
....................    lcd_send_nibble(2); 
0351:  MOVLW  02
0352:  MOVWF  58
....................    delay_ms(5); 
*
0398:  MOVLW  05
0399:  BCF    03.5
039A:  BSF    03.6
039B:  MOVWF  51
039C:  BCF    03.6
039D:  CALL   132
....................    for(i=0;i<=3;++i) 
039E:  BSF    03.6
039F:  CLRF   4C
03A0:  MOVF   4C,W
03A1:  SUBLW  03
03A2:  BTFSS  03.0
03A3:  GOTO   3B2
....................       lcd_send_byte(0,LCD_INIT_STRING[i]); 
03A4:  MOVLW  4D
03A5:  ADDWF  4C,W
03A6:  MOVWF  04
03A7:  BSF    03.7
03A8:  MOVF   00,W
03A9:  MOVWF  51
03AA:  CLRF   55
03AB:  MOVF   51,W
03AC:  MOVWF  56
03AD:  BCF    03.6
03AE:  CALL   146
....................  
....................   #if defined(LCD_EXTENDED_NEWLINE) 
03AF:  BSF    03.6
03B0:  INCF   4C,F
03B1:  GOTO   3A0
03B2:  BCF    03.6
03B3:  BCF    0A.3
03B4:  BSF    0A.4
03B5:  GOTO   296 (RETURN)
....................    g_LcdX = 0; 
....................    g_LcdY = 0; 
....................   #endif 
.................... } 
....................  
.................... void lcd_gotoxy(unsigned int8 x, unsigned int8 y) 
.................... { 
....................    unsigned int8 address; 
....................     
....................    if(y!=1) 
03B6:  BSF    03.6
03B7:  DECFSZ 52,W
03B8:  GOTO   3BA
03B9:  GOTO   3BD
....................       address=LCD_LINE_TWO; 
03BA:  MOVLW  40
03BB:  MOVWF  53
03BC:  GOTO   3BE
....................    else 
....................       address=0; 
03BD:  CLRF   53
....................       
....................    address+=x-1; 
03BE:  MOVLW  01
03BF:  SUBWF  51,W
03C0:  ADDWF  53,F
....................    lcd_send_byte(0,0x80|address); 
03C1:  MOVF   53,W
03C2:  IORLW  80
03C3:  MOVWF  54
03C4:  CLRF   55
03C5:  MOVF   54,W
03C6:  MOVWF  56
03C7:  BCF    03.6
03C8:  CALL   146
....................  
....................   #if defined(LCD_EXTENDED_NEWLINE) 
03C9:  RETURN
....................    g_LcdX = x - 1; 
....................    g_LcdY = y - 1; 
....................   #endif 
.................... } 
....................  
.................... void lcd_putc(char c) 
.................... { 
....................    switch (c) 
03CA:  BSF    03.6
03CB:  MOVF   50,W
03CC:  XORLW  07
03CD:  BCF    03.6
03CE:  BTFSC  03.2
03CF:  GOTO   3DA
03D0:  XORLW  0B
03D1:  BTFSC  03.2
03D2:  GOTO   3E1
03D3:  XORLW  06
03D4:  BTFSC  03.2
03D5:  GOTO   3ED
03D6:  XORLW  02
03D7:  BTFSC  03.2
03D8:  GOTO   3F5
03D9:  GOTO   3FC
....................    { 
....................       case '\a'   :  lcd_gotoxy(1,1);     break; 
03DA:  MOVLW  01
03DB:  BSF    03.6
03DC:  MOVWF  51
03DD:  MOVWF  52
03DE:  BCF    03.6
03DF:  CALL   3B6
03E0:  GOTO   403
....................  
....................       case '\f'   :  lcd_send_byte(0,1); 
03E1:  BSF    03.6
03E2:  CLRF   55
03E3:  MOVLW  01
03E4:  MOVWF  56
03E5:  BCF    03.6
03E6:  CALL   146
....................                      delay_ms(2); 
03E7:  MOVLW  02
03E8:  BSF    03.6
03E9:  MOVWF  51
03EA:  BCF    03.6
03EB:  CALL   132
....................                     #if defined(LCD_EXTENDED_NEWLINE) 
....................                      g_LcdX = 0; 
....................                      g_LcdY = 0; 
....................                     #endif 
....................                      break; 
03EC:  GOTO   403
....................  
....................      #if defined(LCD_EXTENDED_NEWLINE) 
....................       case '\r'   :  lcd_gotoxy(1, g_LcdY+1);   break; 
....................       case '\n'   : 
....................          while (g_LcdX++ < LCD_LINE_LENGTH) 
....................          { 
....................             lcd_send_byte(1, ' '); 
....................          } 
....................          lcd_gotoxy(1, g_LcdY+2); 
....................          break; 
....................      #else 
....................       case '\n'   : lcd_gotoxy(1,2);        break; 
03ED:  MOVLW  01
03EE:  BSF    03.6
03EF:  MOVWF  51
03F0:  MOVLW  02
03F1:  MOVWF  52
03F2:  BCF    03.6
03F3:  CALL   3B6
03F4:  GOTO   403
....................      #endif 
....................       
....................       case '\b'   : lcd_send_byte(0,0x10);  break; 
03F5:  BSF    03.6
03F6:  CLRF   55
03F7:  MOVLW  10
03F8:  MOVWF  56
03F9:  BCF    03.6
03FA:  CALL   146
03FB:  GOTO   403
....................       
....................      #if defined(LCD_EXTENDED_NEWLINE) 
....................       default     :  
....................          if (g_LcdX < LCD_LINE_LENGTH) 
....................          { 
....................             lcd_send_byte(1, c); 
....................             g_LcdX++; 
....................          } 
....................          break; 
....................      #else 
....................       default     : lcd_send_byte(1,c);     break; 
03FC:  MOVLW  01
03FD:  BSF    03.6
03FE:  MOVWF  55
03FF:  MOVF   50,W
0400:  MOVWF  56
0401:  BCF    03.6
0402:  CALL   146
....................      #endif 
....................    } 
0403:  RETURN
.................... } 
....................   
.................... char lcd_getc(unsigned int8 x, unsigned int8 y) 
.................... { 
....................    char value; 
....................  
....................    lcd_gotoxy(x,y); 
....................    while ( bit_test(lcd_read_byte(),7) ); // wait until busy flag is low 
....................    lcd_output_rs(1); 
....................    value = lcd_read_byte(); 
....................    lcd_output_rs(0); 
....................     
....................    return(value); 
.................... } 
....................  
.................... // write a custom character to the ram 
.................... // which is 0-7 and specifies which character array we are modifying. 
.................... // ptr points to an array of 8 bytes, where each byte is the next row of 
.................... //    pixels.  only bits 0-4 are used.  the last row is the cursor row, and 
.................... //    usually you will want to leave this byte 0x00. 
.................... void lcd_set_cgram_char(unsigned int8 which, unsigned int8 *ptr) 
.................... { 
....................    unsigned int i; 
....................  
....................    which <<= 3; 
....................    which &= 0x38; 
....................  
....................    lcd_send_byte(0, 0x40 | which);  //set cgram address 
....................  
....................    for(i=0; i<8; i++) 
....................    { 
....................       lcd_send_byte(1, *ptr++); 
....................    } 
....................    
....................    #if defined(LCD_EXTENDED_NEWLINE) 
....................     lcd_gotoxy(g_LcdX+1, g_LcdY+1);  //set ddram address 
....................    #endif 
.................... } 
....................  
.................... void lcd_cursor_on(int1 on) 
.................... { 
....................    if (on) 
....................    { 
....................       lcd_send_byte(0,0x0F);           //turn LCD cursor ON 
....................    } 
....................    else 
....................    { 
....................       lcd_send_byte(0,0x0C);           //turn LCD cursor OFF 
....................    } 
.................... } 
....................  
.................... #endif 
....................  
.................... #BIT TMR1IF = 0x0C.0 //bit thu 0 (TMR1IF) cua PIR1 
....................  
.................... #INCLUDE <khaibaobien.c> // VARIABLE. 
.................... UNSIGNED INT16 KQADC,AN0, AN1; 
.................... UNSIGNED INT8 CONFIG_FUN=0, ID_NODE = 0, STT_DEVICE=0, STT_SENSOR=0; 
.................... UNSIGNED INT8 VT=0, KYTU=0;// KYTU[30],  
.................... UNSIGNED INT8 ID_NODE_NHAN, ID_DEVICE_NHAN, TT_DEVICE_NHAN; 
.................... //UNSIGNED INT8 ID_SENSOR_NHAN, TT_SENSOR_NHAN; 
.................... CHAR KYTUCHAR[20]="HIHI"; 
*
1134:  MOVLW  48
1135:  MOVWF  41
1136:  MOVLW  49
1137:  MOVWF  42
1138:  MOVLW  48
1139:  MOVWF  43
113A:  MOVLW  49
113B:  MOVWF  44
113C:  CLRF   45
.................... //CHAR *DATA_NHANDUOC[]={"IDGW","IDNODE","COMMAN","DATA"}; 
.................... INT1 TTNHAN = 0, TT_CONFIG=0, TT_CONTROL=0,TT_CONFIG_DONE=0, TT_FUN=0, TT_STT=0; 
.................... INT1 TT_DEVICE[8]={0, 1, 1, 0, 1, 0, 1, 1}; 
113D:  MOVLW  D6
113E:  MOVWF  56
.................... INT1 TT_SENSOR[8]={1, 1, 1, 1, 0, 0, 0, 0}; 
113F:  MOVLW  0F
1140:  MOVWF  57
.................... CHAR *TT_DEVICE_CHAR[]="00000000"; 
1141:  MOVLW  30
1142:  MOVWF  5A
1143:  MOVWF  5B
1144:  MOVWF  5C
1145:  MOVWF  5D
1146:  MOVWF  5E
1147:  MOVWF  5F
1148:  MOVWF  60
1149:  MOVWF  61
114A:  CLRF   62
114B:  CLRF   59
114C:  MOVLW  5A
114D:  MOVWF  58
.................... CHAR *PACKAGE_NHIETDO[]={"*","ID_GW", "ID_NODE","LENGHT", "S_S" ,"TT_cambien","#"}; 
114E:  MOVLW  2A
114F:  BSF    03.5
1150:  MOVWF  20
1151:  CLRF   21
1152:  MOVLW  49
1153:  MOVWF  22
1154:  MOVLW  44
1155:  MOVWF  23
1156:  MOVLW  5F
1157:  MOVWF  24
1158:  MOVLW  47
1159:  MOVWF  25
115A:  MOVLW  57
115B:  MOVWF  26
115C:  CLRF   27
115D:  MOVLW  49
115E:  MOVWF  28
115F:  MOVLW  44
1160:  MOVWF  29
1161:  MOVLW  5F
1162:  MOVWF  2A
1163:  MOVLW  4E
1164:  MOVWF  2B
1165:  MOVLW  4F
1166:  MOVWF  2C
1167:  MOVLW  44
1168:  MOVWF  2D
1169:  MOVLW  45
116A:  MOVWF  2E
116B:  CLRF   2F
116C:  MOVLW  4C
116D:  MOVWF  30
116E:  MOVLW  45
116F:  MOVWF  31
1170:  MOVLW  4E
1171:  MOVWF  32
1172:  MOVLW  47
1173:  MOVWF  33
1174:  MOVLW  48
1175:  MOVWF  34
1176:  MOVLW  54
1177:  MOVWF  35
1178:  CLRF   36
1179:  MOVLW  53
117A:  MOVWF  37
117B:  MOVLW  5F
117C:  MOVWF  38
117D:  MOVLW  53
117E:  MOVWF  39
117F:  CLRF   3A
1180:  MOVLW  54
1181:  MOVWF  3B
1182:  MOVWF  3C
1183:  MOVLW  5F
1184:  MOVWF  3D
1185:  MOVLW  63
1186:  MOVWF  3E
1187:  MOVLW  61
1188:  MOVWF  3F
1189:  MOVLW  6D
118A:  MOVWF  40
118B:  MOVLW  62
118C:  MOVWF  41
118D:  MOVLW  69
118E:  MOVWF  42
118F:  MOVLW  65
1190:  MOVWF  43
1191:  MOVLW  6E
1192:  MOVWF  44
1193:  CLRF   45
1194:  MOVLW  23
1195:  MOVWF  46
1196:  CLRF   47
1197:  BCF    03.5
1198:  CLRF   64
1199:  MOVLW  A0
119A:  MOVWF  63
119B:  CLRF   66
119C:  MOVLW  A2
119D:  MOVWF  65
119E:  CLRF   68
119F:  MOVLW  A8
11A0:  MOVWF  67
11A1:  CLRF   6A
11A2:  MOVLW  B0
11A3:  MOVWF  69
11A4:  CLRF   6C
11A5:  MOVLW  B7
11A6:  MOVWF  6B
11A7:  CLRF   6E
11A8:  MOVLW  BB
11A9:  MOVWF  6D
11AA:  CLRF   70
11AB:  MOVLW  C6
11AC:  MOVWF  6F
....................  
.................... CHAR *PACKAGE_CONFIG[]={"*","ID_GW" ,"ID_NODE", "LENGHT","C_F", "DEVICE1234","SENSOR1234","#"}; 
11AD:  MOVLW  2A
11AE:  BSF    03.6
11AF:  MOVWF  10
11B0:  CLRF   11
11B1:  MOVLW  49
11B2:  MOVWF  12
11B3:  MOVLW  44
11B4:  MOVWF  13
11B5:  MOVLW  5F
11B6:  MOVWF  14
11B7:  MOVLW  47
11B8:  MOVWF  15
11B9:  MOVLW  57
11BA:  MOVWF  16
11BB:  CLRF   17
11BC:  MOVLW  49
11BD:  MOVWF  18
11BE:  MOVLW  44
11BF:  MOVWF  19
11C0:  MOVLW  5F
11C1:  MOVWF  1A
11C2:  MOVLW  4E
11C3:  MOVWF  1B
11C4:  MOVLW  4F
11C5:  MOVWF  1C
11C6:  MOVLW  44
11C7:  MOVWF  1D
11C8:  MOVLW  45
11C9:  MOVWF  1E
11CA:  CLRF   1F
11CB:  MOVLW  4C
11CC:  MOVWF  20
11CD:  MOVLW  45
11CE:  MOVWF  21
11CF:  MOVLW  4E
11D0:  MOVWF  22
11D1:  MOVLW  47
11D2:  MOVWF  23
11D3:  MOVLW  48
11D4:  MOVWF  24
11D5:  MOVLW  54
11D6:  MOVWF  25
11D7:  CLRF   26
11D8:  MOVLW  43
11D9:  MOVWF  27
11DA:  MOVLW  5F
11DB:  MOVWF  28
11DC:  MOVLW  46
11DD:  MOVWF  29
11DE:  CLRF   2A
11DF:  MOVLW  44
11E0:  MOVWF  2B
11E1:  MOVLW  45
11E2:  MOVWF  2C
11E3:  MOVLW  56
11E4:  MOVWF  2D
11E5:  MOVLW  49
11E6:  MOVWF  2E
11E7:  MOVLW  43
11E8:  MOVWF  2F
11E9:  MOVLW  45
11EA:  MOVWF  30
11EB:  MOVLW  31
11EC:  MOVWF  31
11ED:  MOVLW  32
11EE:  MOVWF  32
11EF:  MOVLW  33
11F0:  MOVWF  33
11F1:  MOVLW  34
11F2:  MOVWF  34
11F3:  CLRF   35
11F4:  MOVLW  53
11F5:  MOVWF  36
11F6:  MOVLW  45
11F7:  MOVWF  37
11F8:  MOVLW  4E
11F9:  MOVWF  38
11FA:  MOVLW  53
11FB:  MOVWF  39
11FC:  MOVLW  4F
11FD:  MOVWF  3A
11FE:  MOVLW  52
11FF:  MOVWF  3B
1200:  MOVLW  31
1201:  MOVWF  3C
1202:  MOVLW  32
1203:  MOVWF  3D
1204:  MOVLW  33
1205:  MOVWF  3E
1206:  MOVLW  34
1207:  MOVWF  3F
1208:  CLRF   40
1209:  MOVLW  23
120A:  MOVWF  41
120B:  CLRF   42
120C:  MOVLW  01
120D:  BSF    03.5
120E:  BCF    03.6
120F:  MOVWF  49
1210:  MOVLW  10
1211:  MOVWF  48
1212:  MOVLW  01
1213:  MOVWF  4B
1214:  MOVLW  12
1215:  MOVWF  4A
1216:  MOVLW  01
1217:  MOVWF  4D
1218:  MOVLW  18
1219:  MOVWF  4C
121A:  MOVLW  01
121B:  MOVWF  4F
121C:  MOVLW  20
121D:  MOVWF  4E
121E:  MOVLW  01
121F:  MOVWF  51
1220:  MOVLW  27
1221:  MOVWF  50
1222:  MOVLW  01
1223:  MOVWF  53
1224:  MOVLW  2B
1225:  MOVWF  52
1226:  MOVLW  01
1227:  MOVWF  55
1228:  MOVLW  36
1229:  MOVWF  54
122A:  MOVLW  01
122B:  MOVWF  57
122C:  MOVLW  41
122D:  MOVWF  56
....................  
.................... CHAR *ID_[]="00"; 
122E:  MOVLW  30
122F:  MOVWF  73
1230:  MOVWF  74
1231:  CLRF   75
1232:  CLRF   72
1233:  MOVLW  73
1234:  MOVWF  71
.................... //CHAR *ID_GW[]= "0000"; 
.................... UNSIGNED INT8 ID_GATEWAY[4] = {0,0,0,0}; 
1235:  CLRF   7B
1236:  CLRF   7C
1237:  CLRF   7D
1238:  CLRF   7E
.................... CHAR *TEMP_CHAR[]="00"; 
1239:  MOVLW  30
123A:  MOVWF  5A
123B:  MOVWF  5B
123C:  CLRF   5C
123D:  CLRF   59
123E:  MOVLW  DA
123F:  MOVWF  58
.................... CHAR *TEMP_CHAR2[]="00000000";  
1240:  MOVLW  30
1241:  MOVWF  5F
1242:  MOVWF  60
1243:  MOVWF  61
1244:  MOVWF  62
1245:  MOVWF  63
1246:  MOVWF  64
1247:  MOVWF  65
1248:  MOVWF  66
1249:  CLRF   67
124A:  CLRF   5E
124B:  MOVLW  DF
124C:  MOVWF  5D
.................... CHAR *TEMP_CHAR3[]="0000";  
124D:  MOVLW  30
124E:  MOVWF  6A
124F:  MOVWF  6B
1250:  MOVWF  6C
1251:  MOVWF  6D
1252:  CLRF   6E
1253:  CLRF   69
1254:  MOVLW  EA
1255:  MOVWF  68
.................... UNSIGNED INT8 LEN_PACKAGES = 0; 
.................... CHAR NHIETDO1[]="27"; 
1256:  MOVLW  32
1257:  BCF    03.5
1258:  BSF    03.6
1259:  MOVWF  43
125A:  MOVLW  37
125B:  MOVWF  44
125C:  CLRF   45
.................... CHAR NHIETDO2[]="27"; 
125D:  MOVLW  32
125E:  MOVWF  46
125F:  MOVLW  37
1260:  MOVWF  47
1261:  CLRF   48
....................  
....................  
.................... //#INCLUDE <CONFIG_NODE.C> // CU HINH NODE. 
.................... #INCLUDE <config_1.C> // CU HINH NODE. 
....................  
.................... //--------------------------------------------------------------------// 
.................... VOID CHON_ID() 
.................... { 
....................    // TT_CONFIG_DONE; 
....................    TT_CONFIG_DONE = 0; 
*
0807:  BCF    55.3
....................    TT_STT = 1; 
0808:  BSF    55.5
....................    LCD_GOTOXY (1, 2) ; 
0809:  MOVLW  01
080A:  BSF    03.6
080B:  MOVWF  51
080C:  MOVLW  02
080D:  MOVWF  52
080E:  BCF    0A.3
080F:  BCF    03.6
0810:  CALL   3B6
0811:  BSF    0A.3
....................    DELAY_MS (10); 
0812:  MOVLW  0A
0813:  BSF    03.6
0814:  MOVWF  51
0815:  BCF    0A.3
0816:  BCF    03.6
0817:  CALL   132
0818:  BSF    0A.3
....................    PRINTF (LCD_PUTC, "ID:             "); 
0819:  MOVLW  69
081A:  BSF    03.6
081B:  MOVWF  0D
081C:  MOVLW  00
081D:  MOVWF  0F
081E:  BCF    0A.3
081F:  BCF    03.6
0820:  CALL   404
0821:  BSF    0A.3
....................  
....................    WHILE (TT_STT) 
0822:  BTFSS  55.5
0823:  GOTO   088
....................    { 
....................       IF (INPUT (BT2_PIN) == 0) //NEU NUT BAM DUOC BAM 
0824:  BSF    03.5
0825:  BSF    06.2
0826:  BCF    03.5
0827:  BTFSC  06.2
0828:  GOTO   087
....................       { 
....................          ID_NODE ++; 
0829:  INCF   39,F
....................          IF (ID_NODE > 15) ID_NODE = 0; 
082A:  MOVF   39,W
082B:  SUBLW  0F
082C:  BTFSS  03.0
082D:  CLRF   39
....................          DELAY_MS (300); 
082E:  MOVLW  02
082F:  BSF    03.6
0830:  MOVWF  4C
0831:  MOVLW  96
0832:  MOVWF  51
0833:  BCF    0A.3
0834:  BCF    03.6
0835:  CALL   132
0836:  BSF    0A.3
0837:  BSF    03.6
0838:  DECFSZ 4C,F
0839:  GOTO   031
....................          ITOA (ID_NODE, 10, ID_); 
083A:  CLRF   51
083B:  CLRF   50
083C:  CLRF   4F
083D:  BCF    03.6
083E:  MOVF   39,W
083F:  BSF    03.6
0840:  MOVWF  4E
0841:  MOVLW  0A
0842:  MOVWF  52
0843:  CLRF   54
0844:  MOVLW  71
0845:  MOVWF  53
0846:  BCF    0A.3
0847:  BCF    03.6
0848:  CALL   454
0849:  BSF    0A.3
....................          LCD_GOTOXY (9, 2) ; 
084A:  MOVLW  09
084B:  BSF    03.6
084C:  MOVWF  51
084D:  MOVLW  02
084E:  MOVWF  52
084F:  BCF    0A.3
0850:  BCF    03.6
0851:  CALL   3B6
0852:  BSF    0A.3
....................          DELAY_MS (10); 
0853:  MOVLW  0A
0854:  BSF    03.6
0855:  MOVWF  51
0856:  BCF    0A.3
0857:  BCF    03.6
0858:  CALL   132
0859:  BSF    0A.3
....................          PRINTF (LCD_PUTC, ID_); 
085A:  MOVLW  71
085B:  MOVWF  04
085C:  BCF    03.7
....................          DELAY_MS (1); 
*
087B:  MOVLW  01
087C:  BSF    03.6
087D:  MOVWF  51
087E:  BCF    0A.3
087F:  BCF    03.6
0880:  CALL   132
0881:  BSF    0A.3
....................          OUTPUT_TOGGLE (PIN_D0); 
0882:  BSF    03.5
0883:  BCF    08.0
0884:  MOVLW  01
0885:  BCF    03.5
0886:  XORWF  08,F
....................       } 
0887:  GOTO   022
....................    } 
.................... } 
....................  
.................... VOID CONFIG_DEVICE() 
.................... { 
....................    TT_CONFIG_DONE = 0; 
*
0889:  BCF    55.3
....................    TT_STT = 1; 
088A:  BSF    55.5
....................    LCD_GOTOXY (1, 2) ; 
088B:  MOVLW  01
088C:  BSF    03.6
088D:  MOVWF  51
088E:  MOVLW  02
088F:  MOVWF  52
0890:  BCF    0A.3
0891:  BCF    03.6
0892:  CALL   3B6
0893:  BSF    0A.3
....................    DELAY_MS (10); 
0894:  MOVLW  0A
0895:  BSF    03.6
0896:  MOVWF  51
0897:  BCF    0A.3
0898:  BCF    03.6
0899:  CALL   132
089A:  BSF    0A.3
....................    PRINTF (LCD_PUTC, "DEVICE:           "); 
089B:  MOVLW  72
089C:  BSF    03.6
089D:  MOVWF  0D
089E:  MOVLW  00
089F:  MOVWF  0F
08A0:  BCF    0A.3
08A1:  BCF    03.6
08A2:  CALL   404
08A3:  BSF    0A.3
....................  
....................    WHILE (TT_STT) 
08A4:  BTFSS  55.5
08A5:  GOTO   1E1
....................    { 
....................       IF (!INPUT (BT2_PIN)) //NEU NUT BAM DUOC BAM 
08A6:  BSF    03.5
08A7:  BSF    06.2
08A8:  BCF    03.5
08A9:  BTFSC  06.2
08AA:  GOTO   16B
....................       { 
....................          STT_DEVICE ++; 
08AB:  INCF   3A,F
....................          IF (STT_DEVICE > 7) STT_DEVICE = 0; 
08AC:  MOVF   3A,W
08AD:  SUBLW  07
08AE:  BTFSS  03.0
08AF:  CLRF   3A
....................          DELAY_MS (300); 
08B0:  MOVLW  02
08B1:  BSF    03.6
08B2:  MOVWF  4C
08B3:  MOVLW  96
08B4:  MOVWF  51
08B5:  BCF    0A.3
08B6:  BCF    03.6
08B7:  CALL   132
08B8:  BSF    0A.3
08B9:  BSF    03.6
08BA:  DECFSZ 4C,F
08BB:  GOTO   0B3
....................          ITOA (STT_DEVICE, 10, TEMP_CHAR); 
08BC:  CLRF   51
08BD:  CLRF   50
08BE:  CLRF   4F
08BF:  BCF    03.6
08C0:  MOVF   3A,W
08C1:  BSF    03.6
08C2:  MOVWF  4E
08C3:  MOVLW  0A
08C4:  MOVWF  52
08C5:  CLRF   54
08C6:  MOVLW  D8
08C7:  MOVWF  53
08C8:  BCF    0A.3
08C9:  BCF    03.6
08CA:  CALL   454
08CB:  BSF    0A.3
....................          LCD_GOTOXY (9, 2) ; 
08CC:  MOVLW  09
08CD:  BSF    03.6
08CE:  MOVWF  51
08CF:  MOVLW  02
08D0:  MOVWF  52
08D1:  BCF    0A.3
08D2:  BCF    03.6
08D3:  CALL   3B6
08D4:  BSF    0A.3
....................          DELAY_MS (10); 
08D5:  MOVLW  0A
08D6:  BSF    03.6
08D7:  MOVWF  51
08D8:  BCF    0A.3
08D9:  BCF    03.6
08DA:  CALL   132
08DB:  BSF    0A.3
....................          PRINTF (LCD_PUTC, TEMP_CHAR); 
08DC:  MOVLW  D8
08DD:  MOVWF  04
08DE:  BCF    03.7
....................          DELAY_MS (1); 
*
08FD:  MOVLW  01
08FE:  BSF    03.6
08FF:  MOVWF  51
0900:  BCF    0A.3
0901:  BCF    03.6
0902:  CALL   132
0903:  BSF    0A.3
....................          PRINTF (LCD_PUTC, " : "); 
0904:  MOVLW  20
0905:  BSF    03.6
0906:  MOVWF  50
0907:  BCF    0A.3
0908:  BCF    03.6
0909:  CALL   3CA
090A:  BSF    0A.3
090B:  MOVLW  3A
090C:  BSF    03.6
090D:  MOVWF  50
090E:  BCF    0A.3
090F:  BCF    03.6
0910:  CALL   3CA
0911:  BSF    0A.3
0912:  MOVLW  20
0913:  BSF    03.6
0914:  MOVWF  50
0915:  BCF    0A.3
0916:  BCF    03.6
0917:  CALL   3CA
0918:  BSF    0A.3
....................          DELAY_MS (1); 
0919:  MOVLW  01
091A:  BSF    03.6
091B:  MOVWF  51
091C:  BCF    0A.3
091D:  BCF    03.6
091E:  CALL   132
091F:  BSF    0A.3
....................          ITOA (TT_DEVICE[STT_DEVICE], 10, TEMP_CHAR); 
0920:  MOVF   3A,W
0921:  BSF    03.6
0922:  MOVWF  4E
0923:  CLRF   50
0924:  MOVLW  56
0925:  MOVWF  4F
0926:  BCF    0A.3
0927:  BCF    03.6
0928:  CALL   6A4
0929:  BSF    0A.3
092A:  MOVLW  00
092B:  BTFSC  78.0
092C:  MOVLW  01
092D:  BSF    03.6
092E:  MOVWF  4C
092F:  CLRF   51
0930:  CLRF   50
0931:  CLRF   4F
0932:  MOVF   4C,W
0933:  MOVWF  4E
0934:  MOVLW  0A
0935:  MOVWF  52
0936:  CLRF   54
0937:  MOVLW  D8
0938:  MOVWF  53
0939:  BCF    0A.3
093A:  BCF    03.6
093B:  CALL   454
093C:  BSF    0A.3
....................          PRINTF (LCD_PUTC, TEMP_CHAR); 
093D:  MOVLW  D8
093E:  MOVWF  04
093F:  BCF    03.7
....................          DELAY_MS (1); 
*
095E:  MOVLW  01
095F:  BSF    03.6
0960:  MOVWF  51
0961:  BCF    0A.3
0962:  BCF    03.6
0963:  CALL   132
0964:  BSF    0A.3
....................          OUTPUT_TOGGLE (PIN_D0); 
0965:  BSF    03.5
0966:  BCF    08.0
0967:  MOVLW  01
0968:  BCF    03.5
0969:  XORWF  08,F
....................       } 
096A:  GOTO   1E0
....................  
....................       ELSE IF (!INPUT (BT3_PIN)) 
096B:  BSF    03.5
096C:  BSF    06.3
096D:  BCF    03.5
096E:  BTFSC  06.3
096F:  GOTO   1E0
....................       { 
....................          TT_DEVICE[STT_DEVICE] = ~TT_DEVICE[STT_DEVICE]; 
0970:  MOVF   3A,W
0971:  BSF    03.6
0972:  MOVWF  4E
0973:  CLRF   50
0974:  MOVLW  56
0975:  MOVWF  4F
0976:  BCF    0A.3
0977:  BCF    03.6
0978:  CALL   6A4
0979:  BSF    0A.3
097A:  MOVLW  00
097B:  BTFSS  78.0
097C:  MOVLW  01
097D:  BSF    03.6
097E:  MOVWF  4C
097F:  BCF    03.6
0980:  MOVF   3A,W
0981:  BSF    03.6
0982:  MOVWF  4D
0983:  MOVF   4C,W
0984:  MOVWF  4E
0985:  CLRF   50
0986:  MOVLW  56
0987:  MOVWF  4F
0988:  BCF    0A.3
0989:  BCF    03.6
098A:  CALL   6BD
098B:  BSF    0A.3
....................          LCD_GOTOXY (13, 2) ; 
098C:  MOVLW  0D
098D:  BSF    03.6
098E:  MOVWF  51
098F:  MOVLW  02
0990:  MOVWF  52
0991:  BCF    0A.3
0992:  BCF    03.6
0993:  CALL   3B6
0994:  BSF    0A.3
....................          DELAY_MS (300); 
0995:  MOVLW  02
0996:  BSF    03.6
0997:  MOVWF  4C
0998:  MOVLW  96
0999:  MOVWF  51
099A:  BCF    0A.3
099B:  BCF    03.6
099C:  CALL   132
099D:  BSF    0A.3
099E:  BSF    03.6
099F:  DECFSZ 4C,F
09A0:  GOTO   198
....................          ITOA (TT_DEVICE[STT_DEVICE], 10, TEMP_CHAR); 
09A1:  BCF    03.6
09A2:  MOVF   3A,W
09A3:  BSF    03.6
09A4:  MOVWF  4E
09A5:  CLRF   50
09A6:  MOVLW  56
09A7:  MOVWF  4F
09A8:  BCF    0A.3
09A9:  BCF    03.6
09AA:  CALL   6A4
09AB:  BSF    0A.3
09AC:  MOVLW  00
09AD:  BTFSC  78.0
09AE:  MOVLW  01
09AF:  BSF    03.6
09B0:  MOVWF  4C
09B1:  CLRF   51
09B2:  CLRF   50
09B3:  CLRF   4F
09B4:  MOVF   4C,W
09B5:  MOVWF  4E
09B6:  MOVLW  0A
09B7:  MOVWF  52
09B8:  CLRF   54
09B9:  MOVLW  D8
09BA:  MOVWF  53
09BB:  BCF    0A.3
09BC:  BCF    03.6
09BD:  CALL   454
09BE:  BSF    0A.3
....................          PRINTF (LCD_PUTC, TEMP_CHAR); 
09BF:  MOVLW  D8
09C0:  MOVWF  04
09C1:  BCF    03.7
....................       } 
*
09E0:  GOTO   0A4
....................    } 
.................... } 
....................  
.................... VOID CONFIG_SENSOR () 
.................... { 
....................    TT_CONFIG_DONE = 0; 
*
09E2:  BCF    55.3
....................    TT_STT = 1; 
09E3:  BSF    55.5
....................    LCD_GOTOXY (1, 2) ; 
09E4:  MOVLW  01
09E5:  BSF    03.6
09E6:  MOVWF  51
09E7:  MOVLW  02
09E8:  MOVWF  52
09E9:  BCF    0A.3
09EA:  BCF    03.6
09EB:  CALL   3B6
09EC:  BSF    0A.3
....................    DELAY_MS (10);   
09ED:  MOVLW  0A
09EE:  BSF    03.6
09EF:  MOVWF  51
09F0:  BCF    0A.3
09F1:  BCF    03.6
09F2:  CALL   132
09F3:  BSF    0A.3
....................    PRINTF (LCD_PUTC, "SENSOR:         "); 
09F4:  MOVLW  7C
09F5:  BSF    03.6
09F6:  MOVWF  0D
09F7:  MOVLW  00
09F8:  MOVWF  0F
09F9:  BCF    0A.3
09FA:  BCF    03.6
09FB:  CALL   404
09FC:  BSF    0A.3
....................  
....................    WHILE (TT_STT) 
09FD:  BTFSS  55.5
09FE:  GOTO   33A
....................    { 
....................       IF (!INPUT (BT2_PIN)) //NEU NUT BAM DUOC BAM 
09FF:  BSF    03.5
0A00:  BSF    06.2
0A01:  BCF    03.5
0A02:  BTFSC  06.2
0A03:  GOTO   2C4
....................       { 
....................          STT_SENSOR ++; 
0A04:  INCF   3B,F
....................          IF (STT_SENSOR > 3) STT_SENSOR = 0; 
0A05:  MOVF   3B,W
0A06:  SUBLW  03
0A07:  BTFSS  03.0
0A08:  CLRF   3B
....................          DELAY_MS (300); 
0A09:  MOVLW  02
0A0A:  BSF    03.6
0A0B:  MOVWF  4C
0A0C:  MOVLW  96
0A0D:  MOVWF  51
0A0E:  BCF    0A.3
0A0F:  BCF    03.6
0A10:  CALL   132
0A11:  BSF    0A.3
0A12:  BSF    03.6
0A13:  DECFSZ 4C,F
0A14:  GOTO   20C
....................          ITOA (STT_SENSOR, 10, TEMP_CHAR); 
0A15:  CLRF   51
0A16:  CLRF   50
0A17:  CLRF   4F
0A18:  BCF    03.6
0A19:  MOVF   3B,W
0A1A:  BSF    03.6
0A1B:  MOVWF  4E
0A1C:  MOVLW  0A
0A1D:  MOVWF  52
0A1E:  CLRF   54
0A1F:  MOVLW  D8
0A20:  MOVWF  53
0A21:  BCF    0A.3
0A22:  BCF    03.6
0A23:  CALL   454
0A24:  BSF    0A.3
....................          LCD_GOTOXY (9, 2) ; 
0A25:  MOVLW  09
0A26:  BSF    03.6
0A27:  MOVWF  51
0A28:  MOVLW  02
0A29:  MOVWF  52
0A2A:  BCF    0A.3
0A2B:  BCF    03.6
0A2C:  CALL   3B6
0A2D:  BSF    0A.3
....................          DELAY_MS (10); 
0A2E:  MOVLW  0A
0A2F:  BSF    03.6
0A30:  MOVWF  51
0A31:  BCF    0A.3
0A32:  BCF    03.6
0A33:  CALL   132
0A34:  BSF    0A.3
....................          PRINTF (LCD_PUTC, TEMP_CHAR); 
0A35:  MOVLW  D8
0A36:  MOVWF  04
0A37:  BCF    03.7
....................          DELAY_MS (1); 
*
0A56:  MOVLW  01
0A57:  BSF    03.6
0A58:  MOVWF  51
0A59:  BCF    0A.3
0A5A:  BCF    03.6
0A5B:  CALL   132
0A5C:  BSF    0A.3
....................          PRINTF (LCD_PUTC, " : "); 
0A5D:  MOVLW  20
0A5E:  BSF    03.6
0A5F:  MOVWF  50
0A60:  BCF    0A.3
0A61:  BCF    03.6
0A62:  CALL   3CA
0A63:  BSF    0A.3
0A64:  MOVLW  3A
0A65:  BSF    03.6
0A66:  MOVWF  50
0A67:  BCF    0A.3
0A68:  BCF    03.6
0A69:  CALL   3CA
0A6A:  BSF    0A.3
0A6B:  MOVLW  20
0A6C:  BSF    03.6
0A6D:  MOVWF  50
0A6E:  BCF    0A.3
0A6F:  BCF    03.6
0A70:  CALL   3CA
0A71:  BSF    0A.3
....................          DELAY_MS (1); 
0A72:  MOVLW  01
0A73:  BSF    03.6
0A74:  MOVWF  51
0A75:  BCF    0A.3
0A76:  BCF    03.6
0A77:  CALL   132
0A78:  BSF    0A.3
....................          ITOA (TT_SENSOR[STT_SENSOR], 10, TEMP_CHAR); 
0A79:  MOVF   3B,W
0A7A:  BSF    03.6
0A7B:  MOVWF  4E
0A7C:  CLRF   50
0A7D:  MOVLW  57
0A7E:  MOVWF  4F
0A7F:  BCF    0A.3
0A80:  BCF    03.6
0A81:  CALL   6A4
0A82:  BSF    0A.3
0A83:  MOVLW  00
0A84:  BTFSC  78.0
0A85:  MOVLW  01
0A86:  BSF    03.6
0A87:  MOVWF  4C
0A88:  CLRF   51
0A89:  CLRF   50
0A8A:  CLRF   4F
0A8B:  MOVF   4C,W
0A8C:  MOVWF  4E
0A8D:  MOVLW  0A
0A8E:  MOVWF  52
0A8F:  CLRF   54
0A90:  MOVLW  D8
0A91:  MOVWF  53
0A92:  BCF    0A.3
0A93:  BCF    03.6
0A94:  CALL   454
0A95:  BSF    0A.3
....................          PRINTF (LCD_PUTC, TEMP_CHAR); 
0A96:  MOVLW  D8
0A97:  MOVWF  04
0A98:  BCF    03.7
....................          DELAY_MS (1); 
*
0AB7:  MOVLW  01
0AB8:  BSF    03.6
0AB9:  MOVWF  51
0ABA:  BCF    0A.3
0ABB:  BCF    03.6
0ABC:  CALL   132
0ABD:  BSF    0A.3
....................          OUTPUT_TOGGLE (PIN_D0); 
0ABE:  BSF    03.5
0ABF:  BCF    08.0
0AC0:  MOVLW  01
0AC1:  BCF    03.5
0AC2:  XORWF  08,F
....................       } 
0AC3:  GOTO   339
....................  
....................       ELSE IF (!INPUT (BT3_PIN)) 
0AC4:  BSF    03.5
0AC5:  BSF    06.3
0AC6:  BCF    03.5
0AC7:  BTFSC  06.3
0AC8:  GOTO   339
....................       { 
....................          TT_SENSOR[STT_SENSOR] = ~TT_SENSOR[STT_SENSOR]; 
0AC9:  MOVF   3B,W
0ACA:  BSF    03.6
0ACB:  MOVWF  4E
0ACC:  CLRF   50
0ACD:  MOVLW  57
0ACE:  MOVWF  4F
0ACF:  BCF    0A.3
0AD0:  BCF    03.6
0AD1:  CALL   6A4
0AD2:  BSF    0A.3
0AD3:  MOVLW  00
0AD4:  BTFSS  78.0
0AD5:  MOVLW  01
0AD6:  BSF    03.6
0AD7:  MOVWF  4C
0AD8:  BCF    03.6
0AD9:  MOVF   3B,W
0ADA:  BSF    03.6
0ADB:  MOVWF  4D
0ADC:  MOVF   4C,W
0ADD:  MOVWF  4E
0ADE:  CLRF   50
0ADF:  MOVLW  57
0AE0:  MOVWF  4F
0AE1:  BCF    0A.3
0AE2:  BCF    03.6
0AE3:  CALL   6BD
0AE4:  BSF    0A.3
....................          LCD_GOTOXY (13, 2) ; 
0AE5:  MOVLW  0D
0AE6:  BSF    03.6
0AE7:  MOVWF  51
0AE8:  MOVLW  02
0AE9:  MOVWF  52
0AEA:  BCF    0A.3
0AEB:  BCF    03.6
0AEC:  CALL   3B6
0AED:  BSF    0A.3
....................          DELAY_MS (300); 
0AEE:  MOVLW  02
0AEF:  BSF    03.6
0AF0:  MOVWF  4C
0AF1:  MOVLW  96
0AF2:  MOVWF  51
0AF3:  BCF    0A.3
0AF4:  BCF    03.6
0AF5:  CALL   132
0AF6:  BSF    0A.3
0AF7:  BSF    03.6
0AF8:  DECFSZ 4C,F
0AF9:  GOTO   2F1
....................          ITOA (TT_SENSOR[STT_SENSOR], 10, TEMP_CHAR); 
0AFA:  BCF    03.6
0AFB:  MOVF   3B,W
0AFC:  BSF    03.6
0AFD:  MOVWF  4E
0AFE:  CLRF   50
0AFF:  MOVLW  57
0B00:  MOVWF  4F
0B01:  BCF    0A.3
0B02:  BCF    03.6
0B03:  CALL   6A4
0B04:  BSF    0A.3
0B05:  MOVLW  00
0B06:  BTFSC  78.0
0B07:  MOVLW  01
0B08:  BSF    03.6
0B09:  MOVWF  4C
0B0A:  CLRF   51
0B0B:  CLRF   50
0B0C:  CLRF   4F
0B0D:  MOVF   4C,W
0B0E:  MOVWF  4E
0B0F:  MOVLW  0A
0B10:  MOVWF  52
0B11:  CLRF   54
0B12:  MOVLW  D8
0B13:  MOVWF  53
0B14:  BCF    0A.3
0B15:  BCF    03.6
0B16:  CALL   454
0B17:  BSF    0A.3
....................          PRINTF (LCD_PUTC, TEMP_CHAR); 
0B18:  MOVLW  D8
0B19:  MOVWF  04
0B1A:  BCF    03.7
....................       } 
*
0B39:  GOTO   1FD
....................    } 
.................... } 
....................  
.................... VOID NHAPID_GW() 
*
0B3B:  BSF    03.6
0B3C:  CLRF   4C
.................... { 
....................    UNSIGNED INT8 NUM = 0; 
....................    TEMP_CHAR = "0"; 
0B3D:  CLRF   4D
0B3E:  CLRF   4E
0B3F:  MOVLW  D8
0B40:  MOVWF  04
0B41:  BCF    03.7
0B42:  MOVF   4D,W
0B43:  ADDWF  04,F
0B44:  MOVF   4E,W
0B45:  BCF    0A.3
0B46:  BCF    03.6
0B47:  CALL   058
0B48:  BSF    0A.3
0B49:  MOVWF  00
0B4A:  IORLW  00
0B4B:  BTFSC  03.2
0B4C:  GOTO   352
0B4D:  BSF    03.6
0B4E:  INCF   4E,F
0B4F:  INCF   4D,F
0B50:  GOTO   33F
0B51:  BCF    03.6
....................    TT_CONFIG_DONE = 0; 
0B52:  BCF    55.3
....................    TT_STT = 1; 
0B53:  BSF    55.5
....................    LCD_GOTOXY (1, 2) ; 
0B54:  MOVLW  01
0B55:  BSF    03.6
0B56:  MOVWF  51
0B57:  MOVLW  02
0B58:  MOVWF  52
0B59:  BCF    0A.3
0B5A:  BCF    03.6
0B5B:  CALL   3B6
0B5C:  BSF    0A.3
....................    DELAY_MS (10); 
0B5D:  MOVLW  0A
0B5E:  BSF    03.6
0B5F:  MOVWF  51
0B60:  BCF    0A.3
0B61:  BCF    03.6
0B62:  CALL   132
0B63:  BSF    0A.3
....................    PRINTF (LCD_PUTC, "ID_GW:  0000 "); 
0B64:  MOVLW  85
0B65:  BSF    03.6
0B66:  MOVWF  0D
0B67:  MOVLW  00
0B68:  MOVWF  0F
0B69:  BCF    0A.3
0B6A:  BCF    03.6
0B6B:  CALL   404
0B6C:  BSF    0A.3
....................    LCD_GOTOXY (1, 1) ; 
0B6D:  MOVLW  01
0B6E:  BSF    03.6
0B6F:  MOVWF  51
0B70:  MOVWF  52
0B71:  BCF    0A.3
0B72:  BCF    03.6
0B73:  CALL   3B6
0B74:  BSF    0A.3
....................    PRINTF (LCD_PUTC, "        _    "); 
0B75:  MOVLW  8C
0B76:  BSF    03.6
0B77:  MOVWF  0D
0B78:  MOVLW  00
0B79:  MOVWF  0F
0B7A:  BCF    0A.3
0B7B:  BCF    03.6
0B7C:  CALL   404
0B7D:  BSF    0A.3
....................    //ID_GW = "1234";     
....................  
....................    WHILE (TT_STT) 
0B7E:  BTFSS  55.5
0B7F:  GOTO   439
....................    { 
....................       IF (!INPUT (BT2_PIN)) //NEU NUT BAM DUOC BAM 
0B80:  BSF    03.5
0B81:  BSF    06.2
0B82:  BCF    03.5
0B83:  BTFSC  06.2
0B84:  GOTO   3AA
....................       { 
....................           
....................          NUM++; 
0B85:  BSF    03.6
0B86:  INCF   4C,F
....................          NUM = NUM % 4; 
0B87:  MOVLW  03
0B88:  ANDWF  4C,F
....................          LCD_GOTOXY (5 + NUM, 1); 
0B89:  MOVLW  05
0B8A:  ADDWF  4C,W
0B8B:  MOVWF  4D
0B8C:  MOVWF  51
0B8D:  MOVLW  01
0B8E:  MOVWF  52
0B8F:  BCF    0A.3
0B90:  BCF    03.6
0B91:  CALL   3B6
0B92:  BSF    0A.3
....................          PRINTF (LCD_PUTC, "    _    "); 
0B93:  MOVLW  93
0B94:  BSF    03.6
0B95:  MOVWF  0D
0B96:  MOVLW  00
0B97:  MOVWF  0F
0B98:  BCF    0A.3
0B99:  BCF    03.6
0B9A:  CALL   404
0B9B:  BSF    0A.3
....................          DELAY_MS (300);  
0B9C:  MOVLW  02
0B9D:  BSF    03.6
0B9E:  MOVWF  4D
0B9F:  MOVLW  96
0BA0:  MOVWF  51
0BA1:  BCF    0A.3
0BA2:  BCF    03.6
0BA3:  CALL   132
0BA4:  BSF    0A.3
0BA5:  BSF    03.6
0BA6:  DECFSZ 4D,F
0BA7:  GOTO   39F
....................       } 
0BA8:  GOTO   437
0BA9:  BCF    03.6
....................  
....................       ELSE IF (!INPUT (BT3_PIN)) 
0BAA:  BSF    03.5
0BAB:  BSF    06.3
0BAC:  BCF    03.5
0BAD:  BTFSC  06.3
0BAE:  GOTO   438
....................       { 
....................          ID_GATEWAY[NUM]++; 
0BAF:  MOVLW  7B
0BB0:  BSF    03.6
0BB1:  ADDWF  4C,W
0BB2:  MOVWF  04
0BB3:  BCF    03.7
0BB4:  INCF   00,F
....................          ID_GATEWAY[NUM] = ID_GATEWAY[NUM] % 10; 
0BB5:  MOVLW  7B
0BB6:  ADDWF  4C,W
0BB7:  MOVWF  78
0BB8:  CLRF   7A
0BB9:  BTFSC  03.0
0BBA:  INCF   7A,F
0BBB:  MOVF   78,W
0BBC:  MOVWF  4D
0BBD:  MOVF   7A,W
0BBE:  MOVWF  4E
0BBF:  MOVLW  7B
0BC0:  ADDWF  4C,W
0BC1:  MOVWF  04
0BC2:  BCF    03.7
0BC3:  MOVF   00,W
0BC4:  MOVWF  50
0BC5:  MOVLW  0A
0BC6:  MOVWF  51
*
0BDB:  MOVF   77,W
0BDC:  MOVWF  4F
0BDD:  MOVF   4D,W
0BDE:  MOVWF  04
0BDF:  BCF    03.7
0BE0:  BTFSC  4E.0
0BE1:  BSF    03.7
0BE2:  MOVF   4F,W
0BE3:  MOVWF  00
....................          ITOA (ID_GATEWAY[NUM], 10, TEMP_CHAR); 
0BE4:  MOVLW  7B
0BE5:  ADDWF  4C,W
0BE6:  MOVWF  04
0BE7:  BCF    03.7
0BE8:  MOVF   00,W
0BE9:  MOVWF  4D
0BEA:  CLRF   51
0BEB:  CLRF   50
0BEC:  CLRF   4F
0BED:  MOVF   4D,W
0BEE:  MOVWF  4E
0BEF:  MOVLW  0A
0BF0:  MOVWF  52
0BF1:  CLRF   54
0BF2:  MOVLW  D8
0BF3:  MOVWF  53
0BF4:  BCF    0A.3
0BF5:  BCF    03.6
0BF6:  CALL   454
0BF7:  BSF    0A.3
....................          LCD_GOTOXY (9 + NUM, 2); 
0BF8:  MOVLW  09
0BF9:  BSF    03.6
0BFA:  ADDWF  4C,W
0BFB:  MOVWF  4D
0BFC:  MOVWF  51
0BFD:  MOVLW  02
0BFE:  MOVWF  52
0BFF:  BCF    0A.3
0C00:  BCF    03.6
0C01:  CALL   3B6
0C02:  BSF    0A.3
....................          DELAY_MS (10); 
0C03:  MOVLW  0A
0C04:  BSF    03.6
0C05:  MOVWF  51
0C06:  BCF    0A.3
0C07:  BCF    03.6
0C08:  CALL   132
0C09:  BSF    0A.3
....................          PRINTF (LCD_PUTC, TEMP_CHAR); 
0C0A:  MOVLW  D8
0C0B:  MOVWF  04
0C0C:  BCF    03.7
....................          DELAY_MS (300); 
*
0C2B:  MOVLW  02
0C2C:  BSF    03.6
0C2D:  MOVWF  4D
0C2E:  MOVLW  96
0C2F:  MOVWF  51
0C30:  BCF    0A.3
0C31:  BCF    03.6
0C32:  CALL   132
0C33:  BSF    0A.3
0C34:  BSF    03.6
0C35:  DECFSZ 4D,F
0C36:  GOTO   42E
0C37:  BCF    03.6
....................       } 
0C38:  GOTO   37E
....................    } 
.................... } 
....................  
.................... VOID BUTT_OKE() 
.................... { 
....................    TT_CONFIG_DONE = 0; 
*
010C:  BCF    03.5
010D:  BCF    03.6
010E:  BCF    55.3
....................    TT_FUN = 0; 
010F:  BCF    55.4
....................    TT_STT = 0; 
0110:  BCF    55.5
.................... } 
....................  
.................... VOID SELLECT_FUN() 
.................... { 
....................    TT_CONFIG_DONE = 0; 
*
0800:  BCF    55.3
....................  
....................    SWITCH (CONFIG_FUN) 
0801:  MOVF   38,W
0802:  ADDLW  FC
0803:  BTFSC  03.0
0804:  GOTO   439
0805:  ADDLW  04
0806:  GOTO   43C
....................    { 
....................       CASE 0: 
....................       CHON_ID (); 
....................       BREAK; 
*
0888:  GOTO   439
....................  
....................       CASE 1: 
....................       // CONFIG DEVICE 
....................       CONFIG_DEVICE (); 
....................       BREAK; 
*
09E1:  GOTO   439
....................  
....................       CASE 2: 
....................       CONFIG_SENSOR (); 
....................       BREAK; 
*
0B3A:  GOTO   439
....................  
....................       CASE 3: 
....................       NHAPID_GW (); 
....................       BREAK; 
....................    } 
*
0C39:  BCF    0A.3
0C3A:  BCF    0A.4
0C3B:  GOTO   77C (RETURN)
.................... } 
....................  
.................... VOID BUTT_FUN() 
.................... { 
....................    TT_FUN = 1; 
*
06DF:  BSF    55.4
....................    LCD_GOTOXY (1, 1) ; 
06E0:  MOVLW  01
06E1:  BSF    03.6
06E2:  MOVWF  51
06E3:  MOVWF  52
06E4:  BCF    03.6
06E5:  CALL   3B6
....................    DELAY_MS (10); 
06E6:  MOVLW  0A
06E7:  BSF    03.6
06E8:  MOVWF  51
06E9:  BCF    03.6
06EA:  CALL   132
....................    PRINTF (LCD_PUTC, "CONFIG:        "); 
06EB:  MOVLW  98
06EC:  BSF    03.6
06ED:  MOVWF  0D
06EE:  MOVLW  00
06EF:  MOVWF  0F
06F0:  BCF    03.6
06F1:  CALL   404
....................  
....................    // HIEN THI LCD 
....................    LCD_GOTOXY (1, 2) ; 
06F2:  MOVLW  01
06F3:  BSF    03.6
06F4:  MOVWF  51
06F5:  MOVLW  02
06F6:  MOVWF  52
06F7:  BCF    03.6
06F8:  CALL   3B6
....................    DELAY_MS (10); 
06F9:  MOVLW  0A
06FA:  BSF    03.6
06FB:  MOVWF  51
06FC:  BCF    03.6
06FD:  CALL   132
....................    PRINTF (LCD_PUTC, "CASE:          ") ; 
06FE:  MOVLW  A0
06FF:  BSF    03.6
0700:  MOVWF  0D
0701:  MOVLW  00
0702:  MOVWF  0F
0703:  BCF    03.6
0704:  CALL   404
....................  
....................    WHILE (TT_FUN) 
0705:  BTFSS  55.4
0706:  GOTO   778
....................    { 
....................       IF (INPUT (BT2_PIN) == 0) //NEU NUT BAM DUOC BAM 
0707:  BSF    03.5
0708:  BSF    06.2
0709:  BCF    03.5
070A:  BTFSC  06.2
070B:  GOTO   777
....................       { 
....................          CONFIG_FUN ++; 
070C:  INCF   38,F
....................          CONFIG_FUN = CONFIG_FUN % 4; //IF (CONFIG_FUN > 3) CONFIG_FUN = 0; 
070D:  MOVLW  03
070E:  ANDWF  38,F
....................          DELAY_MS (300); 
070F:  MOVLW  02
0710:  BSF    03.6
0711:  MOVWF  4C
0712:  MOVLW  96
0713:  MOVWF  51
0714:  BCF    03.6
0715:  CALL   132
0716:  BSF    03.6
0717:  DECFSZ 4C,F
0718:  GOTO   712
....................  
....................          //HIEN THI 
....................          LCD_GOTOXY (6, 2) ; 
0719:  MOVLW  06
071A:  MOVWF  51
071B:  MOVLW  02
071C:  MOVWF  52
071D:  BCF    03.6
071E:  CALL   3B6
....................          ITOA (CONFIG_FUN, 10, TEMP_CHAR); 
071F:  BSF    03.6
0720:  CLRF   51
0721:  CLRF   50
0722:  CLRF   4F
0723:  BCF    03.6
0724:  MOVF   38,W
0725:  BSF    03.6
0726:  MOVWF  4E
0727:  MOVLW  0A
0728:  MOVWF  52
0729:  CLRF   54
072A:  MOVLW  D8
072B:  MOVWF  53
072C:  BCF    03.6
072D:  CALL   454
....................          DELAY_MS (10); 
072E:  MOVLW  0A
072F:  BSF    03.6
0730:  MOVWF  51
0731:  BCF    03.6
0732:  CALL   132
....................          PRINTF (LCD_PUTC, TEMP_CHAR); 
0733:  MOVLW  D8
0734:  MOVWF  04
0735:  BCF    03.7
....................  
....................          SWITCH (CONFIG_FUN) 
*
0752:  MOVF   38,W
0753:  ADDLW  FC
0754:  BTFSC  03.0
0755:  GOTO   777
0756:  ADDLW  04
0757:  GOTO   780
....................          { 
....................             CASE 0: 
....................             PRINTF (LCD_PUTC, " - ID         "); 
0758:  MOVLW  A8
0759:  BSF    03.6
075A:  MOVWF  0D
075B:  MOVLW  00
075C:  MOVWF  0F
075D:  BCF    03.6
075E:  CALL   404
....................             BREAK; 
075F:  GOTO   777
....................  
....................             CASE 1: 
....................             PRINTF (LCD_PUTC, " - DEVICES    "); 
0760:  MOVLW  B0
0761:  BSF    03.6
0762:  MOVWF  0D
0763:  MOVLW  00
0764:  MOVWF  0F
0765:  BCF    03.6
0766:  CALL   404
....................             BREAK; 
0767:  GOTO   777
....................              
....................             CASE 2: 
....................             PRINTF (LCD_PUTC, " - SENSORS    "); 
0768:  MOVLW  B8
0769:  BSF    03.6
076A:  MOVWF  0D
076B:  MOVLW  00
076C:  MOVWF  0F
076D:  BCF    03.6
076E:  CALL   404
....................             BREAK; 
076F:  GOTO   777
....................              
....................             CASE 3: 
....................             PRINTF (LCD_PUTC, " - ID - GW:    "); 
0770:  MOVLW  C0
0771:  BSF    03.6
0772:  MOVWF  0D
0773:  MOVLW  00
0774:  MOVWF  0F
0775:  BCF    03.6
0776:  CALL   404
....................             BREAK; 
....................          } 
....................       } 
0777:  GOTO   705
....................    } 
....................  
....................    ////// 
....................    IF (!TT_CONFIG_DONE) 
0778:  BTFSC  55.3
0779:  GOTO   77D
....................    { 
....................       SELLECT_FUN (); 
077A:  BSF    0A.3
077B:  GOTO   000
077C:  BCF    0A.3
....................    } 
077D:  BCF    0A.3
077E:  BSF    0A.4
077F:  GOTO   2A4 (RETURN)
.................... } 
....................  
.................... VOID XULYDEVICE_CF() 
.................... { 
....................    *TEMP_CHAR = '\0'; 
*
0CE5:  CLRF   7A
0CE6:  MOVLW  D8
0CE7:  MOVWF  04
0CE8:  BCF    03.7
0CE9:  BTFSC  7A.0
0CEA:  BSF    03.7
0CEB:  CLRF   00
....................    *TT_DEVICE_CHAR = '\0'; 
0CEC:  CLRF   7A
0CED:  MOVLW  58
0CEE:  MOVWF  04
0CEF:  BCF    03.7
0CF0:  BTFSC  7A.0
0CF1:  BSF    03.7
0CF2:  CLRF   00
....................    FOR (INT I = 0; I < 8; I++) 
0CF3:  BSF    03.6
0CF4:  CLRF   4D
0CF5:  MOVF   4D,W
0CF6:  SUBLW  07
0CF7:  BTFSS  03.0
0CF8:  GOTO   560
....................    { 
....................       IF (TT_DEVICE[I]) 
0CF9:  MOVF   4D,W
0CFA:  MOVWF  4E
0CFB:  CLRF   50
0CFC:  MOVLW  56
0CFD:  MOVWF  4F
0CFE:  BCF    0A.3
0CFF:  BCF    03.6
0D00:  CALL   6A4
0D01:  BSF    0A.3
0D02:  BTFSS  78.0
0D03:  GOTO   55D
....................       { 
....................          ITOA (I, 10, TEMP_CHAR); 
0D04:  BSF    03.6
0D05:  CLRF   51
0D06:  CLRF   50
0D07:  CLRF   4F
0D08:  MOVF   4D,W
0D09:  MOVWF  4E
0D0A:  MOVLW  0A
0D0B:  MOVWF  52
0D0C:  CLRF   54
0D0D:  MOVLW  D8
0D0E:  MOVWF  53
0D0F:  BCF    0A.3
0D10:  BCF    03.6
0D11:  CALL   454
0D12:  BSF    0A.3
....................          DELAY_MS (1); 
0D13:  MOVLW  01
0D14:  BSF    03.6
0D15:  MOVWF  51
0D16:  BCF    0A.3
0D17:  BCF    03.6
0D18:  CALL   132
0D19:  BSF    0A.3
....................          STRCAT (TT_DEVICE_CHAR, TEMP_CHAR); 
0D1A:  BSF    03.6
0D1B:  CLRF   4F
0D1C:  MOVLW  58
0D1D:  MOVWF  4E
0D1E:  CLRF   51
0D1F:  MOVLW  D8
0D20:  MOVWF  50
....................       } 
*
0D5D:  BSF    03.6
0D5E:  INCF   4D,F
0D5F:  GOTO   4F5
....................    } 
....................  
....................    // PACKAGE_CONFIG[6] = TT_DEVICE_CHAR; 
.................... } 
....................  
.................... VOID XULYSENSOR_CF() 
.................... { 
....................    *TEMP_CHAR = '\0'; 
0D60:  CLRF   7A
0D61:  MOVLW  D8
0D62:  MOVWF  04
0D63:  BCF    03.7
0D64:  BTFSC  7A.0
0D65:  BSF    03.7
0D66:  CLRF   00
....................    *TEMP_CHAR2 = '\0'; 
0D67:  CLRF   7A
0D68:  MOVLW  DD
0D69:  MOVWF  04
0D6A:  BCF    03.7
0D6B:  BTFSC  7A.0
0D6C:  BSF    03.7
0D6D:  CLRF   00
....................    FOR (INT J = 0; J < 5; J++) 
0D6E:  CLRF   4D
0D6F:  MOVF   4D,W
0D70:  SUBLW  04
0D71:  BTFSS  03.0
0D72:  GOTO   5DA
....................    { 
....................       IF (TT_SENSOR[J]) 
0D73:  MOVF   4D,W
0D74:  MOVWF  4E
0D75:  CLRF   50
0D76:  MOVLW  57
0D77:  MOVWF  4F
0D78:  BCF    0A.3
0D79:  BCF    03.6
0D7A:  CALL   6A4
0D7B:  BSF    0A.3
0D7C:  BTFSS  78.0
0D7D:  GOTO   5D7
....................       { 
....................          ITOA (J, 10, TEMP_CHAR); 
0D7E:  BSF    03.6
0D7F:  CLRF   51
0D80:  CLRF   50
0D81:  CLRF   4F
0D82:  MOVF   4D,W
0D83:  MOVWF  4E
0D84:  MOVLW  0A
0D85:  MOVWF  52
0D86:  CLRF   54
0D87:  MOVLW  D8
0D88:  MOVWF  53
0D89:  BCF    0A.3
0D8A:  BCF    03.6
0D8B:  CALL   454
0D8C:  BSF    0A.3
....................          DELAY_MS (1); 
0D8D:  MOVLW  01
0D8E:  BSF    03.6
0D8F:  MOVWF  51
0D90:  BCF    0A.3
0D91:  BCF    03.6
0D92:  CALL   132
0D93:  BSF    0A.3
....................          STRCAT (TEMP_CHAR2, TEMP_CHAR); 
0D94:  BSF    03.6
0D95:  CLRF   4F
0D96:  MOVLW  DD
0D97:  MOVWF  4E
0D98:  CLRF   51
0D99:  MOVLW  D8
0D9A:  MOVWF  50
....................       } 
*
0DD7:  BSF    03.6
0DD8:  INCF   4D,F
0DD9:  GOTO   56F
....................    } 
....................  
....................    //PACKAGE_CONFIG[7] = TEMP_CHAR3; 
.................... } 
....................  
.................... VOID CONFIG_DONE() 
.................... { 
....................    TT_FUN = 0; 
*
0C44:  BCF    55.4
....................    TT_STT = 0; 
0C45:  BCF    55.5
....................    *TEMP_CHAR3 = "\0"; 
0C46:  CLRF   7A
0C47:  MOVLW  E8
0C48:  BSF    03.6
0C49:  MOVWF  4D
0C4A:  MOVF   7A,W
0C4B:  MOVWF  4E
0C4C:  MOVF   4D,W
0C4D:  MOVWF  04
0C4E:  BCF    03.7
0C4F:  BTFSC  4E.0
0C50:  BSF    03.7
0C51:  CLRF   00
....................    FOR (int j = 0; j < 4; j++) 
0C52:  CLRF   4C
0C53:  MOVF   4C,W
0C54:  SUBLW  03
0C55:  BTFSS  03.0
0C56:  GOTO   4B6
....................    { 
....................       ITOA (ID_GATEWAY[j], 10, TEMP_CHAR); 
0C57:  MOVLW  7B
0C58:  ADDWF  4C,W
0C59:  MOVWF  04
0C5A:  BCF    03.7
0C5B:  MOVF   00,W
0C5C:  MOVWF  4D
0C5D:  CLRF   51
0C5E:  CLRF   50
0C5F:  CLRF   4F
0C60:  MOVF   4D,W
0C61:  MOVWF  4E
0C62:  MOVLW  0A
0C63:  MOVWF  52
0C64:  CLRF   54
0C65:  MOVLW  D8
0C66:  MOVWF  53
0C67:  BCF    0A.3
0C68:  BCF    03.6
0C69:  CALL   454
0C6A:  BSF    0A.3
....................       DELAY_MS (1); 
0C6B:  MOVLW  01
0C6C:  BSF    03.6
0C6D:  MOVWF  51
0C6E:  BCF    0A.3
0C6F:  BCF    03.6
0C70:  CALL   132
0C71:  BSF    0A.3
....................       STRCAT (TEMP_CHAR3, TEMP_CHAR); 
0C72:  BSF    03.6
0C73:  CLRF   4F
0C74:  MOVLW  E8
0C75:  MOVWF  4E
0C76:  CLRF   51
0C77:  MOVLW  D8
0C78:  MOVWF  50
*
0CB4:  INCF   4C,F
0CB5:  GOTO   453
....................    }    
....................     
....................    PACKAGE_CONFIG[1] = TEMP_CHAR3; 
0CB6:  BSF    03.5
0CB7:  BCF    03.6
0CB8:  CLRF   4B
0CB9:  MOVLW  E8
0CBA:  MOVWF  4A
....................    DELAY_MS (2); 
0CBB:  MOVLW  02
0CBC:  BCF    03.5
0CBD:  BSF    03.6
0CBE:  MOVWF  51
0CBF:  BCF    0A.3
0CC0:  BCF    03.6
0CC1:  CALL   132
0CC2:  BSF    0A.3
....................    PACKAGE_CONFIG[2] = ID_; 
0CC3:  BSF    03.5
0CC4:  CLRF   4D
0CC5:  MOVLW  71
0CC6:  MOVWF  4C
....................    DELAY_MS (2); 
0CC7:  MOVLW  02
0CC8:  BCF    03.5
0CC9:  BSF    03.6
0CCA:  MOVWF  51
0CCB:  BCF    0A.3
0CCC:  BCF    03.6
0CCD:  CALL   132
0CCE:  BSF    0A.3
....................    TT_DEVICE_CHAR = ""; 
0CCF:  BSF    03.6
0CD0:  CLRF   4D
0CD1:  CLRF   4E
0CD2:  MOVLW  58
0CD3:  MOVWF  04
0CD4:  BCF    03.7
0CD5:  MOVF   4D,W
0CD6:  ADDWF  04,F
0CD7:  MOVF   4E,W
0CD8:  BCF    0A.3
0CD9:  BCF    03.6
0CDA:  CALL   05E
0CDB:  BSF    0A.3
0CDC:  MOVWF  00
0CDD:  IORLW  00
0CDE:  BTFSC  03.2
0CDF:  GOTO   4E5
0CE0:  BSF    03.6
0CE1:  INCF   4E,F
0CE2:  INCF   4D,F
0CE3:  GOTO   4D2
0CE4:  BCF    03.6
....................    XULYDEVICE_CF (); 
....................    XULYSENSOR_CF (); 
....................    PACKAGE_CONFIG[5] = TT_DEVICE_CHAR; 
*
0DDA:  BSF    03.5
0DDB:  BCF    03.6
0DDC:  CLRF   53
0DDD:  MOVLW  58
0DDE:  MOVWF  52
....................    DELAY_MS (2); 
0DDF:  MOVLW  02
0DE0:  BCF    03.5
0DE1:  BSF    03.6
0DE2:  MOVWF  51
0DE3:  BCF    0A.3
0DE4:  BCF    03.6
0DE5:  CALL   132
0DE6:  BSF    0A.3
....................    PACKAGE_CONFIG[6] = TEMP_CHAR2; 
0DE7:  BSF    03.5
0DE8:  CLRF   55
0DE9:  MOVLW  DD
0DEA:  MOVWF  54
....................    //TINH DO DAI --> 
....................    LEN_PACKAGES = 0; 
0DEB:  CLRF   76
....................    PACKAGE_CONFIG[3] = "12"; //DO DAI CUA LENGHT C? ?? DAI = 2 
0DEC:  MOVLW  31
0DED:  MOVWF  4E
0DEE:  MOVLW  32
0DEF:  MOVWF  4F
....................    FOR (J = 0; J < 9; J++) 
0DF0:  BCF    03.5
0DF1:  BSF    03.6
0DF2:  CLRF   4C
0DF3:  MOVF   4C,W
0DF4:  SUBLW  08
0DF5:  BTFSS  03.0
0DF6:  GOTO   627
....................    { 
....................       LEN_PACKAGES += strlen(PACKAGE_CONFIG[J]); 
0DF7:  BCF    03.0
0DF8:  RLF    4C,W
0DF9:  ADDLW  C8
0DFA:  MOVWF  04
0DFB:  BCF    03.7
0DFC:  INCF   04,F
0DFD:  MOVF   00,W
0DFE:  MOVWF  4E
0DFF:  DECF   04,F
0E00:  MOVF   00,W
0E01:  MOVWF  4D
0E02:  MOVF   4E,W
0E03:  MOVWF  50
0E04:  MOVF   4D,W
0E05:  MOVWF  4F
*
0E23:  MOVF   78,W
0E24:  ADDWF  76,F
0E25:  INCF   4C,F
0E26:  GOTO   5F3
....................    }    
....................    LEN_PACKAGES = LEN_PACKAGES+7; //7 @ 
0E27:  MOVLW  07
0E28:  ADDWF  76,F
....................    ITOA (LEN_PACKAGES, 10, TEMP_CHAR); 
0E29:  CLRF   51
0E2A:  CLRF   50
0E2B:  CLRF   4F
0E2C:  MOVF   76,W
0E2D:  MOVWF  4E
0E2E:  MOVLW  0A
0E2F:  MOVWF  52
0E30:  CLRF   54
0E31:  MOVLW  D8
0E32:  MOVWF  53
0E33:  BCF    0A.3
0E34:  BCF    03.6
0E35:  CALL   454
0E36:  BSF    0A.3
....................    PACKAGE_CONFIG[3] = TEMP_CHAR; 
0E37:  BSF    03.5
0E38:  CLRF   4F
0E39:  MOVLW  D8
0E3A:  MOVWF  4E
....................     
....................    FOR ( J = 0; J < 8; J++) 
0E3B:  BCF    03.5
0E3C:  BSF    03.6
0E3D:  CLRF   4C
0E3E:  MOVF   4C,W
0E3F:  SUBLW  07
0E40:  BTFSS  03.0
0E41:  GOTO   65C
....................    { 
....................       PRINTF (PACKAGE_CONFIG[J]); 
0E42:  BCF    03.0
0E43:  RLF    4C,W
0E44:  ADDLW  C8
0E45:  MOVWF  04
0E46:  BCF    03.7
0E47:  INCF   04,F
0E48:  MOVF   00,W
0E49:  MOVWF  4E
0E4A:  DECF   04,F
0E4B:  MOVF   00,W
0E4C:  MOVWF  4D
0E4D:  MOVWF  04
0E4E:  BCF    03.7
0E4F:  BTFSC  4E.0
0E50:  BSF    03.7
0E51:  BCF    0A.3
0E52:  BCF    03.6
0E53:  CALL   788
0E54:  BSF    0A.3
....................       PRINTF ("@"); 
0E55:  MOVLW  40
0E56:  BTFSS  0C.4
0E57:  GOTO   656
0E58:  MOVWF  19
0E59:  BSF    03.6
0E5A:  INCF   4C,F
0E5B:  GOTO   63E
....................    } 
....................  
....................    /* 
....................    LCD_GOTOXY (1, 1) ; 
....................    DELAY_MS (10); 
....................    FOR (J = 0; J < 9; J++) 
....................    { 
....................       PRINTF (LCD_PUTC, PACKAGE_CONFIG[J]); 
....................    } 
....................    */ 
....................  
....................    LCD_GOTOXY (1, 1) ; 
0E5C:  MOVLW  01
0E5D:  MOVWF  51
0E5E:  MOVWF  52
0E5F:  BCF    0A.3
0E60:  BCF    03.6
0E61:  CALL   3B6
0E62:  BSF    0A.3
....................    DELAY_MS (10); 
0E63:  MOVLW  0A
0E64:  BSF    03.6
0E65:  MOVWF  51
0E66:  BCF    0A.3
0E67:  BCF    03.6
0E68:  CALL   132
0E69:  BSF    0A.3
....................    PRINTF (LCD_PUTC, "CONFIG DONE        ") ; 
0E6A:  MOVLW  C8
0E6B:  BSF    03.6
0E6C:  MOVWF  0D
0E6D:  MOVLW  00
0E6E:  MOVWF  0F
0E6F:  BCF    0A.3
0E70:  BCF    03.6
0E71:  CALL   404
0E72:  BSF    0A.3
....................    LCD_GOTOXY (1, 2) ; 
0E73:  MOVLW  01
0E74:  BSF    03.6
0E75:  MOVWF  51
0E76:  MOVLW  02
0E77:  MOVWF  52
0E78:  BCF    0A.3
0E79:  BCF    03.6
0E7A:  CALL   3B6
0E7B:  BSF    0A.3
....................    DELAY_MS (10); 
0E7C:  MOVLW  0A
0E7D:  BSF    03.6
0E7E:  MOVWF  51
0E7F:  BCF    0A.3
0E80:  BCF    03.6
0E81:  CALL   132
0E82:  BSF    0A.3
....................    PRINTF (LCD_PUTC, "CONFIG DONE        ") ; 
0E83:  MOVLW  D2
0E84:  BSF    03.6
0E85:  MOVWF  0D
0E86:  MOVLW  00
0E87:  MOVWF  0F
0E88:  BCF    0A.3
0E89:  BCF    03.6
0E8A:  CALL   404
0E8B:  BSF    0A.3
....................    PACKAGE_NHIETDO[1] = ID_; 
0E8C:  CLRF   66
0E8D:  MOVLW  71
0E8E:  MOVWF  65
....................    TT_CONFIG_DONE = 0; 
0E8F:  BCF    55.3
0E90:  BCF    0A.3
0E91:  BSF    0A.4
0E92:  GOTO   2AB (RETURN)
.................... } 
....................  
.................... //--------------------------------------------------------------------// 
....................  
....................  
....................  
....................  
....................  
.................... VOID QUET_PHIM() 
*
00DC:  BSF    03.5
00DD:  BSF    03.6
00DE:  CLRF   16
.................... { 
....................    INT BDT = 0; 
....................  
....................    WHILE (!INPUT (BT1_PIN)) //NEU NUT BAM DUOC BAM 
00DF:  BCF    03.6
00E0:  BSF    06.1
00E1:  BCF    03.5
00E2:  BTFSC  06.1
00E3:  GOTO   0FB
....................    { 
....................       IF (TMR1IF) 
00E4:  BTFSS  0C.0
00E5:  GOTO   0F6
....................       { 
....................          OUTPUT_TOGGLE (PIN_D2); 
00E6:  BSF    03.5
00E7:  BCF    08.2
00E8:  MOVLW  04
00E9:  BCF    03.5
00EA:  XORWF  08,F
....................          TMR1IF = 0; SET_TIMER1 (3036); BDT++; 
00EB:  BCF    0C.0
00EC:  CLRF   0E
00ED:  MOVLW  0B
00EE:  MOVWF  0F
00EF:  MOVLW  DC
00F0:  MOVWF  0E
00F1:  BSF    03.5
00F2:  BSF    03.6
00F3:  INCF   16,F
00F4:  BCF    03.5
00F5:  BCF    03.6
....................       } 
00F6:  BSF    03.5
00F7:  BSF    03.6
00F8:  GOTO   0DF
00F9:  BCF    03.5
00FA:  BCF    03.6
....................    } 
....................  
....................    IF (BDT > 20) 
00FB:  BSF    03.5
00FC:  BSF    03.6
00FD:  MOVF   16,W
00FE:  SUBLW  14
00FF:  BTFSC  03.0
0100:  GOTO   10C
....................    { 
....................       //CONFIG NODE 
....................       TT_CONFIG = ~TT_CONFIG; // VAO TRANG THAI CONFIG 
0101:  MOVLW  02
0102:  BCF    03.5
0103:  BCF    03.6
0104:  XORWF  55,F
....................       TT_CONTROL = ~TT_CONTROL; 
0105:  MOVLW  04
0106:  XORWF  55,F
....................       //CONFIG_DONE (); 
....................       TT_CONFIG_DONE = 1; 
0107:  BSF    55.3
....................       TT_FUN = 0; 
0108:  BCF    55.4
....................    } 
0109:  GOTO   111
010A:  BSF    03.5
010B:  BSF    03.6
....................  
....................    ELSE 
....................    { 
....................       BUTT_OKE (); //OKE 
....................    } 
.................... } 
....................  
.................... #INT_EXT 
....................  
....................  VOID NGAT_NGOAI () 
....................  { 
....................     QUET_PHIM (); 
....................  } 
....................  
*
0111:  BCF    0B.1
0112:  BCF    0A.3
0113:  BCF    0A.4
0114:  GOTO   031
....................  #INT_RDA 
....................  VOID NGAT () 
....................  { 
....................     KYTUCHAR[VT] = GETCH (); 
0115:  MOVLW  41
0116:  ADDWF  3C,W
0117:  MOVWF  04
0118:  BCF    03.7
0119:  BTFSS  0C.5
011A:  GOTO   119
011B:  MOVF   1A,W
011C:  MOVWF  00
....................  
....................     IF (KYTUCHAR[VT] == '.') 
011D:  MOVLW  41
011E:  ADDWF  3C,W
011F:  MOVWF  04
0120:  BCF    03.7
0121:  MOVF   00,W
0122:  SUBLW  2E
0123:  BTFSS  03.2
0124:  GOTO   12D
....................     { 
....................        KYTUCHAR[VT] = '\0'; 
0125:  MOVLW  41
0126:  ADDWF  3C,W
0127:  MOVWF  04
0128:  BCF    03.7
0129:  CLRF   00
....................        VT = 0; 
012A:  CLRF   3C
....................        TTNHAN = 1; 
012B:  BSF    55.0
....................     } 
012C:  GOTO   12E
....................  
....................     ELSE 
....................     VT++; 
012D:  INCF   3C,F
012E:  BCF    0C.5
012F:  BCF    0A.3
0130:  BCF    0A.4
0131:  GOTO   031
....................  } 
....................  
....................  VOID XUATLCD  () 
....................  { 
....................     LCD_GOTOXY (1, 1) ; 
*
07BE:  MOVLW  01
07BF:  BSF    03.6
07C0:  MOVWF  51
07C1:  MOVWF  52
07C2:  BCF    03.6
07C3:  CALL   3B6
....................     DELAY_MS (10); 
07C4:  MOVLW  0A
07C5:  BSF    03.6
07C6:  MOVWF  51
07C7:  BCF    03.6
07C8:  CALL   132
....................     PRINTF (LCD_PUTC, KYTUCHAR); 
07C9:  MOVLW  41
07CA:  MOVWF  04
07CB:  BCF    03.7
....................     DELAY_MS (1); 
*
07E8:  MOVLW  01
07E9:  BSF    03.6
07EA:  MOVWF  51
07EB:  BCF    03.6
07EC:  CALL   132
07ED:  BCF    0A.3
07EE:  BSF    0A.4
07EF:  GOTO   321 (RETURN)
....................  } 
....................  
....................  INT ADC_READ (INT KENH) 
....................  { 
....................     SET_ADC_CHANNEL (KENH); 
....................     KQADC = 0; 
....................     FOR (INT I = 0; I < 100; I++) 
....................     { 
....................        KQADC = KQADC + READ_ADC () ; 
....................        DELAY_MS (1); 
....................     } 
....................  
....................     KQADC = KQADC / (100 * 2.046); 
....................     RETURN KQADC; 
....................  } 
....................  
....................  VOID CHUONG_TRINH_CON () 
....................  { 
....................     FOR (INT I = 0; I <= 30; I++) 
*
07A6:  BSF    03.6
07A7:  CLRF   4C
07A8:  MOVF   4C,W
07A9:  SUBLW  1E
07AA:  BTFSS  03.0
07AB:  GOTO   7BA
....................     { 
....................        OUTPUT_TOGGLE (PIN_D1); 
07AC:  BSF    03.5
07AD:  BCF    03.6
07AE:  BCF    08.1
07AF:  MOVLW  02
07B0:  BCF    03.5
07B1:  XORWF  08,F
....................        DELAY_MS (100); 
07B2:  MOVLW  64
07B3:  BSF    03.6
07B4:  MOVWF  51
07B5:  BCF    03.6
07B6:  CALL   132
07B7:  BSF    03.6
07B8:  INCF   4C,F
07B9:  GOTO   7A8
....................     } 
07BA:  BCF    03.6
07BB:  BCF    0A.3
07BC:  BSF    0A.4
07BD:  GOTO   2B2 (RETURN)
....................  } 
....................  
....................  VOID MAIN  () 
*
1102:  MOVF   03,W
1103:  ANDLW  1F
1104:  MOVWF  03
1105:  BSF    03.5
1106:  BSF    03.6
1107:  BSF    07.3
1108:  MOVLW  08
1109:  BCF    03.6
110A:  MOVWF  19
110B:  MOVLW  02
110C:  MOVWF  1A
110D:  MOVLW  A6
110E:  MOVWF  18
110F:  MOVLW  90
1110:  BCF    03.5
1111:  MOVWF  18
1112:  MOVLW  FF
1113:  MOVWF  31
1114:  CLRF   38
1115:  CLRF   39
1116:  CLRF   3A
1117:  CLRF   3B
1118:  CLRF   3C
1119:  CLRF   3D
111A:  BCF    55.0
111B:  BCF    55.1
111C:  BCF    55.2
111D:  BCF    55.3
111E:  BCF    55.4
111F:  BCF    55.5
1120:  CLRF   76
1121:  BSF    03.5
1122:  BSF    03.6
1123:  MOVF   09,W
1124:  ANDLW  C0
1125:  MOVWF  09
1126:  BCF    03.6
1127:  BCF    1F.4
1128:  BCF    1F.5
1129:  MOVLW  00
112A:  BSF    03.6
112B:  MOVWF  08
112C:  BCF    03.5
112D:  CLRF   07
112E:  CLRF   08
112F:  CLRF   09
1130:  BCF    03.7
....................  { 
....................     SET_TRIS_D (0X00); 
*
1262:  MOVLW  00
1263:  BSF    03.5
1264:  BCF    03.6
1265:  MOVWF  08
....................     SET_TRIS_B (0XFF); 
1266:  MOVLW  FF
1267:  MOVWF  06
....................     SET_TRIS_E (0); 
1268:  BCF    09.0
1269:  BCF    09.1
126A:  BCF    09.2
126B:  BCF    09.3
....................     SET_TRIS_C (0X80); 
126C:  MOVLW  80
126D:  MOVWF  07
126E:  BCF    03.5
126F:  MOVWF  31
....................     SETUP_ADC (ADC_CLOCK_DIV_8); 
1270:  BSF    1F.6
1271:  BCF    1F.7
1272:  BSF    03.5
1273:  BSF    1F.7
1274:  BCF    03.5
1275:  BSF    1F.0
....................     SETUP_ADC_PORTS (SAN0); 
1276:  BSF    03.5
1277:  BSF    03.6
1278:  MOVF   09,W
1279:  ANDLW  C0
127A:  MOVWF  09
127B:  BCF    03.6
127C:  BCF    1F.4
127D:  BCF    1F.5
127E:  MOVLW  01
127F:  BSF    03.6
1280:  MOVWF  08
....................     ENABLE_INTERRUPTS (INT_TIMER0); 
1281:  BCF    03.5
1282:  BCF    03.6
1283:  BSF    0B.5
....................     ENABLE_INTERRUPTS (INT_EXT); //CHO PHEP NGAT NGOAI 
1284:  BSF    0B.4
....................     ENABLE_INTERRUPTS (INT_EXT_H2L); //NGAT XAY RA KHI CO XUNG TU CAO XUONG THAP 
1285:  BSF    0B.4
1286:  BSF    03.5
1287:  BCF    01.6
....................     ENABLE_INTERRUPTS (INT_RDA); 
1288:  BSF    0C.5
....................     ENABLE_INTERRUPTS (GLOBAL); 
1289:  MOVLW  C0
128A:  BCF    03.5
128B:  IORWF  0B,F
....................      
....................     SETUP_TIMER_1 (T1_INTERNAL|T1_DIV_BY_8); 
128C:  MOVLW  35
128D:  MOVWF  10
....................     //SET_TIMER1 (0); 
....................     SET_TIMER1 (3036); 
128E:  CLRF   0E
128F:  MOVLW  0B
1290:  MOVWF  0F
1291:  MOVLW  DC
1292:  MOVWF  0E
....................     TMR1IF = 0; 
1293:  BCF    0C.0
....................     LCD_INIT (); // KHOI TAO LCD 
1294:  BCF    0A.4
1295:  GOTO   2C8
1296:  BSF    0A.4
....................     ID_NODE = 0; 
1297:  CLRF   39
....................     TT_CONFIG = 0; 
1298:  BCF    55.1
....................     TT_CONFIG_DONE = 0; 
1299:  BCF    55.3
....................     TT_CONTROL = 1; 
129A:  BSF    55.2
....................     OUTPUT_D (0X00); 
129B:  BSF    03.5
129C:  CLRF   08
129D:  BCF    03.5
129E:  CLRF   08
....................     TTNHAN = 0; 
129F:  BCF    55.0
....................      
....................      
....................      
....................     WHILE (TRUE) 
....................     { 
....................        //AN1 = ADC_READ (1) ; 
....................        //AN0 = ADC_READ (0) ; 
....................  
....................        IF (TT_CONFIG) 
12A0:  BTFSS  55.1
12A1:  GOTO   2A6
....................        { 
....................           BUTT_FUN (); // GOI HAM CHON LENH (SWITCH CASE) 
12A2:  BCF    0A.4
12A3:  GOTO   6DF
12A4:  BSF    0A.4
....................        } 
12A5:  GOTO   3BE
....................  
....................        ELSE IF (TT_CONFIG_DONE) 
12A6:  BTFSS  55.3
12A7:  GOTO   2AE
....................        { 
....................           CONFIG_DONE (); 
12A8:  BCF    0A.4
12A9:  BSF    0A.3
12AA:  GOTO   444
12AB:  BSF    0A.4
12AC:  BCF    0A.3
....................        } 
12AD:  GOTO   3BE
....................  
....................         
....................        ELSE 
....................        { 
....................           WHILE (!TT_CONFIG) 
12AE:  BTFSC  55.1
12AF:  GOTO   3BE
....................           { 
....................              CHUONG_TRINH_CON (); 
12B0:  BCF    0A.4
12B1:  GOTO   7A6
12B2:  BSF    0A.4
....................  
....................              IF (AN0 > 26) 
12B3:  MOVF   35,F
12B4:  BTFSS  03.2
12B5:  GOTO   2BA
12B6:  MOVF   34,W
12B7:  SUBLW  1A
12B8:  BTFSC  03.0
12B9:  GOTO   31B
....................              { 
....................                 ITOA (AN0, 10, NHIETDO1); 
12BA:  BSF    03.6
12BB:  CLRF   51
12BC:  CLRF   50
12BD:  BCF    03.6
12BE:  MOVF   35,W
12BF:  BSF    03.6
12C0:  MOVWF  4F
12C1:  BCF    03.6
12C2:  MOVF   34,W
12C3:  BSF    03.6
12C4:  MOVWF  4E
12C5:  MOVLW  0A
12C6:  MOVWF  52
12C7:  MOVLW  01
12C8:  MOVWF  54
12C9:  MOVLW  43
12CA:  MOVWF  53
12CB:  BCF    0A.4
12CC:  BCF    03.6
12CD:  CALL   454
12CE:  BSF    0A.4
....................                 PACKAGE_NHIETDO[4] = NHIETDO1; 
12CF:  MOVLW  01
12D0:  MOVWF  6C
12D1:  MOVLW  43
12D2:  MOVWF  6B
....................                 ITOA (AN1, 10, NHIETDO2); 
12D3:  BSF    03.6
12D4:  CLRF   51
12D5:  CLRF   50
12D6:  BCF    03.6
12D7:  MOVF   37,W
12D8:  BSF    03.6
12D9:  MOVWF  4F
12DA:  BCF    03.6
12DB:  MOVF   36,W
12DC:  BSF    03.6
12DD:  MOVWF  4E
12DE:  MOVLW  0A
12DF:  MOVWF  52
12E0:  MOVLW  01
12E1:  MOVWF  54
12E2:  MOVLW  46
12E3:  MOVWF  53
12E4:  BCF    0A.4
12E5:  BCF    03.6
12E6:  CALL   454
12E7:  BSF    0A.4
....................                 PACKAGE_NHIETDO[5] = NHIETDO2; 
12E8:  MOVLW  01
12E9:  MOVWF  6E
12EA:  MOVLW  46
12EB:  MOVWF  6D
....................                  
....................                 FOR (INT I = 0; I < 8; I++) 
12EC:  BSF    03.6
12ED:  CLRF   49
12EE:  MOVF   49,W
12EF:  SUBLW  07
12F0:  BTFSS  03.0
12F1:  GOTO   30F
....................                 { 
....................                    PRINTF (PACKAGE_NHIETDO[I]); 
12F2:  BCF    03.0
12F3:  RLF    49,W
12F4:  ADDLW  63
12F5:  MOVWF  04
12F6:  BCF    03.7
12F7:  INCF   04,F
12F8:  MOVF   00,W
12F9:  MOVWF  4D
12FA:  DECF   04,F
12FB:  MOVF   00,W
12FC:  MOVWF  4C
12FD:  MOVWF  04
12FE:  BCF    03.7
12FF:  BTFSC  4D.0
1300:  BSF    03.7
1301:  BCF    0A.4
1302:  BCF    03.6
1303:  CALL   788
1304:  BSF    0A.4
....................                    DELAY_MS (1); 
1305:  MOVLW  01
1306:  BSF    03.6
1307:  MOVWF  51
1308:  BCF    0A.4
1309:  BCF    03.6
130A:  CALL   132
130B:  BSF    0A.4
130C:  BSF    03.6
130D:  INCF   49,F
130E:  GOTO   2EE
....................                 } 
....................  
....................                  
....................                 DELAY_MS (1000); 
130F:  MOVLW  04
1310:  MOVWF  4C
1311:  MOVLW  FA
1312:  MOVWF  51
1313:  BCF    0A.4
1314:  BCF    03.6
1315:  CALL   132
1316:  BSF    0A.4
1317:  BSF    03.6
1318:  DECFSZ 4C,F
1319:  GOTO   311
131A:  BCF    03.6
....................              } 
....................  
....................               
....................              IF (TTNHAN == 1) 
131B:  BTFSS  55.0
131C:  GOTO   3BD
....................              { 
....................                 TTNHAN = 0; 
131D:  BCF    55.0
....................                 KYTU = 0; 
131E:  CLRF   3D
....................                 //TEMP_CHAR = 'K'; 
....................                 //ID_NODE_NHAN = KYTU[1] - 48; 
....................                 //ID_DEVICE_NHAN = KYTU[2] - 48 + 64; 
....................                 //TT_DEVICE_NHAN = KYTU[3] - 48; // - 48 ASCII -- > S?. + 64 -- > PORT_D (D0 = 64) 
....................                 XUATLCD (); 
131F:  BCF    0A.4
1320:  GOTO   7BE
1321:  BSF    0A.4
....................                  
....................                 /* LAY TOKEN DAU TIEN */ 
....................                 TEMP_CHAR = "_"; 
1322:  BSF    03.6
1323:  CLRF   4C
1324:  CLRF   4D
1325:  MOVLW  D8
1326:  MOVWF  04
1327:  BCF    03.7
1328:  MOVF   4C,W
1329:  ADDWF  04,F
132A:  MOVF   4D,W
132B:  BCF    0A.4
132C:  BCF    03.6
132D:  CALL   063
132E:  BSF    0A.4
132F:  MOVWF  00
1330:  IORLW  00
1331:  BTFSC  03.2
1332:  GOTO   338
1333:  BSF    03.6
1334:  INCF   4D,F
1335:  INCF   4C,F
1336:  GOTO   325
1337:  BCF    03.6
....................                 CHAR * TOKEN; 
....................                 TOKEN = STRTOK (KYTUCHAR, TEMP_CHAR); 
1338:  BSF    03.6
1339:  CLRF   4D
133A:  MOVLW  41
133B:  MOVWF  4C
133C:  CLRF   4F
133D:  MOVLW  D8
133E:  MOVWF  4E
133F:  BCF    0A.4
1340:  BSF    0A.3
1341:  BCF    03.6
1342:  CALL   693
1343:  BSF    0A.4
1344:  BCF    0A.3
1345:  MOVF   79,W
1346:  BSF    03.6
1347:  MOVWF  4B
1348:  MOVF   78,W
1349:  MOVWF  4A
....................                  
....................                 /* DUYET QUA CAC TOKEN CON LAI */ 
....................                  
....................                 LCD_GOTOXY (1, 2) ; 
134A:  MOVLW  01
134B:  MOVWF  51
134C:  MOVLW  02
134D:  MOVWF  52
134E:  BCF    0A.4
134F:  BCF    03.6
1350:  CALL   3B6
1351:  BSF    0A.4
....................                 WHILE (TOKEN != NULL) 
1352:  BSF    03.6
1353:  MOVF   4A,F
1354:  BTFSS  03.2
1355:  GOTO   359
1356:  MOVF   4B,F
1357:  BTFSC  03.2
1358:  GOTO   39B
....................                 {                 
....................                    SWITCH(KYTU) 
1359:  BCF    03.6
135A:  MOVF   3D,W
135B:  ADDLW  FC
135C:  BTFSC  03.0
135D:  GOTO   37F
135E:  ADDLW  04
135F:  GOTO   3C0
....................                    { 
....................                      CASE 0: 
....................                      BREAK; 
1360:  GOTO   37F
....................                      CASE 1: 
....................                      ID_NODE_NHAN = ATOI(TOKEN);   
1361:  BSF    03.6
1362:  MOVF   4B,W
1363:  MOVWF  4D
1364:  MOVF   4A,W
1365:  MOVWF  4C
1366:  BCF    03.6
1367:  CALL   000
1368:  MOVF   78,W
1369:  MOVWF  3E
....................                      BREAK; 
136A:  GOTO   37F
....................                 
....................                      CASE 2: 
....................                      ID_DEVICE_NHAN =  ATOI(TOKEN) + 64 ; 
136B:  BSF    03.6
136C:  MOVF   4B,W
136D:  MOVWF  4D
136E:  MOVF   4A,W
136F:  MOVWF  4C
1370:  BCF    03.6
1371:  CALL   000
1372:  MOVLW  40
1373:  ADDWF  78,W
1374:  MOVWF  3F
....................                      BREAK; 
1375:  GOTO   37F
....................                 
....................                      CASE 3: 
....................                      TT_DEVICE_NHAN =  ATOI(TOKEN);                  
1376:  BSF    03.6
1377:  MOVF   4B,W
1378:  MOVWF  4D
1379:  MOVF   4A,W
137A:  MOVWF  4C
137B:  BCF    03.6
137C:  CALL   000
137D:  MOVF   78,W
137E:  MOVWF  40
....................                      BREAK; 
....................                 
....................                     
....................                    } 
....................                   //PRINTF (LCD_PUTC, TOKEN);    
....................                   DELAY_MS (1);                       
137F:  MOVLW  01
1380:  BSF    03.6
1381:  MOVWF  51
1382:  BCF    0A.4
1383:  BCF    03.6
1384:  CALL   132
1385:  BSF    0A.4
....................                   TOKEN = STRTOK(NULL, TEMP_CHAR); 
1386:  BSF    03.6
1387:  CLRF   4D
1388:  CLRF   4C
1389:  CLRF   4F
138A:  MOVLW  D8
138B:  MOVWF  4E
138C:  BCF    0A.4
138D:  BSF    0A.3
138E:  BCF    03.6
138F:  CALL   693
1390:  BSF    0A.4
1391:  BCF    0A.3
1392:  MOVF   79,W
1393:  BSF    03.6
1394:  MOVWF  4B
1395:  MOVF   78,W
1396:  MOVWF  4A
....................                   KYTU++;      
1397:  BCF    03.6
1398:  INCF   3D,F
1399:  GOTO   352
139A:  BSF    03.6
....................                  
....................                 } 
....................                 IF (ID_NODE_NHAN == ID_NODE) 
139B:  BCF    03.6
139C:  MOVF   39,W
139D:  SUBWF  3E,W
139E:  BTFSS  03.2
139F:  GOTO   3BD
....................                 { 
....................                    OUTPUT_BIT (ID_DEVICE_NHAN, TT_DEVICE_NHAN); 
13A0:  MOVF   40,F
13A1:  BTFSS  03.2
13A2:  GOTO   3A5
13A3:  MOVLW  00
13A4:  GOTO   3A6
13A5:  MOVLW  01
13A6:  MOVWF  77
13A7:  MOVF   3F,W
13A8:  BSF    03.6
13A9:  MOVWF  4D
13AA:  MOVF   77,W
13AB:  MOVWF  4E
13AC:  CLRF   50
13AD:  CLRF   4F
13AE:  BCF    0A.4
13AF:  BCF    03.6
13B0:  CALL   6BD
13B1:  BSF    0A.4
13B2:  MOVF   3F,W
13B3:  BSF    03.6
13B4:  MOVWF  4D
13B5:  CLRF   4E
13B6:  CLRF   50
13B7:  MOVLW  80
13B8:  MOVWF  4F
13B9:  BCF    0A.4
13BA:  BCF    03.6
13BB:  CALL   6BD
13BC:  BSF    0A.4
....................                 } 
....................              } 
13BD:  GOTO   2AE
....................           } 
....................        } 
13BE:  GOTO   2A0
....................     } 
....................  } 
....................  
13BF:  SLEEP

Configuration Fuses:
   Word  1: 2FE2   HS NOWDT PUT MCLR NOPROTECT NOCPD BROWNOUT IESO FCMEN NOLVP NODEBUG
   Word  2: 3FFF   BORV40 NOWRT
