CCS PCM C Compiler, Version 5.015, 5967               06-Nov-21 23:27

               Filename:   E:\DATN_V2\NODE\pic\pic16f887\hellopic.lst

               ROM used:   4373 words (53%)
                           Largest free fragment is 2048
               RAM used:   173 (47%) at main() level
                           258 (70%) worst case
               Stack used: 7 locations (6 in main + 1 for interrupts)
               Stack size: 8

*
0000:  MOVLW  11
0001:  MOVWF  0A
0002:  GOTO   123
0003:  NOP
0004:  MOVWF  7F
0005:  SWAPF  03,W
0006:  CLRF   03
0007:  MOVWF  21
0008:  MOVF   0A,W
0009:  MOVWF  20
000A:  CLRF   0A
000B:  MOVF   04,W
000C:  MOVWF  22
000D:  MOVF   77,W
000E:  MOVWF  23
000F:  MOVF   78,W
0010:  MOVWF  24
0011:  MOVF   79,W
0012:  MOVWF  25
0013:  MOVF   7A,W
0014:  MOVWF  26
0015:  BSF    03.6
0016:  MOVF   0D,W
0017:  BCF    03.6
0018:  MOVWF  27
0019:  BSF    03.6
001A:  MOVF   0F,W
001B:  BCF    03.6
001C:  MOVWF  28
001D:  BSF    03.6
001E:  MOVF   0C,W
001F:  BCF    03.6
0020:  MOVWF  29
0021:  BSF    03.6
0022:  MOVF   0E,W
0023:  BCF    03.6
0024:  MOVWF  2A
0025:  BCF    03.7
0026:  BCF    03.5
0027:  BTFSS  0B.4
0028:  GOTO   02B
0029:  BTFSC  0B.1
002A:  GOTO   052
002B:  MOVLW  8C
002C:  MOVWF  04
002D:  BTFSS  00.5
002E:  GOTO   031
002F:  BTFSC  0C.5
0030:  GOTO   055
0031:  MOVF   22,W
0032:  MOVWF  04
0033:  MOVF   23,W
0034:  MOVWF  77
0035:  MOVF   24,W
0036:  MOVWF  78
0037:  MOVF   25,W
0038:  MOVWF  79
0039:  MOVF   26,W
003A:  MOVWF  7A
003B:  MOVF   27,W
003C:  BSF    03.6
003D:  MOVWF  0D
003E:  BCF    03.6
003F:  MOVF   28,W
0040:  BSF    03.6
0041:  MOVWF  0F
0042:  BCF    03.6
0043:  MOVF   29,W
0044:  BSF    03.6
0045:  MOVWF  0C
0046:  BCF    03.6
0047:  MOVF   2A,W
0048:  BSF    03.6
0049:  MOVWF  0E
004A:  BCF    03.6
004B:  MOVF   20,W
004C:  MOVWF  0A
004D:  SWAPF  21,W
004E:  MOVWF  03
004F:  SWAPF  7F,F
0050:  SWAPF  7F,W
0051:  RETFIE
0052:  BCF    0A.3
0053:  BCF    0A.4
0054:  GOTO   0EF
0055:  BCF    0A.3
0056:  BCF    0A.4
0057:  GOTO   120
....................  
.................... #INCLUDE <thuvien.c> 
.................... #INCLUDE <16F887.H> 
.................... //////////// Standard Header file for the PIC16F887 device //////////////// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2013 Custom Computer Services          //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... #device PIC16F887 
0058:  BCF    0A.0
0059:  BCF    0A.1
005A:  BCF    0A.2
005B:  ADDWF  02,F
005C:  RETLW  30
005D:  RETLW  00
005E:  BCF    0A.0
005F:  BCF    0A.1
0060:  BCF    0A.2
0061:  ADDWF  02,F
0062:  RETLW  5F
0063:  RETLW  00
0064:  BCF    0A.0
0065:  BCF    0A.1
0066:  BCF    0A.2
0067:  ADDWF  02,F
0068:  RETLW  23
0069:  RETLW  00
006A:  BCF    0A.0
006B:  BCF    0A.1
006C:  BCF    0A.2
006D:  ADDWF  02,F
006E:  RETLW  00
006F:  DATA CE,27
0070:  DATA C4,22
0071:  DATA 3A,10
0072:  DATA 00,00
0073:  DATA 30,18
0074:  DATA 30,18
0075:  DATA 20,10
0076:  DATA 20,10
0077:  DATA 20,10
0078:  DATA 20,10
0079:  DATA 20,10
007A:  DATA 00,01
007B:  DATA 20,10
007C:  DATA 20,10
007D:  DATA 20,10
007E:  DATA 5F,10
007F:  DATA 20,10
0080:  DATA 20,10
0081:  DATA 20,10
0082:  DATA 20,10
0083:  DATA 20,10
0084:  DATA 20,10
0085:  DATA 20,00
0086:  DATA 20,10
0087:  DATA 20,10
0088:  DATA 5F,10
0089:  DATA 20,10
008A:  DATA 20,00
008B:  DATA 49,22
008C:  DATA DF,23
008D:  DATA 57,1D
008E:  DATA 00,01
008F:  DATA 30,18
0090:  DATA 30,18
0091:  DATA 30,18
0092:  DATA 20,10
0093:  DATA 20,10
0094:  DATA 20,10
0095:  DATA 20,10
0096:  DATA 00,01
0097:  DATA 20,10
0098:  DATA 20,10
0099:  DATA 20,10
009A:  DATA 5F,10
009B:  DATA 20,10
009C:  DATA 20,10
009D:  DATA 20,10
009E:  DATA 20,10
009F:  DATA 20,10
00A0:  DATA 20,10
00A1:  DATA 20,10
00A2:  DATA 20,00
00A3:  DATA 20,10
00A4:  DATA 20,10
00A5:  DATA 5F,10
00A6:  DATA 20,10
00A7:  DATA 20,10
00A8:  DATA 20,10
00A9:  DATA 20,00
00AA:  DATA C3,27
00AB:  DATA 4E,23
00AC:  DATA C9,23
00AD:  DATA 3A,10
00AE:  DATA 20,10
00AF:  DATA 20,10
00B0:  DATA 20,10
00B1:  DATA 20,00
00B2:  DATA C3,20
00B3:  DATA D3,22
00B4:  DATA 3A,10
00B5:  DATA 20,10
00B6:  DATA 20,10
00B7:  DATA 20,10
00B8:  DATA 20,10
00B9:  DATA 20,00
00BA:  DATA A0,16
00BB:  DATA A0,24
00BC:  DATA C4,16
00BD:  DATA CE,27
00BE:  DATA C4,22
00BF:  DATA 20,10
00C0:  DATA 20,10
00C1:  DATA 20,10
00C2:  DATA 00,01
00C3:  DATA A0,16
00C4:  DATA A0,24
00C5:  DATA C4,16
00C6:  DATA C7,2B
00C7:  DATA 20,10
00C8:  DATA 20,10
00C9:  DATA 20,10
00CA:  DATA 20,00
00CB:  DATA D7,20
00CC:  DATA 49,2A
00CD:  DATA 49,27
00CE:  DATA 47,10
00CF:  DATA 2E,17
00D0:  DATA 2E,17
00D1:  DATA 20,10
00D2:  DATA 20,10
00D3:  DATA 20,10
00D4:  DATA 20,10
00D5:  DATA 00,01
00D6:  DATA D7,20
00D7:  DATA 49,2A
00D8:  DATA 49,27
00D9:  DATA 47,10
00DA:  DATA 2E,17
00DB:  DATA 2E,17
00DC:  DATA 20,10
00DD:  DATA 20,10
00DE:  DATA 20,10
00DF:  DATA 20,10
00E0:  DATA 00,00
00E1:  DATA 20,10
00E2:  DATA 20,10
00E3:  DATA 20,10
00E4:  DATA 20,10
00E5:  DATA 20,10
00E6:  DATA 20,10
00E7:  DATA 00,01
00E8:  DATA 54,21
00E9:  DATA 3A,10
00EA:  DATA 00,01
00EB:  DATA 20,10
00EC:  DATA 20,10
00ED:  DATA 43,21
00EE:  DATA 3A,00
*
013D:  DATA C0,29
013E:  DATA 53,20
013F:  DATA 00,00
*
030E:  MOVF   0B,W
030F:  BSF    03.6
0310:  MOVWF  3D
0311:  BCF    03.6
0312:  BCF    0B.7
0313:  BSF    03.5
0314:  BSF    03.6
0315:  BSF    0C.7
0316:  BSF    0C.0
0317:  NOP
0318:  NOP
0319:  BCF    03.5
031A:  BTFSS  3D.7
031B:  GOTO   31F
031C:  BCF    03.6
031D:  BSF    0B.7
031E:  BSF    03.6
031F:  MOVF   0C,W
0320:  ANDLW  7F
0321:  BTFSC  03.2
0322:  GOTO   35C
0323:  MOVWF  3D
0324:  MOVF   0D,W
0325:  MOVWF  3E
0326:  MOVF   0F,W
0327:  MOVWF  3F
0328:  MOVF   3D,W
0329:  MOVWF  40
032A:  BCF    03.6
032B:  CALL   2D4
032C:  BSF    03.6
032D:  MOVF   3E,W
032E:  MOVWF  0D
032F:  MOVF   3F,W
0330:  MOVWF  0F
0331:  BCF    03.6
0332:  MOVF   0B,W
0333:  BSF    03.6
0334:  MOVWF  40
0335:  BCF    03.6
0336:  BCF    0B.7
0337:  BSF    03.5
0338:  BSF    03.6
0339:  BSF    0C.7
033A:  BSF    0C.0
033B:  NOP
033C:  NOP
033D:  BCF    03.5
033E:  BTFSS  40.7
033F:  GOTO   343
0340:  BCF    03.6
0341:  BSF    0B.7
0342:  BSF    03.6
0343:  RLF    0C,W
0344:  RLF    0E,W
0345:  ANDLW  7F
0346:  BTFSC  03.2
0347:  GOTO   35C
0348:  MOVWF  3D
0349:  MOVF   0D,W
034A:  MOVWF  3E
034B:  MOVF   0F,W
034C:  MOVWF  3F
034D:  MOVF   3D,W
034E:  MOVWF  40
034F:  BCF    03.6
0350:  CALL   2D4
0351:  BSF    03.6
0352:  MOVF   3E,W
0353:  MOVWF  0D
0354:  MOVF   3F,W
0355:  MOVWF  0F
0356:  INCF   0D,F
0357:  BTFSC  03.2
0358:  INCF   0F,F
0359:  BCF    03.6
035A:  GOTO   30E
035B:  BSF    03.6
035C:  BCF    03.6
035D:  RETURN
035E:  BTFSC  03.1
035F:  GOTO   363
0360:  MOVLW  5E
0361:  MOVWF  04
0362:  BSF    03.7
0363:  BSF    03.6
0364:  MOVF   59,W
0365:  XORWF  5D,W
0366:  ANDLW  80
0367:  MOVWF  63
0368:  BTFSS  59.7
0369:  GOTO   375
036A:  COMF   56,F
036B:  COMF   57,F
036C:  COMF   58,F
036D:  COMF   59,F
036E:  INCF   56,F
036F:  BTFSC  03.2
0370:  INCF   57,F
0371:  BTFSC  03.2
0372:  INCF   58,F
0373:  BTFSC  03.2
0374:  INCF   59,F
0375:  BTFSS  5D.7
0376:  GOTO   382
0377:  COMF   5A,F
0378:  COMF   5B,F
0379:  COMF   5C,F
037A:  COMF   5D,F
037B:  INCF   5A,F
037C:  BTFSC  03.2
037D:  INCF   5B,F
037E:  BTFSC  03.2
037F:  INCF   5C,F
0380:  BTFSC  03.2
0381:  INCF   5D,F
0382:  CLRF   77
0383:  CLRF   78
0384:  CLRF   79
0385:  CLRF   7A
0386:  CLRF   5E
0387:  CLRF   5F
0388:  CLRF   60
0389:  CLRF   61
038A:  MOVF   5D,W
038B:  IORWF  5C,W
038C:  IORWF  5B,W
038D:  IORWF  5A,W
038E:  BTFSC  03.2
038F:  GOTO   3C0
0390:  MOVLW  20
0391:  MOVWF  62
0392:  BCF    03.0
0393:  RLF    56,F
0394:  RLF    57,F
0395:  RLF    58,F
0396:  RLF    59,F
0397:  RLF    5E,F
0398:  RLF    5F,F
0399:  RLF    60,F
039A:  RLF    61,F
039B:  MOVF   5D,W
039C:  SUBWF  61,W
039D:  BTFSS  03.2
039E:  GOTO   3A9
039F:  MOVF   5C,W
03A0:  SUBWF  60,W
03A1:  BTFSS  03.2
03A2:  GOTO   3A9
03A3:  MOVF   5B,W
03A4:  SUBWF  5F,W
03A5:  BTFSS  03.2
03A6:  GOTO   3A9
03A7:  MOVF   5A,W
03A8:  SUBWF  5E,W
03A9:  BTFSS  03.0
03AA:  GOTO   3BA
03AB:  MOVF   5A,W
03AC:  SUBWF  5E,F
03AD:  MOVF   5B,W
03AE:  BTFSS  03.0
03AF:  INCFSZ 5B,W
03B0:  SUBWF  5F,F
03B1:  MOVF   5C,W
03B2:  BTFSS  03.0
03B3:  INCFSZ 5C,W
03B4:  SUBWF  60,F
03B5:  MOVF   5D,W
03B6:  BTFSS  03.0
03B7:  INCFSZ 5D,W
03B8:  SUBWF  61,F
03B9:  BSF    03.0
03BA:  RLF    77,F
03BB:  RLF    78,F
03BC:  RLF    79,F
03BD:  RLF    7A,F
03BE:  DECFSZ 62,F
03BF:  GOTO   392
03C0:  BTFSS  63.7
03C1:  GOTO   3CD
03C2:  COMF   77,F
03C3:  COMF   78,F
03C4:  COMF   79,F
03C5:  COMF   7A,F
03C6:  INCF   77,F
03C7:  BTFSC  03.2
03C8:  INCF   78,F
03C9:  BTFSC  03.2
03CA:  INCF   79,F
03CB:  BTFSC  03.2
03CC:  INCF   7A,F
03CD:  MOVF   5E,W
03CE:  MOVWF  00
03CF:  INCF   04,F
03D0:  MOVF   5F,W
03D1:  MOVWF  00
03D2:  INCF   04,F
03D3:  MOVF   60,W
03D4:  MOVWF  00
03D5:  INCF   04,F
03D6:  MOVF   61,W
03D7:  MOVWF  00
03D8:  BCF    03.6
03D9:  RETURN
*
03F3:  MOVLW  20
03F4:  MOVWF  5A
03F5:  CLRF   56
03F6:  CLRF   57
03F7:  CLRF   58
03F8:  CLRF   59
03F9:  MOVF   51,W
03FA:  MOVWF  7A
03FB:  MOVF   50,W
03FC:  MOVWF  79
03FD:  MOVF   4F,W
03FE:  MOVWF  78
03FF:  MOVF   4E,W
0400:  MOVWF  77
0401:  BCF    03.0
0402:  BTFSS  77.0
0403:  GOTO   412
0404:  MOVF   52,W
0405:  ADDWF  56,F
0406:  MOVF   53,W
0407:  BTFSC  03.0
0408:  INCFSZ 53,W
0409:  ADDWF  57,F
040A:  MOVF   54,W
040B:  BTFSC  03.0
040C:  INCFSZ 54,W
040D:  ADDWF  58,F
040E:  MOVF   55,W
040F:  BTFSC  03.0
0410:  INCFSZ 55,W
0411:  ADDWF  59,F
0412:  RRF    59,F
0413:  RRF    58,F
0414:  RRF    57,F
0415:  RRF    56,F
0416:  RRF    7A,F
0417:  RRF    79,F
0418:  RRF    78,F
0419:  RRF    77,F
041A:  DECFSZ 5A,F
041B:  GOTO   401
*
04FA:  MOVF   00,F
04FB:  BTFSC  03.2
04FC:  GOTO   516
04FD:  BSF    03.6
04FE:  CLRF   19
04FF:  MOVF   04,W
0500:  MOVWF  18
0501:  BCF    19.0
0502:  BTFSC  03.7
0503:  BSF    19.0
0504:  MOVF   00,W
0505:  MOVWF  40
0506:  BCF    03.6
0507:  CALL   2D4
0508:  BSF    03.6
0509:  MOVF   18,W
050A:  MOVWF  04
050B:  BCF    03.7
050C:  BTFSC  19.0
050D:  BSF    03.7
050E:  INCF   04,F
050F:  BTFSS  03.2
0510:  GOTO   514
0511:  BCF    03.6
0512:  INCF   05,F
0513:  BSF    03.6
0514:  BCF    03.6
0515:  GOTO   4FA
0516:  RETURN
0517:  BSF    03.6
0518:  MOVF   15,W
0519:  CLRF   78
051A:  SUBWF  14,W
051B:  BTFSC  03.0
051C:  GOTO   520
051D:  MOVF   14,W
051E:  MOVWF  77
051F:  GOTO   52C
0520:  CLRF   77
0521:  MOVLW  08
0522:  MOVWF  16
0523:  RLF    14,F
0524:  RLF    77,F
0525:  MOVF   15,W
0526:  SUBWF  77,W
0527:  BTFSC  03.0
0528:  MOVWF  77
0529:  RLF    78,F
052A:  DECFSZ 16,F
052B:  GOTO   523
052C:  BCF    03.6
052D:  RETURN
*
0769:  MOVF   00,F
076A:  BTFSC  03.2
076B:  GOTO   786
076C:  BSF    03.6
076D:  CLRF   40
076E:  MOVF   04,W
076F:  MOVWF  3F
0770:  BCF    40.0
0771:  BTFSC  03.7
0772:  BSF    40.0
0773:  MOVF   00,W
0774:  BCF    03.6
0775:  BTFSS  0C.4
0776:  GOTO   775
0777:  MOVWF  19
0778:  BSF    03.6
0779:  MOVF   3F,W
077A:  MOVWF  04
077B:  BCF    03.7
077C:  BTFSC  40.0
077D:  BSF    03.7
077E:  INCF   04,F
077F:  BTFSS  03.2
0780:  GOTO   784
0781:  BCF    03.6
0782:  INCF   05,F
0783:  BSF    03.6
0784:  BCF    03.6
0785:  GOTO   769
0786:  RETURN
*
0A98:  CLRF   77
0A99:  CLRF   78
0A9A:  MOVF   1F,W
0A9B:  BCF    03.0
0A9C:  BTFSC  20.0
0A9D:  ADDWF  77,F
0A9E:  RRF    77,F
0A9F:  RRF    78,F
0AA0:  BTFSC  20.1
0AA1:  ADDWF  77,F
0AA2:  RRF    77,F
0AA3:  RRF    78,F
0AA4:  BTFSC  20.2
0AA5:  ADDWF  77,F
0AA6:  RRF    77,F
0AA7:  RRF    78,F
0AA8:  BTFSC  20.3
0AA9:  ADDWF  77,F
0AAA:  RRF    77,F
0AAB:  RRF    78,F
0AAC:  BTFSC  20.4
0AAD:  ADDWF  77,F
0AAE:  RRF    77,F
0AAF:  RRF    78,F
0AB0:  BTFSC  20.5
0AB1:  ADDWF  77,F
0AB2:  RRF    77,F
0AB3:  RRF    78,F
0AB4:  BTFSC  20.6
0AB5:  ADDWF  77,F
0AB6:  RRF    77,F
0AB7:  RRF    78,F
0AB8:  BTFSC  20.7
0AB9:  ADDWF  77,F
0ABA:  RRF    77,F
0ABB:  RRF    78,F
*
0D66:  BSF    0A.0
0D67:  BCF    0A.1
0D68:  BSF    0A.2
0D69:  ADDWF  02,F
0D6A:  GOTO   3D2
0D6B:  GOTO   3D3
0D6C:  GOTO   3E0
0D6D:  GOTO   3ED
0D6E:  GOTO   3F7
0D6F:  GOTO   401
*
0DED:  MOVLW  8E
0DEE:  MOVWF  77
0DEF:  MOVF   1D,W
0DF0:  MOVWF  78
0DF1:  MOVF   1C,W
0DF2:  MOVWF  79
0DF3:  CLRF   7A
0DF4:  MOVF   78,F
0DF5:  BTFSS  03.2
0DF6:  GOTO   601
0DF7:  MOVF   79,W
0DF8:  MOVWF  78
0DF9:  CLRF   79
0DFA:  MOVLW  08
0DFB:  SUBWF  77,F
0DFC:  MOVF   78,F
0DFD:  BTFSS  03.2
0DFE:  GOTO   601
0DFF:  CLRF   77
0E00:  GOTO   609
0E01:  BCF    03.0
0E02:  BTFSC  78.7
0E03:  GOTO   608
0E04:  RLF    79,F
0E05:  RLF    78,F
0E06:  DECF   77,F
0E07:  GOTO   601
0E08:  BCF    78.7
*
0E19:  MOVF   1C,W
0E1A:  BTFSC  03.2
0E1B:  GOTO   6DE
0E1C:  MOVWF  28
0E1D:  MOVF   20,W
0E1E:  BTFSC  03.2
0E1F:  GOTO   6DE
0E20:  SUBWF  28,F
0E21:  BTFSS  03.0
0E22:  GOTO   628
0E23:  MOVLW  7F
0E24:  ADDWF  28,F
0E25:  BTFSC  03.0
0E26:  GOTO   6DE
0E27:  GOTO   62E
0E28:  MOVLW  81
0E29:  SUBWF  28,F
0E2A:  BTFSS  03.0
0E2B:  GOTO   6DE
0E2C:  BTFSC  03.2
0E2D:  GOTO   6DE
0E2E:  MOVF   28,W
0E2F:  MOVWF  77
0E30:  CLRF   78
0E31:  CLRF   79
0E32:  CLRF   7A
0E33:  CLRF   27
0E34:  MOVF   1D,W
0E35:  MOVWF  26
0E36:  BSF    26.7
0E37:  MOVF   1E,W
0E38:  MOVWF  25
0E39:  MOVF   1F,W
0E3A:  MOVWF  24
0E3B:  MOVLW  19
0E3C:  MOVWF  28
0E3D:  MOVF   23,W
0E3E:  SUBWF  24,F
0E3F:  BTFSC  03.0
0E40:  GOTO   651
0E41:  MOVLW  01
0E42:  SUBWF  25,F
0E43:  BTFSC  03.0
0E44:  GOTO   651
0E45:  SUBWF  26,F
0E46:  BTFSC  03.0
0E47:  GOTO   651
0E48:  SUBWF  27,F
0E49:  BTFSC  03.0
0E4A:  GOTO   651
0E4B:  INCF   27,F
0E4C:  INCF   26,F
0E4D:  INCF   25,F
0E4E:  MOVF   23,W
0E4F:  ADDWF  24,F
0E50:  GOTO   683
0E51:  MOVF   22,W
0E52:  SUBWF  25,F
0E53:  BTFSC  03.0
0E54:  GOTO   66C
0E55:  MOVLW  01
0E56:  SUBWF  26,F
0E57:  BTFSC  03.0
0E58:  GOTO   66C
0E59:  SUBWF  27,F
0E5A:  BTFSC  03.0
0E5B:  GOTO   66C
0E5C:  INCF   27,F
0E5D:  INCF   26,F
0E5E:  MOVF   22,W
0E5F:  ADDWF  25,F
0E60:  MOVF   23,W
0E61:  ADDWF  24,F
0E62:  BTFSS  03.0
0E63:  GOTO   683
0E64:  INCF   25,F
0E65:  BTFSS  03.2
0E66:  GOTO   683
0E67:  INCF   26,F
0E68:  BTFSS  03.2
0E69:  GOTO   683
0E6A:  INCF   27,F
0E6B:  GOTO   683
0E6C:  MOVF   21,W
0E6D:  IORLW  80
0E6E:  SUBWF  26,F
0E6F:  BTFSC  03.0
0E70:  GOTO   682
0E71:  MOVLW  01
0E72:  SUBWF  27,F
0E73:  BTFSC  03.0
0E74:  GOTO   682
0E75:  INCF   27,F
0E76:  MOVF   21,W
0E77:  IORLW  80
0E78:  ADDWF  26,F
0E79:  MOVF   22,W
0E7A:  ADDWF  25,F
0E7B:  BTFSS  03.0
0E7C:  GOTO   660
0E7D:  INCF   26,F
0E7E:  BTFSS  03.2
0E7F:  GOTO   660
0E80:  INCF   27,F
0E81:  GOTO   660
0E82:  BSF    7A.0
0E83:  DECFSZ 28,F
0E84:  GOTO   686
0E85:  GOTO   691
0E86:  BCF    03.0
0E87:  RLF    24,F
0E88:  RLF    25,F
0E89:  RLF    26,F
0E8A:  RLF    27,F
0E8B:  BCF    03.0
0E8C:  RLF    7A,F
0E8D:  RLF    79,F
0E8E:  RLF    78,F
0E8F:  RLF    29,F
0E90:  GOTO   63D
0E91:  BTFSS  29.0
0E92:  GOTO   699
0E93:  BCF    03.0
0E94:  RRF    78,F
0E95:  RRF    79,F
0E96:  RRF    7A,F
0E97:  RRF    29,F
0E98:  GOTO   69C
0E99:  DECF   77,F
0E9A:  BTFSC  03.2
0E9B:  GOTO   6DE
0E9C:  BTFSC  29.7
0E9D:  GOTO   6C5
0E9E:  BCF    03.0
0E9F:  RLF    24,F
0EA0:  RLF    25,F
0EA1:  RLF    26,F
0EA2:  RLF    27,F
0EA3:  MOVF   23,W
0EA4:  SUBWF  24,F
0EA5:  BTFSC  03.0
0EA6:  GOTO   6B1
0EA7:  MOVLW  01
0EA8:  SUBWF  25,F
0EA9:  BTFSC  03.0
0EAA:  GOTO   6B1
0EAB:  SUBWF  26,F
0EAC:  BTFSC  03.0
0EAD:  GOTO   6B1
0EAE:  SUBWF  27,F
0EAF:  BTFSS  03.0
0EB0:  GOTO   6D4
0EB1:  MOVF   22,W
0EB2:  SUBWF  25,F
0EB3:  BTFSC  03.0
0EB4:  GOTO   6BC
0EB5:  MOVLW  01
0EB6:  SUBWF  26,F
0EB7:  BTFSC  03.0
0EB8:  GOTO   6BC
0EB9:  SUBWF  27,F
0EBA:  BTFSS  03.0
0EBB:  GOTO   6D4
0EBC:  MOVF   21,W
0EBD:  IORLW  80
0EBE:  SUBWF  26,F
0EBF:  BTFSC  03.0
0EC0:  GOTO   6C5
0EC1:  MOVLW  01
0EC2:  SUBWF  27,F
0EC3:  BTFSS  03.0
0EC4:  GOTO   6D4
0EC5:  INCF   7A,F
0EC6:  BTFSS  03.2
0EC7:  GOTO   6D4
0EC8:  INCF   79,F
0EC9:  BTFSS  03.2
0ECA:  GOTO   6D4
0ECB:  INCF   78,F
0ECC:  BTFSS  03.2
0ECD:  GOTO   6D4
0ECE:  INCF   77,F
0ECF:  BTFSC  03.2
0ED0:  GOTO   6DE
0ED1:  RRF    78,F
0ED2:  RRF    79,F
0ED3:  RRF    7A,F
0ED4:  MOVF   1D,W
0ED5:  MOVWF  28
0ED6:  MOVF   21,W
0ED7:  XORWF  28,F
0ED8:  BTFSS  28.7
0ED9:  GOTO   6DC
0EDA:  BSF    78.7
0EDB:  GOTO   6E2
0EDC:  BCF    78.7
0EDD:  GOTO   6E2
0EDE:  CLRF   77
0EDF:  CLRF   78
0EE0:  CLRF   79
0EE1:  CLRF   7A
*
0EEA:  MOVLW  8E
0EEB:  MOVWF  77
0EEC:  MOVF   1C,W
0EED:  SUBWF  77,F
0EEE:  MOVF   1D,W
0EEF:  MOVWF  79
0EF0:  MOVF   1E,W
0EF1:  MOVWF  78
0EF2:  BSF    79.7
0EF3:  MOVF   77,F
0EF4:  BTFSC  03.2
0EF5:  GOTO   701
0EF6:  BCF    03.0
0EF7:  MOVF   79,F
0EF8:  BTFSS  03.2
0EF9:  GOTO   6FD
0EFA:  MOVF   78,F
0EFB:  BTFSC  03.2
0EFC:  GOTO   701
0EFD:  RRF    79,F
0EFE:  RRF    78,F
0EFF:  DECFSZ 77,F
0F00:  GOTO   6F6
0F01:  BTFSS  1D.7
0F02:  GOTO   708
0F03:  COMF   78,F
0F04:  COMF   79,F
0F05:  INCF   78,F
0F06:  BTFSC  03.2
0F07:  INCF   79,F
*
10A5:  BCF    03.6
10A6:  MOVF   0B,W
10A7:  BSF    03.6
10A8:  MOVWF  3B
10A9:  BCF    03.6
10AA:  BCF    0B.7
10AB:  BSF    03.5
10AC:  BSF    03.6
10AD:  BSF    0C.7
10AE:  BSF    0C.0
10AF:  NOP
10B0:  NOP
10B1:  BCF    03.5
10B2:  BTFSS  3B.7
10B3:  GOTO   0B7
10B4:  BCF    03.6
10B5:  BSF    0B.7
10B6:  BSF    03.6
10B7:  MOVF   0C,W
10B8:  ANDLW  7F
10B9:  BTFSC  03.2
10BA:  GOTO   0F4
10BB:  MOVWF  3B
10BC:  MOVF   0D,W
10BD:  MOVWF  3C
10BE:  MOVF   0F,W
10BF:  MOVWF  3D
10C0:  MOVF   3B,W
10C1:  BCF    03.6
10C2:  BTFSS  0C.4
10C3:  GOTO   0C2
10C4:  MOVWF  19
10C5:  BSF    03.6
10C6:  MOVF   3C,W
10C7:  MOVWF  0D
10C8:  MOVF   3D,W
10C9:  MOVWF  0F
10CA:  BCF    03.6
10CB:  MOVF   0B,W
10CC:  BSF    03.6
10CD:  MOVWF  3E
10CE:  BCF    03.6
10CF:  BCF    0B.7
10D0:  BSF    03.5
10D1:  BSF    03.6
10D2:  BSF    0C.7
10D3:  BSF    0C.0
10D4:  NOP
10D5:  NOP
10D6:  BCF    03.5
10D7:  BTFSS  3E.7
10D8:  GOTO   0DC
10D9:  BCF    03.6
10DA:  BSF    0B.7
10DB:  BSF    03.6
10DC:  RLF    0C,W
10DD:  RLF    0E,W
10DE:  ANDLW  7F
10DF:  BTFSC  03.2
10E0:  GOTO   0F4
10E1:  MOVWF  3B
10E2:  MOVF   0D,W
10E3:  MOVWF  3C
10E4:  MOVF   0F,W
10E5:  MOVWF  3D
10E6:  MOVF   3B,W
10E7:  BCF    03.6
10E8:  BTFSS  0C.4
10E9:  GOTO   0E8
10EA:  MOVWF  19
10EB:  BSF    03.6
10EC:  MOVF   3C,W
10ED:  MOVWF  0D
10EE:  MOVF   3D,W
10EF:  MOVWF  0F
10F0:  INCF   0D,F
10F1:  BTFSC  03.2
10F2:  INCF   0F,F
10F3:  GOTO   0A5
....................  
.................... #list 
....................  
.................... #DEVICE ADC=10 
.................... #INCLUDE <STRING.H> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
*
072B:  BSF    03.6
072C:  MOVF   3F,W
072D:  MOVWF  43
072E:  MOVF   3E,W
072F:  MOVWF  42
0730:  MOVF   43,W
0731:  MOVWF  7A
0732:  MOVF   42,W
0733:  MOVWF  04
0734:  BCF    03.7
0735:  BTFSC  7A.0
0736:  BSF    03.7
0737:  MOVF   00,F
0738:  BTFSC  03.2
0739:  GOTO   73E
073A:  INCF   42,F
073B:  BTFSC  03.2
073C:  INCF   43,F
073D:  GOTO   730
....................    while(*s2 != '\0') 
073E:  MOVF   41,W
073F:  MOVWF  7A
0740:  MOVF   40,W
0741:  MOVWF  04
0742:  BCF    03.7
0743:  BTFSC  7A.0
0744:  BSF    03.7
0745:  MOVF   00,F
0746:  BTFSC  03.2
0747:  GOTO   75D
....................    { 
....................       *s = *s2; 
0748:  MOVF   40,W
0749:  MOVWF  04
074A:  BCF    03.7
074B:  BTFSC  41.0
074C:  BSF    03.7
074D:  MOVF   00,W
074E:  MOVWF  46
074F:  MOVF   42,W
0750:  MOVWF  04
0751:  BCF    03.7
0752:  BTFSC  43.0
0753:  BSF    03.7
0754:  MOVF   46,W
0755:  MOVWF  00
....................       ++s; 
0756:  INCF   42,F
0757:  BTFSC  03.2
0758:  INCF   43,F
....................       ++s2; 
0759:  INCF   40,F
075A:  BTFSC  03.2
075B:  INCF   41,F
075C:  GOTO   73E
....................    } 
....................  
....................    *s = '\0'; 
075D:  MOVF   42,W
075E:  MOVWF  04
075F:  BCF    03.7
0760:  BTFSC  43.0
0761:  BSF    03.7
0762:  CLRF   00
....................    return(s1); 
0763:  MOVF   3E,W
0764:  MOVWF  78
0765:  MOVF   3F,W
0766:  MOVWF  79
0767:  BCF    03.6
0768:  RETURN
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
*
0787:  BSF    03.6
0788:  MOVF   17,W
0789:  MOVWF  7A
078A:  MOVF   16,W
078B:  MOVWF  04
078C:  BCF    03.7
078D:  BTFSC  7A.0
078E:  BSF    03.7
078F:  MOVF   00,W
0790:  MOVWF  1A
0791:  MOVF   19,W
0792:  MOVWF  7A
0793:  MOVF   18,W
0794:  MOVWF  04
0795:  BCF    03.7
0796:  BTFSC  7A.0
0797:  BSF    03.7
0798:  MOVF   00,W
0799:  SUBWF  1A,W
079A:  BTFSS  03.2
079B:  GOTO   7B3
....................       if (*s1 == '\0') 
079C:  MOVF   17,W
079D:  MOVWF  7A
079E:  MOVF   16,W
079F:  MOVWF  04
07A0:  BCF    03.7
07A1:  BTFSC  7A.0
07A2:  BSF    03.7
07A3:  MOVF   00,F
07A4:  BTFSS  03.2
07A5:  GOTO   7A9
....................          return(0); 
07A6:  MOVLW  00
07A7:  MOVWF  78
07A8:  GOTO   7CB
07A9:  MOVF   17,W
07AA:  MOVWF  7A
07AB:  MOVF   16,W
07AC:  INCF   16,F
07AD:  BTFSC  03.2
07AE:  INCF   17,F
07AF:  INCF   18,F
07B0:  BTFSC  03.2
07B1:  INCF   19,F
07B2:  GOTO   788
....................    return((*s1 < *s2) ? -1: 1); 
07B3:  MOVF   17,W
07B4:  MOVWF  7A
07B5:  MOVF   16,W
07B6:  MOVWF  04
07B7:  BCF    03.7
07B8:  BTFSC  17.0
07B9:  BSF    03.7
07BA:  MOVF   00,W
07BB:  MOVWF  1A
07BC:  MOVF   19,W
07BD:  MOVWF  7A
07BE:  MOVF   18,W
07BF:  MOVWF  04
07C0:  BCF    03.7
07C1:  BTFSC  19.0
07C2:  BSF    03.7
07C3:  MOVF   00,W
07C4:  SUBWF  1A,W
07C5:  BTFSC  03.0
07C6:  GOTO   7C9
07C7:  MOVLW  FF
07C8:  GOTO   7CA
07C9:  MOVLW  01
07CA:  MOVWF  78
07CB:  BCF    03.6
07CC:  RETURN
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
*
0B57:  MOVF   17,W
0B58:  MOVWF  7A
0B59:  MOVF   16,W
0B5A:  MOVWF  04
0B5B:  BCF    03.7
0B5C:  BTFSC  7A.0
0B5D:  BSF    03.7
0B5E:  MOVF   18,W
0B5F:  SUBWF  00,W
0B60:  BTFSC  03.2
0B61:  GOTO   374
....................       if (*s == '\0') 
0B62:  MOVF   17,W
0B63:  MOVWF  7A
0B64:  MOVF   16,W
0B65:  MOVWF  04
0B66:  BCF    03.7
0B67:  BTFSC  7A.0
0B68:  BSF    03.7
0B69:  MOVF   00,F
0B6A:  BTFSS  03.2
0B6B:  GOTO   370
....................          return(0); 
0B6C:  MOVLW  00
0B6D:  MOVWF  78
0B6E:  MOVWF  79
0B6F:  GOTO   378
0B70:  INCF   16,F
0B71:  BTFSC  03.2
0B72:  INCF   17,F
0B73:  GOTO   357
....................    return(s); 
0B74:  MOVF   16,W
0B75:  MOVWF  78
0B76:  MOVF   17,W
0B77:  MOVWF  79
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
*
09C4:  MOVF   21,W
09C5:  MOVWF  25
09C6:  MOVF   20,W
09C7:  MOVWF  24
09C8:  MOVF   25,W
09C9:  MOVWF  7A
09CA:  MOVF   24,W
09CB:  MOVWF  04
09CC:  BCF    03.7
09CD:  BTFSC  7A.0
09CE:  BSF    03.7
09CF:  MOVF   00,F
09D0:  BTFSC  03.2
09D1:  GOTO   201
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
09D2:  MOVF   23,W
09D3:  MOVWF  27
09D4:  MOVF   22,W
09D5:  MOVWF  26
09D6:  MOVF   27,W
09D7:  MOVWF  7A
09D8:  MOVF   26,W
09D9:  MOVWF  04
09DA:  BCF    03.7
09DB:  BTFSC  7A.0
09DC:  BSF    03.7
09DD:  MOVF   00,F
09DE:  BTFSC  03.2
09DF:  GOTO   1FD
....................          if (*sc1 == *sc2) 
09E0:  MOVF   25,W
09E1:  MOVWF  7A
09E2:  MOVF   24,W
09E3:  MOVWF  04
09E4:  BCF    03.7
09E5:  BTFSC  7A.0
09E6:  BSF    03.7
09E7:  MOVF   00,W
09E8:  MOVWF  28
09E9:  MOVF   27,W
09EA:  MOVWF  7A
09EB:  MOVF   26,W
09EC:  MOVWF  04
09ED:  BCF    03.7
09EE:  BTFSC  7A.0
09EF:  BSF    03.7
09F0:  MOVF   00,W
09F1:  SUBWF  28,W
09F2:  BTFSS  03.2
09F3:  GOTO   1F9
....................             return(sc1); 
09F4:  MOVF   24,W
09F5:  MOVWF  78
09F6:  MOVF   25,W
09F7:  MOVWF  79
09F8:  GOTO   204
09F9:  INCF   26,F
09FA:  BTFSC  03.2
09FB:  INCF   27,F
09FC:  GOTO   1D6
09FD:  INCF   24,F
09FE:  BTFSC  03.2
09FF:  INCF   25,F
0A00:  GOTO   1C8
....................    return(0); 
0A01:  MOVLW  00
0A02:  MOVWF  78
0A03:  MOVWF  79
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
*
0951:  MOVF   21,W
0952:  MOVWF  25
0953:  MOVF   20,W
0954:  MOVWF  24
0955:  MOVF   25,W
0956:  MOVWF  7A
0957:  MOVF   24,W
0958:  MOVWF  04
0959:  BCF    03.7
095A:  BTFSC  7A.0
095B:  BSF    03.7
095C:  MOVF   00,F
095D:  BTFSC  03.2
095E:  GOTO   196
....................       for (sc2 = s2; ; sc2++) 
095F:  MOVF   23,W
0960:  MOVWF  27
0961:  MOVF   22,W
0962:  MOVWF  26
....................     if (*sc2 == '\0') 
0963:  MOVF   27,W
0964:  MOVWF  7A
0965:  MOVF   26,W
0966:  MOVWF  04
0967:  BCF    03.7
0968:  BTFSC  7A.0
0969:  BSF    03.7
096A:  MOVF   00,F
096B:  BTFSS  03.2
096C:  GOTO   17A
....................        return(sc1 - s1); 
096D:  MOVF   20,W
096E:  SUBWF  24,W
096F:  MOVWF  77
0970:  MOVF   25,W
0971:  MOVWF  7A
0972:  MOVF   21,W
0973:  BTFSS  03.0
0974:  INCFSZ 21,W
0975:  SUBWF  7A,F
0976:  MOVF   77,W
0977:  MOVWF  78
0978:  GOTO   1A1
0979:  GOTO   18E
....................          else if (*sc1 == *sc2) 
097A:  MOVF   25,W
097B:  MOVWF  7A
097C:  MOVF   24,W
097D:  MOVWF  04
097E:  BCF    03.7
097F:  BTFSC  7A.0
0980:  BSF    03.7
0981:  MOVF   00,W
0982:  MOVWF  28
0983:  MOVF   27,W
0984:  MOVWF  7A
0985:  MOVF   26,W
0986:  MOVWF  04
0987:  BCF    03.7
0988:  BTFSC  7A.0
0989:  BSF    03.7
098A:  MOVF   00,W
098B:  SUBWF  28,W
098C:  BTFSC  03.2
....................             break; 
098D:  GOTO   192
098E:  INCF   26,F
098F:  BTFSC  03.2
0990:  INCF   27,F
0991:  GOTO   163
0992:  INCF   24,F
0993:  BTFSC  03.2
0994:  INCF   25,F
0995:  GOTO   155
....................    return(sc1 - s1); 
0996:  MOVF   20,W
0997:  SUBWF  24,W
0998:  MOVWF  77
0999:  MOVF   25,W
099A:  MOVWF  7A
099B:  MOVF   21,W
099C:  BTFSS  03.0
099D:  INCFSZ 21,W
099E:  SUBWF  7A,F
099F:  MOVF   77,W
09A0:  MOVWF  78
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
*
1158:  BCF    03.6
1159:  CLRF   2B
115A:  CLRF   2C
....................  
....................    beg = (s1)? s1: save; 
*
0938:  BSF    03.6
0939:  MOVF   18,W
093A:  IORWF  19,W
093B:  BTFSC  03.2
093C:  GOTO   141
093D:  MOVF   19,W
093E:  MOVWF  7A
093F:  MOVF   18,W
0940:  GOTO   146
0941:  BCF    03.6
0942:  MOVF   2C,W
0943:  MOVWF  7A
0944:  MOVF   2B,W
0945:  BSF    03.6
0946:  MOVWF  1C
0947:  MOVF   7A,W
0948:  MOVWF  1D
....................    beg += strspn(beg, s2); 
0949:  MOVF   1D,W
094A:  MOVWF  21
094B:  MOVF   1C,W
094C:  MOVWF  20
094D:  MOVF   1B,W
094E:  MOVWF  23
094F:  MOVF   1A,W
0950:  MOVWF  22
*
09A1:  MOVF   78,W
09A2:  ADDWF  1C,F
09A3:  BTFSC  03.0
09A4:  INCF   1D,F
....................    if (*beg == '\0') 
09A5:  MOVF   1D,W
09A6:  MOVWF  7A
09A7:  MOVF   1C,W
09A8:  MOVWF  04
09A9:  BCF    03.7
09AA:  BTFSC  7A.0
09AB:  BSF    03.7
09AC:  MOVF   00,F
09AD:  BTFSS  03.2
09AE:  GOTO   1BC
....................    { 
....................       *save = ' '; 
09AF:  BCF    03.6
09B0:  MOVF   2B,W
09B1:  MOVWF  04
09B2:  BCF    03.7
09B3:  BTFSC  2C.0
09B4:  BSF    03.7
09B5:  MOVLW  20
09B6:  MOVWF  00
....................       return(0); 
09B7:  MOVLW  00
09B8:  MOVWF  78
09B9:  MOVWF  79
09BA:  GOTO   228
09BB:  BSF    03.6
....................    } 
....................    end = strpbrk(beg, s2); 
09BC:  MOVF   1D,W
09BD:  MOVWF  21
09BE:  MOVF   1C,W
09BF:  MOVWF  20
09C0:  MOVF   1B,W
09C1:  MOVWF  23
09C2:  MOVF   1A,W
09C3:  MOVWF  22
*
0A04:  MOVF   79,W
0A05:  MOVWF  1F
0A06:  MOVF   78,W
0A07:  MOVWF  1E
....................    if (*end != '\0') 
0A08:  MOVF   1F,W
0A09:  MOVWF  7A
0A0A:  MOVF   1E,W
0A0B:  MOVWF  04
0A0C:  BCF    03.7
0A0D:  BTFSC  7A.0
0A0E:  BSF    03.7
0A0F:  MOVF   00,F
0A10:  BTFSC  03.2
0A11:  GOTO   21B
....................    { 
....................       *end = '\0'; 
0A12:  MOVF   1E,W
0A13:  MOVWF  04
0A14:  BCF    03.7
0A15:  BTFSC  1F.0
0A16:  BSF    03.7
0A17:  CLRF   00
....................       end++; 
0A18:  INCF   1E,F
0A19:  BTFSC  03.2
0A1A:  INCF   1F,F
....................    } 
....................    save = end; 
0A1B:  MOVF   1F,W
0A1C:  BCF    03.6
0A1D:  MOVWF  2C
0A1E:  BSF    03.6
0A1F:  MOVF   1E,W
0A20:  BCF    03.6
0A21:  MOVWF  2B
....................    return(beg); 
0A22:  BSF    03.6
0A23:  MOVF   1C,W
0A24:  MOVWF  78
0A25:  MOVF   1D,W
0A26:  MOVWF  79
0A27:  BCF    03.6
0A28:  RETURN
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
*
0B80:  MOVF   17,W
0B81:  MOVWF  19
0B82:  MOVF   16,W
0B83:  MOVWF  18
0B84:  MOVF   19,W
0B85:  MOVWF  7A
0B86:  MOVF   18,W
0B87:  MOVWF  04
0B88:  BCF    03.7
0B89:  BTFSC  7A.0
0B8A:  BSF    03.7
0B8B:  MOVF   00,F
0B8C:  BTFSC  03.2
0B8D:  GOTO   392
0B8E:  INCF   18,F
0B8F:  BTFSC  03.2
0B90:  INCF   19,F
0B91:  GOTO   384
....................    return(sc - s); 
0B92:  MOVF   16,W
0B93:  SUBWF  18,W
0B94:  MOVWF  77
0B95:  MOVF   19,W
0B96:  MOVWF  7A
0B97:  MOVF   17,W
0B98:  BTFSS  03.0
0B99:  INCFSZ 17,W
0B9A:  SUBWF  7A,F
0B9B:  MOVF   77,W
0B9C:  MOVWF  78
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #INCLUDE <STDLIB.H> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... /* Standart template: float strtof(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... float strtof(char *s,char *endptr); 
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s,char *endptr); 
.................... float64 strtod(char *s,char *endptr); 
.................... #else 
.................... //provided for compatibility 
.................... #define strtof48(s, e) strtof(s, e) 
.................... #define strtod(s, e) strtof(s, e) 
.................... #endif 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof(s)   strtof(s, 0) 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof48(s) strtof48(s, 0) 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof64(s) strtod(s, 0) 
.................... #endif 
....................  
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float atoe(char * s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s); 
.................... #endif 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... unsigned int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................  
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
*
0A29:  BSF    03.6
0A2A:  CLRF   1D
....................    sign = 0; 
0A2B:  CLRF   1B
....................    base = 10; 
0A2C:  MOVLW  0A
0A2D:  MOVWF  1C
....................    result = 0; 
0A2E:  CLRF   1A
....................  
....................    if (!s) 
0A2F:  MOVF   18,W
0A30:  IORWF  19,W
0A31:  BTFSS  03.2
0A32:  GOTO   236
....................       return 0; 
0A33:  MOVLW  00
0A34:  MOVWF  78
0A35:  GOTO   329
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
0A36:  MOVF   1D,W
0A37:  INCF   1D,F
0A38:  ADDWF  18,W
0A39:  MOVWF  04
0A3A:  BCF    03.7
0A3B:  BTFSC  19.0
0A3C:  BSF    03.7
0A3D:  MOVF   00,W
0A3E:  MOVWF  1E
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
0A3F:  MOVF   1E,W
0A40:  SUBLW  2D
0A41:  BTFSS  03.2
0A42:  GOTO   24F
....................    { 
....................       sign = 1;         // Set the sign to negative 
0A43:  MOVLW  01
0A44:  MOVWF  1B
....................       c = s[index++]; 
0A45:  MOVF   1D,W
0A46:  INCF   1D,F
0A47:  ADDWF  18,W
0A48:  MOVWF  04
0A49:  BCF    03.7
0A4A:  BTFSC  19.0
0A4B:  BSF    03.7
0A4C:  MOVF   00,W
0A4D:  MOVWF  1E
....................    } 
0A4E:  GOTO   25C
....................    else if (c == '+') 
0A4F:  MOVF   1E,W
0A50:  SUBLW  2B
0A51:  BTFSS  03.2
0A52:  GOTO   25C
....................    { 
....................       c = s[index++]; 
0A53:  MOVF   1D,W
0A54:  INCF   1D,F
0A55:  ADDWF  18,W
0A56:  MOVWF  04
0A57:  BCF    03.7
0A58:  BTFSC  19.0
0A59:  BSF    03.7
0A5A:  MOVF   00,W
0A5B:  MOVWF  1E
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
0A5C:  MOVF   1E,W
0A5D:  SUBLW  2F
0A5E:  BTFSC  03.0
0A5F:  GOTO   31F
0A60:  MOVF   1E,W
0A61:  SUBLW  39
0A62:  BTFSS  03.0
0A63:  GOTO   31F
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
0A64:  MOVF   1E,W
0A65:  SUBLW  30
0A66:  BTFSS  03.2
0A67:  GOTO   288
0A68:  MOVF   1D,W
0A69:  ADDWF  18,W
0A6A:  MOVWF  04
0A6B:  BCF    03.7
0A6C:  BTFSC  19.0
0A6D:  BSF    03.7
0A6E:  MOVF   00,W
0A6F:  SUBLW  78
0A70:  BTFSC  03.2
0A71:  GOTO   27C
0A72:  MOVF   1D,W
0A73:  ADDWF  18,W
0A74:  MOVWF  04
0A75:  BCF    03.7
0A76:  BTFSC  19.0
0A77:  BSF    03.7
0A78:  MOVF   00,W
0A79:  SUBLW  58
0A7A:  BTFSS  03.2
0A7B:  GOTO   288
....................       { 
....................          base = 16; 
0A7C:  MOVLW  10
0A7D:  MOVWF  1C
....................          index++; 
0A7E:  INCF   1D,F
....................          c = s[index++]; 
0A7F:  MOVF   1D,W
0A80:  INCF   1D,F
0A81:  ADDWF  18,W
0A82:  MOVWF  04
0A83:  BCF    03.7
0A84:  BTFSC  19.0
0A85:  BSF    03.7
0A86:  MOVF   00,W
0A87:  MOVWF  1E
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
0A88:  MOVF   1C,W
0A89:  SUBLW  0A
0A8A:  BTFSS  03.2
0A8B:  GOTO   2CD
....................       { 
....................          while (c >= '0' && c <= '9') 
0A8C:  MOVF   1E,W
0A8D:  SUBLW  2F
0A8E:  BTFSC  03.0
0A8F:  GOTO   2CC
0A90:  MOVF   1E,W
0A91:  SUBLW  39
0A92:  BTFSS  03.0
0A93:  GOTO   2CC
....................          { 
....................             result = 10*result + (c - '0'); 
0A94:  MOVLW  0A
0A95:  MOVWF  1F
0A96:  MOVF   1A,W
0A97:  MOVWF  20
*
0ABC:  MOVF   78,W
0ABD:  MOVWF  1F
0ABE:  MOVLW  30
0ABF:  SUBWF  1E,W
0AC0:  ADDWF  1F,W
0AC1:  MOVWF  1A
....................             c = s[index++]; 
0AC2:  MOVF   1D,W
0AC3:  INCF   1D,F
0AC4:  ADDWF  18,W
0AC5:  MOVWF  04
0AC6:  BCF    03.7
0AC7:  BTFSC  19.0
0AC8:  BSF    03.7
0AC9:  MOVF   00,W
0ACA:  MOVWF  1E
0ACB:  GOTO   28C
....................          } 
....................       } 
0ACC:  GOTO   31F
....................       else if (base == 16)    // The number is a hexa number 
0ACD:  MOVF   1C,W
0ACE:  SUBLW  10
0ACF:  BTFSS  03.2
0AD0:  GOTO   31F
....................       { 
....................          c = toupper(c); 
0AD1:  MOVF   1E,W
0AD2:  SUBLW  60
0AD3:  BTFSC  03.0
0AD4:  GOTO   2DC
0AD5:  MOVF   1E,W
0AD6:  SUBLW  7A
0AD7:  BTFSS  03.0
0AD8:  GOTO   2DC
0AD9:  MOVF   1E,W
0ADA:  ANDLW  DF
0ADB:  GOTO   2DD
0ADC:  MOVF   1E,W
0ADD:  MOVWF  1E
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
0ADE:  MOVF   1E,W
0ADF:  SUBLW  2F
0AE0:  BTFSC  03.0
0AE1:  GOTO   2E6
0AE2:  MOVF   1E,W
0AE3:  SUBLW  39
0AE4:  BTFSC  03.0
0AE5:  GOTO   2EE
0AE6:  MOVF   1E,W
0AE7:  SUBLW  40
0AE8:  BTFSC  03.0
0AE9:  GOTO   31F
0AEA:  MOVF   1E,W
0AEB:  SUBLW  46
0AEC:  BTFSS  03.0
0AED:  GOTO   31F
....................          { 
....................             if (c >= '0' && c <= '9') 
0AEE:  MOVF   1E,W
0AEF:  SUBLW  2F
0AF0:  BTFSC  03.0
0AF1:  GOTO   2FF
0AF2:  MOVF   1E,W
0AF3:  SUBLW  39
0AF4:  BTFSS  03.0
0AF5:  GOTO   2FF
....................                result = (result << 4) + (c - '0'); 
0AF6:  SWAPF  1A,W
0AF7:  MOVWF  1F
0AF8:  MOVLW  F0
0AF9:  ANDWF  1F,F
0AFA:  MOVLW  30
0AFB:  SUBWF  1E,W
0AFC:  ADDWF  1F,W
0AFD:  MOVWF  1A
0AFE:  GOTO   308
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
0AFF:  SWAPF  1A,W
0B00:  MOVWF  1F
0B01:  MOVLW  F0
0B02:  ANDWF  1F,F
0B03:  MOVLW  41
0B04:  SUBWF  1E,W
0B05:  ADDLW  0A
0B06:  ADDWF  1F,W
0B07:  MOVWF  1A
....................  
....................             c = s[index++]; 
0B08:  MOVF   1D,W
0B09:  INCF   1D,F
0B0A:  ADDWF  18,W
0B0B:  MOVWF  04
0B0C:  BCF    03.7
0B0D:  BTFSC  19.0
0B0E:  BSF    03.7
0B0F:  MOVF   00,W
0B10:  MOVWF  1E
....................             c = toupper(c); 
0B11:  MOVF   1E,W
0B12:  SUBLW  60
0B13:  BTFSC  03.0
0B14:  GOTO   31C
0B15:  MOVF   1E,W
0B16:  SUBLW  7A
0B17:  BTFSS  03.0
0B18:  GOTO   31C
0B19:  MOVF   1E,W
0B1A:  ANDLW  DF
0B1B:  GOTO   31D
0B1C:  MOVF   1E,W
0B1D:  MOVWF  1E
0B1E:  GOTO   2DE
....................          } 
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
0B1F:  DECFSZ 1B,W
0B20:  GOTO   327
0B21:  MOVF   1C,W
0B22:  SUBLW  0A
0B23:  BTFSS  03.2
0B24:  GOTO   327
....................        result = -result; 
0B25:  COMF   1A,F
0B26:  INCF   1A,F
....................  
....................    return(result); 
0B27:  MOVF   1A,W
0B28:  MOVWF  78
0B29:  BCF    03.6
0B2A:  RETURN
.................... } 
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
*
03DA:  BSF    03.6
03DB:  CLRF   49
03DC:  CLRF   48
03DD:  CLRF   47
03DE:  MOVLW  01
03DF:  MOVWF  46
03E0:  CLRF   4B
03E1:  CLRF   4C
.................... { 
....................      unsigned int32 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
03E2:  BTFSS  42.7
03E3:  GOTO   424
....................          sign=1;        // Check for negative number 
03E4:  MOVLW  01
03E5:  MOVWF  4B
....................          num*=-1; 
03E6:  MOVF   42,W
03E7:  MOVWF  51
03E8:  MOVF   41,W
03E9:  MOVWF  50
03EA:  MOVF   40,W
03EB:  MOVWF  4F
03EC:  MOVF   3F,W
03ED:  MOVWF  4E
03EE:  MOVLW  FF
03EF:  MOVWF  55
03F0:  MOVWF  54
03F1:  MOVWF  53
03F2:  MOVWF  52
*
041C:  MOVF   7A,W
041D:  MOVWF  42
041E:  MOVF   79,W
041F:  MOVWF  41
0420:  MOVF   78,W
0421:  MOVWF  40
0422:  MOVF   77,W
0423:  MOVWF  3F
....................      } 
....................  
....................      while(temp>0) { 
0424:  MOVF   46,F
0425:  BTFSS  03.2
0426:  GOTO   430
0427:  MOVF   47,F
0428:  BTFSS  03.2
0429:  GOTO   430
042A:  MOVF   48,F
042B:  BTFSS  03.2
042C:  GOTO   430
042D:  MOVF   49,F
042E:  BTFSC  03.2
042F:  GOTO   4AC
....................          temp=(num/base); 
0430:  BCF    03.1
0431:  MOVF   42,W
0432:  MOVWF  59
0433:  MOVF   41,W
0434:  MOVWF  58
0435:  MOVF   40,W
0436:  MOVWF  57
0437:  MOVF   3F,W
0438:  MOVWF  56
0439:  CLRF   5D
043A:  CLRF   5C
043B:  CLRF   5B
043C:  MOVF   43,W
043D:  MOVWF  5A
043E:  BCF    03.6
043F:  CALL   35E
0440:  MOVF   7A,W
0441:  BSF    03.6
0442:  MOVWF  49
0443:  MOVF   79,W
0444:  MOVWF  48
0445:  MOVF   78,W
0446:  MOVWF  47
0447:  MOVF   77,W
0448:  MOVWF  46
....................          s[cnt]=(num%base)+'0';    // Conversion 
0449:  MOVF   4C,W
044A:  ADDWF  44,W
044B:  MOVWF  78
044C:  MOVF   45,W
044D:  MOVWF  7A
044E:  BTFSC  03.0
044F:  INCF   7A,F
0450:  MOVF   78,W
0451:  MOVWF  4E
0452:  MOVF   7A,W
0453:  MOVWF  4F
0454:  CLRF   51
0455:  MOVF   04,W
0456:  MOVWF  50
0457:  BCF    51.0
0458:  BTFSC  03.7
0459:  BSF    51.0
045A:  BSF    03.1
045B:  MOVLW  52
045C:  MOVWF  04
045D:  BSF    03.7
045E:  MOVF   42,W
045F:  MOVWF  59
0460:  MOVF   41,W
0461:  MOVWF  58
0462:  MOVF   40,W
0463:  MOVWF  57
0464:  MOVF   3F,W
0465:  MOVWF  56
0466:  CLRF   5D
0467:  CLRF   5C
0468:  CLRF   5B
0469:  MOVF   43,W
046A:  MOVWF  5A
046B:  BCF    03.6
046C:  CALL   35E
046D:  BSF    03.6
046E:  MOVF   50,W
046F:  MOVWF  04
0470:  BCF    03.7
0471:  BTFSC  51.0
0472:  BSF    03.7
0473:  MOVLW  30
0474:  ADDWF  52,W
0475:  MOVWF  77
0476:  MOVF   53,W
0477:  MOVWF  78
0478:  MOVLW  00
0479:  BTFSC  03.0
047A:  MOVLW  01
047B:  ADDWF  78,F
047C:  MOVF   54,W
047D:  MOVWF  79
047E:  MOVLW  00
047F:  BTFSC  03.0
0480:  MOVLW  01
0481:  ADDWF  79,F
0482:  MOVF   55,W
0483:  MOVWF  7A
0484:  MOVLW  00
0485:  BTFSC  03.0
0486:  MOVLW  01
0487:  ADDWF  7A,F
0488:  MOVF   4E,W
0489:  MOVWF  04
048A:  BCF    03.7
048B:  BTFSC  4F.0
048C:  BSF    03.7
048D:  MOVF   77,W
048E:  MOVWF  00
....................  
....................          if(s[cnt]>0x39) 
048F:  MOVF   4C,W
0490:  ADDWF  44,W
0491:  MOVWF  04
0492:  BCF    03.7
0493:  BTFSC  45.0
0494:  BSF    03.7
0495:  MOVF   00,W
0496:  SUBLW  39
0497:  BTFSC  03.0
0498:  GOTO   4A2
....................             s[cnt]+=0x7; 
0499:  MOVF   4C,W
049A:  ADDWF  44,W
049B:  MOVWF  04
049C:  BCF    03.7
049D:  BTFSC  45.0
049E:  BSF    03.7
049F:  MOVLW  07
04A0:  ADDWF  00,W
04A1:  MOVWF  00
....................  
....................          cnt++; 
04A2:  INCF   4C,F
....................          num=temp; 
04A3:  MOVF   49,W
04A4:  MOVWF  42
04A5:  MOVF   48,W
04A6:  MOVWF  41
04A7:  MOVF   47,W
04A8:  MOVWF  40
04A9:  MOVF   46,W
04AA:  MOVWF  3F
04AB:  GOTO   424
....................      } 
....................  
....................      if(sign==1) { 
04AC:  DECFSZ 4B,W
04AD:  GOTO   4B7
....................          s[cnt]=0x2D;      // Negative sign 
04AE:  MOVF   4C,W
04AF:  ADDWF  44,W
04B0:  MOVWF  04
04B1:  BCF    03.7
04B2:  BTFSC  45.0
04B3:  BSF    03.7
04B4:  MOVLW  2D
04B5:  MOVWF  00
....................          cnt++; 
04B6:  INCF   4C,F
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
04B7:  CLRF   4A
04B8:  BCF    03.0
04B9:  RRF    4C,W
04BA:  SUBWF  4A,W
04BB:  BTFSC  03.0
04BC:  GOTO   4ED
....................  
....................          c=s[i]; 
04BD:  MOVF   4A,W
04BE:  ADDWF  44,W
04BF:  MOVWF  04
04C0:  BCF    03.7
04C1:  BTFSC  45.0
04C2:  BSF    03.7
04C3:  MOVF   00,W
04C4:  MOVWF  4D
....................          s[i]=s[cnt-i-1];        // Reverse the number 
04C5:  MOVF   4A,W
04C6:  ADDWF  44,W
04C7:  MOVWF  78
04C8:  MOVF   45,W
04C9:  MOVWF  7A
04CA:  BTFSC  03.0
04CB:  INCF   7A,F
04CC:  MOVF   78,W
04CD:  MOVWF  4E
04CE:  MOVF   7A,W
04CF:  MOVWF  4F
04D0:  MOVF   4A,W
04D1:  SUBWF  4C,W
04D2:  ADDLW  FF
04D3:  ADDWF  44,W
04D4:  MOVWF  04
04D5:  BCF    03.7
04D6:  BTFSC  45.0
04D7:  BSF    03.7
04D8:  MOVF   00,W
04D9:  MOVWF  50
04DA:  MOVF   4E,W
04DB:  MOVWF  04
04DC:  BCF    03.7
04DD:  BTFSC  4F.0
04DE:  BSF    03.7
04DF:  MOVF   50,W
04E0:  MOVWF  00
....................          s[cnt-i-1]=c; 
04E1:  MOVF   4A,W
04E2:  SUBWF  4C,W
04E3:  ADDLW  FF
04E4:  ADDWF  44,W
04E5:  MOVWF  04
04E6:  BCF    03.7
04E7:  BTFSC  45.0
04E8:  BSF    03.7
04E9:  MOVF   4D,W
04EA:  MOVWF  00
04EB:  INCF   4A,F
04EC:  GOTO   4B8
....................      } 
....................      s[cnt]='\0';     // End the string 
04ED:  MOVF   4C,W
04EE:  ADDWF  44,W
04EF:  MOVWF  04
04F0:  BCF    03.7
04F1:  BTFSC  45.0
04F2:  BSF    03.7
04F3:  CLRF   00
....................      return s; 
04F4:  MOVF   44,W
04F5:  MOVWF  78
04F6:  MOVF   45,W
04F7:  MOVWF  79
04F8:  BCF    03.6
04F9:  RETURN
.................... } 
....................  
.................... #if defined(__PCD__) 
....................  
.................... char * itoa(signed int48 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int48 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... char * itoa(signed int64 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int64 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................       
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1;         
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................              
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #endif 
....................  
.................... float strtof(char *s, char *endptr) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s, char *endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float48)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float48)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s, char *endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float64)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float64)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtoulGO; 
....................  
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................    { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... int8 mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #if !defined(__PCD__) 
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2);  
.................... #else  
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2);  
.................... #endif 
....................  
....................  
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    unsigned int8 t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=1; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = 0; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
.................... #INCLUDE <STDIO.H> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDIO 
.................... #define _STDIO 
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #ifndef getc 
.................... #define getc getch 
.................... #define getchar getch 
.................... #define puts(s) {printf(s); putchar(13); putchar(10);} 
.................... #define putc putchar 
.................... #endif 
.................... /* maps error number to an error message. Writes a sequence of characters to 
.................... stderr stream thus: if s is not null then string pointed to by s follwed by 
.................... a colon (:) and a space and the appropriate error message returned by strerror 
.................... function with argument errno 
....................  
.................... Returns: no value 
.................... */ 
....................  
.................... #ifdef _ERRNO 
.................... void perror(char *s) 
.................... { 
....................   if(s) 
....................   fprintf(STDERR,"%s: ",s); 
....................   fprintf(STDERR,"%s\r\n",strerror(errno)); 
.................... } 
.................... #endif 
.................... #endif 
....................  
.................... #INCLUDE <MATH.H> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2011 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                    //// 
.................... //// History:                                                           //// 
.................... ////  * 9/20/2001 :  Improvments are made to sin/cos code.              //// 
.................... ////                 The code now is small, much faster,                //// 
.................... ////                 and more accurate.                                 //// 
.................... ////  * 2/21/2007 :  Compiler handles & operator differently and does   //// 
.................... ////                 not return generic (int8 *) so type cast is done   //// 
.................... ////  * 6/19/2010 :  Divisions by constants converted to multiplication //// 
.................... ////                 by its inverse to improve computation speed        //// 
.................... ////  * 1/21/2011 :  Constants used for double precision math updated   //// 
.................... ////                 Updated routines include 64 bit versions of cos,   //// 
.................... ////                 asin,atan,exp,log and dependant functions          //// 
.................... ////  * 1/31/2011 :  Optimized current 32-bit float routines for cos    //// 
.................... ////                 and log function                                   //// 
.................... ////  * 6/13/2011 :  Fixed PCD overload CEIL_FLOOR functions for values //// 
.................... ////                 greater then 10000000 and less then -10000000      //// 
.................... ////                                                                    //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef MATH_H 
.................... #define MATH_H 
....................  
.................... #ifdef PI 
.................... #undef  PI 
.................... #endif 
.................... #define PI     3.1415926535897932 
....................  
....................  
.................... #define SQRT2  1.4142135623730950 
....................  
.................... //float const ps[4] = {5.9304945, 21.125224, 8.9403076, 0.29730279}; 
.................... //float const qs[4] = {1.0000000, 15.035723, 17.764134, 2.4934718}; 
....................  
.................... ///////////////////////////// Round Functions ////////////////////////////// 
....................  
.................... float32 CEIL_FLOOR(float32 x, unsigned int8 n) 
.................... { 
....................    float32 y, res; 
....................    unsigned int16 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................       res = (float32)(unsigned int16)y; 
....................  
....................  else if (y < 10000000.0) 
....................    {  
....................       l = (unsigned int16)(y*0.000030517578125); 
....................       y = 32768.0*(y*0.000030517578125 - (float32)l); 
....................       res = 32768.0*(float32)l; 
....................       res += (float32)(unsigned int16)y; 
....................    } 
....................  
....................  else 
....................   res = y; 
....................  
....................  y = y - (float32)(unsigned int16)y; 
....................  
....................  if (s) 
....................   res = -res; 
....................  
....................  if (y != 0) 
....................  { 
....................   if (s == 1 && n == 0) 
....................    res -= 1.0; 
....................  
....................   if (s == 0 && n == 1) 
....................    res += 1.0; 
....................  } 
....................  if (x == 0) 
....................     res = 0; 
....................  
....................  return (res); 
.................... } 
....................  
.................... // Overloaded Functions to take care for new Data types in PCD 
.................... // Overloaded function CEIL_FLOOR() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 CEIL_FLOOR(float48 x, unsigned int8 n) 
.................... { 
....................    float48 y, res; 
....................    unsigned int32 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................       res = (float48)(unsigned int16)y; 
....................  
....................    else if (y < 549755813888.0) 
....................    { 
....................       l = (unsigned int32)(y*0.000030517578125); 
....................       y = 32768.0*(y*0.000030517578125 - (float48)l); 
....................       res = 32768.0*(float48)l; 
....................       res += (float48)(unsigned int16)y; 
....................    } 
....................    else 
....................    {   
....................       res = y; 
....................       y = 0.0; 
....................    } 
....................     
....................    if(y != 0) 
....................       y = y - (float48)(unsigned int16)y; 
....................  
....................    if (s) 
....................       res = -res; 
....................  
....................    if (y != 0) 
....................    { 
....................       if (s == 1 && n == 0) 
....................          res -= 1.0; 
....................  
....................       if (s == 0 && n == 1) 
....................          res += 1.0; 
....................    } 
....................    if (x == 0) 
....................       res = 0; 
....................  
....................    return (res); 
.................... } 
....................  
....................  
.................... // Overloaded function CEIL_FLOOR() for data type - Float64 
.................... float64 CEIL_FLOOR(float64 x, unsigned int8 n) 
.................... { 
....................    float64 y, res; 
....................    int64 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................       res = (float64)(unsigned int16)y; 
....................    else if (y < 4503599627370496.0) 
....................    { 
....................       l = (int64)(y*0.000030517578125); 
....................       y = 32768.0*(y*0.000030517578125 - (float64)l); 
....................       res = 32768.0*(float64)l; 
....................       res += (float64)(unsigned int16)y; 
....................    } 
....................    else 
....................    { 
....................       res = y; 
....................       y = 0.0; 
....................    } 
....................     
....................    if(y != 0) 
....................       y = y - (float64)(unsigned int16)y; 
....................  
....................    if (s) 
....................       res = -res; 
....................  
....................    if (y != 0) 
....................    { 
....................       if (s == 1 && n == 0) 
....................          res -= 1.0; 
....................  
....................       if (s == 0 && n == 1) 
....................          res += 1.0; 
....................    } 
....................     
....................    if (x == 0) 
....................       res = 0; 
....................  
....................    return (res); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float floor(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : rounds down the number x. 
.................... // Date : N/A 
.................... // 
.................... float32 floor(float32 x) 
.................... { 
....................    return CEIL_FLOOR(x,0); 
.................... } 
.................... // Following 2 functions are overloaded functions of floor() for PCD 
.................... // Overloaded function floor() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 floor(float48 x) 
.................... { 
....................    return CEIL_FLOOR(x, 0); 
.................... } 
....................  
.................... // Overloaded function floor() for data type - Float64 
.................... float64 floor(float64 x) 
.................... { 
....................    return CEIL_FLOOR(x, 0); 
.................... } 
.................... #endif 
....................  
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float ceil(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : rounds up the number x. 
.................... // Date : N/A 
.................... // 
.................... float32 ceil(float32 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
.................... // Following 2 functions are overloaded functions of ceil() for PCD 
.................... // Overloaded function ceil() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 ceil(float48 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
....................  
.................... // Overloaded function ceil() for data type - Float64 
.................... float64 ceil(float64 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
.................... #endif 
....................  
....................  //////////////////////////////////////////////////////////////////////////// 
.................... //   float fabs(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the absolute value of floating point number x 
.................... // Returns : returns the absolute value of x 
.................... // Date : N/A 
.................... // 
.................... #define fabs abs 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float fmod(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the floating point remainder of x/y 
.................... // Returns : returns the value of x= i*y, for some integer i such that, if y 
.................... // is non zero, the result has the same isgn of x na dmagnitude less than the 
.................... // magnitude of y. If y is zero then a domain error occurs. 
.................... // Date : N/A 
.................... // 
....................  
.................... float fmod(float32 x,float32 y) 
.................... { 
....................    float32 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... //Overloaded function for fmod() for PCD 
.................... // Overloaded function fmod() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 fmod(float48 x,float48 y) 
.................... { 
....................    float48 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... // Overloaded function fmod() for data type - Float64 
.................... float64 fmod(float64 x,float64 y) 
.................... { 
....................    float64 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... #endif 
.................... //////////////////// Exponential and logarithmic functions //////////////////// 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float exp(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (e^x) 
.................... // Date : N/A 
.................... // 
.................... #define LN2 0.6931471805599453 
.................... #define LN2_INV 1.4426950408889634073 
....................  
.................... float const pe[6] = {0.000207455774, 0.00127100575, 0.00965065093, 
....................                      0.0554965651,  0.240227138,  0.693147172}; 
....................  
....................  
.................... float32 exp(float32 x) 
.................... { 
....................    float32 y, res, r; 
....................    #if defined(__PCD__) 
....................    int8 data1; 
....................    #endif 
....................    signed int8 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 88.722838) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    n = (signed int16)(x*LN2_INV); 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
.................... #if !defined(__PCD__) 
....................    *((unsigned int8 *)(&res)) = n + 0x7F; 
.................... #endif 
....................  
.................... #if defined(__PCD__)  // Takes care of IEEE format for PCD 
....................    data1 = n+0x7F; 
....................    if(bit_test(data1,0)) 
....................    bit_set(*(((unsigned int8 *)(&res)+2)),7); 
....................    rotate_right(&data1,1); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&res)+3)) = data1; 
.................... #endif 
....................  
....................    y = y*LN2_INV - (float32)n; 
....................  
....................    r = pe[0]*y + pe[1]; 
....................    r = r*y + pe[2]; 
....................    r = r*y + pe[3]; 
....................    r = r*y + pe[4]; 
....................    r = r*y + pe[5]; 
....................  
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
....................  
....................  
.................... //Overloaded function for exp() for PCD 
.................... // Overloaded function exp() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 exp(float48 x) 
.................... { 
....................    float48 y, res, r; 
....................    int8 data1; 
....................    signed int8 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 88.722838) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    n = (signed int16)(x*LN2_INV); 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
....................  
....................    data1 = n+0x7F; 
....................    if(bit_test(data1,0)) 
....................    bit_set(*(((unsigned int8 *)(&res)+4)),7); 
....................    rotate_right(&data1,1); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&res)+5)) = data1; 
....................  
....................    y = y*LN2_INV - (float48)n; 
....................  
....................    r = pe[0]*y + pe[1]; 
....................    r = r*y + pe[2]; 
....................    r = r*y + pe[3]; 
....................    r = r*y + pe[4]; 
....................    r = r*y + pe[5]; 
....................  
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function exp() for data type - Float64 
.................... float64 const pe_64[12] ={9.30741400474913e-011,-4.28655416283316e-011, 
....................                           8.71486547014137e-009,9.84458531538385e-008, 
....................                           1.32588296983536e-006,1.52489283823016e-005, 
....................                           0.000154037598423921,0.00133335487036216, 
....................                           0.00961812936407326,0.0555041086222122, 
....................                           0.240226506962827,0.693147180559823}; 
....................  
.................... float64 exp(float64 x) 
.................... { 
....................    float64 y, res, r; 
....................    unsigned int16 data1, data2; 
....................    unsigned int16 *p; 
....................    signed int16 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 709.7827128) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x*LN2_INV; 
....................    n = (signed int16)y; 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
....................  
.................... #if !defined(__PCD__) 
....................    *((unsigned int16 *)(&res)) = n + 0x7F; 
.................... #endif 
....................    p= (((unsigned int16 *)(&res))+3); 
....................    data1 = *p; 
....................    data2 = *p;    
....................    data1 = n + 0x3FF; 
....................    data1 = data1 <<4; 
....................    if(bit_test(data2,15)) 
....................    bit_set(data1,15); 
....................    data2 = data2 & 0x000F; 
....................    data1 ^= data2; 
....................  
....................    *(((unsigned int16 *)(&res)+3)) = data1; 
....................  
....................  
....................    y = y*LN2_INV - (float64)n; 
....................  
....................    r = pe_64[0]*y + pe_64[1]; 
....................    r = r*y + pe_64[2]; 
....................    r = r*y + pe_64[3]; 
....................    r = r*y + pe_64[4]; 
....................    r = r*y + pe_64[5]; 
....................    r = r*y + pe_64[6]; 
....................    r = r*y + pe_64[7]; 
....................    r = r*y + pe_64[8]; 
....................    r = r*y + pe_64[9]; 
....................    r = r*y + pe_64[10]; 
....................    r = r*y + pe_64[11]; 
....................     
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
.................... #ENDIF 
....................  
....................  
.................... /************************************************************/ 
....................  
.................... float32 const pl[4] = {-1.080310025160955, 1.999999947089217}; 
.................... float32 const ql[4] = {0.091284365719509, -0.873491916557671}; 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float log(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the the natural log of x 
.................... // Date : N/A 
.................... // 
.................... float32 log(float32 x) 
.................... { 
....................    float32 y, res, r, y2; 
....................    #if defined(__PCD__) 
....................    unsigned int8  data1,data2; 
....................    #endif 
....................    signed int8 n; 
....................    #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
.................... #if !defined(__PCD__) 
....................     *((unsigned int8 *)(&y)) = 0x7E;  
.................... #endif 
....................  
.................... #if defined(__PCD__) // Takes care of IEEE format 
....................    data2 = *(((unsigned int8 *)(&y))+3); 
....................    *(((unsigned int8 *)(&y))+3) = 0x3F; 
....................    data1 = *(((unsigned int8 *)(&y))+2); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&y))+2) = data1; 
....................    if(bit_test(data2,7)) 
....................      bit_set(*(((unsigned int8 *)(&y))+3),7); 
.................... #endif 
....................  
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl[0]*y2 + pl[1]; 
....................  
....................       r = ql[0]*y2 + ql[1]; 
....................       r = r*y2 + 1.0; 
....................  
....................       res = y*res/r; 
.................... #if !defined(__PCD__) 
....................       n = *((unsigned int8 *)(&x)) - 0x7E; 
.................... #endif 
.................... #if defined(__PCD__)  
....................     data1 = *(((unsigned int8 *)(&x)+3)); 
....................     rotate_left(&data1,1); 
....................     data2 = *(((unsigned int8 *)(&x)+2)); 
....................     if(bit_test (data2,7)) 
....................       bit_set(data1,0); 
....................     n = data1 - 0x7E; 
.................... #endif 
....................  
....................       if (n<0)  
....................          r = -(float32)-n; 
....................       else 
....................          r = (float32)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................       res = 0.0; 
....................  
....................    return(res); 
.................... } 
....................  
.................... //Overloaded function for log() for PCD 
.................... // Overloaded function log() for data type - Float48 
.................... #if defined(__PCD__) 
.................... // Overloaded function log() for data type - float64 
.................... float64 const pl_64[4] = {-0.145694052150681, 1.365485300000370, 
....................                           -3.120535668274329, 2.000000000000000}; 
....................  
.................... float64 const ql_64[4] = {0.006047500465908, -0.208298281937234, 
....................                           1.113943039156721, -1.893601167470470}; 
....................  
.................... float48 log(float48 x) 
.................... { 
....................    float48 y, res, r, y2; 
....................    unsigned int8  data1,data2; 
....................    signed int8 n; 
.................... #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
.................... #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
....................  
.................... #if !defined(__PCD__) 
....................       *((unsigned int8 *)(&y)) = 0x7E;  
.................... #endif 
....................       data2 = *(((unsigned int8 *)(&y))+5); 
....................       *(((unsigned int8 *)(&y))+5) = 0x3F; 
....................       data1 = *(((unsigned int8 *)(&y))+4); 
....................       bit_clear(data1,7); 
....................       *(((unsigned int8 *)(&y))+4) = data1; 
....................  
....................       if(bit_test(data2,7)) 
....................       bit_set(*(((unsigned int8 *)(&y))+4),7); 
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl_64[0]*y2 + pl_64[1]; 
....................       res = res*y2 + pl_64[2]; 
....................       res = res*y2 + pl_64[3]; 
....................  
....................       r = ql_64[0]*y2 + ql_64[1]; 
....................       r = r*y2 + ql_64[2]; 
....................       r = r*y2 + ql_64[3]; 
....................       r = r*y2 + 1.0;  
....................       res = y*res/r; 
....................  
....................       data1 = *(((unsigned int8 *)(&x)+5)); 
....................       rotate_left(&data1,1); 
....................       data2 = *(((unsigned int8 *)(&x)+4)); 
....................       if(bit_test (data2,7)) 
....................       bit_set(data1,0); 
....................        
....................       n = data1 - 0x7E; 
....................  
....................       if (n<0) 
....................       r = -(float48)-n; 
....................       else 
....................       r = (float48)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................    res = 0.0; 
....................  
....................    return(res); 
.................... } 
....................  
.................... float64 log(float64 x) 
.................... { 
....................    float64 y, res, r, y2; 
....................    unsigned int16  data1,data2; 
....................    unsigned int16 *p; 
....................    signed int16 n; 
....................    #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
....................    #if !defined(__PCD__) 
....................        *((unsigned int8 *)(&y)) = 0x7E;  
....................    #endif 
....................       p= (((unsigned int16 *)(&y))+3); 
....................       data1 = *p; 
....................       data2 = *p; 
....................       data1 = 0x3FE; 
....................       data1 = data1 <<4; 
....................       if(bit_test (data2,15)) 
....................          bit_set(data1,15); 
....................       data2 = data2 & 0x000F; 
....................       data1 ^=data2; 
....................  
....................       *p = data1; 
....................  
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl_64[0]*y2 + pl_64[1]; 
....................       res = res*y2 + pl_64[2]; 
....................       res = res*y2 + pl_64[3]; 
....................  
....................       r = ql_64[0]*y2 + ql_64[1]; 
....................       r = r*y2 + ql_64[2]; 
....................       r = r*y2 + ql_64[3]; 
....................       r = r*y2 + 1.0; 
....................  
....................       res = y*res/r; 
....................   
....................       p= (((unsigned int16 *)(&x))+3); 
....................       data1 = *p; 
....................       bit_clear(data1,15); 
....................       data1 = data1 >>4;     
....................       n = data1 - 0x3FE; 
....................  
....................  
....................       if (n<0) 
....................          r = -(float64)-n; 
....................       else 
....................          r = (float64)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................       res = 0.0; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
....................  
.................... #define LN10 2.3025850929940456 
.................... #define LN10_INV 0.4342944819032518276 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float log10(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the the log base 10 of x 
.................... // Date : N/A 
.................... // 
.................... float32 log10(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = log(x); 
....................    r = r*LN10_INV; 
....................    return(r); 
.................... } 
....................  
.................... //Overloaded functions for log10() for PCD 
.................... // Overloaded function log10() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 log10(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = log(x); 
....................    r = r*LN10_INV; 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function log10() for data type - Float64 
.................... float64 log10(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = log(x); 
....................    r = r*LN10_INV; 
....................    return(r); 
.................... } 
.................... #endif 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float modf(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description :breaks the argument value int integral and fractional parts, 
.................... // ach of which have the same sign as the argument.  It stores the integral part 
.................... // as a float in the object pointed to by the iptr 
.................... // Returns : returns the signed fractional part of value. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 modf(float32 value,float32 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... //Overloaded functions for modf() for PCD 
.................... // Overloaded function modf() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 modf(float48 value,float48 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... // Overloaded function modf() for data type - Float64 
.................... float64 modf(float64 value,float64 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float pwr(float x,float y) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (x^y) 
.................... // Date : N/A 
.................... // Note : 0 is returned when the function will generate an imaginary number 
.................... // 
.................... float32 pwr(float32 x,float32 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... //Overloaded functions for pwr() for PCD 
.................... // Overloaded function pwr() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 pwr(float48 x,float48 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... // Overloaded function pwr() for data type - Float64 
.................... float64 pwr(float64 x,float64 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////// Power functions //////////////////// 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float pow(float x,float y) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (x^y) 
.................... // Date : N/A 
.................... // Note : 0 is returned when the function will generate an imaginary number 
.................... // 
.................... float32 pow(float32 x,float32 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... //Overloaded functions for pow() for PCD 
.................... // Overloaded function for pow() data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 pow(float48 x,float48 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
....................  
.................... // Overloaded function pow() for data type - Float64 
.................... float64 pow(float64 x,float64 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sqrt(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the square root of x 
.................... // Date : N/A 
.................... // 
.................... float32 sqrt(float32 x) 
.................... { 
....................    float32 y, res; 
....................    #if defined(__PCD__) 
....................    unsigned int16 data1,data2; 
....................    #endif 
....................    unsigned int8 *p; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................     
....................    #if !defined(__PCD__) 
....................     p=&y; 
....................    (*p)=(unsigned int8)((((unsigned int16)(*p)) + 127) >> 1); 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     p = (((unsigned int8 *)(&y))+3); 
....................     data1 = *(((unsigned int8 *)(&y))+3); 
....................     data2 = *(((unsigned int8 *)(&y))+2); 
....................     rotate_left(&data1,1);     
....................     if(bit_test(data2,7))     
....................        bit_set(data1,0);     
....................     data1 = ((data1+127) >>1); 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+3) = data1; 
....................     *(((unsigned int8 *)(&y))+2) = data2; 
....................      
....................   #endif 
....................  
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................  
....................       #if !defined(__PCD__) 
....................      (*p)--; 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     data1 = *(((unsigned int8 *)(&y))+3); 
....................     data2 = *(((unsigned int8 *)(&y))+2); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................        bit_set(data1,0);     
....................     data1--; 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+3) = data1; 
....................     *(((unsigned int8 *)(&y))+2) = data2; 
....................      
....................   #endif 
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
.................... //Overloaded functions for sqrt() for PCD 
.................... // Overloaded function sqrt() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sqrt(float48 x) 
.................... { 
....................    float48 y, res; 
....................    unsigned int16 data1,data2; 
....................    unsigned int8 *p; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................     
....................    #if !defined(__PCD__) 
....................     p=&y; 
....................    (*p)=(unsigned int8)((((unsigned int16)(*p)) + 127) >> 1); 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     p = (((unsigned int8 *)(&y))+5); 
....................     data1 = *(((unsigned int8 *)(&y))+5); 
....................     data2 = *(((unsigned int8 *)(&y))+4); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................        bit_set(data1,0);     
....................     data1 = ((data1+127) >>1); 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+5) = data1; 
....................     *(((unsigned int8 *)(&y))+4) = data2; 
....................      
....................   #endif 
....................  
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................  
....................       #if !defined(__PCD__) 
....................      (*p)--; 
....................    #endif 
....................     
....................     data1 = *(((unsigned int8 *)(&y))+5); 
....................     data2 = *(((unsigned int8 *)(&y))+4); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................        bit_set(data1,0);     
....................     data1--; 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+5) = data1; 
....................     *(((unsigned int8 *)(&y))+4) = data2; 
....................      
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function sqrt() for data type - Float64 
.................... float64 sqrt(float64 x) 
.................... { 
....................    float64 y, res; 
....................    unsigned int16 *p; 
....................    unsigned int16 temp1,temp2; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................    p= (((unsigned int16 *)(&y))+3); 
....................    temp1 = *p; 
....................    temp2 = *p; 
....................    bit_clear(temp1,15); 
....................    temp1 = (temp1>>4)+1023; 
....................    temp1 = temp1 >> 1; 
....................    temp1 = (temp1<<4) & 0xFFF0; 
....................    if(bit_test(temp2,15)) 
....................       bit_set(temp1,15); 
....................    temp2 = temp2 & 0x000F; 
....................    temp1 ^= temp2; 
....................     
....................    (*p) = temp1; 
....................     
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................      temp1 = *p; 
....................      temp2 = *p; 
....................      bit_clear(temp1,15); 
....................      temp1 = (temp1>>4); 
....................      temp1--; 
....................      temp1 = (temp1<<4) & 0xFFF0; 
....................      if(bit_test(temp2,15)) 
....................         bit_set(temp1,15); 
....................      temp2 = temp2 & 0x000F; 
....................      temp1 ^= temp2; 
....................      (*p) = temp1; 
....................  
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... ////////////////////////////// Trig Functions ////////////////////////////// 
.................... #ifdef PI_DIV_BY_TWO_INV 
.................... #undef PI_DIV_BY_TWO_INV 
.................... #endif 
.................... #define PI_DIV_BY_TWO_INV 0.63661977236758134 
.................... #ifdef PI_DIV_BY_TWO 
.................... #undef PI_DIV_BY_TWO 
.................... #endif 
.................... #define PI_DIV_BY_TWO   1.5707963267948966 
.................... #ifdef TWOBYPI 
.................... #undef TWOBYPI 
.................... #endif 
.................... #define TWOBYPI          0.6366197723675813 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float cos(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the cosine value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 cos(float32 x) 
.................... { 
....................    float32 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float32 frac; 
....................    float32 p[5] = {                    //by the series definition for cosine 
....................       -0.49999999456337096,            // sum ( ( (-1)^n * x^2n )/(2n)! ) 
....................        0.04166663896921267, 
....................       -0.00138883894522527, 
....................        0.00002476138231734, 
....................       -0.00000026070414770 
....................       //-0.00000000001147, 
....................       // 0.00000000000005 
....................    }; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant 
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 1.0; 
....................    t = t * t; 
....................    for (i = 0; i <= 4; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
....................  
.................... //Overloaded functions for cos() for PCD 
.................... // Overloaded function cos() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 cos(float48 x) 
.................... { 
....................    float48 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float48 frac; 
....................    float48 p[6] = {                    //by the series definition for cosine 
....................       -0.5,                            // sum ( ( (-1)^n * x^2n )/(2n)! ) 
....................        0.04166666666667, 
....................       -0.00138888888889, 
....................        0.00002480158730, 
....................       -0.00000027557319, 
....................        0.00000000208767, 
....................       //-0.00000000001147, 
....................       // 0.00000000000005 
....................    }; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant 
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 0.999999999781; 
....................    t = t * t; 
....................    for (i = 0; i <= 5; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
.................... // Overloaded function cos() for data type - Float64 
.................... float64 cos(float64 x) 
.................... { 
....................    float64 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float64 frac; 
....................    float64 p_64[9] = {               //by the series definition for cosine 
....................      -0.49999999999998740,           // sum ( ( (-1)^n * x^2n )/(2n)! )              
....................       0.04166666666656518, 
....................      -0.00138888888851691, 
....................       0.00002480158658490, 
....................      -0.00000027557239796, 
....................       0.00000000208715031, 
....................      -0.00000000001126577, 
....................       0.00000000000000427, 
....................       0.00000000000000372}; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant 
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 1.0; 
....................    t = t * t; 
....................    for (i = 0; i <= 8; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p_64[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sin(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the sine value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 sin(float32 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
....................  
.................... //Overloaded functions for sin() for PCD 
.................... // Overloaded function sin() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sin(float48 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
....................  
.................... // Overloaded function sin() for data type - Float48 
.................... float64 sin(float64 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float tan(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the tangent value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 tan(float32 x) 
.................... { 
....................    float32 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
.................... //Overloaded functions for tan() for PCD 
.................... // Overloaded function tan() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 tan(float48 x) 
.................... { 
....................    float48 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
....................  
.................... // Overloaded function tan() for data type - Float48 
.................... float64 tan(float64 x) 
.................... { 
....................    float64 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
.................... #endif 
....................  
.................... float32 const pas[3] = {0.49559947, -4.6145309, 5.6036290}; 
.................... float32 const qas[3] = {1.0000000,  -5.5484666, 5.6036290}; 
....................  
.................... float32 ASIN_COS(float32 x, unsigned int8 n) 
.................... { 
....................    float32 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)*0.5); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas[0]*y2 + pas[1]; 
....................    res = res*y2 + pas[2]; 
....................  
....................    r = qas[0]*y2 + qas[1]; 
....................    r = r*y2 + qas[2]; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
....................  
....................  
.................... //Overloaded functions for ASIN_COS() for PCD 
.................... // Overloaded function ASIN_COS() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 ASIN_COS(float48 x, unsigned int8 n) 
.................... { 
....................    float48 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)*0.5); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas[0]*y2 + pas[1]; 
....................    res = res*y2 + pas[2]; 
....................  
....................    r = qas[0]*y2 + qas[1]; 
....................    r = r*y2 + qas[2]; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function ASIN_COS() for data type - Float64 
.................... double pas_64[5]={1.000000000000000,-2.069938587724477,1.421444580548907, 
....................                  -0.360690137621842,0.024929451660228}; 
....................  
.................... double qas_64[5]={-2.236605254391134,1.719212122946451,-0.524122954476133, 
....................                    0.052808872045749,-0.000662536036570}; 
....................                     
.................... float64 ASIN_COS(float64 x, unsigned int8 n) 
.................... { 
....................    float64 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)*0.5); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas_64[4]*y2 + pas_64[3]; 
....................    res = res*y2 + pas_64[2]; 
....................    res = res*y2 + pas_64[1]; 
....................    res = res*y2 + pas_64[0]; 
....................  
....................    r = qas_64[4]*y2 + qas_64[3]; 
....................    r = r*y2 + qas_64[2]; 
....................    r = r*y2 + qas_64[1]; 
....................    r = r*y2 + qas_64[0]; 
....................    r = r*y2 + 1.0; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float asin(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arcsine value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 asin(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
.................... //Overloaded functions for asin() for PCD 
.................... // Overloaded function asin() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 asin(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function asin() for data type - Float64 
.................... float64 asin(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float acos(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arccosine value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 acos(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
.................... //Overloaded functions for acos() for PCD 
.................... // Overloaded function acos() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 acos(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function acos() for data type - Float64 
.................... float64 acos(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
.................... #endif 
....................  
.................... float32 const pat[4] = {0.17630401, 5.6710795, 22.376096, 19.818457}; 
.................... float32 const qat[4] = {1.0000000,  11.368190, 28.982246, 19.818457}; 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float atan(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arctangent value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 atan(float32 x) 
.................... { 
....................    float32 y, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................  
....................    res = pat[0]*y*y + pat[1]; 
....................    res = res*y*y + pat[2]; 
....................    res = res*y*y + pat[3]; 
....................  
....................    r = qat[0]*y*y + qat[1]; 
....................    r = r*y*y + qat[2]; 
....................    r = r*y*y + qat[3]; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
.................... //Overloaded functions for atan() for PCD 
.................... // Overloaded function atan() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 atan(float48 x) 
.................... { 
....................    float48 y, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................  
....................    res = pat[0]*y*y + pat[1]; 
....................    res = res*y*y + pat[2]; 
....................    res = res*y*y + pat[3]; 
....................  
....................    r = qat[0]*y*y + qat[1]; 
....................    r = r*y*y + qat[2]; 
....................    r = r*y*y + qat[3]; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
....................  
.................... float64 pat_64[6]={0.999999999999999,2.249923645595566,1.771541617806449, 
....................                    0.579678874003185,0.072162702162882,0.002281100141660}; 
....................  
.................... float64 qat_64[6]={2.583256978928510,2.432627277466967,1.016760379885393, 
....................                    0.182482977188688,0.011155377971690,0.000100013019160}; 
.................... // Overloaded function atan() for data type - Float64 
.................... float64 atan(float64 x) 
.................... { 
....................    float64 y,y2, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................    y2 = y*y; 
....................    res = pat_64[5]*y2 + pat_64[4]; 
....................    res = res*y2 + pat_64[3]; 
....................    res = res*y2 + pat_64[2]; 
....................    res = res*y2 + pat_64[1]; 
....................    res = res*y2 + pat_64[0]; 
....................  
....................    r = qat_64[5]*y2 + qat_64[4]; 
....................    r = r*y2 + qat_64[3]; 
....................    r = r*y2 + qat_64[2]; 
....................    r = r*y2 + qat_64[1]; 
....................    r = r*y2 + qat_64[0]; 
....................    r = r*y2 + 1.0; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... ///////////////////////////////////////////////////////////////////////////// 
.................... //   float atan2(float y, float x) 
.................... ///////////////////////////////////////////////////////////////////////////// 
.................... // Description :computes the principal value of arc tangent of y/x, using the 
.................... // signs of both the arguments to determine the quadrant of the return value 
.................... // Returns : returns the arc tangent of y/x. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 atan2(float32 y,float32 x) 
.................... { 
....................    float32 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
....................  
.................... //Overloaded functions for atan2() for PCD 
.................... // Overloaded function atan2() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 atan2(float48 y,float48 x) 
.................... { 
....................    float48 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
....................  
.................... // Overloaded function atan2() for data type - Float64 
.................... float64 atan2(float64 y,float64 x) 
.................... { 
....................    float64 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////// Hyperbolic functions //////////////////// 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float cosh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic cosine value of x 
.................... // Returns : returns the hyperbolic cosine value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 cosh(float32 x) 
.................... { 
....................    return ((exp(x)+exp(-x))*0.5); 
.................... } 
.................... //Overloaded functions for cosh() for PCD 
.................... // Overloaded function cosh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 cosh(float48 x) 
.................... { 
....................    return ((exp(x)+exp(-x))*0.5); 
.................... } 
....................  
.................... // Overloaded function cosh() for data type - Float64 
.................... float64 cosh(float64 x) 
.................... { 
....................    return ((exp(x)+exp(-x))*0.5); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sinh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic sine value of x 
.................... // Returns : returns the hyperbolic sine value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 sinh(float32 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))*0.5); 
.................... } 
.................... //Overloaded functions for sinh() for PCD 
.................... // Overloaded function sinh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sinh(float48 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))*0.5); 
.................... } 
....................  
.................... // Overloaded function sinh() for data type - Float48 
.................... float64 sinh(float64 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))*0.5); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float tanh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic tangent value of x 
.................... // Returns : returns the hyperbolic tangent value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 tanh(float32 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
.................... //Overloaded functions for tanh() for PCD 
.................... // Overloaded function tanh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 tanh(float48 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
....................  
.................... // Overloaded function tanh() for data type - Float64 
.................... float64 tanh(float64 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float frexp(float x, signed int *exp) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : breaks a floating point number into a normalized fraction and an integral 
.................... // power of 2. It stores the integer in the signed int object pointed to by exp. 
.................... // Returns : returns the value x, such that x is a double with magnitude in the interval 
.................... // [1/2,1) or zero, and value equals x times 2 raised to the power *exp.If value is zero, 
.................... // both parts of the result are zero. 
.................... // Date : N/A 
.................... // 
....................  
.................... #define LOG2 .30102999566398119521 
.................... #define LOG2_INV 3.32192809488736234787 
.................... float32 frexp(float32 x, signed int8 *exp) 
.................... { 
....................    float32 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)*LOG2_INV)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
....................  
.................... //Overloaded functions for frexp() for PCD 
.................... // Overloaded function frexp() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 frexp(float48 x, signed int8 *exp) 
.................... { 
....................    float48 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)*LOG2_INV)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
....................  
.................... // Overloaded function frexp() for data type - Float64 
.................... float64 frexp(float64 x, signed int8 *exp) 
.................... { 
....................    float64 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)*LOG2_INV)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
.................... #endif 
....................  
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... //   float ldexp(float x, signed int *exp) 
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... // Description : multiplies a floating point number by an integral power of 2. 
.................... // Returns : returns the value of x times 2 raised to the power exp. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 ldexp(float32 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... //Overloaded functions for ldexp() for PCD 
.................... // Overloaded function ldexp() for data type - Float48 
....................  
.................... #if defined(__PCD__) 
.................... float48 ldexp(float48 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... // Overloaded function ldexp() for data type - Float64 
.................... float64 ldexp(float64 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... #endif 
....................  
.................... #endif 
....................  
.................... #INCLUDE <xuatbyte74595.c> 
....................  
.................... #DEFINE      DS               PIN_D1 
.................... #DEFINE      SH_CP            PIN_D0   
.................... #DEFINE      STCP             PIN_D2 
.................... VOID XUATTRANGTHAI(UNSIGNED INT8 BYTEXUAT) 
.................... { 
....................    UNSIGNED INT8   SB;    
....................    #BIT BSERI  = BYTEXUAT.7 
....................     
....................    FOR (SB=0;SB<8;SB++) 
*
0D37:  CLRF   17
0D38:  MOVF   17,W
0D39:  SUBLW  07
0D3A:  BTFSS  03.0
0D3B:  GOTO   552
....................       {                                                  
....................          OUTPUT_BIT(DS,BSERI);     
0D3C:  BTFSC  16.7
0D3D:  GOTO   542
0D3E:  BCF    03.6
0D3F:  BCF    08.1
0D40:  GOTO   544
0D41:  BSF    03.6
0D42:  BCF    03.6
0D43:  BSF    08.1
0D44:  BSF    03.5
0D45:  BCF    08.1
....................          OUTPUT_LOW(SH_CP); OUTPUT_HIGH(SH_CP); 
0D46:  BCF    08.0
0D47:  BCF    03.5
0D48:  BCF    08.0
0D49:  BSF    03.5
0D4A:  BCF    08.0
0D4B:  BCF    03.5
0D4C:  BSF    08.0
....................          BYTEXUAT=BYTEXUAT<<1; //10010010->00100100   
0D4D:  BCF    03.0
0D4E:  BSF    03.6
0D4F:  RLF    16,F
0D50:  INCF   17,F
0D51:  GOTO   538
....................      } 
....................       OUTPUT_LOW(STCP); OUTPUT_HIGH(STCP); 
0D52:  BSF    03.5
0D53:  BCF    03.6
0D54:  BCF    08.2
0D55:  BCF    03.5
0D56:  BCF    08.2
0D57:  BSF    03.5
0D58:  BCF    08.2
0D59:  BCF    03.5
0D5A:  BSF    08.2
.................... } 
....................  
....................  
.................... #FUSES NOWDT, PUT, HS 
.................... #USE DELAY(CLOCK=20M) 
*
0140:  MOVLW  41
0141:  MOVWF  04
0142:  BSF    03.7
0143:  MOVF   00,W
0144:  BTFSC  03.2
0145:  GOTO   153
0146:  MOVLW  06
0147:  MOVWF  78
0148:  CLRF   77
0149:  DECFSZ 77,F
014A:  GOTO   149
014B:  DECFSZ 78,F
014C:  GOTO   148
014D:  MOVLW  7B
014E:  MOVWF  77
014F:  DECFSZ 77,F
0150:  GOTO   14F
0151:  DECFSZ 00,F
0152:  GOTO   146
0153:  RETURN
.................... #USE RS232(BAUD=9600,XMIT=PIN_C6,RCV=PIN_C7) 
.................... #DEFINE BT1_PIN PIN_B1 
.................... #DEFINE BT2_PIN PIN_B2 
.................... #DEFINE BT3_PIN PIN_B3 
.................... #DEFINE LCD_ENABLE_PIN  PIN_E0                                    
.................... #DEFINE LCD_RS_PIN      PIN_E1                                 
.................... #DEFINE LCD_RW_PIN      PIN_E2   
.................... #DEFINE LCD_DATA4       PIN_C0                                
.................... #DEFINE LCD_DATA5       PIN_C1                                  
.................... #DEFINE LCD_DATA6       PIN_C2                                    
.................... #DEFINE LCD_DATA7       PIN_C3   
.................... #INCLUDE <LCD.C> 
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... ////                             LCD.C                                     //// 
.................... ////                 Driver for common LCD modules                         //// 
.................... ////                                                                       //// 
.................... ////  lcd_init()   Must be called before any other function.               //// 
.................... ////                                                                       //// 
.................... ////  lcd_putc(c)  Will display c on the next position of the LCD.         //// 
.................... ////                 \a  Set cursor position to upper left                 //// 
.................... ////                 \f  Clear display, set cursor to upper left           //// 
.................... ////                 \n  Go to start of second line                        //// 
.................... ////                 \b  Move back one position                            //// 
.................... ////              If LCD_EXTENDED_NEWLINE is defined, the \n character     //// 
.................... ////              will erase all remanining characters on the current      //// 
.................... ////              line, and move the cursor to the beginning of the next   //// 
.................... ////              line.                                                    //// 
.................... ////              If LCD_EXTENDED_NEWLINE is defined, the \r character     //// 
.................... ////              will move the cursor to the start of the current         //// 
.................... ////              line.                                                    //// 
.................... ////                                                                       //// 
.................... ////  lcd_gotoxy(x,y) Set write position on LCD (upper left is 1,1)        //// 
.................... ////                                                                       //// 
.................... ////  lcd_getc(x,y)   Returns character at position x,y on LCD             //// 
.................... ////                                                                       //// 
.................... ////  lcd_cursor_on(int1 on)   Turn the cursor on (on=TRUE) or off         //// 
.................... ////              (on=FALSE).                                              //// 
.................... ////                                                                       //// 
.................... ////  lcd_set_cgram_char(w, *p)   Write a custom character to the CGRAM.   //// 
.................... ////                                                                       //// 
.................... ////                                                                       //// 
.................... ////  CONFIGURATION                                                        //// 
.................... ////  The LCD can be configured in one of two ways: a.) port access or     //// 
.................... ////  b.) pin access.  Port access requires the entire 7 bit interface     //// 
.................... ////  connected to one GPIO port, and the data bits (D4:D7 of the LCD)     //// 
.................... ////  connected to sequential pins on the GPIO.  Pin access                //// 
.................... ////  has no requirements, all 7 bits of the control interface can         //// 
.................... ////  can be connected to any GPIO using several ports.                    //// 
.................... ////                                                                       //// 
.................... ////  To use port access, #define LCD_DATA_PORT to the SFR location of     //// 
.................... ////  of the GPIO port that holds the interface, -AND- edit LCD_PIN_MAP    //// 
.................... ////  of this file to configure the pin order.  If you are using a         //// 
.................... ////  baseline PIC (PCB), then LCD_OUTPUT_MAP and LCD_INPUT_MAP also must  //// 
.................... ////  be defined.                                                          //// 
.................... ////                                                                       //// 
.................... ////  Example of port access:                                              //// 
.................... ////     #define LCD_DATA_PORT getenv("SFR:PORTD")                         //// 
.................... ////                                                                       //// 
.................... ////  To use pin access, the following pins must be defined:               //// 
.................... ////     LCD_ENABLE_PIN                                                    //// 
.................... ////     LCD_RS_PIN                                                        //// 
.................... ////     LCD_RW_PIN                                                        //// 
.................... ////     LCD_DATA4                                                         //// 
.................... ////     LCD_DATA5                                                         //// 
.................... ////     LCD_DATA6                                                         //// 
.................... ////     LCD_DATA7                                                         //// 
.................... ////                                                                       //// 
.................... ////  Example of pin access:                                               //// 
.................... ////     #define LCD_ENABLE_PIN  PIN_E0                                    //// 
.................... ////     #define LCD_RS_PIN      PIN_E1                                    //// 
.................... ////     #define LCD_RW_PIN      PIN_E2                                    //// 
.................... ////     #define LCD_DATA4       PIN_D4                                    //// 
.................... ////     #define LCD_DATA5       PIN_D5                                    //// 
.................... ////     #define LCD_DATA6       PIN_D6                                    //// 
.................... ////     #define LCD_DATA7       PIN_D7                                    //// 
.................... ////                                                                       //// 
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2010 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef __LCD_C__ 
.................... #define __LCD_C__ 
....................  
.................... // define the pinout. 
.................... // only required if port access is being used. 
.................... typedef struct   
.................... {                            // This structure is overlayed 
....................    int1 enable;           // on to an I/O port to gain 
....................    int1 rs;               // access to the LCD pins. 
....................    int1 rw;               // The bits are allocated from 
....................    int1 unused;           // low order up.  ENABLE will 
....................    unsigned int     data : 4;         // be LSB pin of that port. 
....................   #if defined(__PCD__)       // The port used will be LCD_DATA_PORT. 
....................    unsigned int    reserved: 8; 
....................   #endif 
.................... } LCD_PIN_MAP; 
....................  
.................... // this is to improve compatability with previous LCD drivers that accepted 
.................... // a define labeled 'use_portb_lcd' that configured the LCD onto port B. 
.................... #if ((defined(use_portb_lcd)) && (use_portb_lcd==TRUE)) 
....................  #define LCD_DATA_PORT getenv("SFR:PORTB") 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
....................    // these definitions only need to be modified for baseline PICs. 
....................    // all other PICs use LCD_PIN_MAP or individual LCD_xxx pin definitions. 
.................... /*                                    EN, RS,   RW,   UNUSED,  DATA  */ 
....................  const LCD_PIN_MAP LCD_OUTPUT_MAP =  {0,  0,    0,    0,       0}; 
....................  const LCD_PIN_MAP LCD_INPUT_MAP =   {0,  0,    0,    0,       0xF}; 
.................... #endif 
....................  
.................... ////////////////////// END CONFIGURATION /////////////////////////////////// 
....................  
.................... #ifndef LCD_ENABLE_PIN 
....................    #define lcd_output_enable(x) lcdlat.enable=x 
....................    #define lcd_enable_tris()   lcdtris.enable=0 
.................... #else 
....................    #define lcd_output_enable(x) output_bit(LCD_ENABLE_PIN, x) 
....................    #define lcd_enable_tris()  output_drive(LCD_ENABLE_PIN) 
.................... #endif 
....................  
.................... #ifndef LCD_RS_PIN 
....................    #define lcd_output_rs(x) lcdlat.rs=x 
....................    #define lcd_rs_tris()   lcdtris.rs=0 
.................... #else 
....................    #define lcd_output_rs(x) output_bit(LCD_RS_PIN, x) 
....................    #define lcd_rs_tris()  output_drive(LCD_RS_PIN) 
.................... #endif 
....................  
.................... #ifndef LCD_RW_PIN 
....................    #define lcd_output_rw(x) lcdlat.rw=x 
....................    #define lcd_rw_tris()   lcdtris.rw=0 
.................... #else 
....................    #define lcd_output_rw(x) output_bit(LCD_RW_PIN, x) 
....................    #define lcd_rw_tris()  output_drive(LCD_RW_PIN) 
.................... #endif 
....................  
.................... // original version of this library incorrectly labeled LCD_DATA0 as LCD_DATA4, 
.................... // LCD_DATA1 as LCD_DATA5, and so on.  this block of code makes the driver 
.................... // compatible with any code written for the original library 
.................... #if (defined(LCD_DATA0) && defined(LCD_DATA1) && defined(LCD_DATA2) && defined(LCD_DATA3) && !defined(LCD_DATA4) && !defined(LCD_DATA5) && !defined(LCD_DATA6) && !defined(LCD_DATA7)) 
....................    #define  LCD_DATA4    LCD_DATA0 
....................    #define  LCD_DATA5    LCD_DATA1 
....................    #define  LCD_DATA6    LCD_DATA2 
....................    #define  LCD_DATA7    LCD_DATA3 
.................... #endif 
....................  
.................... #ifndef LCD_DATA4 
.................... #ifndef LCD_DATA_PORT 
....................    #if defined(__PCB__) 
....................       #define LCD_DATA_PORT      0x06     //portb 
....................       #define set_tris_lcd(x)   set_tris_b(x) 
....................    #else 
....................      #if defined(PIN_D0) 
....................       #define LCD_DATA_PORT      getenv("SFR:PORTD")     //portd 
....................      #else 
....................       #define LCD_DATA_PORT      getenv("SFR:PORTB")     //portb 
....................      #endif 
....................    #endif    
.................... #endif 
....................  
.................... #if defined(__PCB__) 
....................    LCD_PIN_MAP lcd, lcdlat; 
....................    #byte lcd = LCD_DATA_PORT 
....................    #byte lcdlat = LCD_DATA_PORT 
.................... #elif defined(__PCM__) 
....................    LCD_PIN_MAP lcd, lcdlat, lcdtris; 
....................    #byte lcd = LCD_DATA_PORT 
....................    #byte lcdlat = LCD_DATA_PORT 
....................    #byte lcdtris = LCD_DATA_PORT+0x80 
.................... #elif defined(__PCH__) 
....................    LCD_PIN_MAP lcd, lcdlat, lcdtris; 
....................    #byte lcd = LCD_DATA_PORT 
....................    #byte lcdlat = LCD_DATA_PORT+9 
....................    #byte lcdtris = LCD_DATA_PORT+0x12 
.................... #elif defined(__PCD__) 
....................    LCD_PIN_MAP lcd, lcdlat, lcdtris; 
....................    #word lcd = LCD_DATA_PORT 
....................    #word lcdlat = LCD_DATA_PORT+2 
....................    #word lcdtris = LCD_DATA_PORT-0x02 
.................... #endif 
.................... #endif   //LCD_DATA4 not defined 
....................  
.................... #ifndef LCD_TYPE 
....................    #define LCD_TYPE 2           // 0=5x7, 1=5x10, 2=2 lines 
.................... #endif 
....................  
.................... #ifndef LCD_LINE_TWO 
....................    #define LCD_LINE_TWO 0x40    // LCD RAM address for the second line 
.................... #endif 
....................  
.................... #ifndef LCD_LINE_LENGTH 
....................    #define LCD_LINE_LENGTH 20 
.................... #endif 
....................  
.................... unsigned int8 lcd_read_nibble(void); 
....................  
.................... unsigned int8 lcd_read_byte(void) 
.................... { 
....................    unsigned int8 low,high; 
....................  
....................  #if defined(__PCB__) 
....................    set_tris_lcd(LCD_INPUT_MAP); 
....................  #else 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    output_float(LCD_DATA4); 
*
01E7:  BSF    07.0
....................    output_float(LCD_DATA5); 
01E8:  BSF    07.1
....................    output_float(LCD_DATA6); 
01E9:  BSF    07.2
....................    output_float(LCD_DATA7); 
01EA:  BSF    07.3
....................   #else 
....................    lcdtris.data = 0xF; 
....................   #endif 
....................  #endif 
....................          
....................    lcd_output_rw(1); 
01EB:  BCF    03.5
01EC:  BSF    09.2
01ED:  BSF    03.5
01EE:  BCF    09.2
....................    delay_cycles(1); 
01EF:  NOP
....................    lcd_output_enable(1); 
01F0:  BCF    03.5
01F1:  BSF    09.0
01F2:  BSF    03.5
01F3:  BCF    09.0
....................    delay_cycles(1); 
01F4:  NOP
....................    high = lcd_read_nibble(); 
01F5:  BCF    03.5
01F6:  CALL   19C
01F7:  MOVF   78,W
01F8:  BSF    03.6
01F9:  MOVWF  48
....................        
....................    lcd_output_enable(0); 
01FA:  BCF    03.6
01FB:  BCF    09.0
01FC:  BSF    03.5
01FD:  BCF    09.0
....................    delay_cycles(1); 
01FE:  NOP
....................    lcd_output_enable(1); 
01FF:  BCF    03.5
0200:  BSF    09.0
0201:  BSF    03.5
0202:  BCF    09.0
....................    delay_us(1); 
0203:  GOTO   204
0204:  GOTO   205
0205:  NOP
....................    low = lcd_read_nibble(); 
0206:  BCF    03.5
0207:  CALL   19C
0208:  MOVF   78,W
0209:  BSF    03.6
020A:  MOVWF  47
....................        
....................    lcd_output_enable(0); 
020B:  BCF    03.6
020C:  BCF    09.0
020D:  BSF    03.5
020E:  BCF    09.0
....................  
....................  #if defined(__PCB__) 
....................    set_tris_lcd(LCD_OUTPUT_MAP); 
....................  #else 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    output_drive(LCD_DATA4); 
020F:  BCF    03.5
0210:  BCF    31.0
0211:  MOVF   31,W
0212:  BSF    03.5
0213:  MOVWF  07
....................    output_drive(LCD_DATA5); 
0214:  BCF    03.5
0215:  BCF    31.1
0216:  MOVF   31,W
0217:  BSF    03.5
0218:  MOVWF  07
....................    output_drive(LCD_DATA6); 
0219:  BCF    03.5
021A:  BCF    31.2
021B:  MOVF   31,W
021C:  BSF    03.5
021D:  MOVWF  07
....................    output_drive(LCD_DATA7); 
021E:  BCF    03.5
021F:  BCF    31.3
0220:  MOVF   31,W
0221:  BSF    03.5
0222:  MOVWF  07
....................   #else 
....................    lcdtris.data = 0x0; 
....................   #endif 
....................  #endif 
....................  
....................    return( (high<<4) | low); 
0223:  BCF    03.5
0224:  BSF    03.6
0225:  SWAPF  48,W
0226:  MOVWF  77
0227:  MOVLW  F0
0228:  ANDWF  77,F
0229:  MOVF   77,W
022A:  IORWF  47,W
022B:  MOVWF  78
.................... } 
....................  
.................... unsigned int8 lcd_read_nibble(void) 
.................... { 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
*
019C:  BSF    03.6
019D:  CLRF   49
....................    unsigned int8 n = 0x00; 
....................  
....................    /* Read the data port */ 
....................    n |= input(LCD_DATA4); 
019E:  BCF    03.6
019F:  BSF    31.0
01A0:  MOVF   31,W
01A1:  BSF    03.5
01A2:  MOVWF  07
01A3:  MOVLW  00
01A4:  BCF    03.5
01A5:  BTFSC  07.0
01A6:  MOVLW  01
01A7:  BSF    03.6
01A8:  IORWF  49,F
....................    n |= input(LCD_DATA5) << 1; 
01A9:  BCF    03.6
01AA:  BSF    31.1
01AB:  MOVF   31,W
01AC:  BSF    03.5
01AD:  MOVWF  07
01AE:  MOVLW  00
01AF:  BCF    03.5
01B0:  BTFSC  07.1
01B1:  MOVLW  01
01B2:  MOVWF  77
01B3:  BCF    03.0
01B4:  RLF    77,F
01B5:  MOVF   77,W
01B6:  BSF    03.6
01B7:  IORWF  49,F
....................    n |= input(LCD_DATA6) << 2; 
01B8:  BCF    03.6
01B9:  BSF    31.2
01BA:  MOVF   31,W
01BB:  BSF    03.5
01BC:  MOVWF  07
01BD:  MOVLW  00
01BE:  BCF    03.5
01BF:  BTFSC  07.2
01C0:  MOVLW  01
01C1:  MOVWF  77
01C2:  RLF    77,F
01C3:  RLF    77,F
01C4:  MOVLW  FC
01C5:  ANDWF  77,F
01C6:  MOVF   77,W
01C7:  BSF    03.6
01C8:  IORWF  49,F
....................    n |= input(LCD_DATA7) << 3; 
01C9:  BCF    03.6
01CA:  BSF    31.3
01CB:  MOVF   31,W
01CC:  BSF    03.5
01CD:  MOVWF  07
01CE:  MOVLW  00
01CF:  BCF    03.5
01D0:  BTFSC  07.3
01D1:  MOVLW  01
01D2:  MOVWF  77
01D3:  RLF    77,F
01D4:  RLF    77,F
01D5:  RLF    77,F
01D6:  MOVLW  F8
01D7:  ANDWF  77,F
01D8:  MOVF   77,W
01D9:  BSF    03.6
01DA:  IORWF  49,F
....................     
....................    return(n); 
01DB:  MOVF   49,W
01DC:  MOVWF  78
....................   #else 
01DD:  BCF    03.6
01DE:  RETURN
....................    return(lcd.data); 
....................   #endif 
.................... } 
....................  
.................... void lcd_send_nibble(unsigned int8 n) 
.................... { 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    /* Write to the data port */ 
....................    output_bit(LCD_DATA4, bit_test(n, 0)); 
*
0154:  BSF    03.6
0155:  BTFSC  48.0
0156:  GOTO   15B
0157:  BCF    03.6
0158:  BCF    07.0
0159:  GOTO   15D
015A:  BSF    03.6
015B:  BCF    03.6
015C:  BSF    07.0
015D:  BCF    31.0
015E:  MOVF   31,W
015F:  BSF    03.5
0160:  MOVWF  07
....................    output_bit(LCD_DATA5, bit_test(n, 1)); 
0161:  BCF    03.5
0162:  BSF    03.6
0163:  BTFSC  48.1
0164:  GOTO   169
0165:  BCF    03.6
0166:  BCF    07.1
0167:  GOTO   16B
0168:  BSF    03.6
0169:  BCF    03.6
016A:  BSF    07.1
016B:  BCF    31.1
016C:  MOVF   31,W
016D:  BSF    03.5
016E:  MOVWF  07
....................    output_bit(LCD_DATA6, bit_test(n, 2)); 
016F:  BCF    03.5
0170:  BSF    03.6
0171:  BTFSC  48.2
0172:  GOTO   177
0173:  BCF    03.6
0174:  BCF    07.2
0175:  GOTO   179
0176:  BSF    03.6
0177:  BCF    03.6
0178:  BSF    07.2
0179:  BCF    31.2
017A:  MOVF   31,W
017B:  BSF    03.5
017C:  MOVWF  07
....................    output_bit(LCD_DATA7, bit_test(n, 3)); 
017D:  BCF    03.5
017E:  BSF    03.6
017F:  BTFSC  48.3
0180:  GOTO   185
0181:  BCF    03.6
0182:  BCF    07.3
0183:  GOTO   187
0184:  BSF    03.6
0185:  BCF    03.6
0186:  BSF    07.3
0187:  BCF    31.3
0188:  MOVF   31,W
0189:  BSF    03.5
018A:  MOVWF  07
....................   #else       
....................    lcdlat.data = n; 
....................   #endif 
....................        
....................    delay_cycles(1); 
018B:  NOP
....................    lcd_output_enable(1); 
018C:  BCF    03.5
018D:  BSF    09.0
018E:  BSF    03.5
018F:  BCF    09.0
....................    delay_us(2); 
0190:  MOVLW  02
0191:  MOVWF  77
0192:  DECFSZ 77,F
0193:  GOTO   192
0194:  GOTO   195
0195:  NOP
....................    lcd_output_enable(0); 
0196:  BCF    03.5
0197:  BCF    09.0
0198:  BSF    03.5
0199:  BCF    09.0
019A:  BCF    03.5
019B:  RETURN
.................... } 
....................  
.................... void lcd_send_byte(unsigned int8 address, unsigned int8 n) 
.................... { 
....................   #if defined(__PCB__) 
....................    set_tris_lcd(LCD_OUTPUT_MAP); 
....................   #else 
....................    lcd_enable_tris(); 
*
01DF:  BSF    03.5
01E0:  BCF    09.0
....................    lcd_rs_tris(); 
01E1:  BCF    09.1
....................    lcd_rw_tris(); 
01E2:  BCF    09.2
....................   #endif 
....................  
....................    lcd_output_rs(0); 
01E3:  BCF    03.5
01E4:  BCF    09.1
01E5:  BSF    03.5
01E6:  BCF    09.1
....................    while ( bit_test(lcd_read_byte(),7) ) ; 
*
022C:  MOVF   78,W
022D:  MOVWF  47
022E:  BTFSS  47.7
022F:  GOTO   233
0230:  BSF    03.5
0231:  BCF    03.6
0232:  GOTO   1E7
....................    lcd_output_rs(address); 
0233:  MOVF   45,F
0234:  BTFSS  03.2
0235:  GOTO   23A
0236:  BCF    03.6
0237:  BCF    09.1
0238:  GOTO   23C
0239:  BSF    03.6
023A:  BCF    03.6
023B:  BSF    09.1
023C:  BSF    03.5
023D:  BCF    09.1
....................    delay_cycles(1); 
023E:  NOP
....................    lcd_output_rw(0); 
023F:  BCF    03.5
0240:  BCF    09.2
0241:  BSF    03.5
0242:  BCF    09.2
....................    delay_cycles(1); 
0243:  NOP
....................    lcd_output_enable(0); 
0244:  BCF    03.5
0245:  BCF    09.0
0246:  BSF    03.5
0247:  BCF    09.0
....................    lcd_send_nibble(n >> 4); 
0248:  BCF    03.5
0249:  BSF    03.6
024A:  SWAPF  46,W
024B:  MOVWF  47
024C:  MOVLW  0F
024D:  ANDWF  47,F
024E:  MOVF   47,W
024F:  MOVWF  48
0250:  BCF    03.6
0251:  CALL   154
....................    lcd_send_nibble(n & 0xf); 
0252:  BSF    03.6
0253:  MOVF   46,W
0254:  ANDLW  0F
0255:  MOVWF  47
0256:  MOVWF  48
0257:  BCF    03.6
0258:  CALL   154
0259:  RETURN
.................... } 
....................  
.................... #if defined(LCD_EXTENDED_NEWLINE) 
.................... unsigned int8 g_LcdX, g_LcdY; 
.................... #endif 
....................  
.................... void lcd_init(void)  
.................... { 
....................    unsigned int8 i; 
....................    unsigned int8 LCD_INIT_STRING[4] = {0x20 | (LCD_TYPE << 2), 0xc, 1, 6}; 
025A:  MOVLW  28
025B:  BSF    03.6
025C:  MOVWF  11
025D:  MOVLW  0C
025E:  MOVWF  12
025F:  MOVLW  01
0260:  MOVWF  13
0261:  MOVLW  06
0262:  MOVWF  14
....................                              // These bytes need to be sent to the LCD 
....................                              // to start it up. 
....................     
....................  
....................    lcd_output_enable(0); 
0263:  BCF    03.6
0264:  BCF    09.0
0265:  BSF    03.5
0266:  BCF    09.0
....................    lcd_output_rs(0); 
0267:  BCF    03.5
0268:  BCF    09.1
0269:  BSF    03.5
026A:  BCF    09.1
....................    lcd_output_rw(0); 
026B:  BCF    03.5
026C:  BCF    09.2
026D:  BSF    03.5
026E:  BCF    09.2
....................  
....................  #if defined(__PCB__) 
....................    set_tris_lcd(LCD_OUTPUT_MAP); 
....................  #else 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    output_drive(LCD_DATA4); 
026F:  BCF    03.5
0270:  BCF    31.0
0271:  MOVF   31,W
0272:  BSF    03.5
0273:  MOVWF  07
....................    output_drive(LCD_DATA5); 
0274:  BCF    03.5
0275:  BCF    31.1
0276:  MOVF   31,W
0277:  BSF    03.5
0278:  MOVWF  07
....................    output_drive(LCD_DATA6); 
0279:  BCF    03.5
027A:  BCF    31.2
027B:  MOVF   31,W
027C:  BSF    03.5
027D:  MOVWF  07
....................    output_drive(LCD_DATA7); 
027E:  BCF    03.5
027F:  BCF    31.3
0280:  MOVF   31,W
0281:  BSF    03.5
0282:  MOVWF  07
....................   #else 
....................    lcdtris.data = 0x0; 
....................   #endif 
....................    lcd_enable_tris(); 
0283:  BCF    09.0
....................    lcd_rs_tris(); 
0284:  BCF    09.1
....................    lcd_rw_tris(); 
0285:  BCF    09.2
....................  #endif 
....................      
....................    delay_ms(15); 
0286:  MOVLW  0F
0287:  BCF    03.5
0288:  BSF    03.6
0289:  MOVWF  41
028A:  BCF    03.6
028B:  CALL   140
....................    for(i=1;i<=3;++i) 
028C:  MOVLW  01
028D:  BSF    03.6
028E:  MOVWF  10
028F:  MOVF   10,W
0290:  SUBLW  03
0291:  BTFSS  03.0
0292:  GOTO   29F
....................    { 
....................        lcd_send_nibble(3); 
0293:  MOVLW  03
0294:  MOVWF  48
0295:  BCF    03.6
0296:  CALL   154
....................        delay_ms(5); 
0297:  MOVLW  05
0298:  BSF    03.6
0299:  MOVWF  41
029A:  BCF    03.6
029B:  CALL   140
029C:  BSF    03.6
029D:  INCF   10,F
029E:  GOTO   28F
....................    } 
....................     
....................    lcd_send_nibble(2); 
029F:  MOVLW  02
02A0:  MOVWF  48
02A1:  BCF    03.6
02A2:  CALL   154
....................    delay_ms(5); 
02A3:  MOVLW  05
02A4:  BSF    03.6
02A5:  MOVWF  41
02A6:  BCF    03.6
02A7:  CALL   140
....................    for(i=0;i<=3;++i) 
02A8:  BSF    03.6
02A9:  CLRF   10
02AA:  MOVF   10,W
02AB:  SUBLW  03
02AC:  BTFSS  03.0
02AD:  GOTO   2BC
....................       lcd_send_byte(0,LCD_INIT_STRING[i]); 
02AE:  MOVLW  11
02AF:  ADDWF  10,W
02B0:  MOVWF  04
02B1:  BSF    03.7
02B2:  MOVF   00,W
02B3:  MOVWF  15
02B4:  CLRF   45
02B5:  MOVF   15,W
02B6:  MOVWF  46
02B7:  BCF    03.6
02B8:  CALL   1DF
....................  
....................   #if defined(LCD_EXTENDED_NEWLINE) 
02B9:  BSF    03.6
02BA:  INCF   10,F
02BB:  GOTO   2AA
02BC:  BCF    03.6
02BD:  BCF    0A.3
02BE:  BSF    0A.4
02BF:  GOTO   1EF (RETURN)
....................    g_LcdX = 0; 
....................    g_LcdY = 0; 
....................   #endif 
.................... } 
....................  
.................... void lcd_gotoxy(unsigned int8 x, unsigned int8 y) 
.................... { 
....................    unsigned int8 address; 
....................     
....................    if(y!=1) 
02C0:  BSF    03.6
02C1:  DECFSZ 42,W
02C2:  GOTO   2C4
02C3:  GOTO   2C7
....................       address=LCD_LINE_TWO; 
02C4:  MOVLW  40
02C5:  MOVWF  43
02C6:  GOTO   2C8
....................    else 
....................       address=0; 
02C7:  CLRF   43
....................       
....................    address+=x-1; 
02C8:  MOVLW  01
02C9:  SUBWF  41,W
02CA:  ADDWF  43,F
....................    lcd_send_byte(0,0x80|address); 
02CB:  MOVF   43,W
02CC:  IORLW  80
02CD:  MOVWF  44
02CE:  CLRF   45
02CF:  MOVF   44,W
02D0:  MOVWF  46
02D1:  BCF    03.6
02D2:  CALL   1DF
....................  
....................   #if defined(LCD_EXTENDED_NEWLINE) 
02D3:  RETURN
....................    g_LcdX = x - 1; 
....................    g_LcdY = y - 1; 
....................   #endif 
.................... } 
....................  
.................... void lcd_putc(char c) 
.................... { 
....................    switch (c) 
02D4:  BSF    03.6
02D5:  MOVF   40,W
02D6:  XORLW  07
02D7:  BCF    03.6
02D8:  BTFSC  03.2
02D9:  GOTO   2E4
02DA:  XORLW  0B
02DB:  BTFSC  03.2
02DC:  GOTO   2EB
02DD:  XORLW  06
02DE:  BTFSC  03.2
02DF:  GOTO   2F7
02E0:  XORLW  02
02E1:  BTFSC  03.2
02E2:  GOTO   2FF
02E3:  GOTO   306
....................    { 
....................       case '\a'   :  lcd_gotoxy(1,1);     break; 
02E4:  MOVLW  01
02E5:  BSF    03.6
02E6:  MOVWF  41
02E7:  MOVWF  42
02E8:  BCF    03.6
02E9:  CALL   2C0
02EA:  GOTO   30D
....................  
....................       case '\f'   :  lcd_send_byte(0,1); 
02EB:  BSF    03.6
02EC:  CLRF   45
02ED:  MOVLW  01
02EE:  MOVWF  46
02EF:  BCF    03.6
02F0:  CALL   1DF
....................                      delay_ms(2); 
02F1:  MOVLW  02
02F2:  BSF    03.6
02F3:  MOVWF  41
02F4:  BCF    03.6
02F5:  CALL   140
....................                     #if defined(LCD_EXTENDED_NEWLINE) 
....................                      g_LcdX = 0; 
....................                      g_LcdY = 0; 
....................                     #endif 
....................                      break; 
02F6:  GOTO   30D
....................  
....................      #if defined(LCD_EXTENDED_NEWLINE) 
....................       case '\r'   :  lcd_gotoxy(1, g_LcdY+1);   break; 
....................       case '\n'   : 
....................          while (g_LcdX++ < LCD_LINE_LENGTH) 
....................          { 
....................             lcd_send_byte(1, ' '); 
....................          } 
....................          lcd_gotoxy(1, g_LcdY+2); 
....................          break; 
....................      #else 
....................       case '\n'   : lcd_gotoxy(1,2);        break; 
02F7:  MOVLW  01
02F8:  BSF    03.6
02F9:  MOVWF  41
02FA:  MOVLW  02
02FB:  MOVWF  42
02FC:  BCF    03.6
02FD:  CALL   2C0
02FE:  GOTO   30D
....................      #endif 
....................       
....................       case '\b'   : lcd_send_byte(0,0x10);  break; 
02FF:  BSF    03.6
0300:  CLRF   45
0301:  MOVLW  10
0302:  MOVWF  46
0303:  BCF    03.6
0304:  CALL   1DF
0305:  GOTO   30D
....................       
....................      #if defined(LCD_EXTENDED_NEWLINE) 
....................       default     :  
....................          if (g_LcdX < LCD_LINE_LENGTH) 
....................          { 
....................             lcd_send_byte(1, c); 
....................             g_LcdX++; 
....................          } 
....................          break; 
....................      #else 
....................       default     : lcd_send_byte(1,c);     break; 
0306:  MOVLW  01
0307:  BSF    03.6
0308:  MOVWF  45
0309:  MOVF   40,W
030A:  MOVWF  46
030B:  BCF    03.6
030C:  CALL   1DF
....................      #endif 
....................    } 
030D:  RETURN
.................... } 
....................   
.................... char lcd_getc(unsigned int8 x, unsigned int8 y) 
.................... { 
....................    char value; 
....................  
....................    lcd_gotoxy(x,y); 
....................    while ( bit_test(lcd_read_byte(),7) ); // wait until busy flag is low 
....................    lcd_output_rs(1); 
....................    value = lcd_read_byte(); 
....................    lcd_output_rs(0); 
....................     
....................    return(value); 
.................... } 
....................  
.................... // write a custom character to the ram 
.................... // which is 0-7 and specifies which character array we are modifying. 
.................... // ptr points to an array of 8 bytes, where each byte is the next row of 
.................... //    pixels.  only bits 0-4 are used.  the last row is the cursor row, and 
.................... //    usually you will want to leave this byte 0x00. 
.................... void lcd_set_cgram_char(unsigned int8 which, unsigned int8 *ptr) 
.................... { 
....................    unsigned int i; 
....................  
....................    which <<= 3; 
....................    which &= 0x38; 
....................  
....................    lcd_send_byte(0, 0x40 | which);  //set cgram address 
....................  
....................    for(i=0; i<8; i++) 
....................    { 
....................       lcd_send_byte(1, *ptr++); 
....................    } 
....................    
....................    #if defined(LCD_EXTENDED_NEWLINE) 
....................     lcd_gotoxy(g_LcdX+1, g_LcdY+1);  //set ddram address 
....................    #endif 
.................... } 
....................  
.................... void lcd_cursor_on(int1 on) 
.................... { 
....................    if (on) 
....................    { 
....................       lcd_send_byte(0,0x0F);           //turn LCD cursor ON 
....................    } 
....................    else 
....................    { 
....................       lcd_send_byte(0,0x0C);           //turn LCD cursor OFF 
....................    } 
.................... } 
....................  
.................... #endif 
....................  
.................... #BIT TMR1IF = 0x0C.0 //bit thu 0 (TMR1IF) cua PIR1 
....................  
.................... #INCLUDE <khaibaobien.c> // VARIABLE. 
.................... UNSIGNED INT16 KQADC; 
.................... UNSIGNED INT8 KET_QUA_ANALOG[]={0,0,0,0}; 
*
115B:  CLRF   34
115C:  CLRF   35
115D:  CLRF   36
115E:  CLRF   37
.................... UNSIGNED INT8 CONFIG_FUN=0; 
.................... UNSIGNED INT8 VT=0, KYTU=0;// KYTU[30],  
.................... UNSIGNED INT8 LENH_DIEU_KHIEN = 0; 
.................... UNSIGNED INT8 ID_GATEWAY[6] = {3,8,6,9,0,7}; 
115F:  MOVLW  03
1160:  MOVWF  3C
1161:  MOVLW  08
1162:  MOVWF  3D
1163:  MOVLW  06
1164:  MOVWF  3E
1165:  MOVLW  09
1166:  MOVWF  3F
1167:  CLRF   40
1168:  MOVLW  07
1169:  MOVWF  41
.................... UNSIGNED INT8 ID_NODE[4] = {1,8,1,0}; 
116A:  MOVLW  01
116B:  MOVWF  42
116C:  MOVLW  08
116D:  MOVWF  43
116E:  MOVLW  01
116F:  MOVWF  44
1170:  CLRF   45
.................... UNSIGNED INT8 LEN_PACKAGES = 0; 
.................... UNSIGNED INT8 LENHDIEUKHIEN =0, DODAI_DATA_NHAN =0; 
.................... UNSIGNED INT8 SOLUONGTHIETBI_CONFIG=0, SOLUONGCAMBIEN_CONFIG = 3; 
.................... SIGNED INT8 SOSANH_IDNODE=0, SOSANH_IDGW=0; 
....................  
.................... INT1 TTNHAN = 0, TT_CONFIG=0, TT_CONTROL=0,TT_CONFIG_DONE=0, TT_FUN=0, TT_STT=0 , TT_CONFIG_OKE_UART = 0; 
....................  
.................... CHAR *ID_NODE_CHAR[]= "0589"; 
1171:  MOVLW  30
1172:  MOVWF  50
1173:  MOVLW  35
1174:  MOVWF  51
1175:  MOVLW  38
1176:  MOVWF  52
1177:  MOVLW  39
1178:  MOVWF  53
1179:  CLRF   54
117A:  CLRF   4F
117B:  MOVLW  50
117C:  MOVWF  4E
.................... CHAR *ID_GATEWAY_CHAR[]= "127102"; 
117D:  MOVLW  31
117E:  MOVWF  57
117F:  MOVLW  32
1180:  MOVWF  58
1181:  MOVLW  37
1182:  MOVWF  59
1183:  MOVLW  31
1184:  MOVWF  5A
1185:  MOVLW  30
1186:  MOVWF  5B
1187:  MOVLW  32
1188:  MOVWF  5C
1189:  CLRF   5D
118A:  CLRF   56
118B:  MOVLW  57
118C:  MOVWF  55
.................... CHAR *ID_NODE_NHAN[]= "0000"; 
118D:  MOVLW  30
118E:  MOVWF  60
118F:  MOVWF  61
1190:  MOVWF  62
1191:  MOVWF  63
1192:  CLRF   64
1193:  CLRF   5F
1194:  MOVLW  60
1195:  MOVWF  5E
.................... CHAR *ID_GW_NHAN[]= "000000"; 
1196:  MOVLW  30
1197:  MOVWF  67
1198:  MOVWF  68
1199:  MOVWF  69
119A:  MOVWF  6A
119B:  MOVWF  6B
119C:  MOVWF  6C
119D:  CLRF   6D
119E:  CLRF   66
119F:  MOVLW  67
11A0:  MOVWF  65
.................... CHAR KYTUCHAR[50]="HIHI"; 
11A1:  MOVLW  48
11A2:  BSF    03.5
11A3:  MOVWF  20
11A4:  MOVLW  49
11A5:  MOVWF  21
11A6:  MOVLW  48
11A7:  MOVWF  22
11A8:  MOVLW  49
11A9:  MOVWF  23
11AA:  CLRF   24
.................... CHAR KYTUCHAR2[25]="HIHI"; 
11AB:  MOVLW  48
11AC:  MOVWF  52
11AD:  MOVLW  49
11AE:  MOVWF  53
11AF:  MOVLW  48
11B0:  MOVWF  54
11B1:  MOVLW  49
11B2:  MOVWF  55
11B3:  CLRF   56
.................... //CHAR *DATA_NHANDUOC[]={"IDGW","IDNODE","COMMAN","DATA"}; 
.................... CHAR *TEMP_CHAR[]="0000";   
11B4:  MOVLW  30
11B5:  MOVWF  70
11B6:  MOVWF  71
11B7:  MOVWF  72
11B8:  MOVWF  73
11B9:  CLRF   74
11BA:  BCF    03.5
11BB:  CLRF   6F
11BC:  MOVLW  70
11BD:  MOVWF  6E
.................... CHAR *TEMP_CHAR2[]="2700";  
11BE:  MOVLW  32
11BF:  BSF    03.5
11C0:  MOVWF  6B
11C1:  MOVLW  37
11C2:  MOVWF  6C
11C3:  MOVLW  30
11C4:  MOVWF  6D
11C5:  MOVWF  6E
11C6:  CLRF   6F
11C7:  CLRF   76
11C8:  MOVLW  EB
11C9:  MOVWF  75
.................... //CHAR *TEMP_CHAR3[]="000000";  
....................  
....................  
....................  
.................... //#INCLUDE <CONFIG_NODE.C> // CU HINH NODE. 
.................... #INCLUDE <config_1.C> // CU HINH NODE. 
....................  
.................... //--------------------------------------------------------------------// 
.................... VOID CHON_ID() 
.................... { 
....................    // TT_CONFIG_DONE; 
....................    TT_CONFIG_DONE = 0; 
*
05A7:  BCF    4D.3
....................    TT_STT = 1; 
05A8:  BSF    4D.5
....................    UNSIGNED INT8 NUM = 0; 
05A9:  BSF    03.6
05AA:  CLRF   10
....................    TEMP_CHAR = "0"; 
05AB:  CLRF   11
05AC:  CLRF   12
05AD:  MOVLW  6E
05AE:  MOVWF  04
05AF:  BCF    03.7
05B0:  MOVF   11,W
05B1:  ADDWF  04,F
05B2:  MOVF   12,W
05B3:  BCF    03.6
05B4:  CALL   058
05B5:  MOVWF  00
05B6:  IORLW  00
05B7:  BTFSC  03.2
05B8:  GOTO   5BE
05B9:  BSF    03.6
05BA:  INCF   12,F
05BB:  INCF   11,F
05BC:  GOTO   5AD
05BD:  BCF    03.6
....................    LCD_GOTOXY (1, 2) ; 
05BE:  MOVLW  01
05BF:  BSF    03.6
05C0:  MOVWF  41
05C1:  MOVLW  02
05C2:  MOVWF  42
05C3:  BCF    03.6
05C4:  CALL   2C0
....................    DELAY_MS (10); 
05C5:  MOVLW  0A
05C6:  BSF    03.6
05C7:  MOVWF  41
05C8:  BCF    03.6
05C9:  CALL   140
....................    PRINTF (LCD_PUTC, "NODE: "); 
05CA:  MOVLW  6F
05CB:  BSF    03.6
05CC:  MOVWF  0D
05CD:  MOVLW  00
05CE:  MOVWF  0F
05CF:  BCF    03.6
05D0:  CALL   30E
....................    PRINTF (LCD_PUTC, "0000          "); 
05D1:  MOVLW  73
05D2:  BSF    03.6
05D3:  MOVWF  0D
05D4:  MOVLW  00
05D5:  MOVWF  0F
05D6:  BCF    03.6
05D7:  CALL   30E
....................    LCD_GOTOXY (1, 1) ; 
05D8:  MOVLW  01
05D9:  BSF    03.6
05DA:  MOVWF  41
05DB:  MOVWF  42
05DC:  BCF    03.6
05DD:  CALL   2C0
....................    PRINTF (LCD_PUTC, "      _              ");//6 SPACE PHIA TRUOC "_" 
05DE:  MOVLW  7B
05DF:  BSF    03.6
05E0:  MOVWF  0D
05E1:  MOVLW  00
05E2:  MOVWF  0F
05E3:  BCF    03.6
05E4:  CALL   30E
....................    //ID_GW = "1234";     
....................  
....................    WHILE (TT_STT) 
05E5:  BTFSS  4D.5
05E6:  GOTO   663
....................    { 
....................       IF (!INPUT (BT2_PIN)) //NEU NUT BAM DUOC BAM 
05E7:  BSF    03.5
05E8:  BSF    06.2
05E9:  BCF    03.5
05EA:  BTFSC  06.2
05EB:  GOTO   60A
....................       { 
....................           
....................          NUM++; 
05EC:  BSF    03.6
05ED:  INCF   10,F
....................          NUM = NUM % 4; 
05EE:  MOVLW  03
05EF:  ANDWF  10,F
....................          LCD_GOTOXY (3 + NUM, 1); 
05F0:  ADDWF  10,W
05F1:  MOVWF  11
05F2:  MOVWF  41
05F3:  MOVLW  01
05F4:  MOVWF  42
05F5:  BCF    03.6
05F6:  CALL   2C0
....................          PRINTF (LCD_PUTC, "    _    ");//4SPACE 
05F7:  MOVLW  86
05F8:  BSF    03.6
05F9:  MOVWF  0D
05FA:  MOVLW  00
05FB:  MOVWF  0F
05FC:  BCF    03.6
05FD:  CALL   30E
....................          DELAY_MS (300);  
05FE:  MOVLW  02
05FF:  BSF    03.6
0600:  MOVWF  11
0601:  MOVLW  96
0602:  MOVWF  41
0603:  BCF    03.6
0604:  CALL   140
0605:  BSF    03.6
0606:  DECFSZ 11,F
0607:  GOTO   601
....................       } 
0608:  GOTO   661
0609:  BCF    03.6
....................  
....................       ELSE IF (!INPUT (BT3_PIN)) 
060A:  BSF    03.5
060B:  BSF    06.3
060C:  BCF    03.5
060D:  BTFSC  06.3
060E:  GOTO   662
....................       { 
....................          ID_NODE[NUM]++; 
060F:  MOVLW  42
0610:  BSF    03.6
0611:  ADDWF  10,W
0612:  MOVWF  04
0613:  BCF    03.7
0614:  INCF   00,F
....................          ID_NODE[NUM] = ID_NODE[NUM] % 10; 
0615:  MOVLW  42
0616:  ADDWF  10,W
0617:  MOVWF  78
0618:  CLRF   7A
0619:  BTFSC  03.0
061A:  INCF   7A,F
061B:  MOVF   78,W
061C:  MOVWF  11
061D:  MOVF   7A,W
061E:  MOVWF  12
061F:  MOVLW  42
0620:  ADDWF  10,W
0621:  MOVWF  04
0622:  BCF    03.7
0623:  MOVF   00,W
0624:  MOVWF  14
0625:  MOVLW  0A
0626:  MOVWF  15
0627:  BCF    03.6
0628:  CALL   517
0629:  MOVF   77,W
062A:  BSF    03.6
062B:  MOVWF  13
062C:  MOVF   11,W
062D:  MOVWF  04
062E:  BCF    03.7
062F:  BTFSC  12.0
0630:  BSF    03.7
0631:  MOVF   13,W
0632:  MOVWF  00
....................          ITOA (ID_NODE[NUM], 10, TEMP_CHAR); 
0633:  MOVLW  42
0634:  ADDWF  10,W
0635:  MOVWF  04
0636:  BCF    03.7
0637:  MOVF   00,W
0638:  MOVWF  11
0639:  CLRF   42
063A:  CLRF   41
063B:  CLRF   40
063C:  MOVF   11,W
063D:  MOVWF  3F
063E:  MOVLW  0A
063F:  MOVWF  43
0640:  CLRF   45
0641:  MOVLW  6E
0642:  MOVWF  44
0643:  BCF    03.6
0644:  CALL   3DA
....................          LCD_GOTOXY (7 + NUM, 2); 
0645:  MOVLW  07
0646:  BSF    03.6
0647:  ADDWF  10,W
0648:  MOVWF  11
0649:  MOVWF  41
064A:  MOVLW  02
064B:  MOVWF  42
064C:  BCF    03.6
064D:  CALL   2C0
....................          DELAY_MS (10); 
064E:  MOVLW  0A
064F:  BSF    03.6
0650:  MOVWF  41
0651:  BCF    03.6
0652:  CALL   140
....................          PRINTF (LCD_PUTC, TEMP_CHAR); 
0653:  MOVLW  6E
0654:  MOVWF  04
0655:  BCF    03.7
0656:  CALL   4FA
....................          DELAY_MS (300); 
0657:  MOVLW  02
0658:  BSF    03.6
0659:  MOVWF  11
065A:  MOVLW  96
065B:  MOVWF  41
065C:  BCF    03.6
065D:  CALL   140
065E:  BSF    03.6
065F:  DECFSZ 11,F
0660:  GOTO   65A
0661:  BCF    03.6
....................       } 
0662:  GOTO   5E5
....................    } 
.................... } 
....................  
.................... VOID NHAPID_GW() 
*
0664:  BSF    03.6
0665:  CLRF   10
.................... { 
....................    UNSIGNED INT8 NUM = 0; 
....................    TEMP_CHAR = "0"; 
0666:  CLRF   11
0667:  CLRF   12
0668:  MOVLW  6E
0669:  MOVWF  04
066A:  BCF    03.7
066B:  MOVF   11,W
066C:  ADDWF  04,F
066D:  MOVF   12,W
066E:  BCF    03.6
066F:  CALL   058
0670:  MOVWF  00
0671:  IORLW  00
0672:  BTFSC  03.2
0673:  GOTO   679
0674:  BSF    03.6
0675:  INCF   12,F
0676:  INCF   11,F
0677:  GOTO   668
0678:  BCF    03.6
....................    TT_CONFIG_DONE = 0; 
0679:  BCF    4D.3
....................    TT_STT = 1; 
067A:  BSF    4D.5
....................    LCD_GOTOXY (1, 2) ; 
067B:  MOVLW  01
067C:  BSF    03.6
067D:  MOVWF  41
067E:  MOVLW  02
067F:  MOVWF  42
0680:  BCF    03.6
0681:  CALL   2C0
....................    DELAY_MS (10); 
0682:  MOVLW  0A
0683:  BSF    03.6
0684:  MOVWF  41
0685:  BCF    03.6
0686:  CALL   140
....................    PRINTF (LCD_PUTC, "ID_GW:"); 
0687:  MOVLW  8B
0688:  BSF    03.6
0689:  MOVWF  0D
068A:  MOVLW  00
068B:  MOVWF  0F
068C:  BCF    03.6
068D:  CALL   30E
....................    PRINTF (LCD_PUTC, "000000        "); 
068E:  MOVLW  8F
068F:  BSF    03.6
0690:  MOVWF  0D
0691:  MOVLW  00
0692:  MOVWF  0F
0693:  BCF    03.6
0694:  CALL   30E
....................    LCD_GOTOXY (1, 1) ; 
0695:  MOVLW  01
0696:  BSF    03.6
0697:  MOVWF  41
0698:  MOVWF  42
0699:  BCF    03.6
069A:  CALL   2C0
....................    PRINTF (LCD_PUTC, "      _                ");//6 SPACE PHIA TRUOC "_" 
069B:  MOVLW  97
069C:  BSF    03.6
069D:  MOVWF  0D
069E:  MOVLW  00
069F:  MOVWF  0F
06A0:  BCF    03.6
06A1:  CALL   30E
....................    //ID_GW = "1234";     
....................  
....................    WHILE (TT_STT) 
06A2:  BTFSS  4D.5
06A3:  GOTO   728
....................    { 
....................       IF (!INPUT (BT2_PIN)) //NEU NUT BAM DUOC BAM 
06A4:  BSF    03.5
06A5:  BSF    06.2
06A6:  BCF    03.5
06A7:  BTFSC  06.2
06A8:  GOTO   6CF
....................       { 
....................           
....................          NUM++; 
06A9:  BSF    03.6
06AA:  INCF   10,F
....................          NUM = NUM % 6; 
06AB:  MOVF   10,W
06AC:  MOVWF  14
06AD:  MOVLW  06
06AE:  MOVWF  15
06AF:  BCF    03.6
06B0:  CALL   517
06B1:  MOVF   77,W
06B2:  BSF    03.6
06B3:  MOVWF  10
....................          LCD_GOTOXY (3 + NUM, 1); 
06B4:  MOVLW  03
06B5:  ADDWF  10,W
06B6:  MOVWF  11
06B7:  MOVWF  41
06B8:  MOVLW  01
06B9:  MOVWF  42
06BA:  BCF    03.6
06BB:  CALL   2C0
....................          PRINTF (LCD_PUTC, "    _        ");//4SPACE 
06BC:  MOVLW  A3
06BD:  BSF    03.6
06BE:  MOVWF  0D
06BF:  MOVLW  00
06C0:  MOVWF  0F
06C1:  BCF    03.6
06C2:  CALL   30E
....................          DELAY_MS (300);  
06C3:  MOVLW  02
06C4:  BSF    03.6
06C5:  MOVWF  11
06C6:  MOVLW  96
06C7:  MOVWF  41
06C8:  BCF    03.6
06C9:  CALL   140
06CA:  BSF    03.6
06CB:  DECFSZ 11,F
06CC:  GOTO   6C6
....................       } 
06CD:  GOTO   726
06CE:  BCF    03.6
....................  
....................       ELSE IF (!INPUT (BT3_PIN)) 
06CF:  BSF    03.5
06D0:  BSF    06.3
06D1:  BCF    03.5
06D2:  BTFSC  06.3
06D3:  GOTO   727
....................       { 
....................          ID_GATEWAY[NUM]++; 
06D4:  MOVLW  3C
06D5:  BSF    03.6
06D6:  ADDWF  10,W
06D7:  MOVWF  04
06D8:  BCF    03.7
06D9:  INCF   00,F
....................          ID_GATEWAY[NUM] = ID_GATEWAY[NUM] % 10; 
06DA:  MOVLW  3C
06DB:  ADDWF  10,W
06DC:  MOVWF  78
06DD:  CLRF   7A
06DE:  BTFSC  03.0
06DF:  INCF   7A,F
06E0:  MOVF   78,W
06E1:  MOVWF  11
06E2:  MOVF   7A,W
06E3:  MOVWF  12
06E4:  MOVLW  3C
06E5:  ADDWF  10,W
06E6:  MOVWF  04
06E7:  BCF    03.7
06E8:  MOVF   00,W
06E9:  MOVWF  14
06EA:  MOVLW  0A
06EB:  MOVWF  15
06EC:  BCF    03.6
06ED:  CALL   517
06EE:  MOVF   77,W
06EF:  BSF    03.6
06F0:  MOVWF  13
06F1:  MOVF   11,W
06F2:  MOVWF  04
06F3:  BCF    03.7
06F4:  BTFSC  12.0
06F5:  BSF    03.7
06F6:  MOVF   13,W
06F7:  MOVWF  00
....................          ITOA (ID_GATEWAY[NUM], 10, TEMP_CHAR); 
06F8:  MOVLW  3C
06F9:  ADDWF  10,W
06FA:  MOVWF  04
06FB:  BCF    03.7
06FC:  MOVF   00,W
06FD:  MOVWF  11
06FE:  CLRF   42
06FF:  CLRF   41
0700:  CLRF   40
0701:  MOVF   11,W
0702:  MOVWF  3F
0703:  MOVLW  0A
0704:  MOVWF  43
0705:  CLRF   45
0706:  MOVLW  6E
0707:  MOVWF  44
0708:  BCF    03.6
0709:  CALL   3DA
....................          LCD_GOTOXY (7 + NUM, 2); 
070A:  MOVLW  07
070B:  BSF    03.6
070C:  ADDWF  10,W
070D:  MOVWF  11
070E:  MOVWF  41
070F:  MOVLW  02
0710:  MOVWF  42
0711:  BCF    03.6
0712:  CALL   2C0
....................          DELAY_MS (10); 
0713:  MOVLW  0A
0714:  BSF    03.6
0715:  MOVWF  41
0716:  BCF    03.6
0717:  CALL   140
....................          PRINTF (LCD_PUTC, TEMP_CHAR); 
0718:  MOVLW  6E
0719:  MOVWF  04
071A:  BCF    03.7
071B:  CALL   4FA
....................          DELAY_MS (300); 
071C:  MOVLW  02
071D:  BSF    03.6
071E:  MOVWF  11
071F:  MOVLW  96
0720:  MOVWF  41
0721:  BCF    03.6
0722:  CALL   140
0723:  BSF    03.6
0724:  DECFSZ 11,F
0725:  GOTO   71F
0726:  BCF    03.6
....................       } 
0727:  GOTO   6A2
....................    } 
.................... } 
....................  
.................... VOID BUTT_OKE() 
.................... { 
....................    TT_CONFIG_DONE = 0; 
*
0118:  BCF    03.6
0119:  BCF    4D.3
....................    TT_FUN = 0;//BREAK WHILE BUTT_FUN 
011A:  BCF    4D.4
....................    TT_STT = 0;// BREAK WHILE CHONID/NHAPID_GW 
011B:  BCF    4D.5
.................... } 
....................  
.................... VOID SELLECT_FUN() 
.................... { 
....................    TT_CONFIG_DONE = 0; 
*
059F:  BCF    4D.3
....................  
....................    SWITCH (CONFIG_FUN) 
05A0:  MOVF   38,W
05A1:  BTFSC  03.2
05A2:  GOTO   5A7
05A3:  XORLW  01
05A4:  BTFSC  03.2
05A5:  GOTO   664
05A6:  GOTO   728
....................    { 
....................       CASE 0: 
....................       CHON_ID (); 
....................       BREAK; 
*
0663:  GOTO   728
....................  
....................       CASE 1:     
....................       NHAPID_GW (); 
....................       BREAK; 
....................    } 
.................... } 
....................  
.................... VOID BUTT_FUN() 
.................... { 
....................    TT_FUN = 1; 
*
052E:  BSF    4D.4
....................    LCD_GOTOXY (1, 1) ; 
052F:  MOVLW  01
0530:  BSF    03.6
0531:  MOVWF  41
0532:  MOVWF  42
0533:  BCF    03.6
0534:  CALL   2C0
....................    DELAY_MS (10); 
0535:  MOVLW  0A
0536:  BSF    03.6
0537:  MOVWF  41
0538:  BCF    03.6
0539:  CALL   140
....................    PRINTF (LCD_PUTC, "CONFIG:        "); 
053A:  MOVLW  AA
053B:  BSF    03.6
053C:  MOVWF  0D
053D:  MOVLW  00
053E:  MOVWF  0F
053F:  BCF    03.6
0540:  CALL   30E
....................  
....................    // HIEN THI LCD 
....................    LCD_GOTOXY (1, 2) ; 
0541:  MOVLW  01
0542:  BSF    03.6
0543:  MOVWF  41
0544:  MOVLW  02
0545:  MOVWF  42
0546:  BCF    03.6
0547:  CALL   2C0
....................    DELAY_MS (10); 
0548:  MOVLW  0A
0549:  BSF    03.6
054A:  MOVWF  41
054B:  BCF    03.6
054C:  CALL   140
....................    PRINTF (LCD_PUTC, "CASE:          ") ; 
054D:  MOVLW  B2
054E:  BSF    03.6
054F:  MOVWF  0D
0550:  MOVLW  00
0551:  MOVWF  0F
0552:  BCF    03.6
0553:  CALL   30E
....................  
....................    WHILE (TT_FUN) 
0554:  BTFSS  4D.4
0555:  GOTO   59D
....................    { 
....................       IF (INPUT (BT2_PIN) == 0) //NEU NUT BAM DUOC BAM 
0556:  BSF    03.5
0557:  BSF    06.2
0558:  BCF    03.5
0559:  BTFSC  06.2
055A:  GOTO   59C
....................       { 
....................          CONFIG_FUN ++; 
055B:  INCF   38,F
....................          CONFIG_FUN = CONFIG_FUN % 2; 
055C:  MOVLW  01
055D:  ANDWF  38,F
....................          DELAY_MS (300); 
055E:  MOVLW  02
055F:  BSF    03.6
0560:  MOVWF  10
0561:  MOVLW  96
0562:  MOVWF  41
0563:  BCF    03.6
0564:  CALL   140
0565:  BSF    03.6
0566:  DECFSZ 10,F
0567:  GOTO   561
....................          //HIEN THI 
....................          LCD_GOTOXY (6, 2) ; 
0568:  MOVLW  06
0569:  MOVWF  41
056A:  MOVLW  02
056B:  MOVWF  42
056C:  BCF    03.6
056D:  CALL   2C0
....................          ITOA (CONFIG_FUN, 10, TEMP_CHAR); 
056E:  BSF    03.6
056F:  CLRF   42
0570:  CLRF   41
0571:  CLRF   40
0572:  BCF    03.6
0573:  MOVF   38,W
0574:  BSF    03.6
0575:  MOVWF  3F
0576:  MOVLW  0A
0577:  MOVWF  43
0578:  CLRF   45
0579:  MOVLW  6E
057A:  MOVWF  44
057B:  BCF    03.6
057C:  CALL   3DA
....................          DELAY_MS (10); 
057D:  MOVLW  0A
057E:  BSF    03.6
057F:  MOVWF  41
0580:  BCF    03.6
0581:  CALL   140
....................          PRINTF (LCD_PUTC, TEMP_CHAR); 
0582:  MOVLW  6E
0583:  MOVWF  04
0584:  BCF    03.7
0585:  CALL   4FA
....................  
....................          SWITCH (CONFIG_FUN) 
0586:  MOVF   38,W
0587:  BTFSC  03.2
0588:  GOTO   58D
0589:  XORLW  01
058A:  BTFSC  03.2
058B:  GOTO   595
058C:  GOTO   59C
....................          { 
....................             CASE 0: 
....................             PRINTF (LCD_PUTC, " - ID-NODE      "); 
058D:  MOVLW  BA
058E:  BSF    03.6
058F:  MOVWF  0D
0590:  MOVLW  00
0591:  MOVWF  0F
0592:  BCF    03.6
0593:  CALL   30E
....................             BREAK; 
0594:  GOTO   59C
....................  
....................             CASE 1: 
....................             PRINTF (LCD_PUTC, " - ID-GW       "); 
0595:  MOVLW  C3
0596:  BSF    03.6
0597:  MOVWF  0D
0598:  MOVLW  00
0599:  MOVWF  0F
059A:  BCF    03.6
059B:  CALL   30E
....................             BREAK;             
....................          } 
....................       } 
059C:  GOTO   554
....................    } 
....................  
....................    ////// 
....................    IF (!TT_CONFIG_DONE) 
059D:  BTFSC  4D.3
059E:  GOTO   728
....................    { 
....................       SELLECT_FUN (); 
....................    } 
*
0728:  BCF    0A.3
0729:  BSF    0A.4
072A:  GOTO   1FC (RETURN)
.................... } 
.................... VOID XULY_IDNODE_NHAP(){ 
....................    //*TEMP_CHAR3 = "\0"; 
....................    *ID_NODE_CHAR = "\0"; 
*
0891:  CLRF   7A
0892:  MOVLW  4E
0893:  MOVWF  3E
0894:  MOVF   7A,W
0895:  MOVWF  3F
0896:  MOVF   3E,W
0897:  MOVWF  04
0898:  BCF    03.7
0899:  BTFSC  3F.0
089A:  BSF    03.7
089B:  CLRF   00
....................    FOR (int j = 0; j < 4; j++) 
089C:  CLRF   3D
089D:  MOVF   3D,W
089E:  SUBLW  03
089F:  BTFSS  03.0
08A0:  GOTO   0CA
....................    { 
....................       ITOA (ID_NODE[j], 10, TEMP_CHAR); 
08A1:  MOVLW  42
08A2:  ADDWF  3D,W
08A3:  MOVWF  04
08A4:  BCF    03.7
08A5:  MOVF   00,W
08A6:  MOVWF  3E
08A7:  CLRF   42
08A8:  CLRF   41
08A9:  CLRF   40
08AA:  MOVF   3E,W
08AB:  MOVWF  3F
08AC:  MOVLW  0A
08AD:  MOVWF  43
08AE:  CLRF   45
08AF:  MOVLW  6E
08B0:  MOVWF  44
08B1:  BCF    0A.3
08B2:  BCF    03.6
08B3:  CALL   3DA
08B4:  BSF    0A.3
....................       DELAY_MS (1); 
08B5:  MOVLW  01
08B6:  BSF    03.6
08B7:  MOVWF  41
08B8:  BCF    0A.3
08B9:  BCF    03.6
08BA:  CALL   140
08BB:  BSF    0A.3
....................       STRCAT (ID_NODE_CHAR, TEMP_CHAR); 
08BC:  BSF    03.6
08BD:  CLRF   3F
08BE:  MOVLW  4E
08BF:  MOVWF  3E
08C0:  CLRF   41
08C1:  MOVLW  6E
08C2:  MOVWF  40
08C3:  BCF    0A.3
08C4:  BCF    03.6
08C5:  CALL   72B
08C6:  BSF    0A.3
08C7:  BSF    03.6
08C8:  INCF   3D,F
08C9:  GOTO   09D
....................    }   
....................    //ID_NODE_CHAR = TEMP_CHAR3;    
....................    //STRCPY(ID_NODE_CHAR,TEMP_CHAR3); 
....................    //strcpy 
.................... } 
.................... VOID XULY_IDGW_NHAP(){ 
....................  
....................    *ID_GATEWAY_CHAR = "\0"; 
*
0855:  CLRF   7A
0856:  MOVLW  55
0857:  MOVWF  3E
0858:  MOVF   7A,W
0859:  MOVWF  3F
085A:  MOVF   3E,W
085B:  MOVWF  04
085C:  BCF    03.7
085D:  BTFSC  3F.0
085E:  BSF    03.7
085F:  CLRF   00
....................    FOR (int j = 0; j < 6; j++) 
0860:  CLRF   3D
0861:  MOVF   3D,W
0862:  SUBLW  05
0863:  BTFSS  03.0
0864:  GOTO   08E
....................    { 
....................       ITOA (ID_GATEWAY[j], 10, TEMP_CHAR); 
0865:  MOVLW  3C
0866:  ADDWF  3D,W
0867:  MOVWF  04
0868:  BCF    03.7
0869:  MOVF   00,W
086A:  MOVWF  3E
086B:  CLRF   42
086C:  CLRF   41
086D:  CLRF   40
086E:  MOVF   3E,W
086F:  MOVWF  3F
0870:  MOVLW  0A
0871:  MOVWF  43
0872:  CLRF   45
0873:  MOVLW  6E
0874:  MOVWF  44
0875:  BCF    0A.3
0876:  BCF    03.6
0877:  CALL   3DA
0878:  BSF    0A.3
....................       DELAY_MS (1); 
0879:  MOVLW  01
087A:  BSF    03.6
087B:  MOVWF  41
087C:  BCF    0A.3
087D:  BCF    03.6
087E:  CALL   140
087F:  BSF    0A.3
....................       STRCAT (ID_GATEWAY_CHAR, TEMP_CHAR); 
0880:  BSF    03.6
0881:  CLRF   3F
0882:  MOVLW  55
0883:  MOVWF  3E
0884:  CLRF   41
0885:  MOVLW  6E
0886:  MOVWF  40
0887:  BCF    0A.3
0888:  BCF    03.6
0889:  CALL   72B
088A:  BSF    0A.3
088B:  BSF    03.6
088C:  INCF   3D,F
088D:  GOTO   061
....................    }   
.................... } 
....................  
....................  
.................... VOID CONFIG_DONE() 
.................... { 
....................    TT_FUN = 0; 
*
0800:  BCF    4D.4
....................    TT_STT = 0; 
0801:  BCF    4D.5
....................    CHAR *PACKAGE_CONFIG[]={"*", "LENGHT","CF", "ID_GW1234" ,"ID_NODE","#"}; 
0802:  MOVLW  2A
0803:  BSF    03.6
0804:  MOVWF  1C
0805:  CLRF   1D
0806:  MOVLW  4C
0807:  MOVWF  1E
0808:  MOVLW  45
0809:  MOVWF  1F
080A:  MOVLW  4E
080B:  MOVWF  20
080C:  MOVLW  47
080D:  MOVWF  21
080E:  MOVLW  48
080F:  MOVWF  22
0810:  MOVLW  54
0811:  MOVWF  23
0812:  CLRF   24
0813:  MOVLW  43
0814:  MOVWF  25
0815:  MOVLW  46
0816:  MOVWF  26
0817:  CLRF   27
0818:  MOVLW  49
0819:  MOVWF  28
081A:  MOVLW  44
081B:  MOVWF  29
081C:  MOVLW  5F
081D:  MOVWF  2A
081E:  MOVLW  47
081F:  MOVWF  2B
0820:  MOVLW  57
0821:  MOVWF  2C
0822:  MOVLW  31
0823:  MOVWF  2D
0824:  MOVLW  32
0825:  MOVWF  2E
0826:  MOVLW  33
0827:  MOVWF  2F
0828:  MOVLW  34
0829:  MOVWF  30
082A:  CLRF   31
082B:  MOVLW  49
082C:  MOVWF  32
082D:  MOVLW  44
082E:  MOVWF  33
082F:  MOVLW  5F
0830:  MOVWF  34
0831:  MOVLW  4E
0832:  MOVWF  35
0833:  MOVLW  4F
0834:  MOVWF  36
0835:  MOVLW  44
0836:  MOVWF  37
0837:  MOVLW  45
0838:  MOVWF  38
0839:  CLRF   39
083A:  MOVLW  23
083B:  MOVWF  3A
083C:  CLRF   3B
083D:  MOVLW  01
083E:  MOVWF  11
083F:  MOVLW  1C
0840:  MOVWF  10
0841:  MOVLW  01
0842:  MOVWF  13
0843:  MOVLW  1E
0844:  MOVWF  12
0845:  MOVLW  01
0846:  MOVWF  15
0847:  MOVLW  25
0848:  MOVWF  14
0849:  MOVLW  01
084A:  MOVWF  17
084B:  MOVLW  28
084C:  MOVWF  16
084D:  MOVLW  01
084E:  MOVWF  19
084F:  MOVLW  32
0850:  MOVWF  18
0851:  MOVLW  01
0852:  MOVWF  1B
0853:  MOVLW  3A
0854:  MOVWF  1A
....................    XULY_IDGW_NHAP(); 
....................    PACKAGE_CONFIG[3] = ID_GATEWAY_CHAR; 
*
088E:  CLRF   17
088F:  MOVLW  55
0890:  MOVWF  16
....................     
....................     
....................    XULY_IDNODE_NHAP(); 
....................  
....................    PACKAGE_CONFIG[4] = ID_NODE_CHAR;     
*
08CA:  CLRF   19
08CB:  MOVLW  4E
08CC:  MOVWF  18
....................       /*     
....................    LEN_PACKAGES = 0; 
....................    PACKAGE_CONFIG[1] = "12"; //DO DAI CUA LENGHT CO DO DAI = 2 
....................    FOR (int J = 0; J < 5; J++) 
....................    { 
....................       LEN_PACKAGES += strlen(PACKAGE_CONFIG[J]); 
....................    }    
....................    */ 
....................    LEN_PACKAGES = 20; //5 @ 
08CD:  MOVLW  14
08CE:  BCF    03.6
08CF:  MOVWF  46
....................    ITOA (LEN_PACKAGES, 10, TEMP_CHAR); 
08D0:  BSF    03.6
08D1:  CLRF   42
08D2:  CLRF   41
08D3:  CLRF   40
08D4:  BCF    03.6
08D5:  MOVF   46,W
08D6:  BSF    03.6
08D7:  MOVWF  3F
08D8:  MOVLW  0A
08D9:  MOVWF  43
08DA:  CLRF   45
08DB:  MOVLW  6E
08DC:  MOVWF  44
08DD:  BCF    0A.3
08DE:  BCF    03.6
08DF:  CALL   3DA
08E0:  BSF    0A.3
....................     
....................    PACKAGE_CONFIG[1] = TEMP_CHAR; 
08E1:  BSF    03.6
08E2:  CLRF   13
08E3:  MOVLW  6E
08E4:  MOVWF  12
....................     
....................    FOR (INT J = 0; J < 6; J++) 
08E5:  CLRF   3C
08E6:  MOVF   3C,W
08E7:  SUBLW  05
08E8:  BTFSS  03.0
08E9:  GOTO   104
....................    { 
....................       PRINTF (PACKAGE_CONFIG[J]); 
08EA:  BCF    03.0
08EB:  RLF    3C,W
08EC:  ADDLW  10
08ED:  MOVWF  04
08EE:  BSF    03.7
08EF:  INCF   04,F
08F0:  MOVF   00,W
08F1:  MOVWF  3E
08F2:  DECF   04,F
08F3:  MOVF   00,W
08F4:  MOVWF  3D
08F5:  MOVWF  04
08F6:  BCF    03.7
08F7:  BTFSC  3E.0
08F8:  BSF    03.7
08F9:  BCF    0A.3
08FA:  BCF    03.6
08FB:  CALL   769
08FC:  BSF    0A.3
....................       PRINTF ("@"); 
08FD:  MOVLW  40
08FE:  BTFSS  0C.4
08FF:  GOTO   0FE
0900:  MOVWF  19
0901:  BSF    03.6
0902:  INCF   3C,F
0903:  GOTO   0E6
....................    } 
....................  
....................  
....................    LCD_GOTOXY (1, 1) ; 
0904:  MOVLW  01
0905:  MOVWF  41
0906:  MOVWF  42
0907:  BCF    0A.3
0908:  BCF    03.6
0909:  CALL   2C0
090A:  BSF    0A.3
....................    DELAY_MS (10); 
090B:  MOVLW  0A
090C:  BSF    03.6
090D:  MOVWF  41
090E:  BCF    0A.3
090F:  BCF    03.6
0910:  CALL   140
0911:  BSF    0A.3
....................    PRINTF (LCD_PUTC, "WAITING ....        ") ; 
0912:  MOVLW  CB
0913:  BSF    03.6
0914:  MOVWF  0D
0915:  MOVLW  00
0916:  MOVWF  0F
0917:  BCF    0A.3
0918:  BCF    03.6
0919:  CALL   30E
091A:  BSF    0A.3
....................    LCD_GOTOXY (1, 2) ; 
091B:  MOVLW  01
091C:  BSF    03.6
091D:  MOVWF  41
091E:  MOVLW  02
091F:  MOVWF  42
0920:  BCF    0A.3
0921:  BCF    03.6
0922:  CALL   2C0
0923:  BSF    0A.3
....................    DELAY_MS (10); 
0924:  MOVLW  0A
0925:  BSF    03.6
0926:  MOVWF  41
0927:  BCF    0A.3
0928:  BCF    03.6
0929:  CALL   140
092A:  BSF    0A.3
....................    PRINTF (LCD_PUTC, "WAITING ....        ") ;    
092B:  MOVLW  D6
092C:  BSF    03.6
092D:  MOVWF  0D
092E:  MOVLW  00
092F:  MOVWF  0F
0930:  BCF    0A.3
0931:  BCF    03.6
0932:  CALL   30E
0933:  BSF    0A.3
....................    TT_CONFIG_DONE = 0; 
0934:  BCF    4D.3
0935:  BCF    0A.3
0936:  BSF    0A.4
0937:  GOTO   203 (RETURN)
.................... } 
....................  
....................  
....................  VOID XACNHANCONFIG() 
....................  {    
....................    KYTU=0;          
*
0C50:  CLRF   3A
....................    LCD_GOTOXY (1, 1) ; 
0C51:  MOVLW  01
0C52:  BSF    03.6
0C53:  MOVWF  41
0C54:  MOVWF  42
0C55:  BCF    0A.3
0C56:  BCF    03.6
0C57:  CALL   2C0
0C58:  BSF    0A.3
....................    DELAY_MS (10); 
0C59:  MOVLW  0A
0C5A:  BSF    03.6
0C5B:  MOVWF  41
0C5C:  BCF    0A.3
0C5D:  BCF    03.6
0C5E:  CALL   140
0C5F:  BSF    0A.3
....................    TEMP_CHAR = "_"; 
0C60:  BSF    03.6
0C61:  CLRF   18
0C62:  CLRF   19
0C63:  MOVLW  6E
0C64:  MOVWF  04
0C65:  BCF    03.7
0C66:  MOVF   18,W
0C67:  ADDWF  04,F
0C68:  MOVF   19,W
0C69:  BCF    0A.3
0C6A:  BCF    03.6
0C6B:  CALL   05E
0C6C:  BSF    0A.3
0C6D:  MOVWF  00
0C6E:  IORLW  00
0C6F:  BTFSC  03.2
0C70:  GOTO   476
0C71:  BSF    03.6
0C72:  INCF   19,F
0C73:  INCF   18,F
0C74:  GOTO   463
0C75:  BCF    03.6
....................    CHAR * TOKEN; 
....................    TOKEN = STRTOK (KYTUCHAR2, TEMP_CHAR);    
0C76:  BSF    03.6
0C77:  CLRF   19
0C78:  MOVLW  D2
0C79:  MOVWF  18
0C7A:  CLRF   1B
0C7B:  MOVLW  6E
0C7C:  MOVWF  1A
0C7D:  BCF    03.6
0C7E:  CALL   138
0C7F:  MOVF   79,W
0C80:  BSF    03.6
0C81:  MOVWF  17
0C82:  MOVF   78,W
0C83:  MOVWF  16
....................     WHILE (TOKEN != NULL) 
0C84:  MOVF   16,F
0C85:  BTFSS  03.2
0C86:  GOTO   48A
0C87:  MOVF   17,F
0C88:  BTFSC  03.2
0C89:  GOTO   4D3
....................     {                 
....................        SWITCH(KYTU) 
0C8A:  BCF    03.6
0C8B:  MOVF   3A,W
0C8C:  BTFSC  03.2
0C8D:  GOTO   495
0C8E:  XORLW  01
0C8F:  BTFSC  03.2
0C90:  GOTO   4AF
0C91:  XORLW  03
0C92:  BTFSC  03.2
0C93:  GOTO   4B9
0C94:  GOTO   4C2
....................        { 
....................          CASE 0: 
....................          DELAY_MS (1); 
0C95:  MOVLW  01
0C96:  BSF    03.6
0C97:  MOVWF  41
0C98:  BCF    0A.3
0C99:  BCF    03.6
0C9A:  CALL   140
0C9B:  BSF    0A.3
....................          PRINTF (LCD_PUTC,TOKEN); 
0C9C:  BSF    03.6
0C9D:  MOVF   16,W
0C9E:  MOVWF  04
0C9F:  BCF    03.7
0CA0:  BTFSC  17.0
0CA1:  BSF    03.7
0CA2:  BCF    0A.3
0CA3:  BCF    03.6
0CA4:  CALL   4FA
0CA5:  BSF    0A.3
....................          PRINTF (LCD_PUTC,"            "); 
0CA6:  MOVLW  E1
0CA7:  BSF    03.6
0CA8:  MOVWF  0D
0CA9:  MOVLW  00
0CAA:  MOVWF  0F
0CAB:  BCF    0A.3
0CAC:  BCF    03.6
0CAD:  CALL   30E
0CAE:  BSF    0A.3
....................          CASE 1:  
....................          SOLUONGTHIETBI_CONFIG = ATOI(TOKEN); 
0CAF:  BSF    03.6
0CB0:  MOVF   17,W
0CB1:  MOVWF  19
0CB2:  MOVF   16,W
0CB3:  MOVWF  18
0CB4:  BCF    03.6
0CB5:  CALL   229
0CB6:  MOVF   78,W
0CB7:  MOVWF  49
....................          BREAK;                      
0CB8:  GOTO   4C2
....................          CASE 2: 
....................          SOLUONGCAMBIEN_CONFIG = ATOI(TOKEN); 
0CB9:  BSF    03.6
0CBA:  MOVF   17,W
0CBB:  MOVWF  19
0CBC:  MOVF   16,W
0CBD:  MOVWF  18
0CBE:  BCF    03.6
0CBF:  CALL   229
0CC0:  MOVF   78,W
0CC1:  MOVWF  4A
....................          BREAK;               
....................        }  
....................       TOKEN = STRTOK(NULL, TEMP_CHAR); 
0CC2:  BSF    03.6
0CC3:  CLRF   19
0CC4:  CLRF   18
0CC5:  CLRF   1B
0CC6:  MOVLW  6E
0CC7:  MOVWF  1A
0CC8:  BCF    03.6
0CC9:  CALL   138
0CCA:  MOVF   79,W
0CCB:  BSF    03.6
0CCC:  MOVWF  17
0CCD:  MOVF   78,W
0CCE:  MOVWF  16
....................       KYTU++;         
0CCF:  BCF    03.6
0CD0:  INCF   3A,F
0CD1:  BSF    03.6
0CD2:  GOTO   484
....................     }           
....................    DELAY_MS (1);       
0CD3:  MOVLW  01
0CD4:  MOVWF  41
0CD5:  BCF    0A.3
0CD6:  BCF    03.6
0CD7:  CALL   140
0CD8:  BSF    0A.3
....................    LCD_GOTOXY (1, 2) ; 
0CD9:  MOVLW  01
0CDA:  BSF    03.6
0CDB:  MOVWF  41
0CDC:  MOVLW  02
0CDD:  MOVWF  42
0CDE:  BCF    0A.3
0CDF:  BCF    03.6
0CE0:  CALL   2C0
0CE1:  BSF    0A.3
....................    DELAY_MS (10); 
0CE2:  MOVLW  0A
0CE3:  BSF    03.6
0CE4:  MOVWF  41
0CE5:  BCF    0A.3
0CE6:  BCF    03.6
0CE7:  CALL   140
0CE8:  BSF    0A.3
....................    PRINTF (LCD_PUTC,"TB: ");    
0CE9:  MOVLW  E8
0CEA:  BSF    03.6
0CEB:  MOVWF  0D
0CEC:  MOVLW  00
0CED:  MOVWF  0F
0CEE:  BCF    0A.3
0CEF:  BCF    03.6
0CF0:  CALL   30E
0CF1:  BSF    0A.3
....................    ITOA (SOLUONGTHIETBI_CONFIG, 10, TEMP_CHAR);    
0CF2:  BSF    03.6
0CF3:  CLRF   42
0CF4:  CLRF   41
0CF5:  CLRF   40
0CF6:  BCF    03.6
0CF7:  MOVF   49,W
0CF8:  BSF    03.6
0CF9:  MOVWF  3F
0CFA:  MOVLW  0A
0CFB:  MOVWF  43
0CFC:  CLRF   45
0CFD:  MOVLW  6E
0CFE:  MOVWF  44
0CFF:  BCF    0A.3
0D00:  BCF    03.6
0D01:  CALL   3DA
0D02:  BSF    0A.3
....................    PRINTF (LCD_PUTC,TEMP_CHAR);    
0D03:  MOVLW  6E
0D04:  MOVWF  04
0D05:  BCF    03.7
0D06:  BCF    0A.3
0D07:  CALL   4FA
0D08:  BSF    0A.3
....................    PRINTF (LCD_PUTC,"    CB:");    
0D09:  MOVLW  EB
0D0A:  BSF    03.6
0D0B:  MOVWF  0D
0D0C:  MOVLW  00
0D0D:  MOVWF  0F
0D0E:  BCF    0A.3
0D0F:  BCF    03.6
0D10:  CALL   30E
0D11:  BSF    0A.3
....................    ITOA (SOLUONGCAMBIEN_CONFIG, 10, TEMP_CHAR);    
0D12:  BSF    03.6
0D13:  CLRF   42
0D14:  CLRF   41
0D15:  CLRF   40
0D16:  BCF    03.6
0D17:  MOVF   4A,W
0D18:  BSF    03.6
0D19:  MOVWF  3F
0D1A:  MOVLW  0A
0D1B:  MOVWF  43
0D1C:  CLRF   45
0D1D:  MOVLW  6E
0D1E:  MOVWF  44
0D1F:  BCF    0A.3
0D20:  BCF    03.6
0D21:  CALL   3DA
0D22:  BSF    0A.3
....................    PRINTF (LCD_PUTC,TEMP_CHAR);       
0D23:  MOVLW  6E
0D24:  MOVWF  04
0D25:  BCF    03.7
0D26:  BCF    0A.3
0D27:  CALL   4FA
0D28:  BSF    0A.3
....................    TT_CONFIG_OKE_UART = 1; 
0D29:  BSF    4D.6
....................     
....................  }  
.................... //--------------------------------------------------------------------// 
....................  
....................  
....................  
....................  
....................  
.................... VOID QUET_PHIM() 
*
00EF:  BSF    03.6
00F0:  CLRF   64
.................... { 
....................    INT BDT = 0; 
....................  
....................    WHILE (!INPUT (BT1_PIN)) //NEU NUT BAM DUOC BAM 
00F1:  BSF    03.5
00F2:  BCF    03.6
00F3:  BSF    06.1
00F4:  BCF    03.5
00F5:  BTFSC  06.1
00F6:  GOTO   10A
....................    { 
....................       IF (TMR1IF) 
00F7:  BTFSS  0C.0
00F8:  GOTO   107
....................       { 
....................          OUTPUT_TOGGLE (PIN_D3); 
00F9:  BSF    03.5
00FA:  BCF    08.3
00FB:  MOVLW  08
00FC:  BCF    03.5
00FD:  XORWF  08,F
....................          TMR1IF = 0; SET_TIMER1 (3036); BDT++; 
00FE:  BCF    0C.0
00FF:  CLRF   0E
0100:  MOVLW  0B
0101:  MOVWF  0F
0102:  MOVLW  DC
0103:  MOVWF  0E
0104:  BSF    03.6
0105:  INCF   64,F
0106:  BCF    03.6
....................       } 
0107:  BSF    03.6
0108:  GOTO   0F1
0109:  BCF    03.6
....................    } 
....................  
....................    IF (BDT > 20) 
010A:  BSF    03.6
010B:  MOVF   64,W
010C:  SUBLW  14
010D:  BTFSC  03.0
010E:  GOTO   118
....................    { 
....................       //CONFIG NODE 
....................       TT_CONFIG = ~TT_CONFIG; // VAO TRANG THAI CONFIG 
010F:  MOVLW  02
0110:  BCF    03.6
0111:  XORWF  4D,F
....................       TT_CONTROL = ~TT_CONTROL; 
0112:  MOVLW  04
0113:  XORWF  4D,F
....................       //CONFIG_DONE (); 
....................       TT_CONFIG_DONE = 1; 
0114:  BSF    4D.3
....................       TT_FUN = 0; 
0115:  BCF    4D.4
....................    } 
0116:  GOTO   11C
0117:  BSF    03.6
....................  
....................    ELSE 
....................    { 
....................       BUTT_OKE (); //OKE 
....................    } 
.................... } 
....................  
.................... #INT_EXT 
....................  
....................  VOID NGAT_NGOAI () 
....................  { 
....................     QUET_PHIM (); 
....................  } 
....................  
*
011C:  BCF    0B.1
011D:  BCF    0A.3
011E:  BCF    0A.4
011F:  GOTO   031
....................  #INT_RDA 
....................  VOID NGAT () 
....................  { 
....................     KYTUCHAR[VT] = GETCH (); 
0120:  MOVLW  A0
0121:  ADDWF  39,W
0122:  MOVWF  04
0123:  BCF    03.7
0124:  BTFSS  0C.5
0125:  GOTO   124
0126:  MOVF   1A,W
0127:  MOVWF  00
....................  
....................     IF (KYTUCHAR[VT] == '.') 
0128:  MOVLW  A0
0129:  ADDWF  39,W
012A:  MOVWF  04
012B:  BCF    03.7
012C:  MOVF   00,W
012D:  SUBLW  2E
012E:  BTFSS  03.2
012F:  GOTO   138
....................     { 
....................        KYTUCHAR[VT] = '\0'; 
0130:  MOVLW  A0
0131:  ADDWF  39,W
0132:  MOVWF  04
0133:  BCF    03.7
0134:  CLRF   00
....................        VT = 0; 
0135:  CLRF   39
....................        TTNHAN = 1; 
0136:  BSF    4D.0
....................     } 
0137:  GOTO   139
....................     ELSE 
....................     VT++; 
0138:  INCF   39,F
0139:  BCF    0C.5
013A:  BCF    0A.3
013B:  BCF    0A.4
013C:  GOTO   031
....................  } 
....................   INT ADC_READ (INT KENH) 
....................  { 
....................     UNSIGNED INT8 ANALOG_PORT[] = {1,2,4,8,16,32,64};  
*
0D84:  MOVLW  01
0D85:  MOVWF  14
0D86:  MOVLW  02
0D87:  MOVWF  15
0D88:  MOVLW  04
0D89:  MOVWF  16
0D8A:  MOVLW  08
0D8B:  MOVWF  17
0D8C:  MOVLW  10
0D8D:  MOVWF  18
0D8E:  MOVLW  20
0D8F:  MOVWF  19
0D90:  MOVLW  40
0D91:  MOVWF  1A
....................     SETUP_ADC_PORTS (ANALOG_PORT[KENH]); 
0D92:  MOVLW  14
0D93:  ADDWF  13,W
0D94:  MOVWF  04
0D95:  BSF    03.7
0D96:  MOVF   00,W
0D97:  MOVWF  1C
0D98:  MOVWF  1D
0D99:  CLRF   1E
0D9A:  CLRF   1F
0D9B:  CLRF   20
0D9C:  MOVLW  89
0D9D:  MOVWF  04
0D9E:  BSF    03.7
0D9F:  MOVLW  C0
0DA0:  ANDWF  00,F
0DA1:  MOVF   1F,W
0DA2:  IORWF  00,F
0DA3:  MOVLW  9F
0DA4:  MOVWF  04
0DA5:  BCF    03.7
0DA6:  MOVLW  CF
0DA7:  ANDWF  00,F
0DA8:  MOVF   1E,W
0DA9:  IORWF  00,F
0DAA:  MOVLW  88
0DAB:  MOVWF  04
0DAC:  BSF    03.7
0DAD:  MOVF   1D,W
0DAE:  MOVWF  00
....................     DELAY_MS(3); 
0DAF:  MOVLW  03
0DB0:  MOVWF  41
0DB1:  BCF    0A.3
0DB2:  BCF    03.6
0DB3:  CALL   140
0DB4:  BSF    0A.3
....................     SET_ADC_CHANNEL (KENH); 
0DB5:  BSF    03.6
0DB6:  RLF    13,W
0DB7:  MOVWF  77
0DB8:  RLF    77,F
0DB9:  MOVLW  FC
0DBA:  ANDWF  77,F
0DBB:  BCF    03.6
0DBC:  MOVF   1F,W
0DBD:  ANDLW  C3
0DBE:  IORWF  77,W
0DBF:  MOVWF  1F
....................     DELAY_MS(3); 
0DC0:  MOVLW  03
0DC1:  BSF    03.6
0DC2:  MOVWF  41
0DC3:  BCF    0A.3
0DC4:  BCF    03.6
0DC5:  CALL   140
0DC6:  BSF    0A.3
....................     KQADC = 0; 
0DC7:  CLRF   33
0DC8:  CLRF   32
....................     FOR (INT I = 0; I < 100; I++) 
0DC9:  BSF    03.6
0DCA:  CLRF   1B
0DCB:  MOVF   1B,W
0DCC:  SUBLW  63
0DCD:  BTFSS  03.0
0DCE:  GOTO   5E5
....................     { 
....................        KQADC = KQADC + READ_ADC () ; 
0DCF:  BCF    03.6
0DD0:  BSF    1F.1
0DD1:  BTFSC  1F.1
0DD2:  GOTO   5D1
0DD3:  BSF    03.5
0DD4:  MOVF   1E,W
0DD5:  BCF    03.5
0DD6:  ADDWF  32,F
0DD7:  MOVF   1E,W
0DD8:  BTFSC  03.0
0DD9:  INCFSZ 1E,W
0DDA:  ADDWF  33,F
....................        DELAY_MS (1); 
0DDB:  MOVLW  01
0DDC:  BSF    03.6
0DDD:  MOVWF  41
0DDE:  BCF    0A.3
0DDF:  BCF    03.6
0DE0:  CALL   140
0DE1:  BSF    0A.3
0DE2:  BSF    03.6
0DE3:  INCF   1B,F
0DE4:  GOTO   5CB
....................     } 
....................  
....................     KQADC = KQADC / (100 * 2.046); 
0DE5:  BCF    03.6
0DE6:  MOVF   33,W
0DE7:  BSF    03.6
0DE8:  MOVWF  1D
0DE9:  BCF    03.6
0DEA:  MOVF   32,W
0DEB:  BSF    03.6
0DEC:  MOVWF  1C
*
0E09:  MOVF   7A,W
0E0A:  MOVWF  1F
0E0B:  MOVF   79,W
0E0C:  MOVWF  1E
0E0D:  MOVF   78,W
0E0E:  MOVWF  1D
0E0F:  MOVF   77,W
0E10:  MOVWF  1C
0E11:  MOVLW  9A
0E12:  MOVWF  23
0E13:  MOVLW  99
0E14:  MOVWF  22
0E15:  MOVLW  4C
0E16:  MOVWF  21
0E17:  MOVLW  86
0E18:  MOVWF  20
*
0EE2:  MOVF   7A,W
0EE3:  MOVWF  1F
0EE4:  MOVF   79,W
0EE5:  MOVWF  1E
0EE6:  MOVF   78,W
0EE7:  MOVWF  1D
0EE8:  MOVF   77,W
0EE9:  MOVWF  1C
*
0F08:  MOVF   79,W
0F09:  BCF    03.6
0F0A:  MOVWF  33
0F0B:  MOVF   78,W
0F0C:  MOVWF  32
....................     RETURN KQADC; 
0F0D:  MOVF   32,W
0F0E:  MOVWF  78
....................  } 
....................  
....................  
....................  VOID READ_ANALOG ( ) 
....................  { 
....................    FOR(INT K = 0; K<SOLUONGCAMBIEN_CONFIG; K++){ 
*
0D70:  BSF    03.6
0D71:  CLRF   10
0D72:  BCF    03.6
0D73:  MOVF   4A,W
0D74:  BSF    03.6
0D75:  SUBWF  10,W
0D76:  BTFSC  03.0
0D77:  GOTO   719
....................       KET_QUA_ANALOG[K] = ADC_READ (K);   
0D78:  MOVLW  34
0D79:  ADDWF  10,W
0D7A:  MOVWF  78
0D7B:  CLRF   7A
0D7C:  BTFSC  03.0
0D7D:  INCF   7A,F
0D7E:  MOVF   78,W
0D7F:  MOVWF  11
0D80:  MOVF   7A,W
0D81:  MOVWF  12
0D82:  MOVF   10,W
0D83:  MOVWF  13
*
0F0F:  BSF    03.6
0F10:  MOVF   11,W
0F11:  MOVWF  04
0F12:  BCF    03.7
0F13:  BTFSC  12.0
0F14:  BSF    03.7
0F15:  MOVF   78,W
0F16:  MOVWF  00
0F17:  INCF   10,F
0F18:  GOTO   572
....................    } 
0F19:  BCF    03.6
0F1A:  BCF    0A.3
0F1B:  BSF    0A.4
0F1C:  GOTO   222 (RETURN)
....................  } 
....................  
....................  VOID SEND_ANALOG_UART() 
....................  { 
....................    OUTPUT_TOGGLE(PIN_D3); 
*
1000:  BSF    03.5
1001:  BCF    08.3
1002:  MOVLW  08
1003:  BCF    03.5
1004:  XORWF  08,F
....................    //CHAR *PACKAGE_SS[]={"*", "26","SS", "IDGW12" ,"NODE","ZZ","AA","VV","CC","SS"}; 
....................    CHAR *PACKAGE_SS[]={"IDGW12" ,"NODE","ZZ","AA","VV","CC","SS"};    
1005:  MOVLW  49
1006:  BSF    03.6
1007:  MOVWF  1E
1008:  MOVLW  44
1009:  MOVWF  1F
100A:  MOVLW  47
100B:  MOVWF  20
100C:  MOVLW  57
100D:  MOVWF  21
100E:  MOVLW  31
100F:  MOVWF  22
1010:  MOVLW  32
1011:  MOVWF  23
1012:  CLRF   24
1013:  MOVLW  4E
1014:  MOVWF  25
1015:  MOVLW  4F
1016:  MOVWF  26
1017:  MOVLW  44
1018:  MOVWF  27
1019:  MOVLW  45
101A:  MOVWF  28
101B:  CLRF   29
101C:  MOVLW  5A
101D:  MOVWF  2A
101E:  MOVWF  2B
101F:  CLRF   2C
1020:  MOVLW  41
1021:  MOVWF  2D
1022:  MOVWF  2E
1023:  CLRF   2F
1024:  MOVLW  56
1025:  MOVWF  30
1026:  MOVWF  31
1027:  CLRF   32
1028:  MOVLW  43
1029:  MOVWF  33
102A:  MOVWF  34
102B:  CLRF   35
102C:  MOVLW  53
102D:  MOVWF  36
102E:  MOVWF  37
102F:  CLRF   38
1030:  MOVLW  01
1031:  MOVWF  11
1032:  MOVLW  1E
1033:  MOVWF  10
1034:  MOVLW  01
1035:  MOVWF  13
1036:  MOVLW  25
1037:  MOVWF  12
1038:  MOVLW  01
1039:  MOVWF  15
103A:  MOVLW  2A
103B:  MOVWF  14
103C:  MOVLW  01
103D:  MOVWF  17
103E:  MOVLW  2D
103F:  MOVWF  16
1040:  MOVLW  01
1041:  MOVWF  19
1042:  MOVLW  30
1043:  MOVWF  18
1044:  MOVLW  01
1045:  MOVWF  1B
1046:  MOVLW  33
1047:  MOVWF  1A
1048:  MOVLW  01
1049:  MOVWF  1D
104A:  MOVLW  36
104B:  MOVWF  1C
....................    PACKAGE_SS[0] = ID_GATEWAY_CHAR; 
104C:  CLRF   11
104D:  MOVLW  55
104E:  MOVWF  10
....................    PACKAGE_SS[1] = ID_NODE_CHAR; 
104F:  CLRF   13
1050:  MOVLW  4E
1051:  MOVWF  12
....................    UNSIGNED INT8 DO_DAI =20; 
1052:  MOVLW  14
1053:  MOVWF  39
....................     
....................    FOR(INT I = 0; I<SOLUONGCAMBIEN_CONFIG; I++) 
1054:  CLRF   3A
1055:  BCF    03.6
1056:  MOVF   4A,W
1057:  BSF    03.6
1058:  SUBWF  3A,W
1059:  BTFSC  03.0
105A:  GOTO   084
....................    { 
....................       ITOA(KET_QUA_ANALOG[I],10,PACKAGE_SS[2+I]); 
105B:  MOVLW  34
105C:  ADDWF  3A,W
105D:  MOVWF  04
105E:  BCF    03.7
105F:  MOVF   00,W
1060:  MOVWF  3B
1061:  MOVLW  02
1062:  ADDWF  3A,W
1063:  MOVWF  77
1064:  BCF    03.0
1065:  RLF    77,F
1066:  MOVF   77,W
1067:  ADDLW  10
1068:  MOVWF  04
1069:  BSF    03.7
106A:  INCF   04,F
106B:  MOVF   00,W
106C:  MOVWF  3D
106D:  DECF   04,F
106E:  MOVF   00,W
106F:  MOVWF  3C
1070:  CLRF   42
1071:  CLRF   41
1072:  CLRF   40
1073:  MOVF   3B,W
1074:  MOVWF  3F
1075:  MOVLW  0A
1076:  MOVWF  43
1077:  MOVF   3D,W
1078:  MOVWF  45
1079:  MOVF   3C,W
107A:  MOVWF  44
107B:  BCF    0A.4
107C:  BCF    03.6
107D:  CALL   3DA
107E:  BSF    0A.4
....................       DO_DAI = DO_DAI + 3; 
107F:  MOVLW  03
1080:  BSF    03.6
1081:  ADDWF  39,F
1082:  INCF   3A,F
1083:  GOTO   055
....................    }       
....................    ITOA(DO_DAI,10,TEMP_CHAR2); 
1084:  CLRF   42
1085:  CLRF   41
1086:  CLRF   40
1087:  MOVF   39,W
1088:  MOVWF  3F
1089:  MOVLW  0A
108A:  MOVWF  43
108B:  CLRF   45
108C:  MOVLW  75
108D:  MOVWF  44
108E:  BCF    0A.4
108F:  BCF    03.6
1090:  CALL   3DA
1091:  BSF    0A.4
....................    PRINTF ("*@");    
1092:  MOVLW  2A
1093:  BTFSS  0C.4
1094:  GOTO   093
1095:  MOVWF  19
1096:  MOVLW  40
1097:  BTFSS  0C.4
1098:  GOTO   097
1099:  MOVWF  19
....................    PRINTF (TEMP_CHAR2); 
109A:  MOVLW  75
109B:  MOVWF  04
109C:  BCF    03.7
109D:  BCF    0A.4
109E:  CALL   769
109F:  BSF    0A.4
....................    PRINTF ("@SS@");    
10A0:  MOVLW  3D
10A1:  BSF    03.6
10A2:  MOVWF  0D
10A3:  MOVLW  01
10A4:  MOVWF  0F
....................    FOR ( I = 0; I < 2 + SOLUONGCAMBIEN_CONFIG; I++) 
*
10F4:  CLRF   3A
10F5:  MOVLW  02
10F6:  BCF    03.6
10F7:  ADDWF  4A,W
10F8:  BSF    03.6
10F9:  SUBWF  3A,W
10FA:  BTFSC  03.0
10FB:  GOTO   116
....................    { 
....................       PRINTF (PACKAGE_SS[I]); 
10FC:  BCF    03.0
10FD:  RLF    3A,W
10FE:  ADDLW  10
10FF:  MOVWF  04
1100:  BSF    03.7
1101:  INCF   04,F
1102:  MOVF   00,W
1103:  MOVWF  3C
1104:  DECF   04,F
1105:  MOVF   00,W
1106:  MOVWF  3B
1107:  MOVWF  04
1108:  BCF    03.7
1109:  BTFSC  3C.0
110A:  BSF    03.7
110B:  BCF    0A.4
110C:  BCF    03.6
110D:  CALL   769
110E:  BSF    0A.4
....................       PRINTF ("@"); 
110F:  MOVLW  40
1110:  BTFSS  0C.4
1111:  GOTO   110
1112:  MOVWF  19
1113:  BSF    03.6
1114:  INCF   3A,F
1115:  GOTO   0F5
....................    } 
....................    PRINTF ("#"); 
1116:  MOVLW  23
1117:  BCF    03.6
1118:  BTFSS  0C.4
1119:  GOTO   118
111A:  MOVWF  19
....................    OUTPUT_TOGGLE(PIN_D3); 
111B:  BSF    03.5
111C:  BCF    08.3
111D:  MOVLW  08
111E:  BCF    03.5
111F:  XORWF  08,F
1120:  BCF    0A.3
1121:  BSF    0A.4
1122:  GOTO   228 (RETURN)
....................     
....................  } 
....................  VOID DIEUKHIENTHIETBI() 
....................  { 
....................    LENH_DIEU_KHIEN = 0;   
*
0D2B:  CLRF   3B
....................    LENH_DIEU_KHIEN = ATOI(KYTUCHAR2); 
0D2C:  BSF    03.6
0D2D:  CLRF   19
0D2E:  MOVLW  D2
0D2F:  MOVWF  18
0D30:  BCF    03.6
0D31:  CALL   229
0D32:  MOVF   78,W
0D33:  MOVWF  3B
....................    XUATTRANGTHAI(LENH_DIEU_KHIEN); 
0D34:  MOVF   3B,W
0D35:  BSF    03.6
0D36:  MOVWF  16
....................  } 
....................  
....................  VOID XU_LY_UART() 
*
0B2B:  MOVLW  2A
0B2C:  BSF    03.6
0B2D:  MOVWF  10
....................  { 
....................      //ID_NODE_NHAN = KYTU[1] - 48; 
....................     //ID_DEVICE_NHAN = KYTU[2] - 48 + 64; 
....................     //TT_DEVICE_NHAN = KYTU[3] - 48; // - 48 ASCII -- > S?. + 64 -- > PORT_D (D0 = 64)                
....................  
....................     /*TINH DO DAI*/ 
....................     CHAR CH = '*'; 
....................     CHAR *RET; 
....................     *ID_NODE_NHAN = '\0'; 
0B2E:  CLRF   7A
0B2F:  MOVLW  5E
0B30:  MOVWF  04
0B31:  BCF    03.7
0B32:  BTFSC  7A.0
0B33:  BSF    03.7
0B34:  CLRF   00
....................     *ID_GW_NHAN = '\0'; 
0B35:  CLRF   7A
0B36:  MOVLW  65
0B37:  MOVWF  04
0B38:  BCF    03.7
0B39:  BTFSC  7A.0
0B3A:  BSF    03.7
0B3B:  CLRF   00
....................     KYTUCHAR2 = ""; 
0B3C:  CLRF   16
0B3D:  CLRF   17
0B3E:  MOVLW  D2
0B3F:  MOVWF  04
0B40:  BCF    03.7
0B41:  MOVF   16,W
0B42:  ADDWF  04,F
0B43:  MOVF   17,W
0B44:  BCF    0A.3
0B45:  BCF    03.6
0B46:  CALL   06A
0B47:  BSF    0A.3
0B48:  MOVWF  00
0B49:  IORLW  00
0B4A:  BTFSC  03.2
0B4B:  GOTO   351
0B4C:  BSF    03.6
0B4D:  INCF   17,F
0B4E:  INCF   16,F
0B4F:  GOTO   33E
0B50:  BCF    03.6
....................     UNSIGNED INT8 LEN_RET;     
....................     RET = STRCHR(KYTUCHAR,CH); 
0B51:  BSF    03.6
0B52:  CLRF   17
0B53:  MOVLW  A0
0B54:  MOVWF  16
0B55:  MOVF   10,W
0B56:  MOVWF  18
*
0B78:  MOVF   79,W
0B79:  MOVWF  12
0B7A:  MOVF   78,W
0B7B:  MOVWF  11
....................     LEN_RET = STRLEN(RET);  
0B7C:  MOVF   12,W
0B7D:  MOVWF  17
0B7E:  MOVF   11,W
0B7F:  MOVWF  16
*
0B9D:  MOVF   78,W
0B9E:  MOVWF  13
....................     /* LAY TOKEN DAU TIEN */     
....................     KYTU = 0; 
0B9F:  BCF    03.6
0BA0:  CLRF   3A
....................     TEMP_CHAR = "#"; 
0BA1:  BSF    03.6
0BA2:  CLRF   16
0BA3:  CLRF   17
0BA4:  MOVLW  6E
0BA5:  MOVWF  04
0BA6:  BCF    03.7
0BA7:  MOVF   16,W
0BA8:  ADDWF  04,F
0BA9:  MOVF   17,W
0BAA:  BCF    0A.3
0BAB:  BCF    03.6
0BAC:  CALL   064
0BAD:  BSF    0A.3
0BAE:  MOVWF  00
0BAF:  IORLW  00
0BB0:  BTFSC  03.2
0BB1:  GOTO   3B7
0BB2:  BSF    03.6
0BB3:  INCF   17,F
0BB4:  INCF   16,F
0BB5:  GOTO   3A4
0BB6:  BCF    03.6
....................     CHAR * TOKEN; 
....................     TOKEN = STRTOK (KYTUCHAR, TEMP_CHAR);                 
0BB7:  BSF    03.6
0BB8:  CLRF   19
0BB9:  MOVLW  A0
0BBA:  MOVWF  18
0BBB:  CLRF   1B
0BBC:  MOVLW  6E
0BBD:  MOVWF  1A
0BBE:  BCF    03.6
0BBF:  CALL   138
0BC0:  MOVF   79,W
0BC1:  BSF    03.6
0BC2:  MOVWF  15
0BC3:  MOVF   78,W
0BC4:  MOVWF  14
....................     /* DUYET QUA CAC TOKEN CON LAI */                 
....................     WHILE (TOKEN != NULL) 
0BC5:  MOVF   14,F
0BC6:  BTFSS  03.2
0BC7:  GOTO   3CB
0BC8:  MOVF   15,F
0BC9:  BTFSC  03.2
0BCA:  GOTO   41E
....................     {                 
....................        SWITCH(KYTU) 
0BCB:  BCF    03.6
0BCC:  MOVF   3A,W
0BCD:  ADDLW  FA
0BCE:  BTFSC  03.0
0BCF:  GOTO   40D
0BD0:  ADDLW  06
0BD1:  GOTO   566
....................        { 
....................          CASE 0: 
....................          BREAK; 
0BD2:  GOTO   40D
....................          CASE 1:  
....................          STRCAT (ID_GW_NHAN, TOKEN); 
0BD3:  BSF    03.6
0BD4:  CLRF   3F
0BD5:  MOVLW  65
0BD6:  MOVWF  3E
0BD7:  MOVF   15,W
0BD8:  MOVWF  41
0BD9:  MOVF   14,W
0BDA:  MOVWF  40
0BDB:  BCF    0A.3
0BDC:  BCF    03.6
0BDD:  CALL   72B
0BDE:  BSF    0A.3
....................          BREAK;                      
0BDF:  GOTO   40D
....................          CASE 2: 
....................          STRCAT (ID_NODE_NHAN, TOKEN); 
0BE0:  BSF    03.6
0BE1:  CLRF   3F
0BE2:  MOVLW  5E
0BE3:  MOVWF  3E
0BE4:  MOVF   15,W
0BE5:  MOVWF  41
0BE6:  MOVF   14,W
0BE7:  MOVWF  40
0BE8:  BCF    0A.3
0BE9:  BCF    03.6
0BEA:  CALL   72B
0BEB:  BSF    0A.3
....................          BREAK;       
0BEC:  GOTO   40D
....................          CASE 3: 
....................          LENHDIEUKHIEN =  ATOI(TOKEN);                  
0BED:  BSF    03.6
0BEE:  MOVF   15,W
0BEF:  MOVWF  19
0BF0:  MOVF   14,W
0BF1:  MOVWF  18
0BF2:  BCF    03.6
0BF3:  CALL   229
0BF4:  MOVF   78,W
0BF5:  MOVWF  47
....................          BREAK;     
0BF6:  GOTO   40D
....................          CASE 4: 
....................          DODAI_DATA_NHAN =  ATOI(TOKEN);                  
0BF7:  BSF    03.6
0BF8:  MOVF   15,W
0BF9:  MOVWF  19
0BFA:  MOVF   14,W
0BFB:  MOVWF  18
0BFC:  BCF    03.6
0BFD:  CALL   229
0BFE:  MOVF   78,W
0BFF:  MOVWF  48
....................          BREAK;   
0C00:  GOTO   40D
....................          CASE 5:   
....................          STRCAT (KYTUCHAR2, TOKEN); 
0C01:  BSF    03.6
0C02:  CLRF   3F
0C03:  MOVLW  D2
0C04:  MOVWF  3E
0C05:  MOVF   15,W
0C06:  MOVWF  41
0C07:  MOVF   14,W
0C08:  MOVWF  40
0C09:  BCF    0A.3
0C0A:  BCF    03.6
0C0B:  CALL   72B
0C0C:  BSF    0A.3
....................          BREAK;          
....................        }          
....................       TOKEN = STRTOK(NULL, TEMP_CHAR); 
0C0D:  BSF    03.6
0C0E:  CLRF   19
0C0F:  CLRF   18
0C10:  CLRF   1B
0C11:  MOVLW  6E
0C12:  MOVWF  1A
0C13:  BCF    03.6
0C14:  CALL   138
0C15:  MOVF   79,W
0C16:  BSF    03.6
0C17:  MOVWF  15
0C18:  MOVF   78,W
0C19:  MOVWF  14
....................       KYTU++;         
0C1A:  BCF    03.6
0C1B:  INCF   3A,F
0C1C:  BSF    03.6
0C1D:  GOTO   3C5
....................     }               
....................       /* SO SANH ID returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................       SOSANH_IDGW = STRCMP(ID_GW_NHAN,ID_GATEWAY_CHAR);       
0C1E:  CLRF   17
0C1F:  MOVLW  65
0C20:  MOVWF  16
0C21:  CLRF   19
0C22:  MOVLW  55
0C23:  MOVWF  18
0C24:  BCF    0A.3
0C25:  BCF    03.6
0C26:  CALL   787
0C27:  BSF    0A.3
0C28:  MOVF   78,W
0C29:  MOVWF  4C
....................       SOSANH_IDNODE = STRCMP(ID_NODE_NHAN,ID_NODE_CHAR);     
0C2A:  BSF    03.6
0C2B:  CLRF   17
0C2C:  MOVLW  5E
0C2D:  MOVWF  16
0C2E:  CLRF   19
0C2F:  MOVLW  4E
0C30:  MOVWF  18
0C31:  BCF    0A.3
0C32:  BCF    03.6
0C33:  CALL   787
0C34:  BSF    0A.3
0C35:  MOVF   78,W
0C36:  MOVWF  4B
....................        
....................     IF ( SOSANH_IDGW == 0 && SOSANH_IDNODE == 0 && LEN_RET == DODAI_DATA_NHAN) 
0C37:  MOVF   4C,F
0C38:  BTFSS  03.2
0C39:  GOTO   55C
0C3A:  MOVF   4B,F
0C3B:  BTFSS  03.2
0C3C:  GOTO   55C
0C3D:  MOVF   48,W
0C3E:  BSF    03.6
0C3F:  SUBWF  13,W
0C40:  BTFSC  03.2
0C41:  GOTO   444
0C42:  BCF    03.6
0C43:  GOTO   55C
....................     {                       
....................       SWITCH(LENHDIEUKHIEN) 
0C44:  BCF    03.6
0C45:  MOVF   47,W
0C46:  BTFSC  03.2
0C47:  GOTO   44F
0C48:  XORLW  01
0C49:  BTFSC  03.2
0C4A:  GOTO   450
0C4B:  XORLW  03
0C4C:  BTFSC  03.2
0C4D:  GOTO   52B
0C4E:  GOTO   55B
....................        { 
....................          CASE 0: 
....................          BREAK; 
0C4F:  GOTO   55B
....................          CASE 1: 
....................          XACNHANCONFIG(); 
....................          BREAK;                      
*
0D2A:  GOTO   55B
....................          CASE 2: 
....................          DIEUKHIENTHIETBI(); 
....................          BREAK;               
....................        }  
....................     } 
*
0D5B:  GOTO   563
....................     ELSE{ 
....................       DELAY_MS (10); 
0D5C:  MOVLW  0A
0D5D:  BSF    03.6
0D5E:  MOVWF  41
0D5F:  BCF    0A.3
0D60:  BCF    03.6
0D61:  CALL   140
0D62:  BSF    0A.3
....................       /*DATA RCV SAI ID NODE, ID GW HOAC LA SAI DO DAI*/ 
....................     } 
0D63:  BCF    0A.3
0D64:  BSF    0A.4
0D65:  GOTO   20E (RETURN)
....................      
....................  } 
....................  
....................  
....................  VOID MAIN  () 
*
1123:  MOVF   03,W
1124:  ANDLW  1F
1125:  MOVWF  03
1126:  BSF    03.5
1127:  BSF    03.6
1128:  BSF    07.3
1129:  MOVLW  08
112A:  BCF    03.6
112B:  MOVWF  19
112C:  MOVLW  02
112D:  MOVWF  1A
112E:  MOVLW  A6
112F:  MOVWF  18
1130:  MOVLW  90
1131:  BCF    03.5
1132:  MOVWF  18
1133:  MOVLW  FF
1134:  MOVWF  31
1135:  CLRF   38
1136:  CLRF   39
1137:  CLRF   3A
1138:  CLRF   3B
1139:  CLRF   46
113A:  CLRF   47
113B:  CLRF   48
113C:  CLRF   49
113D:  MOVLW  03
113E:  MOVWF  4A
113F:  CLRF   4B
1140:  CLRF   4C
1141:  BCF    4D.0
1142:  BCF    4D.1
1143:  BCF    4D.2
1144:  BCF    4D.3
1145:  BCF    4D.4
1146:  BCF    4D.5
1147:  BCF    4D.6
1148:  BSF    03.5
1149:  BSF    03.6
114A:  MOVF   09,W
114B:  ANDLW  C0
114C:  MOVWF  09
114D:  BCF    03.6
114E:  BCF    1F.4
114F:  BCF    1F.5
1150:  MOVLW  00
1151:  BSF    03.6
1152:  MOVWF  08
1153:  BCF    03.5
1154:  CLRF   07
1155:  CLRF   08
1156:  CLRF   09
1157:  BCF    03.7
....................  { 
....................     SET_TRIS_D (0X00); 
*
11CA:  MOVLW  00
11CB:  MOVWF  08
....................     SET_TRIS_B (0XFF); 
11CC:  MOVLW  FF
11CD:  MOVWF  06
....................     SET_TRIS_E (0); 
11CE:  BCF    09.0
11CF:  BCF    09.1
11D0:  BCF    09.2
11D1:  BCF    09.3
....................     SET_TRIS_C (0X80); 
11D2:  MOVLW  80
11D3:  MOVWF  07
11D4:  BCF    03.5
11D5:  MOVWF  31
....................     SETUP_ADC (ADC_CLOCK_DIV_8);        
11D6:  BSF    1F.6
11D7:  BCF    1F.7
11D8:  BSF    03.5
11D9:  BSF    1F.7
11DA:  BCF    03.5
11DB:  BSF    1F.0
....................     ENABLE_INTERRUPTS (INT_TIMER0); 
11DC:  BSF    0B.5
....................     ENABLE_INTERRUPTS (INT_EXT); //CHO PHEP NGAT NGOAI 
11DD:  BSF    0B.4
....................     ENABLE_INTERRUPTS (INT_EXT_H2L); //NGAT XAY RA KHI CO XUNG TU CAO XUONG THAP 
11DE:  BSF    0B.4
11DF:  BSF    03.5
11E0:  BCF    01.6
....................     ENABLE_INTERRUPTS (INT_RDA); 
11E1:  BSF    0C.5
....................     ENABLE_INTERRUPTS (GLOBAL); 
11E2:  MOVLW  C0
11E3:  BCF    03.5
11E4:  IORWF  0B,F
....................      
....................     SETUP_TIMER_1 (T1_INTERNAL|T1_DIV_BY_8); 
11E5:  MOVLW  35
11E6:  MOVWF  10
....................     //SET_TIMER1 (0); 
....................     SET_TIMER1 (3036); 
11E7:  CLRF   0E
11E8:  MOVLW  0B
11E9:  MOVWF  0F
11EA:  MOVLW  DC
11EB:  MOVWF  0E
....................     TMR1IF = 0; 
11EC:  BCF    0C.0
....................     LCD_INIT (); // KHOI TAO LCD 
11ED:  BCF    0A.4
11EE:  GOTO   25A
11EF:  BSF    0A.4
....................  
....................     TT_CONFIG = 0; 
11F0:  BCF    4D.1
....................     TT_CONFIG_DONE = 0; 
11F1:  BCF    4D.3
....................     TT_CONTROL = 1; 
11F2:  BSF    4D.2
....................     OUTPUT_D (0X00); 
11F3:  BSF    03.5
11F4:  CLRF   08
11F5:  BCF    03.5
11F6:  CLRF   08
....................     TTNHAN = 0;     
11F7:  BCF    4D.0
....................     WHILE (TRUE) 
....................     { 
....................        IF (TT_CONFIG)             {BUTT_FUN (); } // GOI HAM CHON LENH (SWITCH CASE) 
11F8:  BTFSS  4D.1
11F9:  GOTO   1FE
11FA:  BCF    0A.4
11FB:  GOTO   52E
11FC:  BSF    0A.4
11FD:  GOTO   229
....................        ELSE IF (TT_CONFIG_DONE)   { CONFIG_DONE ();}        
11FE:  BTFSS  4D.3
11FF:  GOTO   206
1200:  BCF    0A.4
1201:  BSF    0A.3
1202:  GOTO   000
1203:  BSF    0A.4
1204:  BCF    0A.3
1205:  GOTO   229
....................        ELSE 
....................        { 
....................           WHILE (!TT_CONFIG) 
1206:  BTFSC  4D.1
1207:  GOTO   229
....................           {                          
....................              IF (TTNHAN == 1) 
1208:  BTFSS  4D.0
1209:  GOTO   210
....................              { 
....................                 TTNHAN = 0; 
120A:  BCF    4D.0
....................                 XU_LY_UART(); 
120B:  BCF    0A.4
120C:  BSF    0A.3
120D:  GOTO   32B
120E:  BSF    0A.4
120F:  BCF    0A.3
....................              }  
....................               
....................              IF (TT_CONFIG_OKE_UART == 1){ 
1210:  BTFSS  4D.6
1211:  GOTO   228
....................                DELAY_MS(2000); 
1212:  MOVLW  08
1213:  BSF    03.6
1214:  MOVWF  10
1215:  MOVLW  FA
1216:  MOVWF  41
1217:  BCF    0A.4
1218:  BCF    03.6
1219:  CALL   140
121A:  BSF    0A.4
121B:  BSF    03.6
121C:  DECFSZ 10,F
121D:  GOTO   215
....................                READ_ANALOG(); 
121E:  BCF    0A.4
121F:  BSF    0A.3
1220:  BCF    03.6
1221:  GOTO   570
1222:  BSF    0A.4
1223:  BCF    0A.3
....................                IF (KET_QUA_ANALOG[0]>28) 
1224:  MOVF   34,W
1225:  SUBLW  1C
1226:  BTFSS  03.0
....................                {                
....................                SEND_ANALOG_UART(); 
1227:  GOTO   000
....................                } 
....................              } 
1228:  GOTO   206
....................  
....................           } 
....................        } 
1229:  GOTO   1F8
....................     } 
....................  } 
....................  
122A:  SLEEP

Configuration Fuses:
   Word  1: 2FE2   HS NOWDT PUT MCLR NOPROTECT NOCPD BROWNOUT IESO FCMEN NOLVP NODEBUG
   Word  2: 3FFF   BORV40 NOWRT
