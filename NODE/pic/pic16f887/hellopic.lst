CCS PCM C Compiler, Version 5.015, 5967               29-Oct-21 20:56

               Filename:   E:\DATN\NODE\pic\pic16f887\hellopic.lst

               ROM used:   3903 words (48%)
                           Largest free fragment is 2048
               RAM used:   133 (36%) at main() level
                           242 (66%) worst case
               Stack used: 7 locations (6 in main + 1 for interrupts)
               Stack size: 8

*
0000:  MOVLW  0E
0001:  MOVWF  0A
0002:  GOTO   65F
0003:  NOP
0004:  MOVWF  7F
0005:  SWAPF  03,W
0006:  CLRF   03
0007:  MOVWF  21
0008:  MOVF   0A,W
0009:  MOVWF  20
000A:  CLRF   0A
000B:  MOVF   04,W
000C:  MOVWF  22
000D:  MOVF   77,W
000E:  MOVWF  23
000F:  MOVF   78,W
0010:  MOVWF  24
0011:  MOVF   79,W
0012:  MOVWF  25
0013:  MOVF   7A,W
0014:  MOVWF  26
0015:  BSF    03.6
0016:  MOVF   0D,W
0017:  BCF    03.6
0018:  MOVWF  27
0019:  BSF    03.6
001A:  MOVF   0F,W
001B:  BCF    03.6
001C:  MOVWF  28
001D:  BSF    03.6
001E:  MOVF   0C,W
001F:  BCF    03.6
0020:  MOVWF  29
0021:  BSF    03.6
0022:  MOVF   0E,W
0023:  BCF    03.6
0024:  MOVWF  2A
0025:  BCF    03.7
0026:  BCF    03.5
0027:  BTFSS  0B.4
0028:  GOTO   02B
0029:  BTFSC  0B.1
002A:  GOTO   052
002B:  MOVLW  8C
002C:  MOVWF  04
002D:  BTFSS  00.5
002E:  GOTO   031
002F:  BTFSC  0C.5
0030:  GOTO   055
0031:  MOVF   22,W
0032:  MOVWF  04
0033:  MOVF   23,W
0034:  MOVWF  77
0035:  MOVF   24,W
0036:  MOVWF  78
0037:  MOVF   25,W
0038:  MOVWF  79
0039:  MOVF   26,W
003A:  MOVWF  7A
003B:  MOVF   27,W
003C:  BSF    03.6
003D:  MOVWF  0D
003E:  BCF    03.6
003F:  MOVF   28,W
0040:  BSF    03.6
0041:  MOVWF  0F
0042:  BCF    03.6
0043:  MOVF   29,W
0044:  BSF    03.6
0045:  MOVWF  0C
0046:  BCF    03.6
0047:  MOVF   2A,W
0048:  BSF    03.6
0049:  MOVWF  0E
004A:  BCF    03.6
004B:  MOVF   20,W
004C:  MOVWF  0A
004D:  SWAPF  21,W
004E:  MOVWF  03
004F:  SWAPF  7F,F
0050:  SWAPF  7F,W
0051:  RETFIE
0052:  BCF    0A.3
0053:  BCF    0A.4
0054:  GOTO   0F1
0055:  BCF    0A.3
0056:  BCF    0A.4
0057:  GOTO   122
....................  
.................... #INCLUDE <thuvien.c> 
.................... #INCLUDE <16F887.H> 
.................... //////////// Standard Header file for the PIC16F887 device //////////////// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2013 Custom Computer Services          //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... #device PIC16F887 
0058:  BCF    0A.0
0059:  BCF    0A.1
005A:  BCF    0A.2
005B:  ADDWF  02,F
005C:  RETLW  30
005D:  RETLW  00
005E:  BCF    0A.0
005F:  BCF    0A.1
0060:  BCF    0A.2
0061:  ADDWF  02,F
0062:  RETLW  5F
0063:  RETLW  00
0064:  BCF    0A.0
0065:  BCF    0A.1
0066:  BCF    0A.2
0067:  ADDWF  02,F
0068:  RETLW  00
0069:  BCF    0A.0
006A:  BCF    0A.1
006B:  BCF    0A.2
006C:  ADDWF  02,F
006D:  RETLW  23
006E:  RETLW  00
006F:  DATA CE,27
0070:  DATA C4,22
0071:  DATA 3A,10
0072:  DATA 00,00
0073:  DATA 30,18
0074:  DATA 30,18
0075:  DATA 20,10
0076:  DATA 20,10
0077:  DATA 20,10
0078:  DATA 20,10
0079:  DATA 20,10
007A:  DATA 00,01
007B:  DATA 20,10
007C:  DATA 20,10
007D:  DATA 20,10
007E:  DATA 5F,10
007F:  DATA 20,10
0080:  DATA 20,10
0081:  DATA 20,10
0082:  DATA 20,10
0083:  DATA 20,10
0084:  DATA 20,10
0085:  DATA 20,00
0086:  DATA 20,10
0087:  DATA 20,10
0088:  DATA 5F,10
0089:  DATA 20,10
008A:  DATA 20,00
008B:  DATA 49,22
008C:  DATA DF,23
008D:  DATA 57,1D
008E:  DATA 00,01
008F:  DATA 30,18
0090:  DATA 30,18
0091:  DATA 30,18
0092:  DATA 20,10
0093:  DATA 20,10
0094:  DATA 20,10
0095:  DATA 20,10
0096:  DATA 00,01
0097:  DATA 20,10
0098:  DATA 20,10
0099:  DATA 20,10
009A:  DATA 5F,10
009B:  DATA 20,10
009C:  DATA 20,10
009D:  DATA 20,10
009E:  DATA 20,10
009F:  DATA 20,10
00A0:  DATA 20,10
00A1:  DATA 20,10
00A2:  DATA 20,00
00A3:  DATA 20,10
00A4:  DATA 20,10
00A5:  DATA 5F,10
00A6:  DATA 20,10
00A7:  DATA 20,10
00A8:  DATA 20,10
00A9:  DATA 20,00
00AA:  DATA C3,27
00AB:  DATA 4E,23
00AC:  DATA C9,23
00AD:  DATA 3A,10
00AE:  DATA 20,10
00AF:  DATA 20,10
00B0:  DATA 20,10
00B1:  DATA 20,00
00B2:  DATA C3,20
00B3:  DATA D3,22
00B4:  DATA 3A,10
00B5:  DATA 20,10
00B6:  DATA 20,10
00B7:  DATA 20,10
00B8:  DATA 20,10
00B9:  DATA 20,00
00BA:  DATA A0,16
00BB:  DATA A0,24
00BC:  DATA C4,16
00BD:  DATA CE,27
00BE:  DATA C4,22
00BF:  DATA 20,10
00C0:  DATA 20,10
00C1:  DATA 20,10
00C2:  DATA 00,01
00C3:  DATA A0,16
00C4:  DATA A0,24
00C5:  DATA C4,16
00C6:  DATA C7,2B
00C7:  DATA 20,10
00C8:  DATA 20,10
00C9:  DATA 20,10
00CA:  DATA 20,00
00CB:  DATA D7,20
00CC:  DATA 49,2A
00CD:  DATA 49,27
00CE:  DATA 47,10
00CF:  DATA 2E,17
00D0:  DATA 2E,17
00D1:  DATA 20,10
00D2:  DATA 20,10
00D3:  DATA 20,10
00D4:  DATA 20,10
00D5:  DATA 00,01
00D6:  DATA D7,20
00D7:  DATA 49,2A
00D8:  DATA 49,27
00D9:  DATA 47,10
00DA:  DATA 2E,17
00DB:  DATA 2E,17
00DC:  DATA 20,10
00DD:  DATA 20,10
00DE:  DATA 20,10
00DF:  DATA 20,10
00E0:  DATA 00,00
00E1:  DATA 20,10
00E2:  DATA 20,10
00E3:  DATA 20,10
00E4:  DATA 20,10
00E5:  DATA 20,10
00E6:  DATA 20,10
00E7:  DATA 00,01
00E8:  DATA 20,10
00E9:  DATA 20,10
00EA:  DATA 20,10
00EB:  DATA 20,10
00EC:  DATA 20,10
00ED:  DATA 20,10
00EE:  DATA 20,10
00EF:  DATA 20,10
00F0:  DATA 00,00
*
013F:  DATA 20,10
0140:  DATA 20,10
0141:  DATA 20,10
0142:  DATA 20,10
0143:  DATA 20,10
0144:  DATA 20,10
0145:  DATA 20,10
0146:  DATA 20,10
0147:  DATA 20,00
0148:  DATA 20,10
0149:  DATA 20,10
014A:  DATA 20,10
014B:  DATA 20,10
014C:  DATA 20,10
014D:  DATA 20,10
014E:  DATA 20,10
014F:  DATA 20,10
0150:  DATA 20,00
*
0329:  MOVF   0B,W
032A:  BSF    03.6
032B:  MOVWF  32
032C:  BCF    03.6
032D:  BCF    0B.7
032E:  BSF    03.5
032F:  BSF    03.6
0330:  BSF    0C.7
0331:  BSF    0C.0
0332:  NOP
0333:  NOP
0334:  BCF    03.5
0335:  BTFSS  32.7
0336:  GOTO   33A
0337:  BCF    03.6
0338:  BSF    0B.7
0339:  BSF    03.6
033A:  MOVF   0C,W
033B:  ANDLW  7F
033C:  BTFSC  03.2
033D:  GOTO   377
033E:  MOVWF  32
033F:  MOVF   0D,W
0340:  MOVWF  33
0341:  MOVF   0F,W
0342:  MOVWF  34
0343:  MOVF   32,W
0344:  MOVWF  35
0345:  BCF    03.6
0346:  CALL   2EF
0347:  BSF    03.6
0348:  MOVF   33,W
0349:  MOVWF  0D
034A:  MOVF   34,W
034B:  MOVWF  0F
034C:  BCF    03.6
034D:  MOVF   0B,W
034E:  BSF    03.6
034F:  MOVWF  35
0350:  BCF    03.6
0351:  BCF    0B.7
0352:  BSF    03.5
0353:  BSF    03.6
0354:  BSF    0C.7
0355:  BSF    0C.0
0356:  NOP
0357:  NOP
0358:  BCF    03.5
0359:  BTFSS  35.7
035A:  GOTO   35E
035B:  BCF    03.6
035C:  BSF    0B.7
035D:  BSF    03.6
035E:  RLF    0C,W
035F:  RLF    0E,W
0360:  ANDLW  7F
0361:  BTFSC  03.2
0362:  GOTO   377
0363:  MOVWF  32
0364:  MOVF   0D,W
0365:  MOVWF  33
0366:  MOVF   0F,W
0367:  MOVWF  34
0368:  MOVF   32,W
0369:  MOVWF  35
036A:  BCF    03.6
036B:  CALL   2EF
036C:  BSF    03.6
036D:  MOVF   33,W
036E:  MOVWF  0D
036F:  MOVF   34,W
0370:  MOVWF  0F
0371:  INCF   0D,F
0372:  BTFSC  03.2
0373:  INCF   0F,F
0374:  BCF    03.6
0375:  GOTO   329
0376:  BSF    03.6
0377:  BCF    03.6
0378:  RETURN
0379:  BTFSC  03.1
037A:  GOTO   37E
037B:  MOVLW  53
037C:  MOVWF  04
037D:  BSF    03.7
037E:  BSF    03.6
037F:  MOVF   4E,W
0380:  XORWF  52,W
0381:  ANDLW  80
0382:  MOVWF  58
0383:  BTFSS  4E.7
0384:  GOTO   390
0385:  COMF   4B,F
0386:  COMF   4C,F
0387:  COMF   4D,F
0388:  COMF   4E,F
0389:  INCF   4B,F
038A:  BTFSC  03.2
038B:  INCF   4C,F
038C:  BTFSC  03.2
038D:  INCF   4D,F
038E:  BTFSC  03.2
038F:  INCF   4E,F
0390:  BTFSS  52.7
0391:  GOTO   39D
0392:  COMF   4F,F
0393:  COMF   50,F
0394:  COMF   51,F
0395:  COMF   52,F
0396:  INCF   4F,F
0397:  BTFSC  03.2
0398:  INCF   50,F
0399:  BTFSC  03.2
039A:  INCF   51,F
039B:  BTFSC  03.2
039C:  INCF   52,F
039D:  CLRF   77
039E:  CLRF   78
039F:  CLRF   79
03A0:  CLRF   7A
03A1:  CLRF   53
03A2:  CLRF   54
03A3:  CLRF   55
03A4:  CLRF   56
03A5:  MOVF   52,W
03A6:  IORWF  51,W
03A7:  IORWF  50,W
03A8:  IORWF  4F,W
03A9:  BTFSC  03.2
03AA:  GOTO   3DB
03AB:  MOVLW  20
03AC:  MOVWF  57
03AD:  BCF    03.0
03AE:  RLF    4B,F
03AF:  RLF    4C,F
03B0:  RLF    4D,F
03B1:  RLF    4E,F
03B2:  RLF    53,F
03B3:  RLF    54,F
03B4:  RLF    55,F
03B5:  RLF    56,F
03B6:  MOVF   52,W
03B7:  SUBWF  56,W
03B8:  BTFSS  03.2
03B9:  GOTO   3C4
03BA:  MOVF   51,W
03BB:  SUBWF  55,W
03BC:  BTFSS  03.2
03BD:  GOTO   3C4
03BE:  MOVF   50,W
03BF:  SUBWF  54,W
03C0:  BTFSS  03.2
03C1:  GOTO   3C4
03C2:  MOVF   4F,W
03C3:  SUBWF  53,W
03C4:  BTFSS  03.0
03C5:  GOTO   3D5
03C6:  MOVF   4F,W
03C7:  SUBWF  53,F
03C8:  MOVF   50,W
03C9:  BTFSS  03.0
03CA:  INCFSZ 50,W
03CB:  SUBWF  54,F
03CC:  MOVF   51,W
03CD:  BTFSS  03.0
03CE:  INCFSZ 51,W
03CF:  SUBWF  55,F
03D0:  MOVF   52,W
03D1:  BTFSS  03.0
03D2:  INCFSZ 52,W
03D3:  SUBWF  56,F
03D4:  BSF    03.0
03D5:  RLF    77,F
03D6:  RLF    78,F
03D7:  RLF    79,F
03D8:  RLF    7A,F
03D9:  DECFSZ 57,F
03DA:  GOTO   3AD
03DB:  BTFSS  58.7
03DC:  GOTO   3E8
03DD:  COMF   77,F
03DE:  COMF   78,F
03DF:  COMF   79,F
03E0:  COMF   7A,F
03E1:  INCF   77,F
03E2:  BTFSC  03.2
03E3:  INCF   78,F
03E4:  BTFSC  03.2
03E5:  INCF   79,F
03E6:  BTFSC  03.2
03E7:  INCF   7A,F
03E8:  MOVF   53,W
03E9:  MOVWF  00
03EA:  INCF   04,F
03EB:  MOVF   54,W
03EC:  MOVWF  00
03ED:  INCF   04,F
03EE:  MOVF   55,W
03EF:  MOVWF  00
03F0:  INCF   04,F
03F1:  MOVF   56,W
03F2:  MOVWF  00
03F3:  BCF    03.6
03F4:  RETURN
*
040E:  MOVLW  20
040F:  MOVWF  4F
0410:  CLRF   4B
0411:  CLRF   4C
0412:  CLRF   4D
0413:  CLRF   4E
0414:  MOVF   46,W
0415:  MOVWF  7A
0416:  MOVF   45,W
0417:  MOVWF  79
0418:  MOVF   44,W
0419:  MOVWF  78
041A:  MOVF   43,W
041B:  MOVWF  77
041C:  BCF    03.0
041D:  BTFSS  77.0
041E:  GOTO   42D
041F:  MOVF   47,W
0420:  ADDWF  4B,F
0421:  MOVF   48,W
0422:  BTFSC  03.0
0423:  INCFSZ 48,W
0424:  ADDWF  4C,F
0425:  MOVF   49,W
0426:  BTFSC  03.0
0427:  INCFSZ 49,W
0428:  ADDWF  4D,F
0429:  MOVF   4A,W
042A:  BTFSC  03.0
042B:  INCFSZ 4A,W
042C:  ADDWF  4E,F
042D:  RRF    4E,F
042E:  RRF    4D,F
042F:  RRF    4C,F
0430:  RRF    4B,F
0431:  RRF    7A,F
0432:  RRF    79,F
0433:  RRF    78,F
0434:  RRF    77,F
0435:  DECFSZ 4F,F
0436:  GOTO   41C
*
0515:  MOVF   00,F
0516:  BTFSC  03.2
0517:  GOTO   533
0518:  BSF    03.5
0519:  CLRF   56
051A:  MOVF   04,W
051B:  MOVWF  55
051C:  BCF    56.0
051D:  BTFSC  03.7
051E:  BSF    56.0
051F:  MOVF   00,W
0520:  BCF    03.5
0521:  BSF    03.6
0522:  MOVWF  35
0523:  BCF    03.6
0524:  CALL   2EF
0525:  BSF    03.5
0526:  MOVF   55,W
0527:  MOVWF  04
0528:  BCF    03.7
0529:  BTFSC  56.0
052A:  BSF    03.7
052B:  INCF   04,F
052C:  BTFSS  03.2
052D:  GOTO   531
052E:  BCF    03.5
052F:  INCF   05,F
0530:  BSF    03.5
0531:  BCF    03.5
0532:  GOTO   515
0533:  RETURN
0534:  BSF    03.5
0535:  MOVF   52,W
0536:  CLRF   78
0537:  SUBWF  51,W
0538:  BTFSC  03.0
0539:  GOTO   53D
053A:  MOVF   51,W
053B:  MOVWF  77
053C:  GOTO   549
053D:  CLRF   77
053E:  MOVLW  08
053F:  MOVWF  53
0540:  RLF    51,F
0541:  RLF    77,F
0542:  MOVF   52,W
0543:  SUBWF  77,W
0544:  BTFSC  03.0
0545:  MOVWF  77
0546:  RLF    78,F
0547:  DECFSZ 53,F
0548:  GOTO   540
0549:  BCF    03.5
054A:  RETURN
*
07DC:  BSF    03.5
07DD:  MOVF   55,W
07DE:  ANDLW  07
07DF:  MOVWF  77
07E0:  RRF    55,W
07E1:  MOVWF  78
07E2:  RRF    78,F
07E3:  RRF    78,F
07E4:  MOVLW  1F
07E5:  ANDWF  78,F
07E6:  MOVF   78,W
07E7:  ADDWF  57,W
07E8:  MOVWF  04
07E9:  BCF    03.7
07EA:  BTFSC  58.0
07EB:  BSF    03.7
07EC:  CLRF   78
07ED:  INCF   78,F
07EE:  INCF   77,F
07EF:  GOTO   7F1
07F0:  RLF    78,F
07F1:  DECFSZ 77,F
07F2:  GOTO   7F0
07F3:  MOVF   56,F
07F4:  BTFSC  03.2
07F5:  GOTO   7F9
07F6:  MOVF   78,W
07F7:  IORWF  00,F
07F8:  GOTO   7FC
07F9:  COMF   78,F
07FA:  MOVF   78,W
07FB:  ANDWF  00,F
07FC:  BCF    03.5
07FD:  RETURN
*
0930:  MOVF   00,F
0931:  BTFSC  03.2
0932:  GOTO   14F
0933:  BCF    03.5
0934:  BSF    03.6
0935:  CLRF   35
0936:  MOVF   04,W
0937:  MOVWF  34
0938:  BCF    35.0
0939:  BTFSC  03.7
093A:  BSF    35.0
093B:  MOVF   00,W
093C:  BCF    03.6
093D:  BTFSS  0C.4
093E:  GOTO   13D
093F:  MOVWF  19
0940:  BSF    03.6
0941:  MOVF   34,W
0942:  MOVWF  04
0943:  BCF    03.7
0944:  BTFSC  35.0
0945:  BSF    03.7
0946:  INCF   04,F
0947:  BTFSS  03.2
0948:  GOTO   14C
0949:  BCF    03.6
094A:  INCF   05,F
094B:  BSF    03.6
094C:  BSF    03.5
094D:  BCF    03.6
094E:  GOTO   130
*
0AED:  CLRF   77
0AEE:  CLRF   78
0AEF:  MOVF   5C,W
0AF0:  BCF    03.0
0AF1:  BTFSC  5D.0
0AF2:  ADDWF  77,F
0AF3:  RRF    77,F
0AF4:  RRF    78,F
0AF5:  BTFSC  5D.1
0AF6:  ADDWF  77,F
0AF7:  RRF    77,F
0AF8:  RRF    78,F
0AF9:  BTFSC  5D.2
0AFA:  ADDWF  77,F
0AFB:  RRF    77,F
0AFC:  RRF    78,F
0AFD:  BTFSC  5D.3
0AFE:  ADDWF  77,F
0AFF:  RRF    77,F
0B00:  RRF    78,F
0B01:  BTFSC  5D.4
0B02:  ADDWF  77,F
0B03:  RRF    77,F
0B04:  RRF    78,F
0B05:  BTFSC  5D.5
0B06:  ADDWF  77,F
0B07:  RRF    77,F
0B08:  RRF    78,F
0B09:  BTFSC  5D.6
0B0A:  ADDWF  77,F
0B0B:  RRF    77,F
0B0C:  RRF    78,F
0B0D:  BTFSC  5D.7
0B0E:  ADDWF  77,F
0B0F:  RRF    77,F
0B10:  RRF    78,F
*
0E55:  BCF    0A.0
0E56:  BSF    0A.1
0E57:  BSF    0A.2
0E58:  ADDWF  02,F
0E59:  GOTO   45B
0E5A:  GOTO   45C
0E5B:  GOTO   471
0E5C:  GOTO   486
0E5D:  GOTO   490
0E5E:  GOTO   49A
....................  
.................... #list 
....................  
.................... #DEVICE ADC=10 
.................... #INCLUDE <STRING.H> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
*
0768:  BSF    03.6
0769:  MOVF   34,W
076A:  MOVWF  38
076B:  MOVF   33,W
076C:  MOVWF  37
076D:  MOVF   38,W
076E:  MOVWF  7A
076F:  MOVF   37,W
0770:  MOVWF  04
0771:  BCF    03.7
0772:  BTFSC  7A.0
0773:  BSF    03.7
0774:  MOVF   00,F
0775:  BTFSC  03.2
0776:  GOTO   77B
0777:  INCF   37,F
0778:  BTFSC  03.2
0779:  INCF   38,F
077A:  GOTO   76D
....................    while(*s2 != '\0') 
077B:  MOVF   36,W
077C:  MOVWF  7A
077D:  MOVF   35,W
077E:  MOVWF  04
077F:  BCF    03.7
0780:  BTFSC  7A.0
0781:  BSF    03.7
0782:  MOVF   00,F
0783:  BTFSC  03.2
0784:  GOTO   79A
....................    { 
....................       *s = *s2; 
0785:  MOVF   35,W
0786:  MOVWF  04
0787:  BCF    03.7
0788:  BTFSC  36.0
0789:  BSF    03.7
078A:  MOVF   00,W
078B:  MOVWF  3B
078C:  MOVF   37,W
078D:  MOVWF  04
078E:  BCF    03.7
078F:  BTFSC  38.0
0790:  BSF    03.7
0791:  MOVF   3B,W
0792:  MOVWF  00
....................       ++s; 
0793:  INCF   37,F
0794:  BTFSC  03.2
0795:  INCF   38,F
....................       ++s2; 
0796:  INCF   35,F
0797:  BTFSC  03.2
0798:  INCF   36,F
0799:  GOTO   77B
....................    } 
....................  
....................    *s = '\0'; 
079A:  MOVF   37,W
079B:  MOVWF  04
079C:  BCF    03.7
079D:  BTFSC  38.0
079E:  BSF    03.7
079F:  CLRF   00
....................    return(s1); 
07A0:  MOVF   33,W
07A1:  MOVWF  78
07A2:  MOVF   34,W
07A3:  MOVWF  79
07A4:  BCF    03.6
07A5:  RETURN
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
*
0B80:  BSF    03.5
0B81:  MOVF   54,W
0B82:  MOVWF  7A
0B83:  MOVF   53,W
0B84:  MOVWF  04
0B85:  BCF    03.7
0B86:  BTFSC  7A.0
0B87:  BSF    03.7
0B88:  MOVF   00,W
0B89:  MOVWF  57
0B8A:  MOVF   56,W
0B8B:  MOVWF  7A
0B8C:  MOVF   55,W
0B8D:  MOVWF  04
0B8E:  BCF    03.7
0B8F:  BTFSC  7A.0
0B90:  BSF    03.7
0B91:  MOVF   00,W
0B92:  SUBWF  57,W
0B93:  BTFSS  03.2
0B94:  GOTO   3AC
....................       if (*s1 == '\0') 
0B95:  MOVF   54,W
0B96:  MOVWF  7A
0B97:  MOVF   53,W
0B98:  MOVWF  04
0B99:  BCF    03.7
0B9A:  BTFSC  7A.0
0B9B:  BSF    03.7
0B9C:  MOVF   00,F
0B9D:  BTFSS  03.2
0B9E:  GOTO   3A2
....................          return(0); 
0B9F:  MOVLW  00
0BA0:  MOVWF  78
0BA1:  GOTO   3C4
0BA2:  MOVF   54,W
0BA3:  MOVWF  7A
0BA4:  MOVF   53,W
0BA5:  INCF   53,F
0BA6:  BTFSC  03.2
0BA7:  INCF   54,F
0BA8:  INCF   55,F
0BA9:  BTFSC  03.2
0BAA:  INCF   56,F
0BAB:  GOTO   381
....................    return((*s1 < *s2) ? -1: 1); 
0BAC:  MOVF   54,W
0BAD:  MOVWF  7A
0BAE:  MOVF   53,W
0BAF:  MOVWF  04
0BB0:  BCF    03.7
0BB1:  BTFSC  54.0
0BB2:  BSF    03.7
0BB3:  MOVF   00,W
0BB4:  MOVWF  57
0BB5:  MOVF   56,W
0BB6:  MOVWF  7A
0BB7:  MOVF   55,W
0BB8:  MOVWF  04
0BB9:  BCF    03.7
0BBA:  BTFSC  56.0
0BBB:  BSF    03.7
0BBC:  MOVF   00,W
0BBD:  SUBWF  57,W
0BBE:  BTFSC  03.0
0BBF:  GOTO   3C2
0BC0:  MOVLW  FF
0BC1:  GOTO   3C3
0BC2:  MOVLW  01
0BC3:  MOVWF  78
0BC4:  BCF    03.5
0BC5:  RETURN
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
*
0BF2:  MOVF   54,W
0BF3:  MOVWF  7A
0BF4:  MOVF   53,W
0BF5:  MOVWF  04
0BF6:  BCF    03.7
0BF7:  BTFSC  7A.0
0BF8:  BSF    03.7
0BF9:  MOVF   55,W
0BFA:  SUBWF  00,W
0BFB:  BTFSC  03.2
0BFC:  GOTO   40F
....................       if (*s == '\0') 
0BFD:  MOVF   54,W
0BFE:  MOVWF  7A
0BFF:  MOVF   53,W
0C00:  MOVWF  04
0C01:  BCF    03.7
0C02:  BTFSC  7A.0
0C03:  BSF    03.7
0C04:  MOVF   00,F
0C05:  BTFSS  03.2
0C06:  GOTO   40B
....................          return(0); 
0C07:  MOVLW  00
0C08:  MOVWF  78
0C09:  MOVWF  79
0C0A:  GOTO   413
0C0B:  INCF   53,F
0C0C:  BTFSC  03.2
0C0D:  INCF   54,F
0C0E:  GOTO   3F2
....................    return(s); 
0C0F:  MOVF   53,W
0C10:  MOVWF  78
0C11:  MOVF   54,W
0C12:  MOVWF  79
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
*
0A19:  MOVF   5E,W
0A1A:  MOVWF  62
0A1B:  MOVF   5D,W
0A1C:  MOVWF  61
0A1D:  MOVF   62,W
0A1E:  MOVWF  7A
0A1F:  MOVF   61,W
0A20:  MOVWF  04
0A21:  BCF    03.7
0A22:  BTFSC  7A.0
0A23:  BSF    03.7
0A24:  MOVF   00,F
0A25:  BTFSC  03.2
0A26:  GOTO   256
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
0A27:  MOVF   60,W
0A28:  MOVWF  64
0A29:  MOVF   5F,W
0A2A:  MOVWF  63
0A2B:  MOVF   64,W
0A2C:  MOVWF  7A
0A2D:  MOVF   63,W
0A2E:  MOVWF  04
0A2F:  BCF    03.7
0A30:  BTFSC  7A.0
0A31:  BSF    03.7
0A32:  MOVF   00,F
0A33:  BTFSC  03.2
0A34:  GOTO   252
....................          if (*sc1 == *sc2) 
0A35:  MOVF   62,W
0A36:  MOVWF  7A
0A37:  MOVF   61,W
0A38:  MOVWF  04
0A39:  BCF    03.7
0A3A:  BTFSC  7A.0
0A3B:  BSF    03.7
0A3C:  MOVF   00,W
0A3D:  MOVWF  65
0A3E:  MOVF   64,W
0A3F:  MOVWF  7A
0A40:  MOVF   63,W
0A41:  MOVWF  04
0A42:  BCF    03.7
0A43:  BTFSC  7A.0
0A44:  BSF    03.7
0A45:  MOVF   00,W
0A46:  SUBWF  65,W
0A47:  BTFSS  03.2
0A48:  GOTO   24E
....................             return(sc1); 
0A49:  MOVF   61,W
0A4A:  MOVWF  78
0A4B:  MOVF   62,W
0A4C:  MOVWF  79
0A4D:  GOTO   259
0A4E:  INCF   63,F
0A4F:  BTFSC  03.2
0A50:  INCF   64,F
0A51:  GOTO   22B
0A52:  INCF   61,F
0A53:  BTFSC  03.2
0A54:  INCF   62,F
0A55:  GOTO   21D
....................    return(0); 
0A56:  MOVLW  00
0A57:  MOVWF  78
0A58:  MOVWF  79
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
*
09A6:  MOVF   5E,W
09A7:  MOVWF  62
09A8:  MOVF   5D,W
09A9:  MOVWF  61
09AA:  MOVF   62,W
09AB:  MOVWF  7A
09AC:  MOVF   61,W
09AD:  MOVWF  04
09AE:  BCF    03.7
09AF:  BTFSC  7A.0
09B0:  BSF    03.7
09B1:  MOVF   00,F
09B2:  BTFSC  03.2
09B3:  GOTO   1EB
....................       for (sc2 = s2; ; sc2++) 
09B4:  MOVF   60,W
09B5:  MOVWF  64
09B6:  MOVF   5F,W
09B7:  MOVWF  63
....................     if (*sc2 == '\0') 
09B8:  MOVF   64,W
09B9:  MOVWF  7A
09BA:  MOVF   63,W
09BB:  MOVWF  04
09BC:  BCF    03.7
09BD:  BTFSC  7A.0
09BE:  BSF    03.7
09BF:  MOVF   00,F
09C0:  BTFSS  03.2
09C1:  GOTO   1CF
....................        return(sc1 - s1); 
09C2:  MOVF   5D,W
09C3:  SUBWF  61,W
09C4:  MOVWF  77
09C5:  MOVF   62,W
09C6:  MOVWF  7A
09C7:  MOVF   5E,W
09C8:  BTFSS  03.0
09C9:  INCFSZ 5E,W
09CA:  SUBWF  7A,F
09CB:  MOVF   77,W
09CC:  MOVWF  78
09CD:  GOTO   1F6
09CE:  GOTO   1E3
....................          else if (*sc1 == *sc2) 
09CF:  MOVF   62,W
09D0:  MOVWF  7A
09D1:  MOVF   61,W
09D2:  MOVWF  04
09D3:  BCF    03.7
09D4:  BTFSC  7A.0
09D5:  BSF    03.7
09D6:  MOVF   00,W
09D7:  MOVWF  65
09D8:  MOVF   64,W
09D9:  MOVWF  7A
09DA:  MOVF   63,W
09DB:  MOVWF  04
09DC:  BCF    03.7
09DD:  BTFSC  7A.0
09DE:  BSF    03.7
09DF:  MOVF   00,W
09E0:  SUBWF  65,W
09E1:  BTFSC  03.2
....................             break; 
09E2:  GOTO   1E7
09E3:  INCF   63,F
09E4:  BTFSC  03.2
09E5:  INCF   64,F
09E6:  GOTO   1B8
09E7:  INCF   61,F
09E8:  BTFSC  03.2
09E9:  INCF   62,F
09EA:  GOTO   1AA
....................    return(sc1 - s1); 
09EB:  MOVF   5D,W
09EC:  SUBWF  61,W
09ED:  MOVWF  77
09EE:  MOVF   62,W
09EF:  MOVWF  7A
09F0:  MOVF   5E,W
09F1:  BTFSS  03.0
09F2:  INCFSZ 5E,W
09F3:  SUBWF  7A,F
09F4:  MOVF   77,W
09F5:  MOVWF  78
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
*
0E8F:  BCF    03.6
0E90:  CLRF   2B
0E91:  CLRF   2C
....................  
....................    beg = (s1)? s1: save; 
*
098D:  BSF    03.5
098E:  MOVF   55,W
098F:  IORWF  56,W
0990:  BTFSC  03.2
0991:  GOTO   196
0992:  MOVF   56,W
0993:  MOVWF  7A
0994:  MOVF   55,W
0995:  GOTO   19B
0996:  BCF    03.5
0997:  MOVF   2C,W
0998:  MOVWF  7A
0999:  MOVF   2B,W
099A:  BSF    03.5
099B:  MOVWF  59
099C:  MOVF   7A,W
099D:  MOVWF  5A
....................    beg += strspn(beg, s2); 
099E:  MOVF   5A,W
099F:  MOVWF  5E
09A0:  MOVF   59,W
09A1:  MOVWF  5D
09A2:  MOVF   58,W
09A3:  MOVWF  60
09A4:  MOVF   57,W
09A5:  MOVWF  5F
*
09F6:  MOVF   78,W
09F7:  ADDWF  59,F
09F8:  BTFSC  03.0
09F9:  INCF   5A,F
....................    if (*beg == '\0') 
09FA:  MOVF   5A,W
09FB:  MOVWF  7A
09FC:  MOVF   59,W
09FD:  MOVWF  04
09FE:  BCF    03.7
09FF:  BTFSC  7A.0
0A00:  BSF    03.7
0A01:  MOVF   00,F
0A02:  BTFSS  03.2
0A03:  GOTO   211
....................    { 
....................       *save = ' '; 
0A04:  BCF    03.5
0A05:  MOVF   2B,W
0A06:  MOVWF  04
0A07:  BCF    03.7
0A08:  BTFSC  2C.0
0A09:  BSF    03.7
0A0A:  MOVLW  20
0A0B:  MOVWF  00
....................       return(0); 
0A0C:  MOVLW  00
0A0D:  MOVWF  78
0A0E:  MOVWF  79
0A0F:  GOTO   27D
0A10:  BSF    03.5
....................    } 
....................    end = strpbrk(beg, s2); 
0A11:  MOVF   5A,W
0A12:  MOVWF  5E
0A13:  MOVF   59,W
0A14:  MOVWF  5D
0A15:  MOVF   58,W
0A16:  MOVWF  60
0A17:  MOVF   57,W
0A18:  MOVWF  5F
*
0A59:  MOVF   79,W
0A5A:  MOVWF  5C
0A5B:  MOVF   78,W
0A5C:  MOVWF  5B
....................    if (*end != '\0') 
0A5D:  MOVF   5C,W
0A5E:  MOVWF  7A
0A5F:  MOVF   5B,W
0A60:  MOVWF  04
0A61:  BCF    03.7
0A62:  BTFSC  7A.0
0A63:  BSF    03.7
0A64:  MOVF   00,F
0A65:  BTFSC  03.2
0A66:  GOTO   270
....................    { 
....................       *end = '\0'; 
0A67:  MOVF   5B,W
0A68:  MOVWF  04
0A69:  BCF    03.7
0A6A:  BTFSC  5C.0
0A6B:  BSF    03.7
0A6C:  CLRF   00
....................       end++; 
0A6D:  INCF   5B,F
0A6E:  BTFSC  03.2
0A6F:  INCF   5C,F
....................    } 
....................    save = end; 
0A70:  MOVF   5C,W
0A71:  BCF    03.5
0A72:  MOVWF  2C
0A73:  BSF    03.5
0A74:  MOVF   5B,W
0A75:  BCF    03.5
0A76:  MOVWF  2B
....................    return(beg); 
0A77:  BSF    03.5
0A78:  MOVF   59,W
0A79:  MOVWF  78
0A7A:  MOVF   5A,W
0A7B:  MOVWF  79
0A7C:  BCF    03.5
0A7D:  RETURN
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
*
07A6:  BSF    03.6
07A7:  MOVF   35,W
07A8:  MOVWF  37
07A9:  MOVF   34,W
07AA:  MOVWF  36
07AB:  MOVF   37,W
07AC:  MOVWF  7A
07AD:  MOVF   36,W
07AE:  MOVWF  04
07AF:  BCF    03.7
07B0:  BTFSC  7A.0
07B1:  BSF    03.7
07B2:  MOVF   00,F
07B3:  BTFSC  03.2
07B4:  GOTO   7B9
07B5:  INCF   36,F
07B6:  BTFSC  03.2
07B7:  INCF   37,F
07B8:  GOTO   7AB
....................    return(sc - s); 
07B9:  MOVF   34,W
07BA:  SUBWF  36,W
07BB:  MOVWF  77
07BC:  MOVF   37,W
07BD:  MOVWF  7A
07BE:  MOVF   35,W
07BF:  BTFSS  03.0
07C0:  INCFSZ 35,W
07C1:  SUBWF  7A,F
07C2:  MOVF   77,W
07C3:  MOVWF  78
07C4:  BCF    03.6
07C5:  RETURN
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #INCLUDE <STDLIB.H> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... /* Standart template: float strtof(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... float strtof(char *s,char *endptr); 
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s,char *endptr); 
.................... float64 strtod(char *s,char *endptr); 
.................... #else 
.................... //provided for compatibility 
.................... #define strtof48(s, e) strtof(s, e) 
.................... #define strtod(s, e) strtof(s, e) 
.................... #endif 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof(s)   strtof(s, 0) 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof48(s) strtof48(s, 0) 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof64(s) strtod(s, 0) 
.................... #endif 
....................  
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float atoe(char * s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s); 
.................... #endif 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... unsigned int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................  
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
*
0A7E:  BSF    03.5
0A7F:  CLRF   5A
....................    sign = 0; 
0A80:  CLRF   58
....................    base = 10; 
0A81:  MOVLW  0A
0A82:  MOVWF  59
....................    result = 0; 
0A83:  CLRF   57
....................  
....................    if (!s) 
0A84:  MOVF   55,W
0A85:  IORWF  56,W
0A86:  BTFSS  03.2
0A87:  GOTO   28B
....................       return 0; 
0A88:  MOVLW  00
0A89:  MOVWF  78
0A8A:  GOTO   37E
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
0A8B:  MOVF   5A,W
0A8C:  INCF   5A,F
0A8D:  ADDWF  55,W
0A8E:  MOVWF  04
0A8F:  BCF    03.7
0A90:  BTFSC  56.0
0A91:  BSF    03.7
0A92:  MOVF   00,W
0A93:  MOVWF  5B
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
0A94:  MOVF   5B,W
0A95:  SUBLW  2D
0A96:  BTFSS  03.2
0A97:  GOTO   2A4
....................    { 
....................       sign = 1;         // Set the sign to negative 
0A98:  MOVLW  01
0A99:  MOVWF  58
....................       c = s[index++]; 
0A9A:  MOVF   5A,W
0A9B:  INCF   5A,F
0A9C:  ADDWF  55,W
0A9D:  MOVWF  04
0A9E:  BCF    03.7
0A9F:  BTFSC  56.0
0AA0:  BSF    03.7
0AA1:  MOVF   00,W
0AA2:  MOVWF  5B
....................    } 
0AA3:  GOTO   2B1
....................    else if (c == '+') 
0AA4:  MOVF   5B,W
0AA5:  SUBLW  2B
0AA6:  BTFSS  03.2
0AA7:  GOTO   2B1
....................    { 
....................       c = s[index++]; 
0AA8:  MOVF   5A,W
0AA9:  INCF   5A,F
0AAA:  ADDWF  55,W
0AAB:  MOVWF  04
0AAC:  BCF    03.7
0AAD:  BTFSC  56.0
0AAE:  BSF    03.7
0AAF:  MOVF   00,W
0AB0:  MOVWF  5B
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
0AB1:  MOVF   5B,W
0AB2:  SUBLW  2F
0AB3:  BTFSC  03.0
0AB4:  GOTO   374
0AB5:  MOVF   5B,W
0AB6:  SUBLW  39
0AB7:  BTFSS  03.0
0AB8:  GOTO   374
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
0AB9:  MOVF   5B,W
0ABA:  SUBLW  30
0ABB:  BTFSS  03.2
0ABC:  GOTO   2DD
0ABD:  MOVF   5A,W
0ABE:  ADDWF  55,W
0ABF:  MOVWF  04
0AC0:  BCF    03.7
0AC1:  BTFSC  56.0
0AC2:  BSF    03.7
0AC3:  MOVF   00,W
0AC4:  SUBLW  78
0AC5:  BTFSC  03.2
0AC6:  GOTO   2D1
0AC7:  MOVF   5A,W
0AC8:  ADDWF  55,W
0AC9:  MOVWF  04
0ACA:  BCF    03.7
0ACB:  BTFSC  56.0
0ACC:  BSF    03.7
0ACD:  MOVF   00,W
0ACE:  SUBLW  58
0ACF:  BTFSS  03.2
0AD0:  GOTO   2DD
....................       { 
....................          base = 16; 
0AD1:  MOVLW  10
0AD2:  MOVWF  59
....................          index++; 
0AD3:  INCF   5A,F
....................          c = s[index++]; 
0AD4:  MOVF   5A,W
0AD5:  INCF   5A,F
0AD6:  ADDWF  55,W
0AD7:  MOVWF  04
0AD8:  BCF    03.7
0AD9:  BTFSC  56.0
0ADA:  BSF    03.7
0ADB:  MOVF   00,W
0ADC:  MOVWF  5B
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
0ADD:  MOVF   59,W
0ADE:  SUBLW  0A
0ADF:  BTFSS  03.2
0AE0:  GOTO   322
....................       { 
....................          while (c >= '0' && c <= '9') 
0AE1:  MOVF   5B,W
0AE2:  SUBLW  2F
0AE3:  BTFSC  03.0
0AE4:  GOTO   321
0AE5:  MOVF   5B,W
0AE6:  SUBLW  39
0AE7:  BTFSS  03.0
0AE8:  GOTO   321
....................          { 
....................             result = 10*result + (c - '0'); 
0AE9:  MOVLW  0A
0AEA:  MOVWF  5C
0AEB:  MOVF   57,W
0AEC:  MOVWF  5D
*
0B11:  MOVF   78,W
0B12:  MOVWF  5C
0B13:  MOVLW  30
0B14:  SUBWF  5B,W
0B15:  ADDWF  5C,W
0B16:  MOVWF  57
....................             c = s[index++]; 
0B17:  MOVF   5A,W
0B18:  INCF   5A,F
0B19:  ADDWF  55,W
0B1A:  MOVWF  04
0B1B:  BCF    03.7
0B1C:  BTFSC  56.0
0B1D:  BSF    03.7
0B1E:  MOVF   00,W
0B1F:  MOVWF  5B
0B20:  GOTO   2E1
....................          } 
....................       } 
0B21:  GOTO   374
....................       else if (base == 16)    // The number is a hexa number 
0B22:  MOVF   59,W
0B23:  SUBLW  10
0B24:  BTFSS  03.2
0B25:  GOTO   374
....................       { 
....................          c = toupper(c); 
0B26:  MOVF   5B,W
0B27:  SUBLW  60
0B28:  BTFSC  03.0
0B29:  GOTO   331
0B2A:  MOVF   5B,W
0B2B:  SUBLW  7A
0B2C:  BTFSS  03.0
0B2D:  GOTO   331
0B2E:  MOVF   5B,W
0B2F:  ANDLW  DF
0B30:  GOTO   332
0B31:  MOVF   5B,W
0B32:  MOVWF  5B
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
0B33:  MOVF   5B,W
0B34:  SUBLW  2F
0B35:  BTFSC  03.0
0B36:  GOTO   33B
0B37:  MOVF   5B,W
0B38:  SUBLW  39
0B39:  BTFSC  03.0
0B3A:  GOTO   343
0B3B:  MOVF   5B,W
0B3C:  SUBLW  40
0B3D:  BTFSC  03.0
0B3E:  GOTO   374
0B3F:  MOVF   5B,W
0B40:  SUBLW  46
0B41:  BTFSS  03.0
0B42:  GOTO   374
....................          { 
....................             if (c >= '0' && c <= '9') 
0B43:  MOVF   5B,W
0B44:  SUBLW  2F
0B45:  BTFSC  03.0
0B46:  GOTO   354
0B47:  MOVF   5B,W
0B48:  SUBLW  39
0B49:  BTFSS  03.0
0B4A:  GOTO   354
....................                result = (result << 4) + (c - '0'); 
0B4B:  SWAPF  57,W
0B4C:  MOVWF  5C
0B4D:  MOVLW  F0
0B4E:  ANDWF  5C,F
0B4F:  MOVLW  30
0B50:  SUBWF  5B,W
0B51:  ADDWF  5C,W
0B52:  MOVWF  57
0B53:  GOTO   35D
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
0B54:  SWAPF  57,W
0B55:  MOVWF  5C
0B56:  MOVLW  F0
0B57:  ANDWF  5C,F
0B58:  MOVLW  41
0B59:  SUBWF  5B,W
0B5A:  ADDLW  0A
0B5B:  ADDWF  5C,W
0B5C:  MOVWF  57
....................  
....................             c = s[index++]; 
0B5D:  MOVF   5A,W
0B5E:  INCF   5A,F
0B5F:  ADDWF  55,W
0B60:  MOVWF  04
0B61:  BCF    03.7
0B62:  BTFSC  56.0
0B63:  BSF    03.7
0B64:  MOVF   00,W
0B65:  MOVWF  5B
....................             c = toupper(c); 
0B66:  MOVF   5B,W
0B67:  SUBLW  60
0B68:  BTFSC  03.0
0B69:  GOTO   371
0B6A:  MOVF   5B,W
0B6B:  SUBLW  7A
0B6C:  BTFSS  03.0
0B6D:  GOTO   371
0B6E:  MOVF   5B,W
0B6F:  ANDLW  DF
0B70:  GOTO   372
0B71:  MOVF   5B,W
0B72:  MOVWF  5B
0B73:  GOTO   333
....................          } 
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
0B74:  DECFSZ 58,W
0B75:  GOTO   37C
0B76:  MOVF   59,W
0B77:  SUBLW  0A
0B78:  BTFSS  03.2
0B79:  GOTO   37C
....................        result = -result; 
0B7A:  COMF   57,F
0B7B:  INCF   57,F
....................  
....................    return(result); 
0B7C:  MOVF   57,W
0B7D:  MOVWF  78
0B7E:  BCF    03.5
0B7F:  RETURN
.................... } 
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
*
03F5:  BSF    03.6
03F6:  CLRF   3E
03F7:  CLRF   3D
03F8:  CLRF   3C
03F9:  MOVLW  01
03FA:  MOVWF  3B
03FB:  CLRF   40
03FC:  CLRF   41
.................... { 
....................      unsigned int32 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
03FD:  BTFSS  37.7
03FE:  GOTO   43F
....................          sign=1;        // Check for negative number 
03FF:  MOVLW  01
0400:  MOVWF  40
....................          num*=-1; 
0401:  MOVF   37,W
0402:  MOVWF  46
0403:  MOVF   36,W
0404:  MOVWF  45
0405:  MOVF   35,W
0406:  MOVWF  44
0407:  MOVF   34,W
0408:  MOVWF  43
0409:  MOVLW  FF
040A:  MOVWF  4A
040B:  MOVWF  49
040C:  MOVWF  48
040D:  MOVWF  47
*
0437:  MOVF   7A,W
0438:  MOVWF  37
0439:  MOVF   79,W
043A:  MOVWF  36
043B:  MOVF   78,W
043C:  MOVWF  35
043D:  MOVF   77,W
043E:  MOVWF  34
....................      } 
....................  
....................      while(temp>0) { 
043F:  MOVF   3B,F
0440:  BTFSS  03.2
0441:  GOTO   44B
0442:  MOVF   3C,F
0443:  BTFSS  03.2
0444:  GOTO   44B
0445:  MOVF   3D,F
0446:  BTFSS  03.2
0447:  GOTO   44B
0448:  MOVF   3E,F
0449:  BTFSC  03.2
044A:  GOTO   4C7
....................          temp=(num/base); 
044B:  BCF    03.1
044C:  MOVF   37,W
044D:  MOVWF  4E
044E:  MOVF   36,W
044F:  MOVWF  4D
0450:  MOVF   35,W
0451:  MOVWF  4C
0452:  MOVF   34,W
0453:  MOVWF  4B
0454:  CLRF   52
0455:  CLRF   51
0456:  CLRF   50
0457:  MOVF   38,W
0458:  MOVWF  4F
0459:  BCF    03.6
045A:  CALL   379
045B:  MOVF   7A,W
045C:  BSF    03.6
045D:  MOVWF  3E
045E:  MOVF   79,W
045F:  MOVWF  3D
0460:  MOVF   78,W
0461:  MOVWF  3C
0462:  MOVF   77,W
0463:  MOVWF  3B
....................          s[cnt]=(num%base)+'0';    // Conversion 
0464:  MOVF   41,W
0465:  ADDWF  39,W
0466:  MOVWF  78
0467:  MOVF   3A,W
0468:  MOVWF  7A
0469:  BTFSC  03.0
046A:  INCF   7A,F
046B:  MOVF   78,W
046C:  MOVWF  43
046D:  MOVF   7A,W
046E:  MOVWF  44
046F:  CLRF   46
0470:  MOVF   04,W
0471:  MOVWF  45
0472:  BCF    46.0
0473:  BTFSC  03.7
0474:  BSF    46.0
0475:  BSF    03.1
0476:  MOVLW  47
0477:  MOVWF  04
0478:  BSF    03.7
0479:  MOVF   37,W
047A:  MOVWF  4E
047B:  MOVF   36,W
047C:  MOVWF  4D
047D:  MOVF   35,W
047E:  MOVWF  4C
047F:  MOVF   34,W
0480:  MOVWF  4B
0481:  CLRF   52
0482:  CLRF   51
0483:  CLRF   50
0484:  MOVF   38,W
0485:  MOVWF  4F
0486:  BCF    03.6
0487:  CALL   379
0488:  BSF    03.6
0489:  MOVF   45,W
048A:  MOVWF  04
048B:  BCF    03.7
048C:  BTFSC  46.0
048D:  BSF    03.7
048E:  MOVLW  30
048F:  ADDWF  47,W
0490:  MOVWF  77
0491:  MOVF   48,W
0492:  MOVWF  78
0493:  MOVLW  00
0494:  BTFSC  03.0
0495:  MOVLW  01
0496:  ADDWF  78,F
0497:  MOVF   49,W
0498:  MOVWF  79
0499:  MOVLW  00
049A:  BTFSC  03.0
049B:  MOVLW  01
049C:  ADDWF  79,F
049D:  MOVF   4A,W
049E:  MOVWF  7A
049F:  MOVLW  00
04A0:  BTFSC  03.0
04A1:  MOVLW  01
04A2:  ADDWF  7A,F
04A3:  MOVF   43,W
04A4:  MOVWF  04
04A5:  BCF    03.7
04A6:  BTFSC  44.0
04A7:  BSF    03.7
04A8:  MOVF   77,W
04A9:  MOVWF  00
....................  
....................          if(s[cnt]>0x39) 
04AA:  MOVF   41,W
04AB:  ADDWF  39,W
04AC:  MOVWF  04
04AD:  BCF    03.7
04AE:  BTFSC  3A.0
04AF:  BSF    03.7
04B0:  MOVF   00,W
04B1:  SUBLW  39
04B2:  BTFSC  03.0
04B3:  GOTO   4BD
....................             s[cnt]+=0x7; 
04B4:  MOVF   41,W
04B5:  ADDWF  39,W
04B6:  MOVWF  04
04B7:  BCF    03.7
04B8:  BTFSC  3A.0
04B9:  BSF    03.7
04BA:  MOVLW  07
04BB:  ADDWF  00,W
04BC:  MOVWF  00
....................  
....................          cnt++; 
04BD:  INCF   41,F
....................          num=temp; 
04BE:  MOVF   3E,W
04BF:  MOVWF  37
04C0:  MOVF   3D,W
04C1:  MOVWF  36
04C2:  MOVF   3C,W
04C3:  MOVWF  35
04C4:  MOVF   3B,W
04C5:  MOVWF  34
04C6:  GOTO   43F
....................      } 
....................  
....................      if(sign==1) { 
04C7:  DECFSZ 40,W
04C8:  GOTO   4D2
....................          s[cnt]=0x2D;      // Negative sign 
04C9:  MOVF   41,W
04CA:  ADDWF  39,W
04CB:  MOVWF  04
04CC:  BCF    03.7
04CD:  BTFSC  3A.0
04CE:  BSF    03.7
04CF:  MOVLW  2D
04D0:  MOVWF  00
....................          cnt++; 
04D1:  INCF   41,F
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
04D2:  CLRF   3F
04D3:  BCF    03.0
04D4:  RRF    41,W
04D5:  SUBWF  3F,W
04D6:  BTFSC  03.0
04D7:  GOTO   508
....................  
....................          c=s[i]; 
04D8:  MOVF   3F,W
04D9:  ADDWF  39,W
04DA:  MOVWF  04
04DB:  BCF    03.7
04DC:  BTFSC  3A.0
04DD:  BSF    03.7
04DE:  MOVF   00,W
04DF:  MOVWF  42
....................          s[i]=s[cnt-i-1];        // Reverse the number 
04E0:  MOVF   3F,W
04E1:  ADDWF  39,W
04E2:  MOVWF  78
04E3:  MOVF   3A,W
04E4:  MOVWF  7A
04E5:  BTFSC  03.0
04E6:  INCF   7A,F
04E7:  MOVF   78,W
04E8:  MOVWF  43
04E9:  MOVF   7A,W
04EA:  MOVWF  44
04EB:  MOVF   3F,W
04EC:  SUBWF  41,W
04ED:  ADDLW  FF
04EE:  ADDWF  39,W
04EF:  MOVWF  04
04F0:  BCF    03.7
04F1:  BTFSC  3A.0
04F2:  BSF    03.7
04F3:  MOVF   00,W
04F4:  MOVWF  45
04F5:  MOVF   43,W
04F6:  MOVWF  04
04F7:  BCF    03.7
04F8:  BTFSC  44.0
04F9:  BSF    03.7
04FA:  MOVF   45,W
04FB:  MOVWF  00
....................          s[cnt-i-1]=c; 
04FC:  MOVF   3F,W
04FD:  SUBWF  41,W
04FE:  ADDLW  FF
04FF:  ADDWF  39,W
0500:  MOVWF  04
0501:  BCF    03.7
0502:  BTFSC  3A.0
0503:  BSF    03.7
0504:  MOVF   42,W
0505:  MOVWF  00
0506:  INCF   3F,F
0507:  GOTO   4D3
....................      } 
....................      s[cnt]='\0';     // End the string 
0508:  MOVF   41,W
0509:  ADDWF  39,W
050A:  MOVWF  04
050B:  BCF    03.7
050C:  BTFSC  3A.0
050D:  BSF    03.7
050E:  CLRF   00
....................      return s; 
050F:  MOVF   39,W
0510:  MOVWF  78
0511:  MOVF   3A,W
0512:  MOVWF  79
0513:  BCF    03.6
0514:  RETURN
.................... } 
....................  
.................... #if defined(__PCD__) 
....................  
.................... char * itoa(signed int48 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int48 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... char * itoa(signed int64 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int64 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................       
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1;         
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................              
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #endif 
....................  
.................... float strtof(char *s, char *endptr) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s, char *endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float48)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float48)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s, char *endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float64)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float64)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtoulGO; 
....................  
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................    { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... int8 mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #if !defined(__PCD__) 
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2);  
.................... #else  
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2);  
.................... #endif 
....................  
....................  
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    unsigned int8 t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=1; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = 0; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
.................... #INCLUDE <STDIO.H> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDIO 
.................... #define _STDIO 
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #ifndef getc 
.................... #define getc getch 
.................... #define getchar getch 
.................... #define puts(s) {printf(s); putchar(13); putchar(10);} 
.................... #define putc putchar 
.................... #endif 
.................... /* maps error number to an error message. Writes a sequence of characters to 
.................... stderr stream thus: if s is not null then string pointed to by s follwed by 
.................... a colon (:) and a space and the appropriate error message returned by strerror 
.................... function with argument errno 
....................  
.................... Returns: no value 
.................... */ 
....................  
.................... #ifdef _ERRNO 
.................... void perror(char *s) 
.................... { 
....................   if(s) 
....................   fprintf(STDERR,"%s: ",s); 
....................   fprintf(STDERR,"%s\r\n",strerror(errno)); 
.................... } 
.................... #endif 
.................... #endif 
....................  
.................... #FUSES NOWDT, PUT, HS 
.................... #USE DELAY(CLOCK=20M) 
*
0151:  MOVLW  36
0152:  MOVWF  04
0153:  BSF    03.7
0154:  MOVF   00,W
0155:  BTFSC  03.2
0156:  GOTO   164
0157:  MOVLW  06
0158:  MOVWF  78
0159:  CLRF   77
015A:  DECFSZ 77,F
015B:  GOTO   15A
015C:  DECFSZ 78,F
015D:  GOTO   159
015E:  MOVLW  7B
015F:  MOVWF  77
0160:  DECFSZ 77,F
0161:  GOTO   160
0162:  DECFSZ 00,F
0163:  GOTO   157
0164:  RETURN
.................... #USE RS232(BAUD=9600,XMIT=PIN_C6,RCV=PIN_C7) 
.................... #DEFINE BT1_PIN PIN_B1 
.................... #DEFINE BT2_PIN PIN_B2 
.................... #DEFINE BT3_PIN PIN_B3 
.................... #DEFINE LCD_ENABLE_PIN  PIN_E0                                    
.................... #DEFINE LCD_RS_PIN      PIN_E1                                 
.................... #DEFINE LCD_RW_PIN      PIN_E2   
.................... #DEFINE LCD_DATA4       PIN_C0                                
.................... #DEFINE LCD_DATA5       PIN_C1                                  
.................... #DEFINE LCD_DATA6       PIN_C2                                    
.................... #DEFINE LCD_DATA7       PIN_C3   
.................... #INCLUDE <LCD.C> 
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... ////                             LCD.C                                     //// 
.................... ////                 Driver for common LCD modules                         //// 
.................... ////                                                                       //// 
.................... ////  lcd_init()   Must be called before any other function.               //// 
.................... ////                                                                       //// 
.................... ////  lcd_putc(c)  Will display c on the next position of the LCD.         //// 
.................... ////                 \a  Set cursor position to upper left                 //// 
.................... ////                 \f  Clear display, set cursor to upper left           //// 
.................... ////                 \n  Go to start of second line                        //// 
.................... ////                 \b  Move back one position                            //// 
.................... ////              If LCD_EXTENDED_NEWLINE is defined, the \n character     //// 
.................... ////              will erase all remanining characters on the current      //// 
.................... ////              line, and move the cursor to the beginning of the next   //// 
.................... ////              line.                                                    //// 
.................... ////              If LCD_EXTENDED_NEWLINE is defined, the \r character     //// 
.................... ////              will move the cursor to the start of the current         //// 
.................... ////              line.                                                    //// 
.................... ////                                                                       //// 
.................... ////  lcd_gotoxy(x,y) Set write position on LCD (upper left is 1,1)        //// 
.................... ////                                                                       //// 
.................... ////  lcd_getc(x,y)   Returns character at position x,y on LCD             //// 
.................... ////                                                                       //// 
.................... ////  lcd_cursor_on(int1 on)   Turn the cursor on (on=TRUE) or off         //// 
.................... ////              (on=FALSE).                                              //// 
.................... ////                                                                       //// 
.................... ////  lcd_set_cgram_char(w, *p)   Write a custom character to the CGRAM.   //// 
.................... ////                                                                       //// 
.................... ////                                                                       //// 
.................... ////  CONFIGURATION                                                        //// 
.................... ////  The LCD can be configured in one of two ways: a.) port access or     //// 
.................... ////  b.) pin access.  Port access requires the entire 7 bit interface     //// 
.................... ////  connected to one GPIO port, and the data bits (D4:D7 of the LCD)     //// 
.................... ////  connected to sequential pins on the GPIO.  Pin access                //// 
.................... ////  has no requirements, all 7 bits of the control interface can         //// 
.................... ////  can be connected to any GPIO using several ports.                    //// 
.................... ////                                                                       //// 
.................... ////  To use port access, #define LCD_DATA_PORT to the SFR location of     //// 
.................... ////  of the GPIO port that holds the interface, -AND- edit LCD_PIN_MAP    //// 
.................... ////  of this file to configure the pin order.  If you are using a         //// 
.................... ////  baseline PIC (PCB), then LCD_OUTPUT_MAP and LCD_INPUT_MAP also must  //// 
.................... ////  be defined.                                                          //// 
.................... ////                                                                       //// 
.................... ////  Example of port access:                                              //// 
.................... ////     #define LCD_DATA_PORT getenv("SFR:PORTD")                         //// 
.................... ////                                                                       //// 
.................... ////  To use pin access, the following pins must be defined:               //// 
.................... ////     LCD_ENABLE_PIN                                                    //// 
.................... ////     LCD_RS_PIN                                                        //// 
.................... ////     LCD_RW_PIN                                                        //// 
.................... ////     LCD_DATA4                                                         //// 
.................... ////     LCD_DATA5                                                         //// 
.................... ////     LCD_DATA6                                                         //// 
.................... ////     LCD_DATA7                                                         //// 
.................... ////                                                                       //// 
.................... ////  Example of pin access:                                               //// 
.................... ////     #define LCD_ENABLE_PIN  PIN_E0                                    //// 
.................... ////     #define LCD_RS_PIN      PIN_E1                                    //// 
.................... ////     #define LCD_RW_PIN      PIN_E2                                    //// 
.................... ////     #define LCD_DATA4       PIN_D4                                    //// 
.................... ////     #define LCD_DATA5       PIN_D5                                    //// 
.................... ////     #define LCD_DATA6       PIN_D6                                    //// 
.................... ////     #define LCD_DATA7       PIN_D7                                    //// 
.................... ////                                                                       //// 
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2010 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef __LCD_C__ 
.................... #define __LCD_C__ 
....................  
.................... // define the pinout. 
.................... // only required if port access is being used. 
.................... typedef struct   
.................... {                            // This structure is overlayed 
....................    int1 enable;           // on to an I/O port to gain 
....................    int1 rs;               // access to the LCD pins. 
....................    int1 rw;               // The bits are allocated from 
....................    int1 unused;           // low order up.  ENABLE will 
....................    unsigned int     data : 4;         // be LSB pin of that port. 
....................   #if defined(__PCD__)       // The port used will be LCD_DATA_PORT. 
....................    unsigned int    reserved: 8; 
....................   #endif 
.................... } LCD_PIN_MAP; 
....................  
.................... // this is to improve compatability with previous LCD drivers that accepted 
.................... // a define labeled 'use_portb_lcd' that configured the LCD onto port B. 
.................... #if ((defined(use_portb_lcd)) && (use_portb_lcd==TRUE)) 
....................  #define LCD_DATA_PORT getenv("SFR:PORTB") 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
....................    // these definitions only need to be modified for baseline PICs. 
....................    // all other PICs use LCD_PIN_MAP or individual LCD_xxx pin definitions. 
.................... /*                                    EN, RS,   RW,   UNUSED,  DATA  */ 
....................  const LCD_PIN_MAP LCD_OUTPUT_MAP =  {0,  0,    0,    0,       0}; 
....................  const LCD_PIN_MAP LCD_INPUT_MAP =   {0,  0,    0,    0,       0xF}; 
.................... #endif 
....................  
.................... ////////////////////// END CONFIGURATION /////////////////////////////////// 
....................  
.................... #ifndef LCD_ENABLE_PIN 
....................    #define lcd_output_enable(x) lcdlat.enable=x 
....................    #define lcd_enable_tris()   lcdtris.enable=0 
.................... #else 
....................    #define lcd_output_enable(x) output_bit(LCD_ENABLE_PIN, x) 
....................    #define lcd_enable_tris()  output_drive(LCD_ENABLE_PIN) 
.................... #endif 
....................  
.................... #ifndef LCD_RS_PIN 
....................    #define lcd_output_rs(x) lcdlat.rs=x 
....................    #define lcd_rs_tris()   lcdtris.rs=0 
.................... #else 
....................    #define lcd_output_rs(x) output_bit(LCD_RS_PIN, x) 
....................    #define lcd_rs_tris()  output_drive(LCD_RS_PIN) 
.................... #endif 
....................  
.................... #ifndef LCD_RW_PIN 
....................    #define lcd_output_rw(x) lcdlat.rw=x 
....................    #define lcd_rw_tris()   lcdtris.rw=0 
.................... #else 
....................    #define lcd_output_rw(x) output_bit(LCD_RW_PIN, x) 
....................    #define lcd_rw_tris()  output_drive(LCD_RW_PIN) 
.................... #endif 
....................  
.................... // original version of this library incorrectly labeled LCD_DATA0 as LCD_DATA4, 
.................... // LCD_DATA1 as LCD_DATA5, and so on.  this block of code makes the driver 
.................... // compatible with any code written for the original library 
.................... #if (defined(LCD_DATA0) && defined(LCD_DATA1) && defined(LCD_DATA2) && defined(LCD_DATA3) && !defined(LCD_DATA4) && !defined(LCD_DATA5) && !defined(LCD_DATA6) && !defined(LCD_DATA7)) 
....................    #define  LCD_DATA4    LCD_DATA0 
....................    #define  LCD_DATA5    LCD_DATA1 
....................    #define  LCD_DATA6    LCD_DATA2 
....................    #define  LCD_DATA7    LCD_DATA3 
.................... #endif 
....................  
.................... #ifndef LCD_DATA4 
.................... #ifndef LCD_DATA_PORT 
....................    #if defined(__PCB__) 
....................       #define LCD_DATA_PORT      0x06     //portb 
....................       #define set_tris_lcd(x)   set_tris_b(x) 
....................    #else 
....................      #if defined(PIN_D0) 
....................       #define LCD_DATA_PORT      getenv("SFR:PORTD")     //portd 
....................      #else 
....................       #define LCD_DATA_PORT      getenv("SFR:PORTB")     //portb 
....................      #endif 
....................    #endif    
.................... #endif 
....................  
.................... #if defined(__PCB__) 
....................    LCD_PIN_MAP lcd, lcdlat; 
....................    #byte lcd = LCD_DATA_PORT 
....................    #byte lcdlat = LCD_DATA_PORT 
.................... #elif defined(__PCM__) 
....................    LCD_PIN_MAP lcd, lcdlat, lcdtris; 
....................    #byte lcd = LCD_DATA_PORT 
....................    #byte lcdlat = LCD_DATA_PORT 
....................    #byte lcdtris = LCD_DATA_PORT+0x80 
.................... #elif defined(__PCH__) 
....................    LCD_PIN_MAP lcd, lcdlat, lcdtris; 
....................    #byte lcd = LCD_DATA_PORT 
....................    #byte lcdlat = LCD_DATA_PORT+9 
....................    #byte lcdtris = LCD_DATA_PORT+0x12 
.................... #elif defined(__PCD__) 
....................    LCD_PIN_MAP lcd, lcdlat, lcdtris; 
....................    #word lcd = LCD_DATA_PORT 
....................    #word lcdlat = LCD_DATA_PORT+2 
....................    #word lcdtris = LCD_DATA_PORT-0x02 
.................... #endif 
.................... #endif   //LCD_DATA4 not defined 
....................  
.................... #ifndef LCD_TYPE 
....................    #define LCD_TYPE 2           // 0=5x7, 1=5x10, 2=2 lines 
.................... #endif 
....................  
.................... #ifndef LCD_LINE_TWO 
....................    #define LCD_LINE_TWO 0x40    // LCD RAM address for the second line 
.................... #endif 
....................  
.................... #ifndef LCD_LINE_LENGTH 
....................    #define LCD_LINE_LENGTH 20 
.................... #endif 
....................  
.................... unsigned int8 lcd_read_nibble(void); 
....................  
.................... unsigned int8 lcd_read_byte(void) 
.................... { 
....................    unsigned int8 low,high; 
....................  
....................  #if defined(__PCB__) 
....................    set_tris_lcd(LCD_INPUT_MAP); 
....................  #else 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    output_float(LCD_DATA4); 
*
01F8:  BSF    07.0
....................    output_float(LCD_DATA5); 
01F9:  BSF    07.1
....................    output_float(LCD_DATA6); 
01FA:  BSF    07.2
....................    output_float(LCD_DATA7); 
01FB:  BSF    07.3
....................   #else 
....................    lcdtris.data = 0xF; 
....................   #endif 
....................  #endif 
....................          
....................    lcd_output_rw(1); 
01FC:  BCF    03.5
01FD:  BSF    09.2
01FE:  BSF    03.5
01FF:  BCF    09.2
....................    delay_cycles(1); 
0200:  NOP
....................    lcd_output_enable(1); 
0201:  BCF    03.5
0202:  BSF    09.0
0203:  BSF    03.5
0204:  BCF    09.0
....................    delay_cycles(1); 
0205:  NOP
....................    high = lcd_read_nibble(); 
0206:  BCF    03.5
0207:  CALL   1AD
0208:  MOVF   78,W
0209:  BSF    03.6
020A:  MOVWF  3D
....................        
....................    lcd_output_enable(0); 
020B:  BCF    03.6
020C:  BCF    09.0
020D:  BSF    03.5
020E:  BCF    09.0
....................    delay_cycles(1); 
020F:  NOP
....................    lcd_output_enable(1); 
0210:  BCF    03.5
0211:  BSF    09.0
0212:  BSF    03.5
0213:  BCF    09.0
....................    delay_us(1); 
0214:  GOTO   215
0215:  GOTO   216
0216:  NOP
....................    low = lcd_read_nibble(); 
0217:  BCF    03.5
0218:  CALL   1AD
0219:  MOVF   78,W
021A:  BSF    03.6
021B:  MOVWF  3C
....................        
....................    lcd_output_enable(0); 
021C:  BCF    03.6
021D:  BCF    09.0
021E:  BSF    03.5
021F:  BCF    09.0
....................  
....................  #if defined(__PCB__) 
....................    set_tris_lcd(LCD_OUTPUT_MAP); 
....................  #else 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    output_drive(LCD_DATA4); 
0220:  BCF    03.5
0221:  BCF    31.0
0222:  MOVF   31,W
0223:  BSF    03.5
0224:  MOVWF  07
....................    output_drive(LCD_DATA5); 
0225:  BCF    03.5
0226:  BCF    31.1
0227:  MOVF   31,W
0228:  BSF    03.5
0229:  MOVWF  07
....................    output_drive(LCD_DATA6); 
022A:  BCF    03.5
022B:  BCF    31.2
022C:  MOVF   31,W
022D:  BSF    03.5
022E:  MOVWF  07
....................    output_drive(LCD_DATA7); 
022F:  BCF    03.5
0230:  BCF    31.3
0231:  MOVF   31,W
0232:  BSF    03.5
0233:  MOVWF  07
....................   #else 
....................    lcdtris.data = 0x0; 
....................   #endif 
....................  #endif 
....................  
....................    return( (high<<4) | low); 
0234:  BCF    03.5
0235:  BSF    03.6
0236:  SWAPF  3D,W
0237:  MOVWF  77
0238:  MOVLW  F0
0239:  ANDWF  77,F
023A:  MOVF   77,W
023B:  IORWF  3C,W
023C:  MOVWF  78
.................... } 
....................  
.................... unsigned int8 lcd_read_nibble(void) 
.................... { 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
*
01AD:  BSF    03.6
01AE:  CLRF   3E
....................    unsigned int8 n = 0x00; 
....................  
....................    /* Read the data port */ 
....................    n |= input(LCD_DATA4); 
01AF:  BCF    03.6
01B0:  BSF    31.0
01B1:  MOVF   31,W
01B2:  BSF    03.5
01B3:  MOVWF  07
01B4:  MOVLW  00
01B5:  BCF    03.5
01B6:  BTFSC  07.0
01B7:  MOVLW  01
01B8:  BSF    03.6
01B9:  IORWF  3E,F
....................    n |= input(LCD_DATA5) << 1; 
01BA:  BCF    03.6
01BB:  BSF    31.1
01BC:  MOVF   31,W
01BD:  BSF    03.5
01BE:  MOVWF  07
01BF:  MOVLW  00
01C0:  BCF    03.5
01C1:  BTFSC  07.1
01C2:  MOVLW  01
01C3:  MOVWF  77
01C4:  BCF    03.0
01C5:  RLF    77,F
01C6:  MOVF   77,W
01C7:  BSF    03.6
01C8:  IORWF  3E,F
....................    n |= input(LCD_DATA6) << 2; 
01C9:  BCF    03.6
01CA:  BSF    31.2
01CB:  MOVF   31,W
01CC:  BSF    03.5
01CD:  MOVWF  07
01CE:  MOVLW  00
01CF:  BCF    03.5
01D0:  BTFSC  07.2
01D1:  MOVLW  01
01D2:  MOVWF  77
01D3:  RLF    77,F
01D4:  RLF    77,F
01D5:  MOVLW  FC
01D6:  ANDWF  77,F
01D7:  MOVF   77,W
01D8:  BSF    03.6
01D9:  IORWF  3E,F
....................    n |= input(LCD_DATA7) << 3; 
01DA:  BCF    03.6
01DB:  BSF    31.3
01DC:  MOVF   31,W
01DD:  BSF    03.5
01DE:  MOVWF  07
01DF:  MOVLW  00
01E0:  BCF    03.5
01E1:  BTFSC  07.3
01E2:  MOVLW  01
01E3:  MOVWF  77
01E4:  RLF    77,F
01E5:  RLF    77,F
01E6:  RLF    77,F
01E7:  MOVLW  F8
01E8:  ANDWF  77,F
01E9:  MOVF   77,W
01EA:  BSF    03.6
01EB:  IORWF  3E,F
....................     
....................    return(n); 
01EC:  MOVF   3E,W
01ED:  MOVWF  78
....................   #else 
01EE:  BCF    03.6
01EF:  RETURN
....................    return(lcd.data); 
....................   #endif 
.................... } 
....................  
.................... void lcd_send_nibble(unsigned int8 n) 
.................... { 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    /* Write to the data port */ 
....................    output_bit(LCD_DATA4, bit_test(n, 0)); 
*
0165:  BSF    03.6
0166:  BTFSC  3D.0
0167:  GOTO   16C
0168:  BCF    03.6
0169:  BCF    07.0
016A:  GOTO   16E
016B:  BSF    03.6
016C:  BCF    03.6
016D:  BSF    07.0
016E:  BCF    31.0
016F:  MOVF   31,W
0170:  BSF    03.5
0171:  MOVWF  07
....................    output_bit(LCD_DATA5, bit_test(n, 1)); 
0172:  BCF    03.5
0173:  BSF    03.6
0174:  BTFSC  3D.1
0175:  GOTO   17A
0176:  BCF    03.6
0177:  BCF    07.1
0178:  GOTO   17C
0179:  BSF    03.6
017A:  BCF    03.6
017B:  BSF    07.1
017C:  BCF    31.1
017D:  MOVF   31,W
017E:  BSF    03.5
017F:  MOVWF  07
....................    output_bit(LCD_DATA6, bit_test(n, 2)); 
0180:  BCF    03.5
0181:  BSF    03.6
0182:  BTFSC  3D.2
0183:  GOTO   188
0184:  BCF    03.6
0185:  BCF    07.2
0186:  GOTO   18A
0187:  BSF    03.6
0188:  BCF    03.6
0189:  BSF    07.2
018A:  BCF    31.2
018B:  MOVF   31,W
018C:  BSF    03.5
018D:  MOVWF  07
....................    output_bit(LCD_DATA7, bit_test(n, 3)); 
018E:  BCF    03.5
018F:  BSF    03.6
0190:  BTFSC  3D.3
0191:  GOTO   196
0192:  BCF    03.6
0193:  BCF    07.3
0194:  GOTO   198
0195:  BSF    03.6
0196:  BCF    03.6
0197:  BSF    07.3
0198:  BCF    31.3
0199:  MOVF   31,W
019A:  BSF    03.5
019B:  MOVWF  07
....................   #else       
....................    lcdlat.data = n; 
....................   #endif 
....................        
....................    delay_cycles(1); 
019C:  NOP
....................    lcd_output_enable(1); 
019D:  BCF    03.5
019E:  BSF    09.0
019F:  BSF    03.5
01A0:  BCF    09.0
....................    delay_us(2); 
01A1:  MOVLW  02
01A2:  MOVWF  77
01A3:  DECFSZ 77,F
01A4:  GOTO   1A3
01A5:  GOTO   1A6
01A6:  NOP
....................    lcd_output_enable(0); 
01A7:  BCF    03.5
01A8:  BCF    09.0
01A9:  BSF    03.5
01AA:  BCF    09.0
01AB:  BCF    03.5
01AC:  RETURN
.................... } 
....................  
.................... void lcd_send_byte(unsigned int8 address, unsigned int8 n) 
.................... { 
....................   #if defined(__PCB__) 
....................    set_tris_lcd(LCD_OUTPUT_MAP); 
....................   #else 
....................    lcd_enable_tris(); 
*
01F0:  BSF    03.5
01F1:  BCF    09.0
....................    lcd_rs_tris(); 
01F2:  BCF    09.1
....................    lcd_rw_tris(); 
01F3:  BCF    09.2
....................   #endif 
....................  
....................    lcd_output_rs(0); 
01F4:  BCF    03.5
01F5:  BCF    09.1
01F6:  BSF    03.5
01F7:  BCF    09.1
....................    while ( bit_test(lcd_read_byte(),7) ) ; 
*
023D:  MOVF   78,W
023E:  MOVWF  3C
023F:  BTFSS  3C.7
0240:  GOTO   244
0241:  BSF    03.5
0242:  BCF    03.6
0243:  GOTO   1F8
....................    lcd_output_rs(address); 
0244:  MOVF   3A,F
0245:  BTFSS  03.2
0246:  GOTO   24B
0247:  BCF    03.6
0248:  BCF    09.1
0249:  GOTO   24D
024A:  BSF    03.6
024B:  BCF    03.6
024C:  BSF    09.1
024D:  BSF    03.5
024E:  BCF    09.1
....................    delay_cycles(1); 
024F:  NOP
....................    lcd_output_rw(0); 
0250:  BCF    03.5
0251:  BCF    09.2
0252:  BSF    03.5
0253:  BCF    09.2
....................    delay_cycles(1); 
0254:  NOP
....................    lcd_output_enable(0); 
0255:  BCF    03.5
0256:  BCF    09.0
0257:  BSF    03.5
0258:  BCF    09.0
....................    lcd_send_nibble(n >> 4); 
0259:  BCF    03.5
025A:  BSF    03.6
025B:  SWAPF  3B,W
025C:  MOVWF  3C
025D:  MOVLW  0F
025E:  ANDWF  3C,F
025F:  MOVF   3C,W
0260:  MOVWF  3D
0261:  BCF    03.6
0262:  CALL   165
....................    lcd_send_nibble(n & 0xf); 
0263:  BSF    03.6
0264:  MOVF   3B,W
0265:  ANDLW  0F
0266:  MOVWF  3C
0267:  MOVWF  3D
0268:  BCF    03.6
0269:  CALL   165
026A:  RETURN
.................... } 
....................  
.................... #if defined(LCD_EXTENDED_NEWLINE) 
.................... unsigned int8 g_LcdX, g_LcdY; 
.................... #endif 
....................  
.................... void lcd_init(void)  
.................... { 
....................    unsigned int8 i; 
....................    unsigned int8 LCD_INIT_STRING[4] = {0x20 | (LCD_TYPE << 2), 0xc, 1, 6}; 
026B:  MOVLW  28
026C:  BSF    03.5
026D:  MOVWF  4E
026E:  MOVLW  0C
026F:  MOVWF  4F
0270:  MOVLW  01
0271:  MOVWF  50
0272:  MOVLW  06
0273:  MOVWF  51
....................                              // These bytes need to be sent to the LCD 
....................                              // to start it up. 
....................     
....................  
....................    lcd_output_enable(0); 
0274:  BCF    03.5
0275:  BCF    09.0
0276:  BSF    03.5
0277:  BCF    09.0
....................    lcd_output_rs(0); 
0278:  BCF    03.5
0279:  BCF    09.1
027A:  BSF    03.5
027B:  BCF    09.1
....................    lcd_output_rw(0); 
027C:  BCF    03.5
027D:  BCF    09.2
027E:  BSF    03.5
027F:  BCF    09.2
....................  
....................  #if defined(__PCB__) 
....................    set_tris_lcd(LCD_OUTPUT_MAP); 
....................  #else 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    output_drive(LCD_DATA4); 
0280:  BCF    03.5
0281:  BCF    31.0
0282:  MOVF   31,W
0283:  BSF    03.5
0284:  MOVWF  07
....................    output_drive(LCD_DATA5); 
0285:  BCF    03.5
0286:  BCF    31.1
0287:  MOVF   31,W
0288:  BSF    03.5
0289:  MOVWF  07
....................    output_drive(LCD_DATA6); 
028A:  BCF    03.5
028B:  BCF    31.2
028C:  MOVF   31,W
028D:  BSF    03.5
028E:  MOVWF  07
....................    output_drive(LCD_DATA7); 
028F:  BCF    03.5
0290:  BCF    31.3
0291:  MOVF   31,W
0292:  BSF    03.5
0293:  MOVWF  07
....................   #else 
....................    lcdtris.data = 0x0; 
....................   #endif 
....................    lcd_enable_tris(); 
0294:  BCF    09.0
....................    lcd_rs_tris(); 
0295:  BCF    09.1
....................    lcd_rw_tris(); 
0296:  BCF    09.2
....................  #endif 
....................      
....................    delay_ms(15); 
0297:  MOVLW  0F
0298:  BCF    03.5
0299:  BSF    03.6
029A:  MOVWF  36
029B:  BCF    03.6
029C:  CALL   151
....................    for(i=1;i<=3;++i) 
029D:  MOVLW  01
029E:  BSF    03.5
029F:  MOVWF  4D
02A0:  MOVF   4D,W
02A1:  SUBLW  03
02A2:  BTFSS  03.0
02A3:  GOTO   2B2
....................    { 
....................        lcd_send_nibble(3); 
02A4:  MOVLW  03
02A5:  BCF    03.5
02A6:  BSF    03.6
02A7:  MOVWF  3D
02A8:  BCF    03.6
02A9:  CALL   165
....................        delay_ms(5); 
02AA:  MOVLW  05
02AB:  BSF    03.6
02AC:  MOVWF  36
02AD:  BCF    03.6
02AE:  CALL   151
02AF:  BSF    03.5
02B0:  INCF   4D,F
02B1:  GOTO   2A0
....................    } 
....................     
....................    lcd_send_nibble(2); 
02B2:  MOVLW  02
02B3:  BCF    03.5
02B4:  BSF    03.6
02B5:  MOVWF  3D
02B6:  BCF    03.6
02B7:  CALL   165
....................    delay_ms(5); 
02B8:  MOVLW  05
02B9:  BSF    03.6
02BA:  MOVWF  36
02BB:  BCF    03.6
02BC:  CALL   151
....................    for(i=0;i<=3;++i) 
02BD:  BSF    03.5
02BE:  CLRF   4D
02BF:  MOVF   4D,W
02C0:  SUBLW  03
02C1:  BTFSS  03.0
02C2:  GOTO   2D7
....................       lcd_send_byte(0,LCD_INIT_STRING[i]); 
02C3:  MOVLW  CE
02C4:  ADDWF  4D,W
02C5:  MOVWF  04
02C6:  BCF    03.7
02C7:  MOVF   00,W
02C8:  MOVWF  52
02C9:  BCF    03.5
02CA:  BSF    03.6
02CB:  CLRF   3A
02CC:  BSF    03.5
02CD:  BCF    03.6
02CE:  MOVF   52,W
02CF:  BCF    03.5
02D0:  BSF    03.6
02D1:  MOVWF  3B
02D2:  BCF    03.6
02D3:  CALL   1F0
....................  
....................   #if defined(LCD_EXTENDED_NEWLINE) 
02D4:  BSF    03.5
02D5:  INCF   4D,F
02D6:  GOTO   2BF
02D7:  BCF    03.5
02D8:  BSF    0A.3
02D9:  BCF    0A.4
02DA:  GOTO   722 (RETURN)
....................    g_LcdX = 0; 
....................    g_LcdY = 0; 
....................   #endif 
.................... } 
....................  
.................... void lcd_gotoxy(unsigned int8 x, unsigned int8 y) 
.................... { 
....................    unsigned int8 address; 
....................     
....................    if(y!=1) 
02DB:  BSF    03.6
02DC:  DECFSZ 37,W
02DD:  GOTO   2DF
02DE:  GOTO   2E2
....................       address=LCD_LINE_TWO; 
02DF:  MOVLW  40
02E0:  MOVWF  38
02E1:  GOTO   2E3
....................    else 
....................       address=0; 
02E2:  CLRF   38
....................       
....................    address+=x-1; 
02E3:  MOVLW  01
02E4:  SUBWF  36,W
02E5:  ADDWF  38,F
....................    lcd_send_byte(0,0x80|address); 
02E6:  MOVF   38,W
02E7:  IORLW  80
02E8:  MOVWF  39
02E9:  CLRF   3A
02EA:  MOVF   39,W
02EB:  MOVWF  3B
02EC:  BCF    03.6
02ED:  CALL   1F0
....................  
....................   #if defined(LCD_EXTENDED_NEWLINE) 
02EE:  RETURN
....................    g_LcdX = x - 1; 
....................    g_LcdY = y - 1; 
....................   #endif 
.................... } 
....................  
.................... void lcd_putc(char c) 
.................... { 
....................    switch (c) 
02EF:  BSF    03.6
02F0:  MOVF   35,W
02F1:  XORLW  07
02F2:  BCF    03.6
02F3:  BTFSC  03.2
02F4:  GOTO   2FF
02F5:  XORLW  0B
02F6:  BTFSC  03.2
02F7:  GOTO   306
02F8:  XORLW  06
02F9:  BTFSC  03.2
02FA:  GOTO   312
02FB:  XORLW  02
02FC:  BTFSC  03.2
02FD:  GOTO   31A
02FE:  GOTO   321
....................    { 
....................       case '\a'   :  lcd_gotoxy(1,1);     break; 
02FF:  MOVLW  01
0300:  BSF    03.6
0301:  MOVWF  36
0302:  MOVWF  37
0303:  BCF    03.6
0304:  CALL   2DB
0305:  GOTO   328
....................  
....................       case '\f'   :  lcd_send_byte(0,1); 
0306:  BSF    03.6
0307:  CLRF   3A
0308:  MOVLW  01
0309:  MOVWF  3B
030A:  BCF    03.6
030B:  CALL   1F0
....................                      delay_ms(2); 
030C:  MOVLW  02
030D:  BSF    03.6
030E:  MOVWF  36
030F:  BCF    03.6
0310:  CALL   151
....................                     #if defined(LCD_EXTENDED_NEWLINE) 
....................                      g_LcdX = 0; 
....................                      g_LcdY = 0; 
....................                     #endif 
....................                      break; 
0311:  GOTO   328
....................  
....................      #if defined(LCD_EXTENDED_NEWLINE) 
....................       case '\r'   :  lcd_gotoxy(1, g_LcdY+1);   break; 
....................       case '\n'   : 
....................          while (g_LcdX++ < LCD_LINE_LENGTH) 
....................          { 
....................             lcd_send_byte(1, ' '); 
....................          } 
....................          lcd_gotoxy(1, g_LcdY+2); 
....................          break; 
....................      #else 
....................       case '\n'   : lcd_gotoxy(1,2);        break; 
0312:  MOVLW  01
0313:  BSF    03.6
0314:  MOVWF  36
0315:  MOVLW  02
0316:  MOVWF  37
0317:  BCF    03.6
0318:  CALL   2DB
0319:  GOTO   328
....................      #endif 
....................       
....................       case '\b'   : lcd_send_byte(0,0x10);  break; 
031A:  BSF    03.6
031B:  CLRF   3A
031C:  MOVLW  10
031D:  MOVWF  3B
031E:  BCF    03.6
031F:  CALL   1F0
0320:  GOTO   328
....................       
....................      #if defined(LCD_EXTENDED_NEWLINE) 
....................       default     :  
....................          if (g_LcdX < LCD_LINE_LENGTH) 
....................          { 
....................             lcd_send_byte(1, c); 
....................             g_LcdX++; 
....................          } 
....................          break; 
....................      #else 
....................       default     : lcd_send_byte(1,c);     break; 
0321:  MOVLW  01
0322:  BSF    03.6
0323:  MOVWF  3A
0324:  MOVF   35,W
0325:  MOVWF  3B
0326:  BCF    03.6
0327:  CALL   1F0
....................      #endif 
....................    } 
0328:  RETURN
.................... } 
....................   
.................... char lcd_getc(unsigned int8 x, unsigned int8 y) 
.................... { 
....................    char value; 
....................  
....................    lcd_gotoxy(x,y); 
....................    while ( bit_test(lcd_read_byte(),7) ); // wait until busy flag is low 
....................    lcd_output_rs(1); 
....................    value = lcd_read_byte(); 
....................    lcd_output_rs(0); 
....................     
....................    return(value); 
.................... } 
....................  
.................... // write a custom character to the ram 
.................... // which is 0-7 and specifies which character array we are modifying. 
.................... // ptr points to an array of 8 bytes, where each byte is the next row of 
.................... //    pixels.  only bits 0-4 are used.  the last row is the cursor row, and 
.................... //    usually you will want to leave this byte 0x00. 
.................... void lcd_set_cgram_char(unsigned int8 which, unsigned int8 *ptr) 
.................... { 
....................    unsigned int i; 
....................  
....................    which <<= 3; 
....................    which &= 0x38; 
....................  
....................    lcd_send_byte(0, 0x40 | which);  //set cgram address 
....................  
....................    for(i=0; i<8; i++) 
....................    { 
....................       lcd_send_byte(1, *ptr++); 
....................    } 
....................    
....................    #if defined(LCD_EXTENDED_NEWLINE) 
....................     lcd_gotoxy(g_LcdX+1, g_LcdY+1);  //set ddram address 
....................    #endif 
.................... } 
....................  
.................... void lcd_cursor_on(int1 on) 
.................... { 
....................    if (on) 
....................    { 
....................       lcd_send_byte(0,0x0F);           //turn LCD cursor ON 
....................    } 
....................    else 
....................    { 
....................       lcd_send_byte(0,0x0C);           //turn LCD cursor OFF 
....................    } 
.................... } 
....................  
.................... #endif 
....................  
.................... #BIT TMR1IF = 0x0C.0 //bit thu 0 (TMR1IF) cua PIR1 
....................  
.................... #INCLUDE <khaibaobien.c> // VARIABLE. 
.................... UNSIGNED INT16 KQADC,AN0, AN1; 
.................... UNSIGNED INT8 CONFIG_FUN=0; 
.................... UNSIGNED INT8 VT=0, KYTU=0;// KYTU[30],  
.................... UNSIGNED INT8 ID_DEVICE_NHAN,TT_DEVICE_NHAN; 
.................... UNSIGNED INT8 ID_GATEWAY[6] = {1,2,7,1,0,2}; 
*
0E92:  MOVLW  01
0E93:  MOVWF  3D
0E94:  MOVLW  02
0E95:  MOVWF  3E
0E96:  MOVLW  07
0E97:  MOVWF  3F
0E98:  MOVLW  01
0E99:  MOVWF  40
0E9A:  CLRF   41
0E9B:  MOVLW  02
0E9C:  MOVWF  42
.................... UNSIGNED INT8 ID_NODE[4] = {0,5,8,9}; 
0E9D:  CLRF   43
0E9E:  MOVLW  05
0E9F:  MOVWF  44
0EA0:  MOVLW  08
0EA1:  MOVWF  45
0EA2:  MOVLW  09
0EA3:  MOVWF  46
.................... UNSIGNED INT8 LEN_PACKAGES = 0; 
.................... UNSIGNED INT8 LENHDIEUKHIEN =0, DODAI_DATA_NHAN =0; 
.................... SIGNED INT8 SOSANH_IDNODE=0, SOSANH_IDGW=0; 
....................  
.................... INT1 TTNHAN = 0, TT_CONFIG=0, TT_CONTROL=0,TT_CONFIG_DONE=0, TT_FUN=0, TT_STT=0; 
....................  
.................... CHAR *ID_NODE_CHAR[]= "0589"; 
0EA4:  MOVLW  30
0EA5:  MOVWF  4F
0EA6:  MOVLW  35
0EA7:  MOVWF  50
0EA8:  MOVLW  38
0EA9:  MOVWF  51
0EAA:  MOVLW  39
0EAB:  MOVWF  52
0EAC:  CLRF   53
0EAD:  CLRF   4E
0EAE:  MOVLW  4F
0EAF:  MOVWF  4D
.................... CHAR *ID_GATEWAY_CHAR[]= "127102"; 
0EB0:  MOVLW  31
0EB1:  MOVWF  56
0EB2:  MOVLW  32
0EB3:  MOVWF  57
0EB4:  MOVLW  37
0EB5:  MOVWF  58
0EB6:  MOVLW  31
0EB7:  MOVWF  59
0EB8:  MOVLW  30
0EB9:  MOVWF  5A
0EBA:  MOVLW  32
0EBB:  MOVWF  5B
0EBC:  CLRF   5C
0EBD:  CLRF   55
0EBE:  MOVLW  56
0EBF:  MOVWF  54
.................... CHAR *ID_NODE_NHAN[]= "0000"; 
0EC0:  MOVLW  30
0EC1:  MOVWF  5F
0EC2:  MOVWF  60
0EC3:  MOVWF  61
0EC4:  MOVWF  62
0EC5:  CLRF   63
0EC6:  CLRF   5E
0EC7:  MOVLW  5F
0EC8:  MOVWF  5D
.................... CHAR *ID_GW_NHAN[]= "000000"; 
0EC9:  MOVLW  30
0ECA:  MOVWF  66
0ECB:  MOVWF  67
0ECC:  MOVWF  68
0ECD:  MOVWF  69
0ECE:  MOVWF  6A
0ECF:  MOVWF  6B
0ED0:  CLRF   6C
0ED1:  CLRF   65
0ED2:  MOVLW  66
0ED3:  MOVWF  64
.................... CHAR KYTUCHAR[30]="HIHI"; 
0ED4:  MOVLW  48
0ED5:  BSF    03.5
0ED6:  MOVWF  20
0ED7:  MOVLW  49
0ED8:  MOVWF  21
0ED9:  MOVLW  48
0EDA:  MOVWF  22
0EDB:  MOVLW  49
0EDC:  MOVWF  23
0EDD:  CLRF   24
.................... CHAR KYTUCHAR2[15]="HIHI"; 
0EDE:  MOVLW  48
0EDF:  MOVWF  3E
0EE0:  MOVLW  49
0EE1:  MOVWF  3F
0EE2:  MOVLW  48
0EE3:  MOVWF  40
0EE4:  MOVLW  49
0EE5:  MOVWF  41
0EE6:  CLRF   42
.................... //CHAR *DATA_NHANDUOC[]={"IDGW","IDNODE","COMMAN","DATA"}; 
.................... CHAR *TEMP_CHAR[]="00";   
0EE7:  MOVLW  30
0EE8:  BCF    03.5
0EE9:  MOVWF  6F
0EEA:  MOVWF  70
0EEB:  CLRF   71
0EEC:  CLRF   6E
0EED:  MOVLW  6F
0EEE:  MOVWF  6D
.................... //CHAR *TEMP_CHAR3[]="000000";  
....................  
....................  
....................  
.................... //#INCLUDE <CONFIG_NODE.C> // CU HINH NODE. 
.................... #INCLUDE <config_1.C> // CU HINH NODE. 
....................  
.................... //--------------------------------------------------------------------// 
.................... VOID CHON_ID() 
.................... { 
....................    // TT_CONFIG_DONE; 
....................    TT_CONFIG_DONE = 0; 
*
05C8:  BCF    4C.3
....................    TT_STT = 1; 
05C9:  BSF    4C.5
....................    UNSIGNED INT8 NUM = 0; 
05CA:  BSF    03.5
05CB:  CLRF   4D
....................    TEMP_CHAR = "0"; 
05CC:  CLRF   4E
05CD:  CLRF   4F
05CE:  MOVLW  6D
05CF:  MOVWF  04
05D0:  BCF    03.7
05D1:  MOVF   4E,W
05D2:  ADDWF  04,F
05D3:  MOVF   4F,W
05D4:  BCF    03.5
05D5:  CALL   058
05D6:  MOVWF  00
05D7:  IORLW  00
05D8:  BTFSC  03.2
05D9:  GOTO   5DF
05DA:  BSF    03.5
05DB:  INCF   4F,F
05DC:  INCF   4E,F
05DD:  GOTO   5CE
05DE:  BCF    03.5
....................    LCD_GOTOXY (1, 2) ; 
05DF:  MOVLW  01
05E0:  BSF    03.6
05E1:  MOVWF  36
05E2:  MOVLW  02
05E3:  MOVWF  37
05E4:  BCF    03.6
05E5:  CALL   2DB
....................    DELAY_MS (10); 
05E6:  MOVLW  0A
05E7:  BSF    03.6
05E8:  MOVWF  36
05E9:  BCF    03.6
05EA:  CALL   151
....................    PRINTF (LCD_PUTC, "NODE: "); 
05EB:  MOVLW  6F
05EC:  BSF    03.6
05ED:  MOVWF  0D
05EE:  MOVLW  00
05EF:  MOVWF  0F
05F0:  BCF    03.6
05F1:  CALL   329
....................    PRINTF (LCD_PUTC, "0000          "); 
05F2:  MOVLW  73
05F3:  BSF    03.6
05F4:  MOVWF  0D
05F5:  MOVLW  00
05F6:  MOVWF  0F
05F7:  BCF    03.6
05F8:  CALL   329
....................    LCD_GOTOXY (1, 1) ; 
05F9:  MOVLW  01
05FA:  BSF    03.6
05FB:  MOVWF  36
05FC:  MOVWF  37
05FD:  BCF    03.6
05FE:  CALL   2DB
....................    PRINTF (LCD_PUTC, "      _              ");//6 SPACE PHIA TRUOC "_" 
05FF:  MOVLW  7B
0600:  BSF    03.6
0601:  MOVWF  0D
0602:  MOVLW  00
0603:  MOVWF  0F
0604:  BCF    03.6
0605:  CALL   329
....................    //ID_GW = "1234";     
....................  
....................    WHILE (TT_STT) 
0606:  BTFSS  4C.5
0607:  GOTO   692
....................    { 
....................       IF (!INPUT (BT2_PIN)) //NEU NUT BAM DUOC BAM 
0608:  BSF    03.5
0609:  BSF    06.2
060A:  BCF    03.5
060B:  BTFSC  06.2
060C:  GOTO   62F
....................       { 
....................           
....................          NUM++; 
060D:  BSF    03.5
060E:  INCF   4D,F
....................          NUM = NUM % 4; 
060F:  MOVLW  03
0610:  ANDWF  4D,F
....................          LCD_GOTOXY (3 + NUM, 1); 
0611:  ADDWF  4D,W
0612:  MOVWF  4E
0613:  BCF    03.5
0614:  BSF    03.6
0615:  MOVWF  36
0616:  MOVLW  01
0617:  MOVWF  37
0618:  BCF    03.6
0619:  CALL   2DB
....................          PRINTF (LCD_PUTC, "    _    ");//4SPACE 
061A:  MOVLW  86
061B:  BSF    03.6
061C:  MOVWF  0D
061D:  MOVLW  00
061E:  MOVWF  0F
061F:  BCF    03.6
0620:  CALL   329
....................          DELAY_MS (300);  
0621:  MOVLW  02
0622:  BSF    03.5
0623:  MOVWF  4E
0624:  MOVLW  96
0625:  BCF    03.5
0626:  BSF    03.6
0627:  MOVWF  36
0628:  BCF    03.6
0629:  CALL   151
062A:  BSF    03.5
062B:  DECFSZ 4E,F
062C:  GOTO   624
....................       } 
062D:  GOTO   690
062E:  BCF    03.5
....................  
....................       ELSE IF (!INPUT (BT3_PIN)) 
062F:  BSF    03.5
0630:  BSF    06.3
0631:  BCF    03.5
0632:  BTFSC  06.3
0633:  GOTO   691
....................       { 
....................          ID_NODE[NUM]++; 
0634:  MOVLW  43
0635:  BSF    03.5
0636:  ADDWF  4D,W
0637:  MOVWF  04
0638:  BCF    03.7
0639:  INCF   00,F
....................          ID_NODE[NUM] = ID_NODE[NUM] % 10; 
063A:  MOVLW  43
063B:  ADDWF  4D,W
063C:  MOVWF  78
063D:  CLRF   7A
063E:  BTFSC  03.0
063F:  INCF   7A,F
0640:  MOVF   78,W
0641:  MOVWF  4E
0642:  MOVF   7A,W
0643:  MOVWF  4F
0644:  MOVLW  43
0645:  ADDWF  4D,W
0646:  MOVWF  04
0647:  BCF    03.7
0648:  MOVF   00,W
0649:  MOVWF  51
064A:  MOVLW  0A
064B:  MOVWF  52
064C:  BCF    03.5
064D:  CALL   534
064E:  MOVF   77,W
064F:  BSF    03.5
0650:  MOVWF  50
0651:  MOVF   4E,W
0652:  MOVWF  04
0653:  BCF    03.7
0654:  BTFSC  4F.0
0655:  BSF    03.7
0656:  MOVF   50,W
0657:  MOVWF  00
....................          ITOA (ID_NODE[NUM], 10, TEMP_CHAR); 
0658:  MOVLW  43
0659:  ADDWF  4D,W
065A:  MOVWF  04
065B:  BCF    03.7
065C:  MOVF   00,W
065D:  MOVWF  4E
065E:  BCF    03.5
065F:  BSF    03.6
0660:  CLRF   37
0661:  CLRF   36
0662:  CLRF   35
0663:  BSF    03.5
0664:  BCF    03.6
0665:  MOVF   4E,W
0666:  BCF    03.5
0667:  BSF    03.6
0668:  MOVWF  34
0669:  MOVLW  0A
066A:  MOVWF  38
066B:  CLRF   3A
066C:  MOVLW  6D
066D:  MOVWF  39
066E:  BCF    03.6
066F:  CALL   3F5
....................          LCD_GOTOXY (7 + NUM, 2); 
0670:  MOVLW  07
0671:  BSF    03.5
0672:  ADDWF  4D,W
0673:  MOVWF  4E
0674:  BCF    03.5
0675:  BSF    03.6
0676:  MOVWF  36
0677:  MOVLW  02
0678:  MOVWF  37
0679:  BCF    03.6
067A:  CALL   2DB
....................          DELAY_MS (10); 
067B:  MOVLW  0A
067C:  BSF    03.6
067D:  MOVWF  36
067E:  BCF    03.6
067F:  CALL   151
....................          PRINTF (LCD_PUTC, TEMP_CHAR); 
0680:  MOVLW  6D
0681:  MOVWF  04
0682:  BCF    03.7
0683:  CALL   515
....................          DELAY_MS (300); 
0684:  MOVLW  02
0685:  BSF    03.5
0686:  MOVWF  4E
0687:  MOVLW  96
0688:  BCF    03.5
0689:  BSF    03.6
068A:  MOVWF  36
068B:  BCF    03.6
068C:  CALL   151
068D:  BSF    03.5
068E:  DECFSZ 4E,F
068F:  GOTO   687
0690:  BCF    03.5
....................       } 
0691:  GOTO   606
....................    } 
.................... } 
....................  
.................... VOID NHAPID_GW() 
*
0693:  BSF    03.5
0694:  CLRF   4D
.................... { 
....................    UNSIGNED INT8 NUM = 0; 
....................    TEMP_CHAR = "0"; 
0695:  CLRF   4E
0696:  CLRF   4F
0697:  MOVLW  6D
0698:  MOVWF  04
0699:  BCF    03.7
069A:  MOVF   4E,W
069B:  ADDWF  04,F
069C:  MOVF   4F,W
069D:  BCF    03.5
069E:  CALL   058
069F:  MOVWF  00
06A0:  IORLW  00
06A1:  BTFSC  03.2
06A2:  GOTO   6A8
06A3:  BSF    03.5
06A4:  INCF   4F,F
06A5:  INCF   4E,F
06A6:  GOTO   697
06A7:  BCF    03.5
....................    TT_CONFIG_DONE = 0; 
06A8:  BCF    4C.3
....................    TT_STT = 1; 
06A9:  BSF    4C.5
....................    LCD_GOTOXY (1, 2) ; 
06AA:  MOVLW  01
06AB:  BSF    03.6
06AC:  MOVWF  36
06AD:  MOVLW  02
06AE:  MOVWF  37
06AF:  BCF    03.6
06B0:  CALL   2DB
....................    DELAY_MS (10); 
06B1:  MOVLW  0A
06B2:  BSF    03.6
06B3:  MOVWF  36
06B4:  BCF    03.6
06B5:  CALL   151
....................    PRINTF (LCD_PUTC, "ID_GW:"); 
06B6:  MOVLW  8B
06B7:  BSF    03.6
06B8:  MOVWF  0D
06B9:  MOVLW  00
06BA:  MOVWF  0F
06BB:  BCF    03.6
06BC:  CALL   329
....................    PRINTF (LCD_PUTC, "000000        "); 
06BD:  MOVLW  8F
06BE:  BSF    03.6
06BF:  MOVWF  0D
06C0:  MOVLW  00
06C1:  MOVWF  0F
06C2:  BCF    03.6
06C3:  CALL   329
....................    LCD_GOTOXY (1, 1) ; 
06C4:  MOVLW  01
06C5:  BSF    03.6
06C6:  MOVWF  36
06C7:  MOVWF  37
06C8:  BCF    03.6
06C9:  CALL   2DB
....................    PRINTF (LCD_PUTC, "      _                ");//6 SPACE PHIA TRUOC "_" 
06CA:  MOVLW  97
06CB:  BSF    03.6
06CC:  MOVWF  0D
06CD:  MOVLW  00
06CE:  MOVWF  0F
06CF:  BCF    03.6
06D0:  CALL   329
....................    //ID_GW = "1234";     
....................  
....................    WHILE (TT_STT) 
06D1:  BTFSS  4C.5
06D2:  GOTO   765
....................    { 
....................       IF (!INPUT (BT2_PIN)) //NEU NUT BAM DUOC BAM 
06D3:  BSF    03.5
06D4:  BSF    06.2
06D5:  BCF    03.5
06D6:  BTFSC  06.2
06D7:  GOTO   702
....................       { 
....................           
....................          NUM++; 
06D8:  BSF    03.5
06D9:  INCF   4D,F
....................          NUM = NUM % 6; 
06DA:  MOVF   4D,W
06DB:  MOVWF  51
06DC:  MOVLW  06
06DD:  MOVWF  52
06DE:  BCF    03.5
06DF:  CALL   534
06E0:  MOVF   77,W
06E1:  BSF    03.5
06E2:  MOVWF  4D
....................          LCD_GOTOXY (3 + NUM, 1); 
06E3:  MOVLW  03
06E4:  ADDWF  4D,W
06E5:  MOVWF  4E
06E6:  BCF    03.5
06E7:  BSF    03.6
06E8:  MOVWF  36
06E9:  MOVLW  01
06EA:  MOVWF  37
06EB:  BCF    03.6
06EC:  CALL   2DB
....................          PRINTF (LCD_PUTC, "    _        ");//4SPACE 
06ED:  MOVLW  A3
06EE:  BSF    03.6
06EF:  MOVWF  0D
06F0:  MOVLW  00
06F1:  MOVWF  0F
06F2:  BCF    03.6
06F3:  CALL   329
....................          DELAY_MS (300);  
06F4:  MOVLW  02
06F5:  BSF    03.5
06F6:  MOVWF  4E
06F7:  MOVLW  96
06F8:  BCF    03.5
06F9:  BSF    03.6
06FA:  MOVWF  36
06FB:  BCF    03.6
06FC:  CALL   151
06FD:  BSF    03.5
06FE:  DECFSZ 4E,F
06FF:  GOTO   6F7
....................       } 
0700:  GOTO   763
0701:  BCF    03.5
....................  
....................       ELSE IF (!INPUT (BT3_PIN)) 
0702:  BSF    03.5
0703:  BSF    06.3
0704:  BCF    03.5
0705:  BTFSC  06.3
0706:  GOTO   764
....................       { 
....................          ID_GATEWAY[NUM]++; 
0707:  MOVLW  3D
0708:  BSF    03.5
0709:  ADDWF  4D,W
070A:  MOVWF  04
070B:  BCF    03.7
070C:  INCF   00,F
....................          ID_GATEWAY[NUM] = ID_GATEWAY[NUM] % 10; 
070D:  MOVLW  3D
070E:  ADDWF  4D,W
070F:  MOVWF  78
0710:  CLRF   7A
0711:  BTFSC  03.0
0712:  INCF   7A,F
0713:  MOVF   78,W
0714:  MOVWF  4E
0715:  MOVF   7A,W
0716:  MOVWF  4F
0717:  MOVLW  3D
0718:  ADDWF  4D,W
0719:  MOVWF  04
071A:  BCF    03.7
071B:  MOVF   00,W
071C:  MOVWF  51
071D:  MOVLW  0A
071E:  MOVWF  52
071F:  BCF    03.5
0720:  CALL   534
0721:  MOVF   77,W
0722:  BSF    03.5
0723:  MOVWF  50
0724:  MOVF   4E,W
0725:  MOVWF  04
0726:  BCF    03.7
0727:  BTFSC  4F.0
0728:  BSF    03.7
0729:  MOVF   50,W
072A:  MOVWF  00
....................          ITOA (ID_GATEWAY[NUM], 10, TEMP_CHAR); 
072B:  MOVLW  3D
072C:  ADDWF  4D,W
072D:  MOVWF  04
072E:  BCF    03.7
072F:  MOVF   00,W
0730:  MOVWF  4E
0731:  BCF    03.5
0732:  BSF    03.6
0733:  CLRF   37
0734:  CLRF   36
0735:  CLRF   35
0736:  BSF    03.5
0737:  BCF    03.6
0738:  MOVF   4E,W
0739:  BCF    03.5
073A:  BSF    03.6
073B:  MOVWF  34
073C:  MOVLW  0A
073D:  MOVWF  38
073E:  CLRF   3A
073F:  MOVLW  6D
0740:  MOVWF  39
0741:  BCF    03.6
0742:  CALL   3F5
....................          LCD_GOTOXY (7 + NUM, 2); 
0743:  MOVLW  07
0744:  BSF    03.5
0745:  ADDWF  4D,W
0746:  MOVWF  4E
0747:  BCF    03.5
0748:  BSF    03.6
0749:  MOVWF  36
074A:  MOVLW  02
074B:  MOVWF  37
074C:  BCF    03.6
074D:  CALL   2DB
....................          DELAY_MS (10); 
074E:  MOVLW  0A
074F:  BSF    03.6
0750:  MOVWF  36
0751:  BCF    03.6
0752:  CALL   151
....................          PRINTF (LCD_PUTC, TEMP_CHAR); 
0753:  MOVLW  6D
0754:  MOVWF  04
0755:  BCF    03.7
0756:  CALL   515
....................          DELAY_MS (300); 
0757:  MOVLW  02
0758:  BSF    03.5
0759:  MOVWF  4E
075A:  MOVLW  96
075B:  BCF    03.5
075C:  BSF    03.6
075D:  MOVWF  36
075E:  BCF    03.6
075F:  CALL   151
0760:  BSF    03.5
0761:  DECFSZ 4E,F
0762:  GOTO   75A
0763:  BCF    03.5
....................       } 
0764:  GOTO   6D1
....................    } 
.................... } 
....................  
.................... VOID BUTT_OKE() 
.................... { 
....................    TT_CONFIG_DONE = 0; 
*
011A:  BCF    03.6
011B:  BCF    4C.3
....................    TT_FUN = 0;//BREAK WHILE BUTT_FUN 
011C:  BCF    4C.4
....................    TT_STT = 0;// BREAK WHILE CHONID/NHAPID_GW 
011D:  BCF    4C.5
.................... } 
....................  
.................... VOID SELLECT_FUN() 
.................... { 
....................    TT_CONFIG_DONE = 0; 
*
05C0:  BCF    4C.3
....................  
....................    SWITCH (CONFIG_FUN) 
05C1:  MOVF   38,W
05C2:  BTFSC  03.2
05C3:  GOTO   5C8
05C4:  XORLW  01
05C5:  BTFSC  03.2
05C6:  GOTO   693
05C7:  GOTO   765
....................    { 
....................       CASE 0: 
....................       CHON_ID (); 
....................       BREAK; 
*
0692:  GOTO   765
....................  
....................       CASE 1:     
....................       NHAPID_GW (); 
....................       BREAK; 
....................    } 
.................... } 
....................  
.................... VOID BUTT_FUN() 
.................... { 
....................    TT_FUN = 1; 
*
054B:  BSF    4C.4
....................    LCD_GOTOXY (1, 1) ; 
054C:  MOVLW  01
054D:  BSF    03.6
054E:  MOVWF  36
054F:  MOVWF  37
0550:  BCF    03.6
0551:  CALL   2DB
....................    DELAY_MS (10); 
0552:  MOVLW  0A
0553:  BSF    03.6
0554:  MOVWF  36
0555:  BCF    03.6
0556:  CALL   151
....................    PRINTF (LCD_PUTC, "CONFIG:        "); 
0557:  MOVLW  AA
0558:  BSF    03.6
0559:  MOVWF  0D
055A:  MOVLW  00
055B:  MOVWF  0F
055C:  BCF    03.6
055D:  CALL   329
....................  
....................    // HIEN THI LCD 
....................    LCD_GOTOXY (1, 2) ; 
055E:  MOVLW  01
055F:  BSF    03.6
0560:  MOVWF  36
0561:  MOVLW  02
0562:  MOVWF  37
0563:  BCF    03.6
0564:  CALL   2DB
....................    DELAY_MS (10); 
0565:  MOVLW  0A
0566:  BSF    03.6
0567:  MOVWF  36
0568:  BCF    03.6
0569:  CALL   151
....................    PRINTF (LCD_PUTC, "CASE:          ") ; 
056A:  MOVLW  B2
056B:  BSF    03.6
056C:  MOVWF  0D
056D:  MOVLW  00
056E:  MOVWF  0F
056F:  BCF    03.6
0570:  CALL   329
....................  
....................    WHILE (TT_FUN) 
0571:  BTFSS  4C.4
0572:  GOTO   5BE
....................    { 
....................       IF (INPUT (BT2_PIN) == 0) //NEU NUT BAM DUOC BAM 
0573:  BSF    03.5
0574:  BSF    06.2
0575:  BCF    03.5
0576:  BTFSC  06.2
0577:  GOTO   5BD
....................       { 
....................          CONFIG_FUN ++; 
0578:  INCF   38,F
....................          CONFIG_FUN = CONFIG_FUN % 2; 
0579:  MOVLW  01
057A:  ANDWF  38,F
....................          DELAY_MS (300); 
057B:  MOVLW  02
057C:  BSF    03.5
057D:  MOVWF  4D
057E:  MOVLW  96
057F:  BCF    03.5
0580:  BSF    03.6
0581:  MOVWF  36
0582:  BCF    03.6
0583:  CALL   151
0584:  BSF    03.5
0585:  DECFSZ 4D,F
0586:  GOTO   57E
....................          //HIEN THI 
....................          LCD_GOTOXY (6, 2) ; 
0587:  MOVLW  06
0588:  BCF    03.5
0589:  BSF    03.6
058A:  MOVWF  36
058B:  MOVLW  02
058C:  MOVWF  37
058D:  BCF    03.6
058E:  CALL   2DB
....................          ITOA (CONFIG_FUN, 10, TEMP_CHAR); 
058F:  BSF    03.6
0590:  CLRF   37
0591:  CLRF   36
0592:  CLRF   35
0593:  BCF    03.6
0594:  MOVF   38,W
0595:  BSF    03.6
0596:  MOVWF  34
0597:  MOVLW  0A
0598:  MOVWF  38
0599:  CLRF   3A
059A:  MOVLW  6D
059B:  MOVWF  39
059C:  BCF    03.6
059D:  CALL   3F5
....................          DELAY_MS (10); 
059E:  MOVLW  0A
059F:  BSF    03.6
05A0:  MOVWF  36
05A1:  BCF    03.6
05A2:  CALL   151
....................          PRINTF (LCD_PUTC, TEMP_CHAR); 
05A3:  MOVLW  6D
05A4:  MOVWF  04
05A5:  BCF    03.7
05A6:  CALL   515
....................  
....................          SWITCH (CONFIG_FUN) 
05A7:  MOVF   38,W
05A8:  BTFSC  03.2
05A9:  GOTO   5AE
05AA:  XORLW  01
05AB:  BTFSC  03.2
05AC:  GOTO   5B6
05AD:  GOTO   5BD
....................          { 
....................             CASE 0: 
....................             PRINTF (LCD_PUTC, " - ID-NODE      "); 
05AE:  MOVLW  BA
05AF:  BSF    03.6
05B0:  MOVWF  0D
05B1:  MOVLW  00
05B2:  MOVWF  0F
05B3:  BCF    03.6
05B4:  CALL   329
....................             BREAK; 
05B5:  GOTO   5BD
....................  
....................             CASE 1: 
....................             PRINTF (LCD_PUTC, " - ID-GW       "); 
05B6:  MOVLW  C3
05B7:  BSF    03.6
05B8:  MOVWF  0D
05B9:  MOVLW  00
05BA:  MOVWF  0F
05BB:  BCF    03.6
05BC:  CALL   329
....................             BREAK;             
....................          } 
....................       } 
05BD:  GOTO   571
....................    } 
....................  
....................    ////// 
....................    IF (!TT_CONFIG_DONE) 
05BE:  BTFSC  4C.3
05BF:  GOTO   765
....................    { 
....................       SELLECT_FUN (); 
....................    } 
*
0765:  BSF    0A.3
0766:  BCF    0A.4
0767:  GOTO   72F (RETURN)
.................... } 
.................... VOID XULY_IDNODE_NHAP(){ 
....................    //*TEMP_CHAR3 = "\0"; 
....................    *ID_NODE_CHAR = "\0"; 
*
0899:  CLRF   7A
089A:  MOVLW  4D
089B:  BCF    03.5
089C:  BSF    03.6
089D:  MOVWF  33
089E:  MOVF   7A,W
089F:  MOVWF  34
08A0:  MOVF   33,W
08A1:  MOVWF  04
08A2:  BCF    03.7
08A3:  BTFSC  34.0
08A4:  BSF    03.7
08A5:  CLRF   00
....................    FOR (int j = 0; j < 4; j++) 
08A6:  CLRF   32
08A7:  MOVF   32,W
08A8:  SUBLW  03
08A9:  BTFSS  03.0
08AA:  GOTO   0D4
....................    { 
....................       ITOA (ID_NODE[j], 10, TEMP_CHAR); 
08AB:  MOVLW  43
08AC:  ADDWF  32,W
08AD:  MOVWF  04
08AE:  BCF    03.7
08AF:  MOVF   00,W
08B0:  MOVWF  33
08B1:  CLRF   37
08B2:  CLRF   36
08B3:  CLRF   35
08B4:  MOVF   33,W
08B5:  MOVWF  34
08B6:  MOVLW  0A
08B7:  MOVWF  38
08B8:  CLRF   3A
08B9:  MOVLW  6D
08BA:  MOVWF  39
08BB:  BCF    0A.3
08BC:  BCF    03.6
08BD:  CALL   3F5
08BE:  BSF    0A.3
....................       DELAY_MS (1); 
08BF:  MOVLW  01
08C0:  BSF    03.6
08C1:  MOVWF  36
08C2:  BCF    0A.3
08C3:  BCF    03.6
08C4:  CALL   151
08C5:  BSF    0A.3
....................       STRCAT (ID_NODE_CHAR, TEMP_CHAR); 
08C6:  BSF    03.6
08C7:  CLRF   34
08C8:  MOVLW  4D
08C9:  MOVWF  33
08CA:  CLRF   36
08CB:  MOVLW  6D
08CC:  MOVWF  35
08CD:  BCF    0A.3
08CE:  BCF    03.6
08CF:  CALL   768
08D0:  BSF    0A.3
08D1:  BSF    03.6
08D2:  INCF   32,F
08D3:  GOTO   0A7
....................    }   
....................    //ID_NODE_CHAR = TEMP_CHAR3;    
....................    //STRCPY(ID_NODE_CHAR,TEMP_CHAR3); 
....................    //strcpy 
.................... } 
.................... VOID XULY_IDGW_NHAP(){ 
....................  
....................    *ID_GATEWAY_CHAR = "\0"; 
*
0859:  CLRF   7A
085A:  MOVLW  54
085B:  BCF    03.5
085C:  BSF    03.6
085D:  MOVWF  33
085E:  MOVF   7A,W
085F:  MOVWF  34
0860:  MOVF   33,W
0861:  MOVWF  04
0862:  BCF    03.7
0863:  BTFSC  34.0
0864:  BSF    03.7
0865:  CLRF   00
....................    FOR (int j = 0; j < 6; j++) 
0866:  CLRF   32
0867:  MOVF   32,W
0868:  SUBLW  05
0869:  BTFSS  03.0
086A:  GOTO   094
....................    { 
....................       ITOA (ID_GATEWAY[j], 10, TEMP_CHAR); 
086B:  MOVLW  3D
086C:  ADDWF  32,W
086D:  MOVWF  04
086E:  BCF    03.7
086F:  MOVF   00,W
0870:  MOVWF  33
0871:  CLRF   37
0872:  CLRF   36
0873:  CLRF   35
0874:  MOVF   33,W
0875:  MOVWF  34
0876:  MOVLW  0A
0877:  MOVWF  38
0878:  CLRF   3A
0879:  MOVLW  6D
087A:  MOVWF  39
087B:  BCF    0A.3
087C:  BCF    03.6
087D:  CALL   3F5
087E:  BSF    0A.3
....................       DELAY_MS (1); 
087F:  MOVLW  01
0880:  BSF    03.6
0881:  MOVWF  36
0882:  BCF    0A.3
0883:  BCF    03.6
0884:  CALL   151
0885:  BSF    0A.3
....................       STRCAT (ID_GATEWAY_CHAR, TEMP_CHAR); 
0886:  BSF    03.6
0887:  CLRF   34
0888:  MOVLW  54
0889:  MOVWF  33
088A:  CLRF   36
088B:  MOVLW  6D
088C:  MOVWF  35
088D:  BCF    0A.3
088E:  BCF    03.6
088F:  CALL   768
0890:  BSF    0A.3
0891:  BSF    03.6
0892:  INCF   32,F
0893:  GOTO   067
....................    }   
.................... } 
....................  
....................  
.................... VOID CONFIG_DONE() 
.................... { 
....................    TT_FUN = 0; 
*
0800:  BCF    4C.4
....................    TT_STT = 0; 
0801:  BCF    4C.5
....................    CHAR *PACKAGE_CONFIG[]={"*", "LENGHT","C_F", "ID_GW1234" ,"ID_NODE","#"}; 
0802:  MOVLW  2A
0803:  BSF    03.6
0804:  MOVWF  10
0805:  CLRF   11
0806:  MOVLW  4C
0807:  MOVWF  12
0808:  MOVLW  45
0809:  MOVWF  13
080A:  MOVLW  4E
080B:  MOVWF  14
080C:  MOVLW  47
080D:  MOVWF  15
080E:  MOVLW  48
080F:  MOVWF  16
0810:  MOVLW  54
0811:  MOVWF  17
0812:  CLRF   18
0813:  MOVLW  43
0814:  MOVWF  19
0815:  MOVLW  5F
0816:  MOVWF  1A
0817:  MOVLW  46
0818:  MOVWF  1B
0819:  CLRF   1C
081A:  MOVLW  49
081B:  MOVWF  1D
081C:  MOVLW  44
081D:  MOVWF  1E
081E:  MOVLW  5F
081F:  MOVWF  1F
0820:  MOVLW  47
0821:  MOVWF  20
0822:  MOVLW  57
0823:  MOVWF  21
0824:  MOVLW  31
0825:  MOVWF  22
0826:  MOVLW  32
0827:  MOVWF  23
0828:  MOVLW  33
0829:  MOVWF  24
082A:  MOVLW  34
082B:  MOVWF  25
082C:  CLRF   26
082D:  MOVLW  49
082E:  MOVWF  27
082F:  MOVLW  44
0830:  MOVWF  28
0831:  MOVLW  5F
0832:  MOVWF  29
0833:  MOVLW  4E
0834:  MOVWF  2A
0835:  MOVLW  4F
0836:  MOVWF  2B
0837:  MOVLW  44
0838:  MOVWF  2C
0839:  MOVLW  45
083A:  MOVWF  2D
083B:  CLRF   2E
083C:  MOVLW  23
083D:  MOVWF  2F
083E:  CLRF   30
083F:  MOVLW  01
0840:  BSF    03.5
0841:  BCF    03.6
0842:  MOVWF  4E
0843:  MOVLW  10
0844:  MOVWF  4D
0845:  MOVLW  01
0846:  MOVWF  50
0847:  MOVLW  12
0848:  MOVWF  4F
0849:  MOVLW  01
084A:  MOVWF  52
084B:  MOVLW  19
084C:  MOVWF  51
084D:  MOVLW  01
084E:  MOVWF  54
084F:  MOVLW  1D
0850:  MOVWF  53
0851:  MOVLW  01
0852:  MOVWF  56
0853:  MOVLW  27
0854:  MOVWF  55
0855:  MOVLW  01
0856:  MOVWF  58
0857:  MOVLW  2F
0858:  MOVWF  57
....................    XULY_IDGW_NHAP(); 
....................    PACKAGE_CONFIG[3] = ID_GATEWAY_CHAR; 
*
0894:  BSF    03.5
0895:  BCF    03.6
0896:  CLRF   54
0897:  MOVLW  54
0898:  MOVWF  53
....................     
....................    XULY_IDNODE_NHAP(); 
....................    PACKAGE_CONFIG[4] = ID_NODE_CHAR;          
*
08D4:  BSF    03.5
08D5:  BCF    03.6
08D6:  CLRF   56
08D7:  MOVLW  4D
08D8:  MOVWF  55
....................    LEN_PACKAGES = 0; 
08D9:  BCF    03.5
08DA:  CLRF   47
....................    PACKAGE_CONFIG[1] = "12"; //DO DAI CUA LENGHT CO DO DAI = 2 
08DB:  MOVLW  31
08DC:  BSF    03.5
08DD:  MOVWF  4F
08DE:  MOVLW  32
08DF:  MOVWF  50
....................    FOR (int J = 0; J < 6; J++) 
08E0:  CLRF   59
08E1:  MOVF   59,W
08E2:  SUBLW  05
08E3:  BTFSS  03.0
08E4:  GOTO   103
....................    { 
....................       LEN_PACKAGES += strlen(PACKAGE_CONFIG[J]); 
08E5:  BCF    03.0
08E6:  RLF    59,W
08E7:  ADDLW  CD
08E8:  MOVWF  04
08E9:  BCF    03.7
08EA:  INCF   04,F
08EB:  MOVF   00,W
08EC:  MOVWF  5B
08ED:  DECF   04,F
08EE:  MOVF   00,W
08EF:  MOVWF  5A
08F0:  MOVF   5B,W
08F1:  BCF    03.5
08F2:  BSF    03.6
08F3:  MOVWF  35
08F4:  BSF    03.5
08F5:  BCF    03.6
08F6:  MOVF   5A,W
08F7:  BCF    03.5
08F8:  BSF    03.6
08F9:  MOVWF  34
08FA:  BCF    0A.3
08FB:  BCF    03.6
08FC:  CALL   7A6
08FD:  BSF    0A.3
08FE:  MOVF   78,W
08FF:  ADDWF  47,F
0900:  BSF    03.5
0901:  INCF   59,F
0902:  GOTO   0E1
....................    }    
....................    LEN_PACKAGES = LEN_PACKAGES+5; //5 @ 
0903:  MOVLW  05
0904:  BCF    03.5
0905:  ADDWF  47,F
....................    ITOA (LEN_PACKAGES, 10, TEMP_CHAR); 
0906:  BSF    03.6
0907:  CLRF   37
0908:  CLRF   36
0909:  CLRF   35
090A:  BCF    03.6
090B:  MOVF   47,W
090C:  BSF    03.6
090D:  MOVWF  34
090E:  MOVLW  0A
090F:  MOVWF  38
0910:  CLRF   3A
0911:  MOVLW  6D
0912:  MOVWF  39
0913:  BCF    0A.3
0914:  BCF    03.6
0915:  CALL   3F5
0916:  BSF    0A.3
....................    PACKAGE_CONFIG[1] = TEMP_CHAR; 
0917:  BSF    03.5
0918:  CLRF   50
0919:  MOVLW  6D
091A:  MOVWF  4F
....................     
....................    FOR ( J = 0; J < 6; J++) 
091B:  CLRF   59
091C:  MOVF   59,W
091D:  SUBLW  05
091E:  BTFSS  03.0
091F:  GOTO   157
....................    { 
....................       PRINTF (PACKAGE_CONFIG[J]); 
0920:  BCF    03.0
0921:  RLF    59,W
0922:  ADDLW  CD
0923:  MOVWF  04
0924:  BCF    03.7
0925:  INCF   04,F
0926:  MOVF   00,W
0927:  MOVWF  5B
0928:  DECF   04,F
0929:  MOVF   00,W
092A:  MOVWF  5A
092B:  MOVF   5A,W
092C:  MOVWF  04
092D:  BCF    03.7
092E:  BTFSC  5B.0
092F:  BSF    03.7
....................       PRINTF ("@"); 
*
094F:  MOVLW  40
0950:  BCF    03.5
0951:  BTFSS  0C.4
0952:  GOTO   151
0953:  MOVWF  19
0954:  BSF    03.5
0955:  INCF   59,F
0956:  GOTO   11C
....................    } 
....................  
....................  
....................    LCD_GOTOXY (1, 1) ; 
0957:  MOVLW  01
0958:  BCF    03.5
0959:  BSF    03.6
095A:  MOVWF  36
095B:  MOVWF  37
095C:  BCF    0A.3
095D:  BCF    03.6
095E:  CALL   2DB
095F:  BSF    0A.3
....................    DELAY_MS (10); 
0960:  MOVLW  0A
0961:  BSF    03.6
0962:  MOVWF  36
0963:  BCF    0A.3
0964:  BCF    03.6
0965:  CALL   151
0966:  BSF    0A.3
....................    PRINTF (LCD_PUTC, "WAITING ....        ") ; 
0967:  MOVLW  CB
0968:  BSF    03.6
0969:  MOVWF  0D
096A:  MOVLW  00
096B:  MOVWF  0F
096C:  BCF    0A.3
096D:  BCF    03.6
096E:  CALL   329
096F:  BSF    0A.3
....................    LCD_GOTOXY (1, 2) ; 
0970:  MOVLW  01
0971:  BSF    03.6
0972:  MOVWF  36
0973:  MOVLW  02
0974:  MOVWF  37
0975:  BCF    0A.3
0976:  BCF    03.6
0977:  CALL   2DB
0978:  BSF    0A.3
....................    DELAY_MS (10); 
0979:  MOVLW  0A
097A:  BSF    03.6
097B:  MOVWF  36
097C:  BCF    0A.3
097D:  BCF    03.6
097E:  CALL   151
097F:  BSF    0A.3
....................    PRINTF (LCD_PUTC, "WAITING ....        ") ;    
0980:  MOVLW  D6
0981:  BSF    03.6
0982:  MOVWF  0D
0983:  MOVLW  00
0984:  MOVWF  0F
0985:  BCF    0A.3
0986:  BCF    03.6
0987:  CALL   329
0988:  BSF    0A.3
....................    TT_CONFIG_DONE = 0; 
0989:  BCF    4C.3
098A:  BSF    0A.3
098B:  BCF    0A.4
098C:  GOTO   734 (RETURN)
.................... } 
....................  
....................  
....................  VOID XACNHANCONFIG() 
....................  { 
....................    OUTPUT_D (0XFF);     
*
0CED:  BSF    03.5
0CEE:  CLRF   08
0CEF:  MOVLW  FF
0CF0:  BCF    03.5
0CF1:  MOVWF  08
....................    DELAY_MS(500); 
0CF2:  MOVLW  02
0CF3:  BSF    03.5
0CF4:  MOVWF  53
0CF5:  MOVLW  FA
0CF6:  BCF    03.5
0CF7:  BSF    03.6
0CF8:  MOVWF  36
0CF9:  BCF    0A.3
0CFA:  BCF    03.6
0CFB:  CALL   151
0CFC:  BSF    0A.3
0CFD:  BSF    03.5
0CFE:  DECFSZ 53,F
0CFF:  GOTO   4F5
....................    LCD_GOTOXY (1, 1) ; 
0D00:  MOVLW  01
0D01:  BCF    03.5
0D02:  BSF    03.6
0D03:  MOVWF  36
0D04:  MOVWF  37
0D05:  BCF    0A.3
0D06:  BCF    03.6
0D07:  CALL   2DB
0D08:  BSF    0A.3
....................    DELAY_MS (10); 
0D09:  MOVLW  0A
0D0A:  BSF    03.6
0D0B:  MOVWF  36
0D0C:  BCF    0A.3
0D0D:  BCF    03.6
0D0E:  CALL   151
0D0F:  BSF    0A.3
....................    PRINTF (LCD_PUTC,KYTUCHAR2); 
0D10:  MOVLW  BE
0D11:  MOVWF  04
0D12:  BCF    03.7
0D13:  BCF    0A.3
0D14:  CALL   515
0D15:  BSF    0A.3
....................    PRINTF (LCD_PUTC,"            "); 
0D16:  MOVLW  E1
0D17:  BSF    03.6
0D18:  MOVWF  0D
0D19:  MOVLW  00
0D1A:  MOVWF  0F
0D1B:  BCF    0A.3
0D1C:  BCF    03.6
0D1D:  CALL   329
0D1E:  BSF    0A.3
....................    DELAY_MS (1);  
0D1F:  MOVLW  01
0D20:  BSF    03.6
0D21:  MOVWF  36
0D22:  BCF    0A.3
0D23:  BCF    03.6
0D24:  CALL   151
0D25:  BSF    0A.3
....................    OUTPUT_D (0XFF);   
0D26:  BSF    03.5
0D27:  CLRF   08
0D28:  MOVLW  FF
0D29:  BCF    03.5
0D2A:  MOVWF  08
....................    LCD_GOTOXY (1, 2) ; 
0D2B:  MOVLW  01
0D2C:  BSF    03.6
0D2D:  MOVWF  36
0D2E:  MOVLW  02
0D2F:  MOVWF  37
0D30:  BCF    0A.3
0D31:  BCF    03.6
0D32:  CALL   2DB
0D33:  BSF    0A.3
....................    DELAY_MS (10); 
0D34:  MOVLW  0A
0D35:  BSF    03.6
0D36:  MOVWF  36
0D37:  BCF    0A.3
0D38:  BCF    03.6
0D39:  CALL   151
0D3A:  BSF    0A.3
....................    PRINTF (LCD_PUTC,"                ");    
0D3B:  MOVLW  E8
0D3C:  BSF    03.6
0D3D:  MOVWF  0D
0D3E:  MOVLW  00
0D3F:  MOVWF  0F
0D40:  BCF    0A.3
0D41:  BCF    03.6
0D42:  CALL   329
0D43:  BSF    0A.3
....................    OUTPUT_D (0X00); 
0D44:  BSF    03.5
0D45:  CLRF   08
0D46:  BCF    03.5
0D47:  CLRF   08
....................    DELAY_MS(500); 
0D48:  MOVLW  02
0D49:  BSF    03.5
0D4A:  MOVWF  53
0D4B:  MOVLW  FA
0D4C:  BCF    03.5
0D4D:  BSF    03.6
0D4E:  MOVWF  36
0D4F:  BCF    0A.3
0D50:  BCF    03.6
0D51:  CALL   151
0D52:  BSF    0A.3
0D53:  BSF    03.5
0D54:  DECFSZ 53,F
0D55:  GOTO   54B
....................    OUTPUT_D (0XFF);     
0D56:  CLRF   08
0D57:  MOVLW  FF
0D58:  BCF    03.5
0D59:  MOVWF  08
....................    DELAY_MS(500); 
0D5A:  MOVLW  02
0D5B:  BSF    03.5
0D5C:  MOVWF  53
0D5D:  MOVLW  FA
0D5E:  BCF    03.5
0D5F:  BSF    03.6
0D60:  MOVWF  36
0D61:  BCF    0A.3
0D62:  BCF    03.6
0D63:  CALL   151
0D64:  BSF    0A.3
0D65:  BSF    03.5
0D66:  DECFSZ 53,F
0D67:  GOTO   55D
....................    OUTPUT_D (0X00); 
0D68:  CLRF   08
0D69:  BCF    03.5
0D6A:  CLRF   08
....................     
....................  }  
.................... //--------------------------------------------------------------------// 
....................  
....................  
....................  
....................  
....................  
.................... VOID QUET_PHIM() 
*
00F1:  BSF    03.6
00F2:  CLRF   59
.................... { 
....................    INT BDT = 0; 
....................  
....................    WHILE (!INPUT (BT1_PIN)) //NEU NUT BAM DUOC BAM 
00F3:  BSF    03.5
00F4:  BCF    03.6
00F5:  BSF    06.1
00F6:  BCF    03.5
00F7:  BTFSC  06.1
00F8:  GOTO   10C
....................    { 
....................       IF (TMR1IF) 
00F9:  BTFSS  0C.0
00FA:  GOTO   109
....................       { 
....................          OUTPUT_TOGGLE (PIN_D2); 
00FB:  BSF    03.5
00FC:  BCF    08.2
00FD:  MOVLW  04
00FE:  BCF    03.5
00FF:  XORWF  08,F
....................          TMR1IF = 0; SET_TIMER1 (3036); BDT++; 
0100:  BCF    0C.0
0101:  CLRF   0E
0102:  MOVLW  0B
0103:  MOVWF  0F
0104:  MOVLW  DC
0105:  MOVWF  0E
0106:  BSF    03.6
0107:  INCF   59,F
0108:  BCF    03.6
....................       } 
0109:  BSF    03.6
010A:  GOTO   0F3
010B:  BCF    03.6
....................    } 
....................  
....................    IF (BDT > 20) 
010C:  BSF    03.6
010D:  MOVF   59,W
010E:  SUBLW  14
010F:  BTFSC  03.0
0110:  GOTO   11A
....................    { 
....................       //CONFIG NODE 
....................       TT_CONFIG = ~TT_CONFIG; // VAO TRANG THAI CONFIG 
0111:  MOVLW  02
0112:  BCF    03.6
0113:  XORWF  4C,F
....................       TT_CONTROL = ~TT_CONTROL; 
0114:  MOVLW  04
0115:  XORWF  4C,F
....................       //CONFIG_DONE (); 
....................       TT_CONFIG_DONE = 1; 
0116:  BSF    4C.3
....................       TT_FUN = 0; 
0117:  BCF    4C.4
....................    } 
0118:  GOTO   11E
0119:  BSF    03.6
....................  
....................    ELSE 
....................    { 
....................       BUTT_OKE (); //OKE 
....................    } 
.................... } 
....................  
.................... #INT_EXT 
....................  
....................  VOID NGAT_NGOAI () 
....................  { 
....................     QUET_PHIM (); 
....................  } 
....................  
*
011E:  BCF    0B.1
011F:  BCF    0A.3
0120:  BCF    0A.4
0121:  GOTO   031
....................  #INT_RDA 
....................  VOID NGAT () 
....................  { 
....................     KYTUCHAR[VT] = GETCH (); 
0122:  MOVLW  A0
0123:  ADDWF  39,W
0124:  MOVWF  04
0125:  BCF    03.7
0126:  BTFSS  0C.5
0127:  GOTO   126
0128:  MOVF   1A,W
0129:  MOVWF  00
....................  
....................     IF (KYTUCHAR[VT] == '.') 
012A:  MOVLW  A0
012B:  ADDWF  39,W
012C:  MOVWF  04
012D:  BCF    03.7
012E:  MOVF   00,W
012F:  SUBLW  2E
0130:  BTFSS  03.2
0131:  GOTO   13A
....................     { 
....................        KYTUCHAR[VT] = '\0'; 
0132:  MOVLW  A0
0133:  ADDWF  39,W
0134:  MOVWF  04
0135:  BCF    03.7
0136:  CLRF   00
....................        VT = 0; 
0137:  CLRF   39
....................        TTNHAN = 1; 
0138:  BSF    4C.0
....................     } 
0139:  GOTO   13B
....................  
....................     ELSE 
....................     VT++; 
013A:  INCF   39,F
013B:  BCF    0C.5
013C:  BCF    0A.3
013D:  BCF    0A.4
013E:  GOTO   031
....................  } 
....................  
....................  VOID XUATLCD ( CHAR CHUOI_PRINT[]) 
....................  { 
....................     LCD_GOTOXY (1, 1) ; 
....................     DELAY_MS (10); 
....................     PRINTF (LCD_PUTC, CHUOI_PRINT); 
....................     DELAY_MS (1); 
....................  } 
....................  
....................  VOID DIEUKHIENTHIETBI() 
....................  { 
....................     /* LAY TOKEN DAU TIEN */     
....................     KYTU = 0; 
*
0D6C:  CLRF   3A
....................     TEMP_CHAR = "_"; 
0D6D:  BSF    03.5
0D6E:  CLRF   55
0D6F:  CLRF   56
0D70:  MOVLW  6D
0D71:  MOVWF  04
0D72:  BCF    03.7
0D73:  MOVF   55,W
0D74:  ADDWF  04,F
0D75:  MOVF   56,W
0D76:  BCF    0A.3
0D77:  BCF    03.5
0D78:  CALL   05E
0D79:  BSF    0A.3
0D7A:  MOVWF  00
0D7B:  IORLW  00
0D7C:  BTFSC  03.2
0D7D:  GOTO   583
0D7E:  BSF    03.5
0D7F:  INCF   56,F
0D80:  INCF   55,F
0D81:  GOTO   570
0D82:  BCF    03.5
....................     LCD_GOTOXY (1, 1) ; 
0D83:  MOVLW  01
0D84:  BSF    03.6
0D85:  MOVWF  36
0D86:  MOVWF  37
0D87:  BCF    0A.3
0D88:  BCF    03.6
0D89:  CALL   2DB
0D8A:  BSF    0A.3
....................     DELAY_MS (10);        
0D8B:  MOVLW  0A
0D8C:  BSF    03.6
0D8D:  MOVWF  36
0D8E:  BCF    0A.3
0D8F:  BCF    03.6
0D90:  CALL   151
0D91:  BSF    0A.3
....................     PRINTF (LCD_PUTC, KYTUCHAR2);    
0D92:  MOVLW  BE
0D93:  MOVWF  04
0D94:  BCF    03.7
0D95:  BCF    0A.3
0D96:  CALL   515
0D97:  BSF    0A.3
....................     PRINTF (LCD_PUTC, "                 "); 
0D98:  MOVLW  3F
0D99:  BSF    03.6
0D9A:  MOVWF  0D
0D9B:  MOVLW  01
0D9C:  MOVWF  0F
0D9D:  BCF    0A.3
0D9E:  BCF    03.6
0D9F:  CALL   329
0DA0:  BSF    0A.3
....................         LCD_GOTOXY (1, 2) ; 
0DA1:  MOVLW  01
0DA2:  BSF    03.6
0DA3:  MOVWF  36
0DA4:  MOVLW  02
0DA5:  MOVWF  37
0DA6:  BCF    0A.3
0DA7:  BCF    03.6
0DA8:  CALL   2DB
0DA9:  BSF    0A.3
....................     DELAY_MS (10);           
0DAA:  MOVLW  0A
0DAB:  BSF    03.6
0DAC:  MOVWF  36
0DAD:  BCF    0A.3
0DAE:  BCF    03.6
0DAF:  CALL   151
0DB0:  BSF    0A.3
....................     PRINTF (LCD_PUTC, "                 ");     
0DB1:  MOVLW  48
0DB2:  BSF    03.6
0DB3:  MOVWF  0D
0DB4:  MOVLW  01
0DB5:  MOVWF  0F
0DB6:  BCF    0A.3
0DB7:  BCF    03.6
0DB8:  CALL   329
0DB9:  BSF    0A.3
....................     CHAR * TOKEN; 
....................     TOKEN = STRTOK (KYTUCHAR2, TEMP_CHAR);    
0DBA:  BSF    03.5
0DBB:  CLRF   56
0DBC:  MOVLW  BE
0DBD:  MOVWF  55
0DBE:  CLRF   58
0DBF:  MOVLW  6D
0DC0:  MOVWF  57
0DC1:  BCF    03.5
0DC2:  CALL   18D
0DC3:  MOVF   79,W
0DC4:  BSF    03.5
0DC5:  MOVWF  54
0DC6:  MOVF   78,W
0DC7:  MOVWF  53
....................      
....................     /* DUYET QUA CAC TOKEN CON LAI */                 
....................     WHILE (TOKEN != NULL) 
0DC8:  MOVF   53,F
0DC9:  BTFSS  03.2
0DCA:  GOTO   5CE
0DCB:  MOVF   54,F
0DCC:  BTFSC  03.2
0DCD:  GOTO   62C
....................     {                 
....................        SWITCH(KYTU) 
0DCE:  BCF    03.5
0DCF:  MOVF   3A,W
0DD0:  BTFSC  03.2
0DD1:  GOTO   5D9
0DD2:  XORLW  01
0DD3:  BTFSC  03.2
0DD4:  GOTO   5E3
0DD5:  XORLW  03
0DD6:  BTFSC  03.2
0DD7:  GOTO   5ED
0DD8:  GOTO   601
....................        { 
....................          CASE 0: 
....................          ID_DEVICE_NHAN =  ATOI(TOKEN) +64 ;        
0DD9:  BSF    03.5
0DDA:  MOVF   54,W
0DDB:  MOVWF  56
0DDC:  MOVF   53,W
0DDD:  MOVWF  55
0DDE:  BCF    03.5
0DDF:  CALL   27E
0DE0:  MOVLW  40
0DE1:  ADDWF  78,W
0DE2:  MOVWF  3B
....................          CASE 1:  
....................          TT_DEVICE_NHAN =  ATOI(TOKEN);        
0DE3:  BSF    03.5
0DE4:  MOVF   54,W
0DE5:  MOVWF  56
0DE6:  MOVF   53,W
0DE7:  MOVWF  55
0DE8:  BCF    03.5
0DE9:  CALL   27E
0DEA:  MOVF   78,W
0DEB:  MOVWF  3C
....................          BREAK;                      
0DEC:  GOTO   601
....................          CASE 2: 
....................          STRCAT (ID_NODE_NHAN, TOKEN); 
0DED:  BSF    03.6
0DEE:  CLRF   34
0DEF:  MOVLW  5D
0DF0:  MOVWF  33
0DF1:  BSF    03.5
0DF2:  BCF    03.6
0DF3:  MOVF   54,W
0DF4:  BCF    03.5
0DF5:  BSF    03.6
0DF6:  MOVWF  36
0DF7:  BSF    03.5
0DF8:  BCF    03.6
0DF9:  MOVF   53,W
0DFA:  BCF    03.5
0DFB:  BSF    03.6
0DFC:  MOVWF  35
0DFD:  BCF    0A.3
0DFE:  BCF    03.6
0DFF:  CALL   768
0E00:  BSF    0A.3
....................          BREAK;               
....................        }  
....................        LCD_GOTOXY (7, 2) ; 
0E01:  MOVLW  07
0E02:  BSF    03.6
0E03:  MOVWF  36
0E04:  MOVLW  02
0E05:  MOVWF  37
0E06:  BCF    0A.3
0E07:  BCF    03.6
0E08:  CALL   2DB
0E09:  BSF    0A.3
....................        DELAY_MS (10);        
0E0A:  MOVLW  0A
0E0B:  BSF    03.6
0E0C:  MOVWF  36
0E0D:  BCF    0A.3
0E0E:  BCF    03.6
0E0F:  CALL   151
0E10:  BSF    0A.3
....................        PRINTF (LCD_PUTC, TOKEN); 
0E11:  BSF    03.5
0E12:  MOVF   53,W
0E13:  MOVWF  04
0E14:  BCF    03.7
0E15:  BTFSC  54.0
0E16:  BSF    03.7
0E17:  BCF    0A.3
0E18:  BCF    03.5
0E19:  CALL   515
0E1A:  BSF    0A.3
....................       TOKEN = STRTOK(NULL, TEMP_CHAR); 
0E1B:  BSF    03.5
0E1C:  CLRF   56
0E1D:  CLRF   55
0E1E:  CLRF   58
0E1F:  MOVLW  6D
0E20:  MOVWF  57
0E21:  BCF    03.5
0E22:  CALL   18D
0E23:  MOVF   79,W
0E24:  BSF    03.5
0E25:  MOVWF  54
0E26:  MOVF   78,W
0E27:  MOVWF  53
....................       KYTU++;         
0E28:  BCF    03.5
0E29:  INCF   3A,F
0E2A:  BSF    03.5
0E2B:  GOTO   5C8
....................     }  
....................     OUTPUT_BIT (ID_DEVICE_NHAN, TT_DEVICE_NHAN); 
0E2C:  BCF    03.5
0E2D:  MOVF   3C,F
0E2E:  BTFSS  03.2
0E2F:  GOTO   632
0E30:  MOVLW  00
0E31:  GOTO   633
0E32:  MOVLW  01
0E33:  MOVWF  77
0E34:  MOVF   3B,W
0E35:  BSF    03.5
0E36:  MOVWF  55
0E37:  MOVF   77,W
0E38:  MOVWF  56
0E39:  CLRF   58
0E3A:  CLRF   57
0E3B:  BCF    0A.3
0E3C:  BCF    03.5
0E3D:  CALL   7DC
0E3E:  BSF    0A.3
0E3F:  MOVF   3B,W
0E40:  BSF    03.5
0E41:  MOVWF  55
0E42:  CLRF   56
0E43:  CLRF   58
0E44:  MOVLW  80
0E45:  MOVWF  57
0E46:  BCF    0A.3
0E47:  BCF    03.5
0E48:  CALL   7DC
0E49:  BSF    0A.3
....................  } 
....................  
....................  VOID XU_LY_UART() 
*
0BC6:  MOVLW  2A
0BC7:  BSF    03.5
0BC8:  MOVWF  4D
....................  { 
....................      //ID_NODE_NHAN = KYTU[1] - 48; 
....................     //ID_DEVICE_NHAN = KYTU[2] - 48 + 64; 
....................     //TT_DEVICE_NHAN = KYTU[3] - 48; // - 48 ASCII -- > S?. + 64 -- > PORT_D (D0 = 64)                
....................  
....................     /*TINH DO DAI*/ 
....................     CHAR CH = '*'; 
....................     CHAR *RET; 
....................     *ID_NODE_NHAN = '\0'; 
0BC9:  CLRF   7A
0BCA:  MOVLW  5D
0BCB:  MOVWF  04
0BCC:  BCF    03.7
0BCD:  BTFSC  7A.0
0BCE:  BSF    03.7
0BCF:  CLRF   00
....................     *ID_GW_NHAN = '\0'; 
0BD0:  CLRF   7A
0BD1:  MOVLW  64
0BD2:  MOVWF  04
0BD3:  BCF    03.7
0BD4:  BTFSC  7A.0
0BD5:  BSF    03.7
0BD6:  CLRF   00
....................     KYTUCHAR2 = ""; 
0BD7:  CLRF   53
0BD8:  CLRF   54
0BD9:  MOVLW  BE
0BDA:  MOVWF  04
0BDB:  BCF    03.7
0BDC:  MOVF   53,W
0BDD:  ADDWF  04,F
0BDE:  MOVF   54,W
0BDF:  BCF    0A.3
0BE0:  BCF    03.5
0BE1:  CALL   064
0BE2:  BSF    0A.3
0BE3:  MOVWF  00
0BE4:  IORLW  00
0BE5:  BTFSC  03.2
0BE6:  GOTO   3EC
0BE7:  BSF    03.5
0BE8:  INCF   54,F
0BE9:  INCF   53,F
0BEA:  GOTO   3D9
0BEB:  BCF    03.5
....................     UNSIGNED INT8 LEN_RET;     
....................     RET = STRCHR(KYTUCHAR,CH); 
0BEC:  BSF    03.5
0BED:  CLRF   54
0BEE:  MOVLW  A0
0BEF:  MOVWF  53
0BF0:  MOVF   4D,W
0BF1:  MOVWF  55
*
0C13:  MOVF   79,W
0C14:  MOVWF  4F
0C15:  MOVF   78,W
0C16:  MOVWF  4E
....................     LEN_RET = STRLEN(RET);  
0C17:  MOVF   4F,W
0C18:  BCF    03.5
0C19:  BSF    03.6
0C1A:  MOVWF  35
0C1B:  BSF    03.5
0C1C:  BCF    03.6
0C1D:  MOVF   4E,W
0C1E:  BCF    03.5
0C1F:  BSF    03.6
0C20:  MOVWF  34
0C21:  BCF    0A.3
0C22:  BCF    03.6
0C23:  CALL   7A6
0C24:  BSF    0A.3
0C25:  MOVF   78,W
0C26:  BSF    03.5
0C27:  MOVWF  50
....................     /* LAY TOKEN DAU TIEN */     
....................     KYTU = 0; 
0C28:  BCF    03.5
0C29:  CLRF   3A
....................     TEMP_CHAR = "#"; 
0C2A:  BSF    03.5
0C2B:  CLRF   53
0C2C:  CLRF   54
0C2D:  MOVLW  6D
0C2E:  MOVWF  04
0C2F:  BCF    03.7
0C30:  MOVF   53,W
0C31:  ADDWF  04,F
0C32:  MOVF   54,W
0C33:  BCF    0A.3
0C34:  BCF    03.5
0C35:  CALL   069
0C36:  BSF    0A.3
0C37:  MOVWF  00
0C38:  IORLW  00
0C39:  BTFSC  03.2
0C3A:  GOTO   440
0C3B:  BSF    03.5
0C3C:  INCF   54,F
0C3D:  INCF   53,F
0C3E:  GOTO   42D
0C3F:  BCF    03.5
....................     CHAR * TOKEN; 
....................     TOKEN = STRTOK (KYTUCHAR, TEMP_CHAR);                 
0C40:  BSF    03.5
0C41:  CLRF   56
0C42:  MOVLW  A0
0C43:  MOVWF  55
0C44:  CLRF   58
0C45:  MOVLW  6D
0C46:  MOVWF  57
0C47:  BCF    03.5
0C48:  CALL   18D
0C49:  MOVF   79,W
0C4A:  BSF    03.5
0C4B:  MOVWF  52
0C4C:  MOVF   78,W
0C4D:  MOVWF  51
....................     /* DUYET QUA CAC TOKEN CON LAI */                 
....................     WHILE (TOKEN != NULL) 
0C4E:  MOVF   51,F
0C4F:  BTFSS  03.2
0C50:  GOTO   454
0C51:  MOVF   52,F
0C52:  BTFSC  03.2
0C53:  GOTO   4BF
....................     {                 
....................        SWITCH(KYTU) 
0C54:  BCF    03.5
0C55:  MOVF   3A,W
0C56:  ADDLW  FA
0C57:  BTFSC  03.0
0C58:  GOTO   4AE
0C59:  ADDLW  06
0C5A:  GOTO   655
....................        { 
....................          CASE 0: 
....................          BREAK; 
0C5B:  GOTO   4AE
....................          CASE 1:  
....................          STRCAT (ID_GW_NHAN, TOKEN); 
0C5C:  BSF    03.6
0C5D:  CLRF   34
0C5E:  MOVLW  64
0C5F:  MOVWF  33
0C60:  BSF    03.5
0C61:  BCF    03.6
0C62:  MOVF   52,W
0C63:  BCF    03.5
0C64:  BSF    03.6
0C65:  MOVWF  36
0C66:  BSF    03.5
0C67:  BCF    03.6
0C68:  MOVF   51,W
0C69:  BCF    03.5
0C6A:  BSF    03.6
0C6B:  MOVWF  35
0C6C:  BCF    0A.3
0C6D:  BCF    03.6
0C6E:  CALL   768
0C6F:  BSF    0A.3
....................          BREAK;                      
0C70:  GOTO   4AE
....................          CASE 2: 
....................          STRCAT (ID_NODE_NHAN, TOKEN); 
0C71:  BSF    03.6
0C72:  CLRF   34
0C73:  MOVLW  5D
0C74:  MOVWF  33
0C75:  BSF    03.5
0C76:  BCF    03.6
0C77:  MOVF   52,W
0C78:  BCF    03.5
0C79:  BSF    03.6
0C7A:  MOVWF  36
0C7B:  BSF    03.5
0C7C:  BCF    03.6
0C7D:  MOVF   51,W
0C7E:  BCF    03.5
0C7F:  BSF    03.6
0C80:  MOVWF  35
0C81:  BCF    0A.3
0C82:  BCF    03.6
0C83:  CALL   768
0C84:  BSF    0A.3
....................          BREAK;       
0C85:  GOTO   4AE
....................          CASE 3: 
....................          LENHDIEUKHIEN =  ATOI(TOKEN);                  
0C86:  BSF    03.5
0C87:  MOVF   52,W
0C88:  MOVWF  56
0C89:  MOVF   51,W
0C8A:  MOVWF  55
0C8B:  BCF    03.5
0C8C:  CALL   27E
0C8D:  MOVF   78,W
0C8E:  MOVWF  48
....................          BREAK;     
0C8F:  GOTO   4AE
....................          CASE 4: 
....................          DODAI_DATA_NHAN =  ATOI(TOKEN);                  
0C90:  BSF    03.5
0C91:  MOVF   52,W
0C92:  MOVWF  56
0C93:  MOVF   51,W
0C94:  MOVWF  55
0C95:  BCF    03.5
0C96:  CALL   27E
0C97:  MOVF   78,W
0C98:  MOVWF  49
....................          BREAK;   
0C99:  GOTO   4AE
....................          CASE 5:   
....................          STRCAT (KYTUCHAR2, TOKEN); 
0C9A:  BSF    03.6
0C9B:  CLRF   34
0C9C:  MOVLW  BE
0C9D:  MOVWF  33
0C9E:  BSF    03.5
0C9F:  BCF    03.6
0CA0:  MOVF   52,W
0CA1:  BCF    03.5
0CA2:  BSF    03.6
0CA3:  MOVWF  36
0CA4:  BSF    03.5
0CA5:  BCF    03.6
0CA6:  MOVF   51,W
0CA7:  BCF    03.5
0CA8:  BSF    03.6
0CA9:  MOVWF  35
0CAA:  BCF    0A.3
0CAB:  BCF    03.6
0CAC:  CALL   768
0CAD:  BSF    0A.3
....................          BREAK;          
....................        }          
....................       TOKEN = STRTOK(NULL, TEMP_CHAR); 
0CAE:  BSF    03.5
0CAF:  CLRF   56
0CB0:  CLRF   55
0CB1:  CLRF   58
0CB2:  MOVLW  6D
0CB3:  MOVWF  57
0CB4:  BCF    03.5
0CB5:  CALL   18D
0CB6:  MOVF   79,W
0CB7:  BSF    03.5
0CB8:  MOVWF  52
0CB9:  MOVF   78,W
0CBA:  MOVWF  51
....................       KYTU++;         
0CBB:  BCF    03.5
0CBC:  INCF   3A,F
0CBD:  BSF    03.5
0CBE:  GOTO   44E
....................     }               
....................       /* SO SANH ID returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................       SOSANH_IDGW = STRCMP(ID_GW_NHAN,ID_GATEWAY_CHAR);       
0CBF:  CLRF   54
0CC0:  MOVLW  64
0CC1:  MOVWF  53
0CC2:  CLRF   56
0CC3:  MOVLW  54
0CC4:  MOVWF  55
0CC5:  BCF    03.5
0CC6:  CALL   380
0CC7:  MOVF   78,W
0CC8:  MOVWF  4B
....................       SOSANH_IDNODE = STRCMP(ID_NODE_NHAN,ID_NODE_CHAR);     
0CC9:  BSF    03.5
0CCA:  CLRF   54
0CCB:  MOVLW  5D
0CCC:  MOVWF  53
0CCD:  CLRF   56
0CCE:  MOVLW  4D
0CCF:  MOVWF  55
0CD0:  BCF    03.5
0CD1:  CALL   380
0CD2:  MOVF   78,W
0CD3:  MOVWF  4A
....................     IF ( SOSANH_IDGW == 0 && SOSANH_IDNODE == 0 && LEN_RET == DODAI_DATA_NHAN) 
0CD4:  MOVF   4B,F
0CD5:  BTFSS  03.2
0CD6:  GOTO   64B
0CD7:  MOVF   4A,F
0CD8:  BTFSS  03.2
0CD9:  GOTO   64B
0CDA:  MOVF   49,W
0CDB:  BSF    03.5
0CDC:  SUBWF  50,W
0CDD:  BTFSC  03.2
0CDE:  GOTO   4E1
0CDF:  BCF    03.5
0CE0:  GOTO   64B
....................     {                       
....................       SWITCH(LENHDIEUKHIEN) 
0CE1:  BCF    03.5
0CE2:  MOVF   48,W
0CE3:  BTFSC  03.2
0CE4:  GOTO   4EC
0CE5:  XORLW  01
0CE6:  BTFSC  03.2
0CE7:  GOTO   4ED
0CE8:  XORLW  03
0CE9:  BTFSC  03.2
0CEA:  GOTO   56C
0CEB:  GOTO   64A
....................        { 
....................          CASE 0: 
....................          BREAK; 
0CEC:  GOTO   64A
....................          CASE 1: 
....................          XACNHANCONFIG(); 
....................          BREAK;                      
*
0D6B:  GOTO   64A
....................          CASE 2: 
....................          DIEUKHIENTHIETBI(); 
....................          BREAK;               
....................        }  
....................     } 
*
0E4A:  GOTO   652
....................     ELSE{ 
....................       DELAY_MS (10); 
0E4B:  MOVLW  0A
0E4C:  BSF    03.6
0E4D:  MOVWF  36
0E4E:  BCF    0A.3
0E4F:  BCF    03.6
0E50:  CALL   151
0E51:  BSF    0A.3
....................       /*DATA RCV SAI ID NODE, ID GW HOAC LA SAI DO DAI*/ 
....................     } 
0E52:  BSF    0A.3
0E53:  BCF    0A.4
0E54:  GOTO   73E (RETURN)
....................      
....................  } 
....................  
....................  INT ADC_READ (INT KENH) 
....................  { 
....................     SET_ADC_CHANNEL (KENH); 
....................     KQADC = 0; 
....................     FOR (INT I = 0; I < 100; I++) 
....................     { 
....................        KQADC = KQADC + READ_ADC () ; 
....................        DELAY_MS (1); 
....................     } 
....................  
....................     KQADC = KQADC / (100 * 2.046); 
....................     RETURN KQADC; 
....................  } 
....................  
....................  VOID CHUONG_TRINH_CON () 
....................  { 
....................     FOR (INT I = 0; I <= 30; I++) 
*
07C6:  BSF    03.5
07C7:  CLRF   4D
07C8:  MOVF   4D,W
07C9:  SUBLW  1E
07CA:  BTFSS  03.0
07CB:  GOTO   7D8
....................     { 
....................        OUTPUT_TOGGLE (PIN_D1); 
07CC:  BCF    08.1
07CD:  MOVLW  02
07CE:  BCF    03.5
07CF:  XORWF  08,F
....................        DELAY_MS (100); 
07D0:  MOVLW  64
07D1:  BSF    03.6
07D2:  MOVWF  36
07D3:  BCF    03.6
07D4:  CALL   151
07D5:  BSF    03.5
07D6:  INCF   4D,F
07D7:  GOTO   7C8
....................     } 
07D8:  BCF    03.5
07D9:  BSF    0A.3
07DA:  BCF    0A.4
07DB:  GOTO   739 (RETURN)
....................  } 
....................  
....................  VOID MAIN  () 
*
0E5F:  MOVF   03,W
0E60:  ANDLW  1F
0E61:  MOVWF  03
0E62:  BSF    03.5
0E63:  BSF    03.6
0E64:  BSF    07.3
0E65:  MOVLW  08
0E66:  BCF    03.6
0E67:  MOVWF  19
0E68:  MOVLW  02
0E69:  MOVWF  1A
0E6A:  MOVLW  A6
0E6B:  MOVWF  18
0E6C:  MOVLW  90
0E6D:  BCF    03.5
0E6E:  MOVWF  18
0E6F:  MOVLW  FF
0E70:  MOVWF  31
0E71:  CLRF   38
0E72:  CLRF   39
0E73:  CLRF   3A
0E74:  CLRF   47
0E75:  CLRF   48
0E76:  CLRF   49
0E77:  CLRF   4A
0E78:  CLRF   4B
0E79:  BCF    4C.0
0E7A:  BCF    4C.1
0E7B:  BCF    4C.2
0E7C:  BCF    4C.3
0E7D:  BCF    4C.4
0E7E:  BCF    4C.5
0E7F:  BSF    03.5
0E80:  BSF    03.6
0E81:  MOVF   09,W
0E82:  ANDLW  C0
0E83:  MOVWF  09
0E84:  BCF    03.6
0E85:  BCF    1F.4
0E86:  BCF    1F.5
0E87:  MOVLW  00
0E88:  BSF    03.6
0E89:  MOVWF  08
0E8A:  BCF    03.5
0E8B:  CLRF   07
0E8C:  CLRF   08
0E8D:  CLRF   09
0E8E:  BCF    03.7
....................  { 
....................     SET_TRIS_D (0X00); 
*
0EEF:  MOVLW  00
0EF0:  BSF    03.5
0EF1:  MOVWF  08
....................     SET_TRIS_B (0XFF); 
0EF2:  MOVLW  FF
0EF3:  MOVWF  06
....................     SET_TRIS_E (0); 
0EF4:  BCF    09.0
0EF5:  BCF    09.1
0EF6:  BCF    09.2
0EF7:  BCF    09.3
....................     SET_TRIS_C (0X80); 
0EF8:  MOVLW  80
0EF9:  MOVWF  07
0EFA:  BCF    03.5
0EFB:  MOVWF  31
....................     SETUP_ADC (ADC_CLOCK_DIV_8); 
0EFC:  BSF    1F.6
0EFD:  BCF    1F.7
0EFE:  BSF    03.5
0EFF:  BSF    1F.7
0F00:  BCF    03.5
0F01:  BSF    1F.0
....................     SETUP_ADC_PORTS (SAN0); 
0F02:  BSF    03.5
0F03:  BSF    03.6
0F04:  MOVF   09,W
0F05:  ANDLW  C0
0F06:  MOVWF  09
0F07:  BCF    03.6
0F08:  BCF    1F.4
0F09:  BCF    1F.5
0F0A:  MOVLW  01
0F0B:  BSF    03.6
0F0C:  MOVWF  08
....................     ENABLE_INTERRUPTS (INT_TIMER0); 
0F0D:  BCF    03.5
0F0E:  BCF    03.6
0F0F:  BSF    0B.5
....................     ENABLE_INTERRUPTS (INT_EXT); //CHO PHEP NGAT NGOAI 
0F10:  BSF    0B.4
....................     ENABLE_INTERRUPTS (INT_EXT_H2L); //NGAT XAY RA KHI CO XUNG TU CAO XUONG THAP 
0F11:  BSF    0B.4
0F12:  BSF    03.5
0F13:  BCF    01.6
....................     ENABLE_INTERRUPTS (INT_RDA); 
0F14:  BSF    0C.5
....................     ENABLE_INTERRUPTS (GLOBAL); 
0F15:  MOVLW  C0
0F16:  BCF    03.5
0F17:  IORWF  0B,F
....................      
....................     SETUP_TIMER_1 (T1_INTERNAL|T1_DIV_BY_8); 
0F18:  MOVLW  35
0F19:  MOVWF  10
....................     //SET_TIMER1 (0); 
....................     SET_TIMER1 (3036); 
0F1A:  CLRF   0E
0F1B:  MOVLW  0B
0F1C:  MOVWF  0F
0F1D:  MOVLW  DC
0F1E:  MOVWF  0E
....................     TMR1IF = 0; 
0F1F:  BCF    0C.0
....................     LCD_INIT (); // KHOI TAO LCD 
0F20:  BCF    0A.3
0F21:  GOTO   26B
0F22:  BSF    0A.3
....................  
....................     TT_CONFIG = 0; 
0F23:  BCF    4C.1
....................     TT_CONFIG_DONE = 0; 
0F24:  BCF    4C.3
....................     TT_CONTROL = 1; 
0F25:  BSF    4C.2
....................     OUTPUT_D (0X00); 
0F26:  BSF    03.5
0F27:  CLRF   08
0F28:  BCF    03.5
0F29:  CLRF   08
....................     TTNHAN = 0; 
0F2A:  BCF    4C.0
....................      
....................     
....................     WHILE (TRUE) 
....................     { 
....................        IF (TT_CONFIG)             {BUTT_FUN (); } // GOI HAM CHON LENH (SWITCH CASE) 
0F2B:  BTFSS  4C.1
0F2C:  GOTO   731
0F2D:  BCF    0A.3
0F2E:  GOTO   54B
0F2F:  BSF    0A.3
0F30:  GOTO   73F
....................        ELSE IF (TT_CONFIG_DONE)   { CONFIG_DONE ();}        
0F31:  BTFSS  4C.3
0F32:  GOTO   735
0F33:  GOTO   000
0F34:  GOTO   73F
....................        ELSE 
....................        { 
....................           WHILE (!TT_CONFIG) 
0F35:  BTFSC  4C.1
0F36:  GOTO   73F
....................           { 
....................              CHUONG_TRINH_CON ();              
0F37:  BCF    0A.3
0F38:  GOTO   7C6
0F39:  BSF    0A.3
....................              IF (TTNHAN == 1) 
0F3A:  BTFSS  4C.0
0F3B:  GOTO   73E
....................              { 
....................                 TTNHAN = 0; 
0F3C:  BCF    4C.0
....................                 XU_LY_UART(); 
0F3D:  GOTO   3C6
....................              } 
0F3E:  GOTO   735
....................           } 
....................        } 
0F3F:  GOTO   72B
....................     } 
....................  } 
....................  
0F40:  SLEEP

Configuration Fuses:
   Word  1: 2FE2   HS NOWDT PUT MCLR NOPROTECT NOCPD BROWNOUT IESO FCMEN NOLVP NODEBUG
   Word  2: 3FFF   BORV40 NOWRT
